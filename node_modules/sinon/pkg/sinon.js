/* Sinon.JS 21.0.1, 2025-12-19, @license BSD-3 */(function(g,f){if(typeof exports=="object"&&typeof module<"u"){module.exports=f(require)}else if("function"==typeof define && define.amd){define("sinon",["timers","timers/promises","fs"],function(_d_0,_d_1,_d_2){var d={"timers": _d_0,"timers/promises": _d_1,"fs": _d_2},r=function(m){if(m in d) return d[m];if(typeof require=="function") return require(m);throw new Error("Cannot find module '"+m+"'")};return f(r)})}else {var gN={"timers":"timers","timers/promises":"timers/promises","fs":"fs"},gReq=function(r){var mod = r in gN ? g[gN[r]] : g[r]; return mod };g["sinon"]=f(gReq)}}(typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : this,function(require){var exports={};var __exports=exports;var module={exports};
"use strict";
var __getOwnPropNames = Object.getOwnPropertyNames;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};

// node_modules/@sinonjs/commons/lib/global.js
var require_global = __commonJS({
  "node_modules/@sinonjs/commons/lib/global.js"(exports2, module2) {
    "use strict";
    var globalObject;
    if (typeof global !== "undefined") {
      globalObject = global;
    } else if (typeof window !== "undefined") {
      globalObject = window;
    } else {
      globalObject = self;
    }
    module2.exports = globalObject;
  }
});

// node_modules/@sinonjs/commons/lib/prototypes/throws-on-proto.js
var require_throws_on_proto = __commonJS({
  "node_modules/@sinonjs/commons/lib/prototypes/throws-on-proto.js"(exports2, module2) {
    "use strict";
    var throwsOnProto;
    try {
      const object = {};
      object.__proto__;
      throwsOnProto = false;
    } catch (_) {
      throwsOnProto = true;
    }
    module2.exports = throwsOnProto;
  }
});

// node_modules/@sinonjs/commons/lib/prototypes/copy-prototype-methods.js
var require_copy_prototype_methods = __commonJS({
  "node_modules/@sinonjs/commons/lib/prototypes/copy-prototype-methods.js"(exports2, module2) {
    "use strict";
    var call = Function.call;
    var throwsOnProto = require_throws_on_proto();
    var disallowedProperties = [
      // ignore size because it throws from Map
      "size",
      "caller",
      "callee",
      "arguments"
    ];
    if (throwsOnProto) {
      disallowedProperties.push("__proto__");
    }
    module2.exports = function copyPrototypeMethods(prototype) {
      return Object.getOwnPropertyNames(prototype).reduce(
        function(result, name) {
          if (disallowedProperties.includes(name)) {
            return result;
          }
          if (typeof prototype[name] !== "function") {
            return result;
          }
          result[name] = call.bind(prototype[name]);
          return result;
        },
        /* @__PURE__ */ Object.create(null)
      );
    };
  }
});

// node_modules/@sinonjs/commons/lib/prototypes/array.js
var require_array = __commonJS({
  "node_modules/@sinonjs/commons/lib/prototypes/array.js"(exports2, module2) {
    "use strict";
    var copyPrototype = require_copy_prototype_methods();
    module2.exports = copyPrototype(Array.prototype);
  }
});

// node_modules/@sinonjs/commons/lib/called-in-order.js
var require_called_in_order = __commonJS({
  "node_modules/@sinonjs/commons/lib/called-in-order.js"(exports2, module2) {
    "use strict";
    var every = require_array().every;
    function hasCallsLeft(callMap, spy) {
      if (callMap[spy.id] === void 0) {
        callMap[spy.id] = 0;
      }
      return callMap[spy.id] < spy.callCount;
    }
    function checkAdjacentCalls(callMap, spy, index, spies) {
      var calledBeforeNext = true;
      if (index !== spies.length - 1) {
        calledBeforeNext = spy.calledBefore(spies[index + 1]);
      }
      if (hasCallsLeft(callMap, spy) && calledBeforeNext) {
        callMap[spy.id] += 1;
        return true;
      }
      return false;
    }
    function calledInOrder(spies) {
      var callMap = {};
      var _spies = arguments.length > 1 ? arguments : spies;
      return every(_spies, checkAdjacentCalls.bind(null, callMap));
    }
    module2.exports = calledInOrder;
  }
});

// node_modules/@sinonjs/commons/lib/class-name.js
var require_class_name = __commonJS({
  "node_modules/@sinonjs/commons/lib/class-name.js"(exports2, module2) {
    "use strict";
    function className(value) {
      const name = value.constructor && value.constructor.name;
      return name || null;
    }
    module2.exports = className;
  }
});

// node_modules/@sinonjs/commons/lib/deprecated.js
var require_deprecated = __commonJS({
  "node_modules/@sinonjs/commons/lib/deprecated.js"(exports2) {
    "use strict";
    exports2.wrap = function(func, msg) {
      var wrapped = function() {
        exports2.printWarning(msg);
        return func.apply(this, arguments);
      };
      if (func.prototype) {
        wrapped.prototype = func.prototype;
      }
      return wrapped;
    };
    exports2.defaultMsg = function(packageName, funcName) {
      return `${packageName}.${funcName} is deprecated and will be removed from the public API in a future version of ${packageName}.`;
    };
    exports2.printWarning = function(msg) {
      if (typeof process === "object" && process.emitWarning) {
        process.emitWarning(msg);
      } else if (console.info) {
        console.info(msg);
      } else {
        console.log(msg);
      }
    };
  }
});

// node_modules/@sinonjs/commons/lib/every.js
var require_every = __commonJS({
  "node_modules/@sinonjs/commons/lib/every.js"(exports2, module2) {
    "use strict";
    module2.exports = function every(obj, fn) {
      var pass = true;
      try {
        obj.forEach(function() {
          if (!fn.apply(this, arguments)) {
            throw new Error();
          }
        });
      } catch (e) {
        pass = false;
      }
      return pass;
    };
  }
});

// node_modules/@sinonjs/commons/lib/function-name.js
var require_function_name = __commonJS({
  "node_modules/@sinonjs/commons/lib/function-name.js"(exports2, module2) {
    "use strict";
    module2.exports = function functionName(func) {
      if (!func) {
        return "";
      }
      try {
        return func.displayName || func.name || // Use function decomposition as a last resort to get function
        // name. Does not rely on function decomposition to work - if it
        // doesn't debugging will be slightly less informative
        // (i.e. toString will say 'spy' rather than 'myFunc').
        (String(func).match(/function ([^\s(]+)/) || [])[1];
      } catch (e) {
        return "";
      }
    };
  }
});

// node_modules/@sinonjs/commons/lib/order-by-first-call.js
var require_order_by_first_call = __commonJS({
  "node_modules/@sinonjs/commons/lib/order-by-first-call.js"(exports2, module2) {
    "use strict";
    var sort = require_array().sort;
    var slice = require_array().slice;
    function comparator(a, b) {
      var aCall = a.getCall(0);
      var bCall = b.getCall(0);
      var aId = aCall && aCall.callId || -1;
      var bId = bCall && bCall.callId || -1;
      return aId < bId ? -1 : 1;
    }
    function orderByFirstCall(spies) {
      return sort(slice(spies), comparator);
    }
    module2.exports = orderByFirstCall;
  }
});

// node_modules/@sinonjs/commons/lib/prototypes/function.js
var require_function = __commonJS({
  "node_modules/@sinonjs/commons/lib/prototypes/function.js"(exports2, module2) {
    "use strict";
    var copyPrototype = require_copy_prototype_methods();
    module2.exports = copyPrototype(Function.prototype);
  }
});

// node_modules/@sinonjs/commons/lib/prototypes/map.js
var require_map = __commonJS({
  "node_modules/@sinonjs/commons/lib/prototypes/map.js"(exports2, module2) {
    "use strict";
    var copyPrototype = require_copy_prototype_methods();
    module2.exports = copyPrototype(Map.prototype);
  }
});

// node_modules/@sinonjs/commons/lib/prototypes/object.js
var require_object = __commonJS({
  "node_modules/@sinonjs/commons/lib/prototypes/object.js"(exports2, module2) {
    "use strict";
    var copyPrototype = require_copy_prototype_methods();
    module2.exports = copyPrototype(Object.prototype);
  }
});

// node_modules/@sinonjs/commons/lib/prototypes/set.js
var require_set = __commonJS({
  "node_modules/@sinonjs/commons/lib/prototypes/set.js"(exports2, module2) {
    "use strict";
    var copyPrototype = require_copy_prototype_methods();
    module2.exports = copyPrototype(Set.prototype);
  }
});

// node_modules/@sinonjs/commons/lib/prototypes/string.js
var require_string = __commonJS({
  "node_modules/@sinonjs/commons/lib/prototypes/string.js"(exports2, module2) {
    "use strict";
    var copyPrototype = require_copy_prototype_methods();
    module2.exports = copyPrototype(String.prototype);
  }
});

// node_modules/@sinonjs/commons/lib/prototypes/index.js
var require_prototypes = __commonJS({
  "node_modules/@sinonjs/commons/lib/prototypes/index.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      array: require_array(),
      function: require_function(),
      map: require_map(),
      object: require_object(),
      set: require_set(),
      string: require_string()
    };
  }
});

// node_modules/type-detect/type-detect.js
var require_type_detect = __commonJS({
  "node_modules/type-detect/type-detect.js"(exports2, module2) {
    (function(global2, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? module2.exports = factory() : typeof define === "function" && define.amd ? define(factory) : global2.typeDetect = factory();
    })(exports2, (function() {
      "use strict";
      var promiseExists = typeof Promise === "function";
      var globalObject = typeof self === "object" ? self : global;
      var symbolExists = typeof Symbol !== "undefined";
      var mapExists = typeof Map !== "undefined";
      var setExists = typeof Set !== "undefined";
      var weakMapExists = typeof WeakMap !== "undefined";
      var weakSetExists = typeof WeakSet !== "undefined";
      var dataViewExists = typeof DataView !== "undefined";
      var symbolIteratorExists = symbolExists && typeof Symbol.iterator !== "undefined";
      var symbolToStringTagExists = symbolExists && typeof Symbol.toStringTag !== "undefined";
      var setEntriesExists = setExists && typeof Set.prototype.entries === "function";
      var mapEntriesExists = mapExists && typeof Map.prototype.entries === "function";
      var setIteratorPrototype = setEntriesExists && Object.getPrototypeOf((/* @__PURE__ */ new Set()).entries());
      var mapIteratorPrototype = mapEntriesExists && Object.getPrototypeOf((/* @__PURE__ */ new Map()).entries());
      var arrayIteratorExists = symbolIteratorExists && typeof Array.prototype[Symbol.iterator] === "function";
      var arrayIteratorPrototype = arrayIteratorExists && Object.getPrototypeOf([][Symbol.iterator]());
      var stringIteratorExists = symbolIteratorExists && typeof String.prototype[Symbol.iterator] === "function";
      var stringIteratorPrototype = stringIteratorExists && Object.getPrototypeOf(""[Symbol.iterator]());
      var toStringLeftSliceLength = 8;
      var toStringRightSliceLength = -1;
      function typeDetect(obj) {
        var typeofObj = typeof obj;
        if (typeofObj !== "object") {
          return typeofObj;
        }
        if (obj === null) {
          return "null";
        }
        if (obj === globalObject) {
          return "global";
        }
        if (Array.isArray(obj) && (symbolToStringTagExists === false || !(Symbol.toStringTag in obj))) {
          return "Array";
        }
        if (typeof window === "object" && window !== null) {
          if (typeof window.location === "object" && obj === window.location) {
            return "Location";
          }
          if (typeof window.document === "object" && obj === window.document) {
            return "Document";
          }
          if (typeof window.navigator === "object") {
            if (typeof window.navigator.mimeTypes === "object" && obj === window.navigator.mimeTypes) {
              return "MimeTypeArray";
            }
            if (typeof window.navigator.plugins === "object" && obj === window.navigator.plugins) {
              return "PluginArray";
            }
          }
          if ((typeof window.HTMLElement === "function" || typeof window.HTMLElement === "object") && obj instanceof window.HTMLElement) {
            if (obj.tagName === "BLOCKQUOTE") {
              return "HTMLQuoteElement";
            }
            if (obj.tagName === "TD") {
              return "HTMLTableDataCellElement";
            }
            if (obj.tagName === "TH") {
              return "HTMLTableHeaderCellElement";
            }
          }
        }
        var stringTag = symbolToStringTagExists && obj[Symbol.toStringTag];
        if (typeof stringTag === "string") {
          return stringTag;
        }
        var objPrototype = Object.getPrototypeOf(obj);
        if (objPrototype === RegExp.prototype) {
          return "RegExp";
        }
        if (objPrototype === Date.prototype) {
          return "Date";
        }
        if (promiseExists && objPrototype === Promise.prototype) {
          return "Promise";
        }
        if (setExists && objPrototype === Set.prototype) {
          return "Set";
        }
        if (mapExists && objPrototype === Map.prototype) {
          return "Map";
        }
        if (weakSetExists && objPrototype === WeakSet.prototype) {
          return "WeakSet";
        }
        if (weakMapExists && objPrototype === WeakMap.prototype) {
          return "WeakMap";
        }
        if (dataViewExists && objPrototype === DataView.prototype) {
          return "DataView";
        }
        if (mapExists && objPrototype === mapIteratorPrototype) {
          return "Map Iterator";
        }
        if (setExists && objPrototype === setIteratorPrototype) {
          return "Set Iterator";
        }
        if (arrayIteratorExists && objPrototype === arrayIteratorPrototype) {
          return "Array Iterator";
        }
        if (stringIteratorExists && objPrototype === stringIteratorPrototype) {
          return "String Iterator";
        }
        if (objPrototype === null) {
          return "Object";
        }
        return Object.prototype.toString.call(obj).slice(toStringLeftSliceLength, toStringRightSliceLength);
      }
      return typeDetect;
    }));
  }
});

// node_modules/@sinonjs/commons/lib/type-of.js
var require_type_of = __commonJS({
  "node_modules/@sinonjs/commons/lib/type-of.js"(exports2, module2) {
    "use strict";
    var type = require_type_detect();
    module2.exports = function typeOf(value) {
      return type(value).toLowerCase();
    };
  }
});

// node_modules/@sinonjs/commons/lib/value-to-string.js
var require_value_to_string = __commonJS({
  "node_modules/@sinonjs/commons/lib/value-to-string.js"(exports2, module2) {
    "use strict";
    function valueToString(value) {
      if (value && value.toString) {
        return value.toString();
      }
      return String(value);
    }
    module2.exports = valueToString;
  }
});

// node_modules/@sinonjs/commons/lib/index.js
var require_lib = __commonJS({
  "node_modules/@sinonjs/commons/lib/index.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      global: require_global(),
      calledInOrder: require_called_in_order(),
      className: require_class_name(),
      deprecated: require_deprecated(),
      every: require_every(),
      functionName: require_function_name(),
      orderByFirstCall: require_order_by_first_call(),
      prototypes: require_prototypes(),
      typeOf: require_type_of(),
      valueToString: require_value_to_string()
    };
  }
});

// lib/sinon/util/core/extend.js
var require_extend = __commonJS({
  "lib/sinon/util/core/extend.js"(exports2, module2) {
    "use strict";
    var arrayProto = require_lib().prototypes.array;
    var hasOwnProperty = require_lib().prototypes.object.hasOwnProperty;
    var join = arrayProto.join;
    var push = arrayProto.push;
    var hasDontEnumBug = (function() {
      const obj = {
        constructor: function() {
          return "0";
        },
        toString: function() {
          return "1";
        },
        valueOf: function() {
          return "2";
        },
        toLocaleString: function() {
          return "3";
        },
        prototype: function() {
          return "4";
        },
        isPrototypeOf: function() {
          return "5";
        },
        propertyIsEnumerable: function() {
          return "6";
        },
        hasOwnProperty: function() {
          return "7";
        },
        length: function() {
          return "8";
        },
        unique: function() {
          return "9";
        }
      };
      const result = [];
      for (const prop in obj) {
        if (hasOwnProperty(obj, prop)) {
          push(result, obj[prop]());
        }
      }
      return join(result, "") !== "0123456789";
    })();
    function extendCommon(target, sources, doCopy) {
      let source, i, prop;
      for (i = 0; i < sources.length; i++) {
        source = sources[i];
        for (prop in source) {
          if (hasOwnProperty(source, prop)) {
            doCopy(target, source, prop);
          }
        }
        if (hasDontEnumBug && hasOwnProperty(source, "toString") && source.toString !== target.toString) {
          target.toString = source.toString;
        }
      }
      return target;
    }
    module2.exports = function extend(target, ...sources) {
      return extendCommon(
        target,
        sources,
        function copyValue(dest, source, prop) {
          const destOwnPropertyDescriptor = Object.getOwnPropertyDescriptor(
            dest,
            prop
          );
          const sourceOwnPropertyDescriptor = Object.getOwnPropertyDescriptor(
            source,
            prop
          );
          if (prop === "name" && !destOwnPropertyDescriptor.writable) {
            return;
          }
          const descriptors = {
            configurable: sourceOwnPropertyDescriptor.configurable,
            enumerable: sourceOwnPropertyDescriptor.enumerable
          };
          if (hasOwnProperty(sourceOwnPropertyDescriptor, "writable")) {
            descriptors.writable = sourceOwnPropertyDescriptor.writable;
            descriptors.value = sourceOwnPropertyDescriptor.value;
          } else {
            if (sourceOwnPropertyDescriptor.get) {
              descriptors.get = sourceOwnPropertyDescriptor.get.bind(dest);
            }
            if (sourceOwnPropertyDescriptor.set) {
              descriptors.set = sourceOwnPropertyDescriptor.set.bind(dest);
            }
          }
          Object.defineProperty(dest, prop, descriptors);
        }
      );
    };
    module2.exports.nonEnum = function extendNonEnum(target, ...sources) {
      return extendCommon(
        target,
        sources,
        function copyProperty(dest, source, prop) {
          Object.defineProperty(dest, prop, {
            value: source[prop],
            enumerable: false,
            configurable: true,
            writable: true
          });
        }
      );
    };
  }
});

// lib/sinon/util/core/get-next-tick.js
var require_get_next_tick = __commonJS({
  "lib/sinon/util/core/get-next-tick.js"(exports2, module2) {
    "use strict";
    function nextTick(callback) {
      setTimeout(callback, 0);
    }
    module2.exports = function getNextTick(process2, setImmediate) {
      if (typeof process2 === "object" && typeof process2.nextTick === "function") {
        return process2.nextTick;
      }
      if (typeof setImmediate === "function") {
        return setImmediate;
      }
      return nextTick;
    };
  }
});

// lib/sinon/util/core/next-tick.js
var require_next_tick = __commonJS({
  "lib/sinon/util/core/next-tick.js"(exports2, module2) {
    "use strict";
    var globalObject = require_lib().global;
    var getNextTick = require_get_next_tick();
    module2.exports = getNextTick(globalObject.process, globalObject.setImmediate);
  }
});

// lib/sinon/util/core/export-async-behaviors.js
var require_export_async_behaviors = __commonJS({
  "lib/sinon/util/core/export-async-behaviors.js"(exports2, module2) {
    "use strict";
    var arrayProto = require_lib().prototypes.array;
    var reduce = arrayProto.reduce;
    module2.exports = function exportAsyncBehaviors(behaviorMethods) {
      return reduce(
        Object.keys(behaviorMethods),
        function(acc, method) {
          if (method.match(/^(callsArg|yields)/) && !method.match(/Async/)) {
            acc[`${method}Async`] = function() {
              const result = behaviorMethods[method].apply(
                this,
                arguments
              );
              this.callbackAsync = true;
              return result;
            };
          }
          return acc;
        },
        {}
      );
    };
  }
});

// lib/sinon/behavior.js
var require_behavior = __commonJS({
  "lib/sinon/behavior.js"(exports2, module2) {
    "use strict";
    var arrayProto = require_lib().prototypes.array;
    var extend = require_extend();
    var functionName = require_lib().functionName;
    var nextTick = require_next_tick();
    var valueToString = require_lib().valueToString;
    var exportAsyncBehaviors = require_export_async_behaviors();
    var concat = arrayProto.concat;
    var join = arrayProto.join;
    var reverse = arrayProto.reverse;
    var slice = arrayProto.slice;
    var useLeftMostCallback = -1;
    var useRightMostCallback = -2;
    function getCallback(behavior, args) {
      const callArgAt = behavior.callArgAt;
      if (callArgAt >= 0) {
        return args[callArgAt];
      }
      let argumentList;
      if (callArgAt === useLeftMostCallback) {
        argumentList = args;
      }
      if (callArgAt === useRightMostCallback) {
        argumentList = reverse(slice(args));
      }
      const callArgProp = behavior.callArgProp;
      for (let i = 0, l = argumentList.length; i < l; ++i) {
        if (!callArgProp && typeof argumentList[i] === "function") {
          return argumentList[i];
        }
        if (callArgProp && argumentList[i] && typeof argumentList[i][callArgProp] === "function") {
          return argumentList[i][callArgProp];
        }
      }
      return null;
    }
    function getCallbackError(behavior, func, args) {
      if (behavior.callArgAt < 0) {
        let msg;
        if (behavior.callArgProp) {
          msg = `${functionName(
            behavior.stub
          )} expected to yield to '${valueToString(
            behavior.callArgProp
          )}', but no object with such a property was passed.`;
        } else {
          msg = `${functionName(
            behavior.stub
          )} expected to yield, but no callback was passed.`;
        }
        if (args.length > 0) {
          msg += ` Received [${join(args, ", ")}]`;
        }
        return msg;
      }
      return `argument at index ${behavior.callArgAt} is not a function: ${func}`;
    }
    function ensureArgs(name, behavior, args) {
      const property = name.replace(/sArg/, "ArgAt");
      const index = behavior[property];
      if (index >= args.length) {
        throw new TypeError(
          `${name} failed: ${index + 1} arguments required but only ${args.length} present`
        );
      }
    }
    function callCallback(behavior, args) {
      if (typeof behavior.callArgAt === "number") {
        ensureArgs("callsArg", behavior, args);
        const func = getCallback(behavior, args);
        if (typeof func !== "function") {
          throw new TypeError(getCallbackError(behavior, func, args));
        }
        if (behavior.callbackAsync) {
          nextTick(function() {
            func.apply(
              behavior.callbackContext,
              behavior.callbackArguments
            );
          });
        } else {
          return func.apply(
            behavior.callbackContext,
            behavior.callbackArguments
          );
        }
      }
      return void 0;
    }
    var proto = {
      create: function create(stub) {
        const behavior = extend({}, proto);
        delete behavior.create;
        delete behavior.addBehavior;
        delete behavior.createBehavior;
        behavior.stub = stub;
        if (stub.defaultBehavior && stub.defaultBehavior.promiseLibrary) {
          behavior.promiseLibrary = stub.defaultBehavior.promiseLibrary;
        }
        return behavior;
      },
      isPresent: function isPresent() {
        return typeof this.callArgAt === "number" || this.exception || this.exceptionCreator || typeof this.returnArgAt === "number" || this.returnThis || typeof this.resolveArgAt === "number" || this.resolveThis || typeof this.throwArgAt === "number" || this.fakeFn || this.returnValueDefined;
      },
      /*eslint complexity: ["error", 20]*/
      invoke: function invoke(context, args) {
        const returnValue = callCallback(this, args);
        if (this.exception) {
          throw this.exception;
        } else if (this.exceptionCreator) {
          this.exception = this.exceptionCreator();
          this.exceptionCreator = void 0;
          throw this.exception;
        } else if (typeof this.returnArgAt === "number") {
          ensureArgs("returnsArg", this, args);
          return args[this.returnArgAt];
        } else if (this.returnThis) {
          return context;
        } else if (typeof this.throwArgAt === "number") {
          ensureArgs("throwsArg", this, args);
          throw args[this.throwArgAt];
        } else if (this.fakeFn) {
          return this.fakeFn.apply(context, args);
        } else if (typeof this.resolveArgAt === "number") {
          ensureArgs("resolvesArg", this, args);
          return (this.promiseLibrary || Promise).resolve(
            args[this.resolveArgAt]
          );
        } else if (this.resolveThis) {
          return (this.promiseLibrary || Promise).resolve(context);
        } else if (this.resolve) {
          return (this.promiseLibrary || Promise).resolve(this.returnValue);
        } else if (this.reject) {
          return (this.promiseLibrary || Promise).reject(this.returnValue);
        } else if (this.callsThrough) {
          const wrappedMethod = this.effectiveWrappedMethod();
          return wrappedMethod.apply(context, args);
        } else if (this.callsThroughWithNew) {
          const WrappedClass = this.effectiveWrappedMethod();
          const argsArray = slice(args);
          const F = WrappedClass.bind.apply(
            WrappedClass,
            concat([null], argsArray)
          );
          return new F();
        } else if (typeof this.returnValue !== "undefined") {
          return this.returnValue;
        } else if (typeof this.callArgAt === "number") {
          return returnValue;
        }
        return this.returnValue;
      },
      effectiveWrappedMethod: function effectiveWrappedMethod() {
        for (let stubb = this.stub; stubb; stubb = stubb.parent) {
          if (stubb.wrappedMethod) {
            return stubb.wrappedMethod;
          }
        }
        throw new Error("Unable to find wrapped method");
      },
      onCall: function onCall(index) {
        return this.stub.onCall(index);
      },
      onFirstCall: function onFirstCall() {
        return this.stub.onFirstCall();
      },
      onSecondCall: function onSecondCall() {
        return this.stub.onSecondCall();
      },
      onThirdCall: function onThirdCall() {
        return this.stub.onThirdCall();
      },
      withArgs: function withArgs() {
        throw new Error(
          'Defining a stub by invoking "stub.onCall(...).withArgs(...)" is not supported. Use "stub.withArgs(...).onCall(...)" to define sequential behavior for calls with certain arguments.'
        );
      }
    };
    function createBehavior(behaviorMethod) {
      return function() {
        this.defaultBehavior = this.defaultBehavior || proto.create(this);
        this.defaultBehavior[behaviorMethod].apply(
          this.defaultBehavior,
          arguments
        );
        return this;
      };
    }
    function addBehavior(stub, name, fn) {
      proto[name] = function() {
        fn.apply(this, concat([this], slice(arguments)));
        return this.stub || this;
      };
      stub[name] = createBehavior(name);
    }
    proto.addBehavior = addBehavior;
    proto.createBehavior = createBehavior;
    var asyncBehaviors = exportAsyncBehaviors(proto);
    module2.exports = extend.nonEnum({}, proto, asyncBehaviors);
  }
});

// lib/sinon/util/core/walk.js
var require_walk = __commonJS({
  "lib/sinon/util/core/walk.js"(exports2, module2) {
    "use strict";
    var forEach = require_lib().prototypes.array.forEach;
    function walkInternal(obj, iterator, context, originalObj, seen) {
      let prop;
      const proto = Object.getPrototypeOf(obj);
      if (typeof Object.getOwnPropertyNames !== "function") {
        for (prop in obj) {
          iterator.call(context, obj[prop], prop, obj);
        }
        return;
      }
      forEach(Object.getOwnPropertyNames(obj), function(k) {
        if (seen[k] !== true) {
          seen[k] = true;
          const target = typeof Object.getOwnPropertyDescriptor(obj, k).get === "function" ? originalObj : obj;
          iterator.call(context, k, target);
        }
      });
      if (proto) {
        walkInternal(proto, iterator, context, originalObj, seen);
      }
    }
    module2.exports = function walk(obj, iterator, context) {
      return walkInternal(obj, iterator, context, obj, {});
    };
  }
});

// lib/sinon/util/core/get-property-descriptor.js
var require_get_property_descriptor = __commonJS({
  "lib/sinon/util/core/get-property-descriptor.js"(exports2, module2) {
    "use strict";
    function getPropertyDescriptor(object, property) {
      let proto = object;
      let descriptor;
      const isOwn = Boolean(
        object && Object.getOwnPropertyDescriptor(object, property)
      );
      while (proto && !(descriptor = Object.getOwnPropertyDescriptor(proto, property))) {
        proto = Object.getPrototypeOf(proto);
      }
      if (descriptor) {
        descriptor.isOwn = isOwn;
      }
      return descriptor;
    }
    module2.exports = getPropertyDescriptor;
  }
});

// lib/sinon/collect-own-methods.js
var require_collect_own_methods = __commonJS({
  "lib/sinon/collect-own-methods.js"(exports2, module2) {
    "use strict";
    var walk = require_walk();
    var getPropertyDescriptor = require_get_property_descriptor();
    var hasOwnProperty = require_lib().prototypes.object.hasOwnProperty;
    var push = require_lib().prototypes.array.push;
    function collectMethod(methods, object, prop, propOwner) {
      if (typeof getPropertyDescriptor(propOwner, prop).value === "function" && hasOwnProperty(object, prop)) {
        push(methods, object[prop]);
      }
    }
    function collectOwnMethods(object) {
      const methods = [];
      walk(object, collectMethod.bind(null, methods, object));
      return methods;
    }
    module2.exports = collectOwnMethods;
  }
});

// lib/sinon/util/core/is-property-configurable.js
var require_is_property_configurable = __commonJS({
  "lib/sinon/util/core/is-property-configurable.js"(exports2, module2) {
    "use strict";
    var getPropertyDescriptor = require_get_property_descriptor();
    function isPropertyConfigurable(obj, propName) {
      const propertyDescriptor = getPropertyDescriptor(obj, propName);
      return propertyDescriptor ? propertyDescriptor.configurable : true;
    }
    module2.exports = isPropertyConfigurable;
  }
});

// node_modules/@sinonjs/samsam/lib/is-nan.js
var require_is_nan = __commonJS({
  "node_modules/@sinonjs/samsam/lib/is-nan.js"(exports2, module2) {
    "use strict";
    function isNaN2(value) {
      return typeof value === "number" && value !== value;
    }
    module2.exports = isNaN2;
  }
});

// node_modules/@sinonjs/samsam/lib/is-neg-zero.js
var require_is_neg_zero = __commonJS({
  "node_modules/@sinonjs/samsam/lib/is-neg-zero.js"(exports2, module2) {
    "use strict";
    function isNegZero(value) {
      return value === 0 && 1 / value === -Infinity;
    }
    module2.exports = isNegZero;
  }
});

// node_modules/@sinonjs/samsam/lib/identical.js
var require_identical = __commonJS({
  "node_modules/@sinonjs/samsam/lib/identical.js"(exports2, module2) {
    "use strict";
    var isNaN2 = require_is_nan();
    var isNegZero = require_is_neg_zero();
    function identical(obj1, obj2) {
      if (obj1 === obj2 || isNaN2(obj1) && isNaN2(obj2)) {
        return obj1 !== 0 || isNegZero(obj1) === isNegZero(obj2);
      }
      return false;
    }
    module2.exports = identical;
  }
});

// node_modules/@sinonjs/samsam/lib/get-class.js
var require_get_class = __commonJS({
  "node_modules/@sinonjs/samsam/lib/get-class.js"(exports2, module2) {
    "use strict";
    var toString = require_lib().prototypes.object.toString;
    function getClass(value) {
      return toString(value).split(/[ \]]/)[1];
    }
    module2.exports = getClass;
  }
});

// node_modules/@sinonjs/samsam/lib/is-arguments.js
var require_is_arguments = __commonJS({
  "node_modules/@sinonjs/samsam/lib/is-arguments.js"(exports2, module2) {
    "use strict";
    var getClass = require_get_class();
    function isArguments(object) {
      return getClass(object) === "Arguments";
    }
    module2.exports = isArguments;
  }
});

// node_modules/@sinonjs/samsam/lib/is-element.js
var require_is_element = __commonJS({
  "node_modules/@sinonjs/samsam/lib/is-element.js"(exports2, module2) {
    "use strict";
    var div = typeof document !== "undefined" && document.createElement("div");
    function isElement(object) {
      if (!object || object.nodeType !== 1 || !div) {
        return false;
      }
      try {
        object.appendChild(div);
        object.removeChild(div);
      } catch (e) {
        return false;
      }
      return true;
    }
    module2.exports = isElement;
  }
});

// node_modules/@sinonjs/samsam/lib/is-set.js
var require_is_set = __commonJS({
  "node_modules/@sinonjs/samsam/lib/is-set.js"(exports2, module2) {
    "use strict";
    function isSet(val) {
      return typeof Set !== "undefined" && val instanceof Set || false;
    }
    module2.exports = isSet;
  }
});

// node_modules/@sinonjs/samsam/lib/is-map.js
var require_is_map = __commonJS({
  "node_modules/@sinonjs/samsam/lib/is-map.js"(exports2, module2) {
    "use strict";
    function isMap(value) {
      return typeof Map !== "undefined" && value instanceof Map;
    }
    module2.exports = isMap;
  }
});

// node_modules/@sinonjs/samsam/node_modules/type-detect/type-detect.js
var require_type_detect2 = __commonJS({
  "node_modules/@sinonjs/samsam/node_modules/type-detect/type-detect.js"(exports2, module2) {
    (function(global2, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? module2.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, global2.typeDetect = factory());
    })(exports2, (function() {
      "use strict";
      var promiseExists = typeof Promise === "function";
      var globalObject = (function(Obj) {
        if (typeof globalThis === "object") {
          return globalThis;
        }
        Object.defineProperty(Obj, "typeDetectGlobalObject", {
          get: function get() {
            return this;
          },
          configurable: true
        });
        var global2 = typeDetectGlobalObject;
        delete Obj.typeDetectGlobalObject;
        return global2;
      })(Object.prototype);
      var symbolExists = typeof Symbol !== "undefined";
      var mapExists = typeof Map !== "undefined";
      var setExists = typeof Set !== "undefined";
      var weakMapExists = typeof WeakMap !== "undefined";
      var weakSetExists = typeof WeakSet !== "undefined";
      var dataViewExists = typeof DataView !== "undefined";
      var symbolIteratorExists = symbolExists && typeof Symbol.iterator !== "undefined";
      var symbolToStringTagExists = symbolExists && typeof Symbol.toStringTag !== "undefined";
      var setEntriesExists = setExists && typeof Set.prototype.entries === "function";
      var mapEntriesExists = mapExists && typeof Map.prototype.entries === "function";
      var setIteratorPrototype = setEntriesExists && Object.getPrototypeOf((/* @__PURE__ */ new Set()).entries());
      var mapIteratorPrototype = mapEntriesExists && Object.getPrototypeOf((/* @__PURE__ */ new Map()).entries());
      var arrayIteratorExists = symbolIteratorExists && typeof Array.prototype[Symbol.iterator] === "function";
      var arrayIteratorPrototype = arrayIteratorExists && Object.getPrototypeOf([][Symbol.iterator]());
      var stringIteratorExists = symbolIteratorExists && typeof String.prototype[Symbol.iterator] === "function";
      var stringIteratorPrototype = stringIteratorExists && Object.getPrototypeOf(""[Symbol.iterator]());
      var toStringLeftSliceLength = 8;
      var toStringRightSliceLength = -1;
      function typeDetect(obj) {
        var typeofObj = typeof obj;
        if (typeofObj !== "object") {
          return typeofObj;
        }
        if (obj === null) {
          return "null";
        }
        if (obj === globalObject) {
          return "global";
        }
        if (Array.isArray(obj) && (symbolToStringTagExists === false || !(Symbol.toStringTag in obj))) {
          return "Array";
        }
        if (typeof window === "object" && window !== null) {
          if (typeof window.location === "object" && obj === window.location) {
            return "Location";
          }
          if (typeof window.document === "object" && obj === window.document) {
            return "Document";
          }
          if (typeof window.navigator === "object") {
            if (typeof window.navigator.mimeTypes === "object" && obj === window.navigator.mimeTypes) {
              return "MimeTypeArray";
            }
            if (typeof window.navigator.plugins === "object" && obj === window.navigator.plugins) {
              return "PluginArray";
            }
          }
          if ((typeof window.HTMLElement === "function" || typeof window.HTMLElement === "object") && obj instanceof window.HTMLElement) {
            if (obj.tagName === "BLOCKQUOTE") {
              return "HTMLQuoteElement";
            }
            if (obj.tagName === "TD") {
              return "HTMLTableDataCellElement";
            }
            if (obj.tagName === "TH") {
              return "HTMLTableHeaderCellElement";
            }
          }
        }
        var stringTag = symbolToStringTagExists && obj[Symbol.toStringTag];
        if (typeof stringTag === "string") {
          return stringTag;
        }
        var objPrototype = Object.getPrototypeOf(obj);
        if (objPrototype === RegExp.prototype) {
          return "RegExp";
        }
        if (objPrototype === Date.prototype) {
          return "Date";
        }
        if (promiseExists && objPrototype === Promise.prototype) {
          return "Promise";
        }
        if (setExists && objPrototype === Set.prototype) {
          return "Set";
        }
        if (mapExists && objPrototype === Map.prototype) {
          return "Map";
        }
        if (weakSetExists && objPrototype === WeakSet.prototype) {
          return "WeakSet";
        }
        if (weakMapExists && objPrototype === WeakMap.prototype) {
          return "WeakMap";
        }
        if (dataViewExists && objPrototype === DataView.prototype) {
          return "DataView";
        }
        if (mapExists && objPrototype === mapIteratorPrototype) {
          return "Map Iterator";
        }
        if (setExists && objPrototype === setIteratorPrototype) {
          return "Set Iterator";
        }
        if (arrayIteratorExists && objPrototype === arrayIteratorPrototype) {
          return "Array Iterator";
        }
        if (stringIteratorExists && objPrototype === stringIteratorPrototype) {
          return "String Iterator";
        }
        if (objPrototype === null) {
          return "Object";
        }
        return Object.prototype.toString.call(obj).slice(toStringLeftSliceLength, toStringRightSliceLength);
      }
      return typeDetect;
    }));
  }
});

// node_modules/@sinonjs/samsam/lib/array-types.js
var require_array_types = __commonJS({
  "node_modules/@sinonjs/samsam/lib/array-types.js"(exports2, module2) {
    "use strict";
    var ARRAY_TYPES = [
      Array,
      Int8Array,
      Uint8Array,
      Uint8ClampedArray,
      Int16Array,
      Uint16Array,
      Int32Array,
      Uint32Array,
      Float32Array,
      Float64Array
    ];
    module2.exports = ARRAY_TYPES;
  }
});

// node_modules/@sinonjs/samsam/lib/is-array-type.js
var require_is_array_type = __commonJS({
  "node_modules/@sinonjs/samsam/lib/is-array-type.js"(exports2, module2) {
    "use strict";
    var functionName = require_lib().functionName;
    var indexOf = require_lib().prototypes.array.indexOf;
    var map = require_lib().prototypes.array.map;
    var ARRAY_TYPES = require_array_types();
    var type = require_type_detect2();
    function isArrayType(object) {
      return indexOf(map(ARRAY_TYPES, functionName), type(object)) !== -1;
    }
    module2.exports = isArrayType;
  }
});

// node_modules/@sinonjs/samsam/lib/is-date.js
var require_is_date = __commonJS({
  "node_modules/@sinonjs/samsam/lib/is-date.js"(exports2, module2) {
    "use strict";
    function isDate(value) {
      return value instanceof Date;
    }
    module2.exports = isDate;
  }
});

// node_modules/@sinonjs/samsam/lib/is-iterable.js
var require_is_iterable = __commonJS({
  "node_modules/@sinonjs/samsam/lib/is-iterable.js"(exports2, module2) {
    "use strict";
    function isIterable(val) {
      if (typeof val !== "object") {
        return false;
      }
      return typeof val[Symbol.iterator] === "function";
    }
    module2.exports = isIterable;
  }
});

// node_modules/@sinonjs/samsam/lib/is-object.js
var require_is_object = __commonJS({
  "node_modules/@sinonjs/samsam/lib/is-object.js"(exports2, module2) {
    "use strict";
    function isObject(value) {
      return typeof value === "object" && value !== null && // none of these are collection objects, so we can return false
      !(value instanceof Boolean) && !(value instanceof Date) && !(value instanceof Error) && !(value instanceof Number) && !(value instanceof RegExp) && !(value instanceof String);
    }
    module2.exports = isObject;
  }
});

// node_modules/@sinonjs/samsam/lib/is-subset.js
var require_is_subset = __commonJS({
  "node_modules/@sinonjs/samsam/lib/is-subset.js"(exports2, module2) {
    "use strict";
    var forEach = require_lib().prototypes.set.forEach;
    function isSubset(s1, s2, compare) {
      var allContained = true;
      forEach(s1, function(v1) {
        var includes = false;
        forEach(s2, function(v2) {
          if (compare(v2, v1)) {
            includes = true;
          }
        });
        allContained = allContained && includes;
      });
      return allContained;
    }
    module2.exports = isSubset;
  }
});

// node_modules/@sinonjs/samsam/lib/deep-equal.js
var require_deep_equal = __commonJS({
  "node_modules/@sinonjs/samsam/lib/deep-equal.js"(exports2, module2) {
    "use strict";
    var valueToString = require_lib().valueToString;
    var className = require_lib().className;
    var typeOf = require_lib().typeOf;
    var arrayProto = require_lib().prototypes.array;
    var objectProto = require_lib().prototypes.object;
    var mapForEach = require_lib().prototypes.map.forEach;
    var getClass = require_get_class();
    var identical = require_identical();
    var isArguments = require_is_arguments();
    var isArrayType = require_is_array_type();
    var isDate = require_is_date();
    var isElement = require_is_element();
    var isIterable = require_is_iterable();
    var isMap = require_is_map();
    var isNaN2 = require_is_nan();
    var isObject = require_is_object();
    var isSet = require_is_set();
    var isSubset = require_is_subset();
    var concat = arrayProto.concat;
    var every = arrayProto.every;
    var push = arrayProto.push;
    var getTime = Date.prototype.getTime;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var indexOf = arrayProto.indexOf;
    var keys = Object.keys;
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    function deepEqualCyclic(actual, expectation, match) {
      var actualObjects = [];
      var expectationObjects = [];
      var actualPaths = [];
      var expectationPaths = [];
      var compared = {};
      return (function deepEqual(actualObj, expectationObj, actualPath, expectationPath) {
        if (match && match.isMatcher(expectationObj)) {
          if (match.isMatcher(actualObj)) {
            return actualObj === expectationObj;
          }
          return expectationObj.test(actualObj);
        }
        var actualType = typeof actualObj;
        var expectationType = typeof expectationObj;
        if (actualObj === expectationObj || isNaN2(actualObj) || isNaN2(expectationObj) || actualObj === null || expectationObj === null || actualObj === void 0 || expectationObj === void 0 || actualType !== "object" || expectationType !== "object") {
          return identical(actualObj, expectationObj);
        }
        if (isElement(actualObj) || isElement(expectationObj)) {
          return false;
        }
        var isActualDate = isDate(actualObj);
        var isExpectationDate = isDate(expectationObj);
        if (isActualDate || isExpectationDate) {
          if (!isActualDate || !isExpectationDate || getTime.call(actualObj) !== getTime.call(expectationObj)) {
            return false;
          }
        }
        if (actualObj instanceof RegExp && expectationObj instanceof RegExp) {
          if (valueToString(actualObj) !== valueToString(expectationObj)) {
            return false;
          }
        }
        if (actualObj instanceof Promise && expectationObj instanceof Promise) {
          return actualObj === expectationObj;
        }
        if (actualObj instanceof Error && expectationObj instanceof Error) {
          return actualObj === expectationObj;
        }
        var actualClass = getClass(actualObj);
        var expectationClass = getClass(expectationObj);
        var actualKeys = keys(actualObj);
        var expectationKeys = keys(expectationObj);
        var actualName = className(actualObj);
        var expectationName = className(expectationObj);
        var expectationSymbols = typeOf(getOwnPropertySymbols) === "function" ? getOwnPropertySymbols(expectationObj) : (
          /* istanbul ignore next: cannot collect coverage for engine that doesn't support Symbol */
          []
        );
        var expectationKeysAndSymbols = concat(
          expectationKeys,
          expectationSymbols
        );
        if (isArguments(actualObj) || isArguments(expectationObj)) {
          if (actualObj.length !== expectationObj.length) {
            return false;
          }
        } else {
          if (actualType !== expectationType || actualClass !== expectationClass || actualKeys.length !== expectationKeys.length || actualName && expectationName && actualName !== expectationName) {
            return false;
          }
        }
        if (isSet(actualObj) || isSet(expectationObj)) {
          if (!isSet(actualObj) || !isSet(expectationObj) || actualObj.size !== expectationObj.size) {
            return false;
          }
          return isSubset(actualObj, expectationObj, deepEqual);
        }
        if (isMap(actualObj) || isMap(expectationObj)) {
          if (!isMap(actualObj) || !isMap(expectationObj) || actualObj.size !== expectationObj.size) {
            return false;
          }
          var mapsDeeplyEqual = true;
          mapForEach(actualObj, function(value, key) {
            mapsDeeplyEqual = mapsDeeplyEqual && deepEqualCyclic(value, expectationObj.get(key));
          });
          return mapsDeeplyEqual;
        }
        if (actualObj.constructor && actualObj.constructor.name === "jQuery" && typeof actualObj.is === "function") {
          return actualObj.is(expectationObj);
        }
        var isActualNonArrayIterable = isIterable(actualObj) && !isArrayType(actualObj) && !isArguments(actualObj);
        var isExpectationNonArrayIterable = isIterable(expectationObj) && !isArrayType(expectationObj) && !isArguments(expectationObj);
        if (isActualNonArrayIterable || isExpectationNonArrayIterable) {
          var actualArray = Array.from(actualObj);
          var expectationArray = Array.from(expectationObj);
          if (actualArray.length !== expectationArray.length) {
            return false;
          }
          var arrayDeeplyEquals = true;
          every(actualArray, function(key) {
            arrayDeeplyEquals = arrayDeeplyEquals && deepEqualCyclic(actualArray[key], expectationArray[key]);
          });
          return arrayDeeplyEquals;
        }
        return every(expectationKeysAndSymbols, function(key) {
          if (!hasOwnProperty(actualObj, key)) {
            return false;
          }
          var actualValue = actualObj[key];
          var expectationValue = expectationObj[key];
          var actualObject = isObject(actualValue);
          var expectationObject = isObject(expectationValue);
          var actualIndex = actualObject ? indexOf(actualObjects, actualValue) : -1;
          var expectationIndex = expectationObject ? indexOf(expectationObjects, expectationValue) : -1;
          var newActualPath = actualIndex !== -1 ? actualPaths[actualIndex] : `${actualPath}[${JSON.stringify(key)}]`;
          var newExpectationPath = expectationIndex !== -1 ? expectationPaths[expectationIndex] : `${expectationPath}[${JSON.stringify(key)}]`;
          var combinedPath = newActualPath + newExpectationPath;
          if (compared[combinedPath]) {
            return true;
          }
          if (actualIndex === -1 && actualObject) {
            push(actualObjects, actualValue);
            push(actualPaths, newActualPath);
          }
          if (expectationIndex === -1 && expectationObject) {
            push(expectationObjects, expectationValue);
            push(expectationPaths, newExpectationPath);
          }
          if (actualObject && expectationObject) {
            compared[combinedPath] = true;
          }
          return deepEqual(
            actualValue,
            expectationValue,
            newActualPath,
            newExpectationPath
          );
        });
      })(actual, expectation, "$1", "$2");
    }
    deepEqualCyclic.use = function(match) {
      return function deepEqual(a, b) {
        return deepEqualCyclic(a, b, match);
      };
    };
    module2.exports = deepEqualCyclic;
  }
});

// node_modules/@sinonjs/samsam/lib/iterable-to-string.js
var require_iterable_to_string = __commonJS({
  "node_modules/@sinonjs/samsam/lib/iterable-to-string.js"(exports2, module2) {
    "use strict";
    var slice = require_lib().prototypes.string.slice;
    var typeOf = require_lib().typeOf;
    var valueToString = require_lib().valueToString;
    function iterableToString(obj) {
      if (typeOf(obj) === "map") {
        return mapToString(obj);
      }
      return genericIterableToString(obj);
    }
    function mapToString(map) {
      var representation = "";
      map.forEach(function(value, key) {
        representation += `[${stringify(key)},${stringify(value)}],`;
      });
      representation = slice(representation, 0, -1);
      return representation;
    }
    function genericIterableToString(iterable) {
      var representation = "";
      iterable.forEach(function(value) {
        representation += `${stringify(value)},`;
      });
      representation = slice(representation, 0, -1);
      return representation;
    }
    function stringify(item) {
      return typeof item === "string" ? `'${item}'` : valueToString(item);
    }
    module2.exports = iterableToString;
  }
});

// node_modules/@sinonjs/samsam/lib/create-matcher/matcher-prototype.js
var require_matcher_prototype = __commonJS({
  "node_modules/@sinonjs/samsam/lib/create-matcher/matcher-prototype.js"(exports2, module2) {
    "use strict";
    var matcherPrototype = {
      toString: function() {
        return this.message;
      }
    };
    matcherPrototype.or = function(valueOrMatcher) {
      var createMatcher = require_create_matcher();
      var isMatcher = createMatcher.isMatcher;
      if (!arguments.length) {
        throw new TypeError("Matcher expected");
      }
      var m2 = isMatcher(valueOrMatcher) ? valueOrMatcher : createMatcher(valueOrMatcher);
      var m1 = this;
      var or = Object.create(matcherPrototype);
      or.test = function(actual) {
        return m1.test(actual) || m2.test(actual);
      };
      or.message = `${m1.message}.or(${m2.message})`;
      return or;
    };
    matcherPrototype.and = function(valueOrMatcher) {
      var createMatcher = require_create_matcher();
      var isMatcher = createMatcher.isMatcher;
      if (!arguments.length) {
        throw new TypeError("Matcher expected");
      }
      var m2 = isMatcher(valueOrMatcher) ? valueOrMatcher : createMatcher(valueOrMatcher);
      var m1 = this;
      var and = Object.create(matcherPrototype);
      and.test = function(actual) {
        return m1.test(actual) && m2.test(actual);
      };
      and.message = `${m1.message}.and(${m2.message})`;
      return and;
    };
    module2.exports = matcherPrototype;
  }
});

// node_modules/@sinonjs/samsam/lib/create-matcher/is-matcher.js
var require_is_matcher = __commonJS({
  "node_modules/@sinonjs/samsam/lib/create-matcher/is-matcher.js"(exports2, module2) {
    "use strict";
    var isPrototypeOf = require_lib().prototypes.object.isPrototypeOf;
    var matcherPrototype = require_matcher_prototype();
    function isMatcher(object) {
      return isPrototypeOf(matcherPrototype, object);
    }
    module2.exports = isMatcher;
  }
});

// node_modules/@sinonjs/samsam/lib/create-matcher/assert-matcher.js
var require_assert_matcher = __commonJS({
  "node_modules/@sinonjs/samsam/lib/create-matcher/assert-matcher.js"(exports2, module2) {
    "use strict";
    var isMatcher = require_is_matcher();
    function assertMatcher(value) {
      if (!isMatcher(value)) {
        throw new TypeError("Matcher expected");
      }
    }
    module2.exports = assertMatcher;
  }
});

// node_modules/@sinonjs/samsam/lib/create-matcher/assert-method-exists.js
var require_assert_method_exists = __commonJS({
  "node_modules/@sinonjs/samsam/lib/create-matcher/assert-method-exists.js"(exports2, module2) {
    "use strict";
    function assertMethodExists(value, method, name, methodPath) {
      if (value[method] === null || value[method] === void 0) {
        throw new TypeError(`Expected ${name} to have method ${methodPath}`);
      }
    }
    module2.exports = assertMethodExists;
  }
});

// node_modules/@sinonjs/samsam/lib/create-matcher/assert-type.js
var require_assert_type = __commonJS({
  "node_modules/@sinonjs/samsam/lib/create-matcher/assert-type.js"(exports2, module2) {
    "use strict";
    var typeOf = require_lib().typeOf;
    function assertType(value, type, name) {
      var actual = typeOf(value);
      if (actual !== type) {
        throw new TypeError(
          `Expected type of ${name} to be ${type}, but was ${actual}`
        );
      }
    }
    module2.exports = assertType;
  }
});

// node_modules/@sinonjs/samsam/lib/create-matcher/is-iterable.js
var require_is_iterable2 = __commonJS({
  "node_modules/@sinonjs/samsam/lib/create-matcher/is-iterable.js"(exports2, module2) {
    "use strict";
    var typeOf = require_lib().typeOf;
    function isIterable(value) {
      return Boolean(value) && typeOf(value.forEach) === "function";
    }
    module2.exports = isIterable;
  }
});

// node_modules/@sinonjs/samsam/lib/create-matcher/match-object.js
var require_match_object = __commonJS({
  "node_modules/@sinonjs/samsam/lib/create-matcher/match-object.js"(exports2, module2) {
    "use strict";
    var every = require_lib().prototypes.array.every;
    var concat = require_lib().prototypes.array.concat;
    var typeOf = require_lib().typeOf;
    var deepEqualFactory = require_deep_equal().use;
    var identical = require_identical();
    var isMatcher = require_is_matcher();
    var keys = Object.keys;
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    function matchObject(actual, expectation, matcher) {
      var deepEqual = deepEqualFactory(matcher);
      if (actual === null || actual === void 0) {
        return false;
      }
      var expectedKeys = keys(expectation);
      if (typeOf(getOwnPropertySymbols) === "function") {
        expectedKeys = concat(expectedKeys, getOwnPropertySymbols(expectation));
      }
      return every(expectedKeys, function(key) {
        var exp = expectation[key];
        var act = actual[key];
        if (isMatcher(exp)) {
          if (!exp.test(act)) {
            return false;
          }
        } else if (typeOf(exp) === "object") {
          if (identical(exp, act)) {
            return true;
          }
          if (!matchObject(act, exp, matcher)) {
            return false;
          }
        } else if (!deepEqual(act, exp)) {
          return false;
        }
        return true;
      });
    }
    module2.exports = matchObject;
  }
});

// node_modules/@sinonjs/samsam/lib/create-matcher/type-map.js
var require_type_map = __commonJS({
  "node_modules/@sinonjs/samsam/lib/create-matcher/type-map.js"(exports2, module2) {
    "use strict";
    var functionName = require_lib().functionName;
    var join = require_lib().prototypes.array.join;
    var map = require_lib().prototypes.array.map;
    var stringIndexOf = require_lib().prototypes.string.indexOf;
    var valueToString = require_lib().valueToString;
    var matchObject = require_match_object();
    var createTypeMap = function(match) {
      return {
        function: function(m, expectation, message) {
          m.test = expectation;
          m.message = message || `match(${functionName(expectation)})`;
        },
        number: function(m, expectation) {
          m.test = function(actual) {
            return expectation == actual;
          };
        },
        object: function(m, expectation) {
          var array = [];
          if (typeof expectation.test === "function") {
            m.test = function(actual) {
              return expectation.test(actual) === true;
            };
            m.message = `match(${functionName(expectation.test)})`;
            return m;
          }
          array = map(Object.keys(expectation), function(key) {
            return `${key}: ${valueToString(expectation[key])}`;
          });
          m.test = function(actual) {
            return matchObject(actual, expectation, match);
          };
          m.message = `match(${join(array, ", ")})`;
          return m;
        },
        regexp: function(m, expectation) {
          m.test = function(actual) {
            return typeof actual === "string" && expectation.test(actual);
          };
        },
        string: function(m, expectation) {
          m.test = function(actual) {
            return typeof actual === "string" && stringIndexOf(actual, expectation) !== -1;
          };
          m.message = `match("${expectation}")`;
        }
      };
    };
    module2.exports = createTypeMap;
  }
});

// node_modules/@sinonjs/samsam/lib/create-matcher.js
var require_create_matcher = __commonJS({
  "node_modules/@sinonjs/samsam/lib/create-matcher.js"(exports2, module2) {
    "use strict";
    var arrayProto = require_lib().prototypes.array;
    var deepEqual = require_deep_equal().use(createMatcher);
    var every = require_lib().every;
    var functionName = require_lib().functionName;
    var iterableToString = require_iterable_to_string();
    var objectProto = require_lib().prototypes.object;
    var typeOf = require_lib().typeOf;
    var valueToString = require_lib().valueToString;
    var assertMatcher = require_assert_matcher();
    var assertMethodExists = require_assert_method_exists();
    var assertType = require_assert_type();
    var isIterable = require_is_iterable2();
    var isMatcher = require_is_matcher();
    var matcherPrototype = require_matcher_prototype();
    var arrayIndexOf = arrayProto.indexOf;
    var some = arrayProto.some;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var objectToString = objectProto.toString;
    var TYPE_MAP = require_type_map()(createMatcher);
    function createMatcher(expectation, message) {
      var m = Object.create(matcherPrototype);
      var type = typeOf(expectation);
      if (message !== void 0 && typeof message !== "string") {
        throw new TypeError("Message should be a string");
      }
      if (arguments.length > 2) {
        throw new TypeError(
          `Expected 1 or 2 arguments, received ${arguments.length}`
        );
      }
      if (type in TYPE_MAP) {
        TYPE_MAP[type](m, expectation, message);
      } else {
        m.test = function(actual) {
          return deepEqual(actual, expectation);
        };
      }
      if (!m.message) {
        m.message = `match(${valueToString(expectation)})`;
      }
      Object.defineProperty(m, "message", {
        configurable: false,
        writable: false,
        value: m.message
      });
      return m;
    }
    createMatcher.isMatcher = isMatcher;
    createMatcher.any = createMatcher(function() {
      return true;
    }, "any");
    createMatcher.defined = createMatcher(function(actual) {
      return actual !== null && actual !== void 0;
    }, "defined");
    createMatcher.truthy = createMatcher(function(actual) {
      return Boolean(actual);
    }, "truthy");
    createMatcher.falsy = createMatcher(function(actual) {
      return !actual;
    }, "falsy");
    createMatcher.same = function(expectation) {
      return createMatcher(
        function(actual) {
          return expectation === actual;
        },
        `same(${valueToString(expectation)})`
      );
    };
    createMatcher.in = function(arrayOfExpectations) {
      if (typeOf(arrayOfExpectations) !== "array") {
        throw new TypeError("array expected");
      }
      return createMatcher(
        function(actual) {
          return some(arrayOfExpectations, function(expectation) {
            return expectation === actual;
          });
        },
        `in(${valueToString(arrayOfExpectations)})`
      );
    };
    createMatcher.typeOf = function(type) {
      assertType(type, "string", "type");
      return createMatcher(function(actual) {
        return typeOf(actual) === type;
      }, `typeOf("${type}")`);
    };
    createMatcher.instanceOf = function(type) {
      if (typeof Symbol === "undefined" || typeof Symbol.hasInstance === "undefined") {
        assertType(type, "function", "type");
      } else {
        assertMethodExists(
          type,
          Symbol.hasInstance,
          "type",
          "[Symbol.hasInstance]"
        );
      }
      return createMatcher(
        function(actual) {
          return actual instanceof type;
        },
        `instanceOf(${functionName(type) || objectToString(type)})`
      );
    };
    function createPropertyMatcher(propertyTest, messagePrefix) {
      return function(property, value) {
        assertType(property, "string", "property");
        var onlyProperty = arguments.length === 1;
        var message = `${messagePrefix}("${property}"`;
        if (!onlyProperty) {
          message += `, ${valueToString(value)}`;
        }
        message += ")";
        return createMatcher(function(actual) {
          if (actual === void 0 || actual === null || !propertyTest(actual, property)) {
            return false;
          }
          return onlyProperty || deepEqual(actual[property], value);
        }, message);
      };
    }
    createMatcher.has = createPropertyMatcher(function(actual, property) {
      if (typeof actual === "object") {
        return property in actual;
      }
      return actual[property] !== void 0;
    }, "has");
    createMatcher.hasOwn = createPropertyMatcher(function(actual, property) {
      return hasOwnProperty(actual, property);
    }, "hasOwn");
    createMatcher.hasNested = function(property, value) {
      assertType(property, "string", "property");
      var onlyProperty = arguments.length === 1;
      var message = `hasNested("${property}"`;
      if (!onlyProperty) {
        message += `, ${valueToString(value)}`;
      }
      message += ")";
      return createMatcher(function(actual) {
        const parts = property.split(/(?:\.|\[|\])+?/).filter(Boolean);
        let current = actual;
        for (const part of parts) {
          current = current?.[part];
          if (current === void 0) {
            return false;
          }
        }
        return onlyProperty || deepEqual(current, value);
      }, message);
    };
    var jsonParseResultTypes = {
      null: true,
      boolean: true,
      number: true,
      string: true,
      object: true,
      array: true
    };
    createMatcher.json = function(value) {
      if (!jsonParseResultTypes[typeOf(value)]) {
        throw new TypeError("Value cannot be the result of JSON.parse");
      }
      var message = `json(${JSON.stringify(value, null, "  ")})`;
      return createMatcher(function(actual) {
        var parsed;
        try {
          parsed = JSON.parse(actual);
        } catch (e) {
          return false;
        }
        return deepEqual(parsed, value);
      }, message);
    };
    createMatcher.every = function(predicate) {
      assertMatcher(predicate);
      return createMatcher(function(actual) {
        if (typeOf(actual) === "object") {
          return every(Object.keys(actual), function(key) {
            return predicate.test(actual[key]);
          });
        }
        return isIterable(actual) && every(actual, function(element) {
          return predicate.test(element);
        });
      }, `every(${predicate.message})`);
    };
    createMatcher.some = function(predicate) {
      assertMatcher(predicate);
      return createMatcher(function(actual) {
        if (typeOf(actual) === "object") {
          return !every(Object.keys(actual), function(key) {
            return !predicate.test(actual[key]);
          });
        }
        return isIterable(actual) && !every(actual, function(element) {
          return !predicate.test(element);
        });
      }, `some(${predicate.message})`);
    };
    createMatcher.array = createMatcher.typeOf("array");
    createMatcher.array.deepEquals = function(expectation) {
      return createMatcher(
        function(actual) {
          var sameLength = actual.length === expectation.length;
          return typeOf(actual) === "array" && sameLength && every(actual, function(element, index) {
            var expected = expectation[index];
            return typeOf(expected) === "array" && typeOf(element) === "array" ? createMatcher.array.deepEquals(expected).test(element) : deepEqual(expected, element);
          });
        },
        `deepEquals([${iterableToString(expectation)}])`
      );
    };
    createMatcher.array.startsWith = function(expectation) {
      return createMatcher(
        function(actual) {
          return typeOf(actual) === "array" && every(expectation, function(expectedElement, index) {
            return actual[index] === expectedElement;
          });
        },
        `startsWith([${iterableToString(expectation)}])`
      );
    };
    createMatcher.array.endsWith = function(expectation) {
      return createMatcher(
        function(actual) {
          var offset = actual.length - expectation.length;
          return typeOf(actual) === "array" && every(expectation, function(expectedElement, index) {
            return actual[offset + index] === expectedElement;
          });
        },
        `endsWith([${iterableToString(expectation)}])`
      );
    };
    createMatcher.array.contains = function(expectation) {
      return createMatcher(
        function(actual) {
          return typeOf(actual) === "array" && every(expectation, function(expectedElement) {
            return arrayIndexOf(actual, expectedElement) !== -1;
          });
        },
        `contains([${iterableToString(expectation)}])`
      );
    };
    createMatcher.map = createMatcher.typeOf("map");
    createMatcher.map.deepEquals = function mapDeepEquals(expectation) {
      return createMatcher(
        function(actual) {
          var sameLength = actual.size === expectation.size;
          return typeOf(actual) === "map" && sameLength && every(actual, function(element, key) {
            return expectation.has(key) && expectation.get(key) === element;
          });
        },
        `deepEquals(Map[${iterableToString(expectation)}])`
      );
    };
    createMatcher.map.contains = function mapContains(expectation) {
      return createMatcher(
        function(actual) {
          return typeOf(actual) === "map" && every(expectation, function(element, key) {
            return actual.has(key) && actual.get(key) === element;
          });
        },
        `contains(Map[${iterableToString(expectation)}])`
      );
    };
    createMatcher.set = createMatcher.typeOf("set");
    createMatcher.set.deepEquals = function setDeepEquals(expectation) {
      return createMatcher(
        function(actual) {
          var sameLength = actual.size === expectation.size;
          return typeOf(actual) === "set" && sameLength && every(actual, function(element) {
            return expectation.has(element);
          });
        },
        `deepEquals(Set[${iterableToString(expectation)}])`
      );
    };
    createMatcher.set.contains = function setContains(expectation) {
      return createMatcher(
        function(actual) {
          return typeOf(actual) === "set" && every(expectation, function(element) {
            return actual.has(element);
          });
        },
        `contains(Set[${iterableToString(expectation)}])`
      );
    };
    createMatcher.bool = createMatcher.typeOf("boolean");
    createMatcher.number = createMatcher.typeOf("number");
    createMatcher.string = createMatcher.typeOf("string");
    createMatcher.object = createMatcher.typeOf("object");
    createMatcher.func = createMatcher.typeOf("function");
    createMatcher.regexp = createMatcher.typeOf("regexp");
    createMatcher.date = createMatcher.typeOf("date");
    createMatcher.symbol = createMatcher.typeOf("symbol");
    module2.exports = createMatcher;
  }
});

// node_modules/@sinonjs/samsam/lib/match.js
var require_match = __commonJS({
  "node_modules/@sinonjs/samsam/lib/match.js"(exports2, module2) {
    "use strict";
    var valueToString = require_lib().valueToString;
    var indexOf = require_lib().prototypes.string.indexOf;
    var forEach = require_lib().prototypes.array.forEach;
    var type = require_type_detect2();
    var engineCanCompareMaps = typeof Array.from === "function";
    var deepEqual = require_deep_equal().use(match);
    var isArrayType = require_is_array_type();
    var isSubset = require_is_subset();
    var createMatcher = require_create_matcher();
    function arrayContains(array, subset, compare) {
      if (subset.length === 0) {
        return true;
      }
      var i, l, j, k;
      for (i = 0, l = array.length; i < l; ++i) {
        if (compare(array[i], subset[0])) {
          for (j = 0, k = subset.length; j < k; ++j) {
            if (i + j >= l) {
              return false;
            }
            if (!compare(array[i + j], subset[j])) {
              return false;
            }
          }
          return true;
        }
      }
      return false;
    }
    function match(object, matcherOrValue) {
      if (matcherOrValue && typeof matcherOrValue.test === "function") {
        return matcherOrValue.test(object);
      }
      switch (type(matcherOrValue)) {
        case "bigint":
        case "boolean":
        case "number":
        case "symbol":
          return matcherOrValue === object;
        case "function":
          return matcherOrValue(object) === true;
        case "string":
          var notNull = typeof object === "string" || Boolean(object);
          return notNull && indexOf(
            valueToString(object).toLowerCase(),
            matcherOrValue.toLowerCase()
          ) >= 0;
        case "null":
          return object === null;
        case "undefined":
          return typeof object === "undefined";
        case "Date":
          if (type(object) === "Date") {
            return object.getTime() === matcherOrValue.getTime();
          }
          break;
        case "Array":
        case "Int8Array":
        case "Uint8Array":
        case "Uint8ClampedArray":
        case "Int16Array":
        case "Uint16Array":
        case "Int32Array":
        case "Uint32Array":
        case "Float32Array":
        case "Float64Array":
          return isArrayType(matcherOrValue) && arrayContains(object, matcherOrValue, match);
        case "Map":
          if (!engineCanCompareMaps) {
            throw new Error(
              "The JavaScript engine does not support Array.from and cannot reliably do value comparison of Map instances"
            );
          }
          return type(object) === "Map" && arrayContains(
            Array.from(object),
            Array.from(matcherOrValue),
            match
          );
        default:
          break;
      }
      switch (type(object)) {
        case "null":
          return false;
        case "Set":
          return isSubset(matcherOrValue, object, match);
        default:
          break;
      }
      if (matcherOrValue && typeof matcherOrValue === "object") {
        if (matcherOrValue === object) {
          return true;
        }
        if (typeof object !== "object") {
          return false;
        }
        var prop;
        for (prop in matcherOrValue) {
          var value = object[prop];
          if (typeof value === "undefined" && typeof object.getAttribute === "function") {
            value = object.getAttribute(prop);
          }
          if (matcherOrValue[prop] === null || typeof matcherOrValue[prop] === "undefined") {
            if (value !== matcherOrValue[prop]) {
              return false;
            }
          } else if (typeof value === "undefined" || !deepEqual(value, matcherOrValue[prop])) {
            return false;
          }
        }
        return true;
      }
      throw new Error("Matcher was an unknown or unsupported type");
    }
    forEach(Object.keys(createMatcher), function(key) {
      match[key] = createMatcher[key];
    });
    module2.exports = match;
  }
});

// node_modules/@sinonjs/samsam/lib/samsam.js
var require_samsam = __commonJS({
  "node_modules/@sinonjs/samsam/lib/samsam.js"(exports2, module2) {
    "use strict";
    var identical = require_identical();
    var isArguments = require_is_arguments();
    var isElement = require_is_element();
    var isNegZero = require_is_neg_zero();
    var isSet = require_is_set();
    var isMap = require_is_map();
    var match = require_match();
    var deepEqualCyclic = require_deep_equal().use(match);
    var createMatcher = require_create_matcher();
    module2.exports = {
      createMatcher,
      deepEqual: deepEqualCyclic,
      identical,
      isArguments,
      isElement,
      isMap,
      isNegZero,
      isSet,
      match
    };
  }
});

// lib/sinon/util/core/times-in-words.js
var require_times_in_words = __commonJS({
  "lib/sinon/util/core/times-in-words.js"(exports2, module2) {
    "use strict";
    var array = [null, "once", "twice", "thrice"];
    module2.exports = function timesInWords(count) {
      return array[count] || `${count || 0} times`;
    };
  }
});

// node_modules/has-symbols/shams.js
var require_shams = __commonJS({
  "node_modules/has-symbols/shams.js"(exports2, module2) {
    "use strict";
    module2.exports = function hasSymbols() {
      if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
        return false;
      }
      if (typeof Symbol.iterator === "symbol") {
        return true;
      }
      var obj = {};
      var sym = /* @__PURE__ */ Symbol("test");
      var symObj = Object(sym);
      if (typeof sym === "string") {
        return false;
      }
      if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
        return false;
      }
      if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
        return false;
      }
      var symVal = 42;
      obj[sym] = symVal;
      for (sym in obj) {
        return false;
      }
      if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
        return false;
      }
      if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
        return false;
      }
      var syms = Object.getOwnPropertySymbols(obj);
      if (syms.length !== 1 || syms[0] !== sym) {
        return false;
      }
      if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
        return false;
      }
      if (typeof Object.getOwnPropertyDescriptor === "function") {
        var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
        if (descriptor.value !== symVal || descriptor.enumerable !== true) {
          return false;
        }
      }
      return true;
    };
  }
});

// node_modules/has-tostringtag/shams.js
var require_shams2 = __commonJS({
  "node_modules/has-tostringtag/shams.js"(exports2, module2) {
    "use strict";
    var hasSymbols = require_shams();
    module2.exports = function hasToStringTagShams() {
      return hasSymbols() && !!Symbol.toStringTag;
    };
  }
});

// node_modules/es-errors/index.js
var require_es_errors = __commonJS({
  "node_modules/es-errors/index.js"(exports2, module2) {
    "use strict";
    module2.exports = Error;
  }
});

// node_modules/es-errors/eval.js
var require_eval = __commonJS({
  "node_modules/es-errors/eval.js"(exports2, module2) {
    "use strict";
    module2.exports = EvalError;
  }
});

// node_modules/es-errors/range.js
var require_range = __commonJS({
  "node_modules/es-errors/range.js"(exports2, module2) {
    "use strict";
    module2.exports = RangeError;
  }
});

// node_modules/es-errors/ref.js
var require_ref = __commonJS({
  "node_modules/es-errors/ref.js"(exports2, module2) {
    "use strict";
    module2.exports = ReferenceError;
  }
});

// node_modules/es-errors/syntax.js
var require_syntax = __commonJS({
  "node_modules/es-errors/syntax.js"(exports2, module2) {
    "use strict";
    module2.exports = SyntaxError;
  }
});

// node_modules/es-errors/type.js
var require_type = __commonJS({
  "node_modules/es-errors/type.js"(exports2, module2) {
    "use strict";
    module2.exports = TypeError;
  }
});

// node_modules/es-errors/uri.js
var require_uri = __commonJS({
  "node_modules/es-errors/uri.js"(exports2, module2) {
    "use strict";
    module2.exports = URIError;
  }
});

// node_modules/has-symbols/index.js
var require_has_symbols = __commonJS({
  "node_modules/has-symbols/index.js"(exports2, module2) {
    "use strict";
    var origSymbol = typeof Symbol !== "undefined" && Symbol;
    var hasSymbolSham = require_shams();
    module2.exports = function hasNativeSymbols() {
      if (typeof origSymbol !== "function") {
        return false;
      }
      if (typeof Symbol !== "function") {
        return false;
      }
      if (typeof origSymbol("foo") !== "symbol") {
        return false;
      }
      if (typeof /* @__PURE__ */ Symbol("bar") !== "symbol") {
        return false;
      }
      return hasSymbolSham();
    };
  }
});

// node_modules/has-proto/index.js
var require_has_proto = __commonJS({
  "node_modules/has-proto/index.js"(exports2, module2) {
    "use strict";
    var test = {
      __proto__: null,
      foo: {}
    };
    var $Object = Object;
    module2.exports = function hasProto() {
      return { __proto__: test }.foo === test.foo && !(test instanceof $Object);
    };
  }
});

// node_modules/function-bind/implementation.js
var require_implementation = __commonJS({
  "node_modules/function-bind/implementation.js"(exports2, module2) {
    "use strict";
    var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
    var toStr = Object.prototype.toString;
    var max = Math.max;
    var funcType = "[object Function]";
    var concatty = function concatty2(a, b) {
      var arr = [];
      for (var i = 0; i < a.length; i += 1) {
        arr[i] = a[i];
      }
      for (var j = 0; j < b.length; j += 1) {
        arr[j + a.length] = b[j];
      }
      return arr;
    };
    var slicy = function slicy2(arrLike, offset) {
      var arr = [];
      for (var i = offset || 0, j = 0; i < arrLike.length; i += 1, j += 1) {
        arr[j] = arrLike[i];
      }
      return arr;
    };
    var joiny = function(arr, joiner) {
      var str = "";
      for (var i = 0; i < arr.length; i += 1) {
        str += arr[i];
        if (i + 1 < arr.length) {
          str += joiner;
        }
      }
      return str;
    };
    module2.exports = function bind(that) {
      var target = this;
      if (typeof target !== "function" || toStr.apply(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
      }
      var args = slicy(arguments, 1);
      var bound;
      var binder = function() {
        if (this instanceof bound) {
          var result = target.apply(
            this,
            concatty(args, arguments)
          );
          if (Object(result) === result) {
            return result;
          }
          return this;
        }
        return target.apply(
          that,
          concatty(args, arguments)
        );
      };
      var boundLength = max(0, target.length - args.length);
      var boundArgs = [];
      for (var i = 0; i < boundLength; i++) {
        boundArgs[i] = "$" + i;
      }
      bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
      if (target.prototype) {
        var Empty = function Empty2() {
        };
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
      }
      return bound;
    };
  }
});

// node_modules/function-bind/index.js
var require_function_bind = __commonJS({
  "node_modules/function-bind/index.js"(exports2, module2) {
    "use strict";
    var implementation = require_implementation();
    module2.exports = Function.prototype.bind || implementation;
  }
});

// node_modules/hasown/index.js
var require_hasown = __commonJS({
  "node_modules/hasown/index.js"(exports2, module2) {
    "use strict";
    var call = Function.prototype.call;
    var $hasOwn = Object.prototype.hasOwnProperty;
    var bind = require_function_bind();
    module2.exports = bind.call(call, $hasOwn);
  }
});

// node_modules/get-intrinsic/index.js
var require_get_intrinsic = __commonJS({
  "node_modules/get-intrinsic/index.js"(exports2, module2) {
    "use strict";
    var undefined2;
    var $Error = require_es_errors();
    var $EvalError = require_eval();
    var $RangeError = require_range();
    var $ReferenceError = require_ref();
    var $SyntaxError = require_syntax();
    var $TypeError = require_type();
    var $URIError = require_uri();
    var $Function = Function;
    var getEvalledConstructor = function(expressionSyntax) {
      try {
        return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
      } catch (e) {
      }
    };
    var $gOPD = Object.getOwnPropertyDescriptor;
    if ($gOPD) {
      try {
        $gOPD({}, "");
      } catch (e) {
        $gOPD = null;
      }
    }
    var throwTypeError = function() {
      throw new $TypeError();
    };
    var ThrowTypeError = $gOPD ? (function() {
      try {
        arguments.callee;
        return throwTypeError;
      } catch (calleeThrows) {
        try {
          return $gOPD(arguments, "callee").get;
        } catch (gOPDthrows) {
          return throwTypeError;
        }
      }
    })() : throwTypeError;
    var hasSymbols = require_has_symbols()();
    var hasProto = require_has_proto()();
    var getProto = Object.getPrototypeOf || (hasProto ? function(x) {
      return x.__proto__;
    } : null);
    var needsEval = {};
    var TypedArray = typeof Uint8Array === "undefined" || !getProto ? undefined2 : getProto(Uint8Array);
    var INTRINSICS = {
      __proto__: null,
      "%AggregateError%": typeof AggregateError === "undefined" ? undefined2 : AggregateError,
      "%Array%": Array,
      "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined2 : ArrayBuffer,
      "%ArrayIteratorPrototype%": hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined2,
      "%AsyncFromSyncIteratorPrototype%": undefined2,
      "%AsyncFunction%": needsEval,
      "%AsyncGenerator%": needsEval,
      "%AsyncGeneratorFunction%": needsEval,
      "%AsyncIteratorPrototype%": needsEval,
      "%Atomics%": typeof Atomics === "undefined" ? undefined2 : Atomics,
      "%BigInt%": typeof BigInt === "undefined" ? undefined2 : BigInt,
      "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined2 : BigInt64Array,
      "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined2 : BigUint64Array,
      "%Boolean%": Boolean,
      "%DataView%": typeof DataView === "undefined" ? undefined2 : DataView,
      "%Date%": Date,
      "%decodeURI%": decodeURI,
      "%decodeURIComponent%": decodeURIComponent,
      "%encodeURI%": encodeURI,
      "%encodeURIComponent%": encodeURIComponent,
      "%Error%": $Error,
      "%eval%": eval,
      // eslint-disable-line no-eval
      "%EvalError%": $EvalError,
      "%Float32Array%": typeof Float32Array === "undefined" ? undefined2 : Float32Array,
      "%Float64Array%": typeof Float64Array === "undefined" ? undefined2 : Float64Array,
      "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined2 : FinalizationRegistry,
      "%Function%": $Function,
      "%GeneratorFunction%": needsEval,
      "%Int8Array%": typeof Int8Array === "undefined" ? undefined2 : Int8Array,
      "%Int16Array%": typeof Int16Array === "undefined" ? undefined2 : Int16Array,
      "%Int32Array%": typeof Int32Array === "undefined" ? undefined2 : Int32Array,
      "%isFinite%": isFinite,
      "%isNaN%": isNaN,
      "%IteratorPrototype%": hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined2,
      "%JSON%": typeof JSON === "object" ? JSON : undefined2,
      "%Map%": typeof Map === "undefined" ? undefined2 : Map,
      "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
      "%Math%": Math,
      "%Number%": Number,
      "%Object%": Object,
      "%parseFloat%": parseFloat,
      "%parseInt%": parseInt,
      "%Promise%": typeof Promise === "undefined" ? undefined2 : Promise,
      "%Proxy%": typeof Proxy === "undefined" ? undefined2 : Proxy,
      "%RangeError%": $RangeError,
      "%ReferenceError%": $ReferenceError,
      "%Reflect%": typeof Reflect === "undefined" ? undefined2 : Reflect,
      "%RegExp%": RegExp,
      "%Set%": typeof Set === "undefined" ? undefined2 : Set,
      "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
      "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined2 : SharedArrayBuffer,
      "%String%": String,
      "%StringIteratorPrototype%": hasSymbols && getProto ? getProto(""[Symbol.iterator]()) : undefined2,
      "%Symbol%": hasSymbols ? Symbol : undefined2,
      "%SyntaxError%": $SyntaxError,
      "%ThrowTypeError%": ThrowTypeError,
      "%TypedArray%": TypedArray,
      "%TypeError%": $TypeError,
      "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined2 : Uint8Array,
      "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined2 : Uint8ClampedArray,
      "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined2 : Uint16Array,
      "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined2 : Uint32Array,
      "%URIError%": $URIError,
      "%WeakMap%": typeof WeakMap === "undefined" ? undefined2 : WeakMap,
      "%WeakRef%": typeof WeakRef === "undefined" ? undefined2 : WeakRef,
      "%WeakSet%": typeof WeakSet === "undefined" ? undefined2 : WeakSet
    };
    if (getProto) {
      try {
        null.error;
      } catch (e) {
        errorProto = getProto(getProto(e));
        INTRINSICS["%Error.prototype%"] = errorProto;
      }
    }
    var errorProto;
    var doEval = function doEval2(name) {
      var value;
      if (name === "%AsyncFunction%") {
        value = getEvalledConstructor("async function () {}");
      } else if (name === "%GeneratorFunction%") {
        value = getEvalledConstructor("function* () {}");
      } else if (name === "%AsyncGeneratorFunction%") {
        value = getEvalledConstructor("async function* () {}");
      } else if (name === "%AsyncGenerator%") {
        var fn = doEval2("%AsyncGeneratorFunction%");
        if (fn) {
          value = fn.prototype;
        }
      } else if (name === "%AsyncIteratorPrototype%") {
        var gen = doEval2("%AsyncGenerator%");
        if (gen && getProto) {
          value = getProto(gen.prototype);
        }
      }
      INTRINSICS[name] = value;
      return value;
    };
    var LEGACY_ALIASES = {
      __proto__: null,
      "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
      "%ArrayPrototype%": ["Array", "prototype"],
      "%ArrayProto_entries%": ["Array", "prototype", "entries"],
      "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
      "%ArrayProto_keys%": ["Array", "prototype", "keys"],
      "%ArrayProto_values%": ["Array", "prototype", "values"],
      "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
      "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
      "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
      "%BooleanPrototype%": ["Boolean", "prototype"],
      "%DataViewPrototype%": ["DataView", "prototype"],
      "%DatePrototype%": ["Date", "prototype"],
      "%ErrorPrototype%": ["Error", "prototype"],
      "%EvalErrorPrototype%": ["EvalError", "prototype"],
      "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
      "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
      "%FunctionPrototype%": ["Function", "prototype"],
      "%Generator%": ["GeneratorFunction", "prototype"],
      "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
      "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
      "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
      "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
      "%JSONParse%": ["JSON", "parse"],
      "%JSONStringify%": ["JSON", "stringify"],
      "%MapPrototype%": ["Map", "prototype"],
      "%NumberPrototype%": ["Number", "prototype"],
      "%ObjectPrototype%": ["Object", "prototype"],
      "%ObjProto_toString%": ["Object", "prototype", "toString"],
      "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
      "%PromisePrototype%": ["Promise", "prototype"],
      "%PromiseProto_then%": ["Promise", "prototype", "then"],
      "%Promise_all%": ["Promise", "all"],
      "%Promise_reject%": ["Promise", "reject"],
      "%Promise_resolve%": ["Promise", "resolve"],
      "%RangeErrorPrototype%": ["RangeError", "prototype"],
      "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
      "%RegExpPrototype%": ["RegExp", "prototype"],
      "%SetPrototype%": ["Set", "prototype"],
      "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
      "%StringPrototype%": ["String", "prototype"],
      "%SymbolPrototype%": ["Symbol", "prototype"],
      "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
      "%TypedArrayPrototype%": ["TypedArray", "prototype"],
      "%TypeErrorPrototype%": ["TypeError", "prototype"],
      "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
      "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
      "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
      "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
      "%URIErrorPrototype%": ["URIError", "prototype"],
      "%WeakMapPrototype%": ["WeakMap", "prototype"],
      "%WeakSetPrototype%": ["WeakSet", "prototype"]
    };
    var bind = require_function_bind();
    var hasOwn = require_hasown();
    var $concat = bind.call(Function.call, Array.prototype.concat);
    var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
    var $replace = bind.call(Function.call, String.prototype.replace);
    var $strSlice = bind.call(Function.call, String.prototype.slice);
    var $exec = bind.call(Function.call, RegExp.prototype.exec);
    var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = function stringToPath2(string) {
      var first = $strSlice(string, 0, 1);
      var last = $strSlice(string, -1);
      if (first === "%" && last !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
      } else if (last === "%" && first !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
      }
      var result = [];
      $replace(string, rePropName, function(match, number, quote, subString) {
        result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match;
      });
      return result;
    };
    var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {
      var intrinsicName = name;
      var alias;
      if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
        alias = LEGACY_ALIASES[intrinsicName];
        intrinsicName = "%" + alias[0] + "%";
      }
      if (hasOwn(INTRINSICS, intrinsicName)) {
        var value = INTRINSICS[intrinsicName];
        if (value === needsEval) {
          value = doEval(intrinsicName);
        }
        if (typeof value === "undefined" && !allowMissing) {
          throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
        }
        return {
          alias,
          name: intrinsicName,
          value
        };
      }
      throw new $SyntaxError("intrinsic " + name + " does not exist!");
    };
    module2.exports = function GetIntrinsic(name, allowMissing) {
      if (typeof name !== "string" || name.length === 0) {
        throw new $TypeError("intrinsic name must be a non-empty string");
      }
      if (arguments.length > 1 && typeof allowMissing !== "boolean") {
        throw new $TypeError('"allowMissing" argument must be a boolean');
      }
      if ($exec(/^%?[^%]*%?$/, name) === null) {
        throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
      }
      var parts = stringToPath(name);
      var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
      var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
      var intrinsicRealName = intrinsic.name;
      var value = intrinsic.value;
      var skipFurtherCaching = false;
      var alias = intrinsic.alias;
      if (alias) {
        intrinsicBaseName = alias[0];
        $spliceApply(parts, $concat([0, 1], alias));
      }
      for (var i = 1, isOwn = true; i < parts.length; i += 1) {
        var part = parts[i];
        var first = $strSlice(part, 0, 1);
        var last = $strSlice(part, -1);
        if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
          throw new $SyntaxError("property names with quotes must have matching quotes");
        }
        if (part === "constructor" || !isOwn) {
          skipFurtherCaching = true;
        }
        intrinsicBaseName += "." + part;
        intrinsicRealName = "%" + intrinsicBaseName + "%";
        if (hasOwn(INTRINSICS, intrinsicRealName)) {
          value = INTRINSICS[intrinsicRealName];
        } else if (value != null) {
          if (!(part in value)) {
            if (!allowMissing) {
              throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
            }
            return void undefined2;
          }
          if ($gOPD && i + 1 >= parts.length) {
            var desc = $gOPD(value, part);
            isOwn = !!desc;
            if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
              value = desc.get;
            } else {
              value = value[part];
            }
          } else {
            isOwn = hasOwn(value, part);
            value = value[part];
          }
          if (isOwn && !skipFurtherCaching) {
            INTRINSICS[intrinsicRealName] = value;
          }
        }
      }
      return value;
    };
  }
});

// node_modules/es-define-property/index.js
var require_es_define_property = __commonJS({
  "node_modules/es-define-property/index.js"(exports2, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $defineProperty = GetIntrinsic("%Object.defineProperty%", true) || false;
    if ($defineProperty) {
      try {
        $defineProperty({}, "a", { value: 1 });
      } catch (e) {
        $defineProperty = false;
      }
    }
    module2.exports = $defineProperty;
  }
});

// node_modules/gopd/index.js
var require_gopd = __commonJS({
  "node_modules/gopd/index.js"(exports2, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $gOPD = GetIntrinsic("%Object.getOwnPropertyDescriptor%", true);
    if ($gOPD) {
      try {
        $gOPD([], "length");
      } catch (e) {
        $gOPD = null;
      }
    }
    module2.exports = $gOPD;
  }
});

// node_modules/define-data-property/index.js
var require_define_data_property = __commonJS({
  "node_modules/define-data-property/index.js"(exports2, module2) {
    "use strict";
    var $defineProperty = require_es_define_property();
    var $SyntaxError = require_syntax();
    var $TypeError = require_type();
    var gopd = require_gopd();
    module2.exports = function defineDataProperty(obj, property, value) {
      if (!obj || typeof obj !== "object" && typeof obj !== "function") {
        throw new $TypeError("`obj` must be an object or a function`");
      }
      if (typeof property !== "string" && typeof property !== "symbol") {
        throw new $TypeError("`property` must be a string or a symbol`");
      }
      if (arguments.length > 3 && typeof arguments[3] !== "boolean" && arguments[3] !== null) {
        throw new $TypeError("`nonEnumerable`, if provided, must be a boolean or null");
      }
      if (arguments.length > 4 && typeof arguments[4] !== "boolean" && arguments[4] !== null) {
        throw new $TypeError("`nonWritable`, if provided, must be a boolean or null");
      }
      if (arguments.length > 5 && typeof arguments[5] !== "boolean" && arguments[5] !== null) {
        throw new $TypeError("`nonConfigurable`, if provided, must be a boolean or null");
      }
      if (arguments.length > 6 && typeof arguments[6] !== "boolean") {
        throw new $TypeError("`loose`, if provided, must be a boolean");
      }
      var nonEnumerable = arguments.length > 3 ? arguments[3] : null;
      var nonWritable = arguments.length > 4 ? arguments[4] : null;
      var nonConfigurable = arguments.length > 5 ? arguments[5] : null;
      var loose = arguments.length > 6 ? arguments[6] : false;
      var desc = !!gopd && gopd(obj, property);
      if ($defineProperty) {
        $defineProperty(obj, property, {
          configurable: nonConfigurable === null && desc ? desc.configurable : !nonConfigurable,
          enumerable: nonEnumerable === null && desc ? desc.enumerable : !nonEnumerable,
          value,
          writable: nonWritable === null && desc ? desc.writable : !nonWritable
        });
      } else if (loose || !nonEnumerable && !nonWritable && !nonConfigurable) {
        obj[property] = value;
      } else {
        throw new $SyntaxError("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
      }
    };
  }
});

// node_modules/has-property-descriptors/index.js
var require_has_property_descriptors = __commonJS({
  "node_modules/has-property-descriptors/index.js"(exports2, module2) {
    "use strict";
    var $defineProperty = require_es_define_property();
    var hasPropertyDescriptors = function hasPropertyDescriptors2() {
      return !!$defineProperty;
    };
    hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
      if (!$defineProperty) {
        return null;
      }
      try {
        return $defineProperty([], "length", { value: 1 }).length !== 1;
      } catch (e) {
        return true;
      }
    };
    module2.exports = hasPropertyDescriptors;
  }
});

// node_modules/set-function-length/index.js
var require_set_function_length = __commonJS({
  "node_modules/set-function-length/index.js"(exports2, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var define2 = require_define_data_property();
    var hasDescriptors = require_has_property_descriptors()();
    var gOPD = require_gopd();
    var $TypeError = require_type();
    var $floor = GetIntrinsic("%Math.floor%");
    module2.exports = function setFunctionLength(fn, length) {
      if (typeof fn !== "function") {
        throw new $TypeError("`fn` is not a function");
      }
      if (typeof length !== "number" || length < 0 || length > 4294967295 || $floor(length) !== length) {
        throw new $TypeError("`length` must be a positive 32-bit integer");
      }
      var loose = arguments.length > 2 && !!arguments[2];
      var functionLengthIsConfigurable = true;
      var functionLengthIsWritable = true;
      if ("length" in fn && gOPD) {
        var desc = gOPD(fn, "length");
        if (desc && !desc.configurable) {
          functionLengthIsConfigurable = false;
        }
        if (desc && !desc.writable) {
          functionLengthIsWritable = false;
        }
      }
      if (functionLengthIsConfigurable || functionLengthIsWritable || !loose) {
        if (hasDescriptors) {
          define2(
            /** @type {Parameters<define>[0]} */
            fn,
            "length",
            length,
            true,
            true
          );
        } else {
          define2(
            /** @type {Parameters<define>[0]} */
            fn,
            "length",
            length
          );
        }
      }
      return fn;
    };
  }
});

// node_modules/call-bind/index.js
var require_call_bind = __commonJS({
  "node_modules/call-bind/index.js"(exports2, module2) {
    "use strict";
    var bind = require_function_bind();
    var GetIntrinsic = require_get_intrinsic();
    var setFunctionLength = require_set_function_length();
    var $TypeError = require_type();
    var $apply = GetIntrinsic("%Function.prototype.apply%");
    var $call = GetIntrinsic("%Function.prototype.call%");
    var $reflectApply = GetIntrinsic("%Reflect.apply%", true) || bind.call($call, $apply);
    var $defineProperty = require_es_define_property();
    var $max = GetIntrinsic("%Math.max%");
    module2.exports = function callBind(originalFunction) {
      if (typeof originalFunction !== "function") {
        throw new $TypeError("a function is required");
      }
      var func = $reflectApply(bind, $call, arguments);
      return setFunctionLength(
        func,
        1 + $max(0, originalFunction.length - (arguments.length - 1)),
        true
      );
    };
    var applyBind = function applyBind2() {
      return $reflectApply(bind, $apply, arguments);
    };
    if ($defineProperty) {
      $defineProperty(module2.exports, "apply", { value: applyBind });
    } else {
      module2.exports.apply = applyBind;
    }
  }
});

// node_modules/call-bind/callBound.js
var require_callBound = __commonJS({
  "node_modules/call-bind/callBound.js"(exports2, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var callBind = require_call_bind();
    var $indexOf = callBind(GetIntrinsic("String.prototype.indexOf"));
    module2.exports = function callBoundIntrinsic(name, allowMissing) {
      var intrinsic = GetIntrinsic(name, !!allowMissing);
      if (typeof intrinsic === "function" && $indexOf(name, ".prototype.") > -1) {
        return callBind(intrinsic);
      }
      return intrinsic;
    };
  }
});

// node_modules/is-arguments/index.js
var require_is_arguments2 = __commonJS({
  "node_modules/is-arguments/index.js"(exports2, module2) {
    "use strict";
    var hasToStringTag = require_shams2()();
    var callBound = require_callBound();
    var $toString = callBound("Object.prototype.toString");
    var isStandardArguments = function isArguments(value) {
      if (hasToStringTag && value && typeof value === "object" && Symbol.toStringTag in value) {
        return false;
      }
      return $toString(value) === "[object Arguments]";
    };
    var isLegacyArguments = function isArguments(value) {
      if (isStandardArguments(value)) {
        return true;
      }
      return value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && $toString(value) !== "[object Array]" && $toString(value.callee) === "[object Function]";
    };
    var supportsStandardArguments = (function() {
      return isStandardArguments(arguments);
    })();
    isStandardArguments.isLegacyArguments = isLegacyArguments;
    module2.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;
  }
});

// node_modules/is-generator-function/index.js
var require_is_generator_function = __commonJS({
  "node_modules/is-generator-function/index.js"(exports2, module2) {
    "use strict";
    var toStr = Object.prototype.toString;
    var fnToStr = Function.prototype.toString;
    var isFnRegex = /^\s*(?:function)?\*/;
    var hasToStringTag = require_shams2()();
    var getProto = Object.getPrototypeOf;
    var getGeneratorFunc = function() {
      if (!hasToStringTag) {
        return false;
      }
      try {
        return Function("return function*() {}")();
      } catch (e) {
      }
    };
    var GeneratorFunction;
    module2.exports = function isGeneratorFunction(fn) {
      if (typeof fn !== "function") {
        return false;
      }
      if (isFnRegex.test(fnToStr.call(fn))) {
        return true;
      }
      if (!hasToStringTag) {
        var str = toStr.call(fn);
        return str === "[object GeneratorFunction]";
      }
      if (!getProto) {
        return false;
      }
      if (typeof GeneratorFunction === "undefined") {
        var generatorFunc = getGeneratorFunc();
        GeneratorFunction = generatorFunc ? getProto(generatorFunc) : false;
      }
      return getProto(fn) === GeneratorFunction;
    };
  }
});

// node_modules/is-callable/index.js
var require_is_callable = __commonJS({
  "node_modules/is-callable/index.js"(exports2, module2) {
    "use strict";
    var fnToStr = Function.prototype.toString;
    var reflectApply = typeof Reflect === "object" && Reflect !== null && Reflect.apply;
    var badArrayLike;
    var isCallableMarker;
    if (typeof reflectApply === "function" && typeof Object.defineProperty === "function") {
      try {
        badArrayLike = Object.defineProperty({}, "length", {
          get: function() {
            throw isCallableMarker;
          }
        });
        isCallableMarker = {};
        reflectApply(function() {
          throw 42;
        }, null, badArrayLike);
      } catch (_) {
        if (_ !== isCallableMarker) {
          reflectApply = null;
        }
      }
    } else {
      reflectApply = null;
    }
    var constructorRegex = /^\s*class\b/;
    var isES6ClassFn = function isES6ClassFunction(value) {
      try {
        var fnStr = fnToStr.call(value);
        return constructorRegex.test(fnStr);
      } catch (e) {
        return false;
      }
    };
    var tryFunctionObject = function tryFunctionToStr(value) {
      try {
        if (isES6ClassFn(value)) {
          return false;
        }
        fnToStr.call(value);
        return true;
      } catch (e) {
        return false;
      }
    };
    var toStr = Object.prototype.toString;
    var objectClass = "[object Object]";
    var fnClass = "[object Function]";
    var genClass = "[object GeneratorFunction]";
    var ddaClass = "[object HTMLAllCollection]";
    var ddaClass2 = "[object HTML document.all class]";
    var ddaClass3 = "[object HTMLCollection]";
    var hasToStringTag = typeof Symbol === "function" && !!Symbol.toStringTag;
    var isIE68 = !(0 in [,]);
    var isDDA = function isDocumentDotAll() {
      return false;
    };
    if (typeof document === "object") {
      all = document.all;
      if (toStr.call(all) === toStr.call(document.all)) {
        isDDA = function isDocumentDotAll(value) {
          if ((isIE68 || !value) && (typeof value === "undefined" || typeof value === "object")) {
            try {
              var str = toStr.call(value);
              return (str === ddaClass || str === ddaClass2 || str === ddaClass3 || str === objectClass) && value("") == null;
            } catch (e) {
            }
          }
          return false;
        };
      }
    }
    var all;
    module2.exports = reflectApply ? function isCallable(value) {
      if (isDDA(value)) {
        return true;
      }
      if (!value) {
        return false;
      }
      if (typeof value !== "function" && typeof value !== "object") {
        return false;
      }
      try {
        reflectApply(value, null, badArrayLike);
      } catch (e) {
        if (e !== isCallableMarker) {
          return false;
        }
      }
      return !isES6ClassFn(value) && tryFunctionObject(value);
    } : function isCallable(value) {
      if (isDDA(value)) {
        return true;
      }
      if (!value) {
        return false;
      }
      if (typeof value !== "function" && typeof value !== "object") {
        return false;
      }
      if (hasToStringTag) {
        return tryFunctionObject(value);
      }
      if (isES6ClassFn(value)) {
        return false;
      }
      var strClass = toStr.call(value);
      if (strClass !== fnClass && strClass !== genClass && !/^\[object HTML/.test(strClass)) {
        return false;
      }
      return tryFunctionObject(value);
    };
  }
});

// node_modules/for-each/index.js
var require_for_each = __commonJS({
  "node_modules/for-each/index.js"(exports2, module2) {
    "use strict";
    var isCallable = require_is_callable();
    var toStr = Object.prototype.toString;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var forEachArray = function forEachArray2(array, iterator, receiver) {
      for (var i = 0, len = array.length; i < len; i++) {
        if (hasOwnProperty.call(array, i)) {
          if (receiver == null) {
            iterator(array[i], i, array);
          } else {
            iterator.call(receiver, array[i], i, array);
          }
        }
      }
    };
    var forEachString = function forEachString2(string, iterator, receiver) {
      for (var i = 0, len = string.length; i < len; i++) {
        if (receiver == null) {
          iterator(string.charAt(i), i, string);
        } else {
          iterator.call(receiver, string.charAt(i), i, string);
        }
      }
    };
    var forEachObject = function forEachObject2(object, iterator, receiver) {
      for (var k in object) {
        if (hasOwnProperty.call(object, k)) {
          if (receiver == null) {
            iterator(object[k], k, object);
          } else {
            iterator.call(receiver, object[k], k, object);
          }
        }
      }
    };
    var forEach = function forEach2(list, iterator, thisArg) {
      if (!isCallable(iterator)) {
        throw new TypeError("iterator must be a function");
      }
      var receiver;
      if (arguments.length >= 3) {
        receiver = thisArg;
      }
      if (toStr.call(list) === "[object Array]") {
        forEachArray(list, iterator, receiver);
      } else if (typeof list === "string") {
        forEachString(list, iterator, receiver);
      } else {
        forEachObject(list, iterator, receiver);
      }
    };
    module2.exports = forEach;
  }
});

// node_modules/possible-typed-array-names/index.js
var require_possible_typed_array_names = __commonJS({
  "node_modules/possible-typed-array-names/index.js"(exports2, module2) {
    "use strict";
    module2.exports = [
      "Float32Array",
      "Float64Array",
      "Int8Array",
      "Int16Array",
      "Int32Array",
      "Uint8Array",
      "Uint8ClampedArray",
      "Uint16Array",
      "Uint32Array",
      "BigInt64Array",
      "BigUint64Array"
    ];
  }
});

// node_modules/available-typed-arrays/index.js
var require_available_typed_arrays = __commonJS({
  "node_modules/available-typed-arrays/index.js"(exports2, module2) {
    "use strict";
    var possibleNames = require_possible_typed_array_names();
    var g = typeof globalThis === "undefined" ? global : globalThis;
    module2.exports = function availableTypedArrays() {
      var out = [];
      for (var i = 0; i < possibleNames.length; i++) {
        if (typeof g[possibleNames[i]] === "function") {
          out[out.length] = possibleNames[i];
        }
      }
      return out;
    };
  }
});

// node_modules/which-typed-array/index.js
var require_which_typed_array = __commonJS({
  "node_modules/which-typed-array/index.js"(exports2, module2) {
    "use strict";
    var forEach = require_for_each();
    var availableTypedArrays = require_available_typed_arrays();
    var callBind = require_call_bind();
    var callBound = require_callBound();
    var gOPD = require_gopd();
    var $toString = callBound("Object.prototype.toString");
    var hasToStringTag = require_shams2()();
    var g = typeof globalThis === "undefined" ? global : globalThis;
    var typedArrays = availableTypedArrays();
    var $slice = callBound("String.prototype.slice");
    var getPrototypeOf = Object.getPrototypeOf;
    var $indexOf = callBound("Array.prototype.indexOf", true) || function indexOf(array, value) {
      for (var i = 0; i < array.length; i += 1) {
        if (array[i] === value) {
          return i;
        }
      }
      return -1;
    };
    var cache = { __proto__: null };
    if (hasToStringTag && gOPD && getPrototypeOf) {
      forEach(typedArrays, function(typedArray) {
        var arr = new g[typedArray]();
        if (Symbol.toStringTag in arr) {
          var proto = getPrototypeOf(arr);
          var descriptor = gOPD(proto, Symbol.toStringTag);
          if (!descriptor) {
            var superProto = getPrototypeOf(proto);
            descriptor = gOPD(superProto, Symbol.toStringTag);
          }
          cache["$" + typedArray] = callBind(descriptor.get);
        }
      });
    } else {
      forEach(typedArrays, function(typedArray) {
        var arr = new g[typedArray]();
        var fn = arr.slice || arr.set;
        if (fn) {
          cache["$" + typedArray] = callBind(fn);
        }
      });
    }
    var tryTypedArrays = function tryAllTypedArrays(value) {
      var found = false;
      forEach(
        // eslint-disable-next-line no-extra-parens
        /** @type {Record<`\$${TypedArrayName}`, Getter>} */
        /** @type {any} */
        cache,
        /** @type {(getter: Getter, name: `\$${import('.').TypedArrayName}`) => void} */
        function(getter, typedArray) {
          if (!found) {
            try {
              if ("$" + getter(value) === typedArray) {
                found = $slice(typedArray, 1);
              }
            } catch (e) {
            }
          }
        }
      );
      return found;
    };
    var trySlices = function tryAllSlices(value) {
      var found = false;
      forEach(
        // eslint-disable-next-line no-extra-parens
        /** @type {Record<`\$${TypedArrayName}`, Getter>} */
        /** @type {any} */
        cache,
        /** @type {(getter: typeof cache, name: `\$${import('.').TypedArrayName}`) => void} */
        function(getter, name) {
          if (!found) {
            try {
              getter(value);
              found = $slice(name, 1);
            } catch (e) {
            }
          }
        }
      );
      return found;
    };
    module2.exports = function whichTypedArray(value) {
      if (!value || typeof value !== "object") {
        return false;
      }
      if (!hasToStringTag) {
        var tag = $slice($toString(value), 8, -1);
        if ($indexOf(typedArrays, tag) > -1) {
          return tag;
        }
        if (tag !== "Object") {
          return false;
        }
        return trySlices(value);
      }
      if (!gOPD) {
        return null;
      }
      return tryTypedArrays(value);
    };
  }
});

// node_modules/is-typed-array/index.js
var require_is_typed_array = __commonJS({
  "node_modules/is-typed-array/index.js"(exports2, module2) {
    "use strict";
    var whichTypedArray = require_which_typed_array();
    module2.exports = function isTypedArray(value) {
      return !!whichTypedArray(value);
    };
  }
});

// node_modules/util/support/types.js
var require_types = __commonJS({
  "node_modules/util/support/types.js"(exports2) {
    "use strict";
    var isArgumentsObject = require_is_arguments2();
    var isGeneratorFunction = require_is_generator_function();
    var whichTypedArray = require_which_typed_array();
    var isTypedArray = require_is_typed_array();
    function uncurryThis(f) {
      return f.call.bind(f);
    }
    var BigIntSupported = typeof BigInt !== "undefined";
    var SymbolSupported = typeof Symbol !== "undefined";
    var ObjectToString = uncurryThis(Object.prototype.toString);
    var numberValue = uncurryThis(Number.prototype.valueOf);
    var stringValue = uncurryThis(String.prototype.valueOf);
    var booleanValue = uncurryThis(Boolean.prototype.valueOf);
    if (BigIntSupported) {
      bigIntValue = uncurryThis(BigInt.prototype.valueOf);
    }
    var bigIntValue;
    if (SymbolSupported) {
      symbolValue = uncurryThis(Symbol.prototype.valueOf);
    }
    var symbolValue;
    function checkBoxedPrimitive(value, prototypeValueOf) {
      if (typeof value !== "object") {
        return false;
      }
      try {
        prototypeValueOf(value);
        return true;
      } catch (e) {
        return false;
      }
    }
    exports2.isArgumentsObject = isArgumentsObject;
    exports2.isGeneratorFunction = isGeneratorFunction;
    exports2.isTypedArray = isTypedArray;
    function isPromise(input) {
      return typeof Promise !== "undefined" && input instanceof Promise || input !== null && typeof input === "object" && typeof input.then === "function" && typeof input.catch === "function";
    }
    exports2.isPromise = isPromise;
    function isArrayBufferView(value) {
      if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
        return ArrayBuffer.isView(value);
      }
      return isTypedArray(value) || isDataView(value);
    }
    exports2.isArrayBufferView = isArrayBufferView;
    function isUint8Array(value) {
      return whichTypedArray(value) === "Uint8Array";
    }
    exports2.isUint8Array = isUint8Array;
    function isUint8ClampedArray(value) {
      return whichTypedArray(value) === "Uint8ClampedArray";
    }
    exports2.isUint8ClampedArray = isUint8ClampedArray;
    function isUint16Array(value) {
      return whichTypedArray(value) === "Uint16Array";
    }
    exports2.isUint16Array = isUint16Array;
    function isUint32Array(value) {
      return whichTypedArray(value) === "Uint32Array";
    }
    exports2.isUint32Array = isUint32Array;
    function isInt8Array(value) {
      return whichTypedArray(value) === "Int8Array";
    }
    exports2.isInt8Array = isInt8Array;
    function isInt16Array(value) {
      return whichTypedArray(value) === "Int16Array";
    }
    exports2.isInt16Array = isInt16Array;
    function isInt32Array(value) {
      return whichTypedArray(value) === "Int32Array";
    }
    exports2.isInt32Array = isInt32Array;
    function isFloat32Array(value) {
      return whichTypedArray(value) === "Float32Array";
    }
    exports2.isFloat32Array = isFloat32Array;
    function isFloat64Array(value) {
      return whichTypedArray(value) === "Float64Array";
    }
    exports2.isFloat64Array = isFloat64Array;
    function isBigInt64Array(value) {
      return whichTypedArray(value) === "BigInt64Array";
    }
    exports2.isBigInt64Array = isBigInt64Array;
    function isBigUint64Array(value) {
      return whichTypedArray(value) === "BigUint64Array";
    }
    exports2.isBigUint64Array = isBigUint64Array;
    function isMapToString(value) {
      return ObjectToString(value) === "[object Map]";
    }
    isMapToString.working = typeof Map !== "undefined" && isMapToString(/* @__PURE__ */ new Map());
    function isMap(value) {
      if (typeof Map === "undefined") {
        return false;
      }
      return isMapToString.working ? isMapToString(value) : value instanceof Map;
    }
    exports2.isMap = isMap;
    function isSetToString(value) {
      return ObjectToString(value) === "[object Set]";
    }
    isSetToString.working = typeof Set !== "undefined" && isSetToString(/* @__PURE__ */ new Set());
    function isSet(value) {
      if (typeof Set === "undefined") {
        return false;
      }
      return isSetToString.working ? isSetToString(value) : value instanceof Set;
    }
    exports2.isSet = isSet;
    function isWeakMapToString(value) {
      return ObjectToString(value) === "[object WeakMap]";
    }
    isWeakMapToString.working = typeof WeakMap !== "undefined" && isWeakMapToString(/* @__PURE__ */ new WeakMap());
    function isWeakMap(value) {
      if (typeof WeakMap === "undefined") {
        return false;
      }
      return isWeakMapToString.working ? isWeakMapToString(value) : value instanceof WeakMap;
    }
    exports2.isWeakMap = isWeakMap;
    function isWeakSetToString(value) {
      return ObjectToString(value) === "[object WeakSet]";
    }
    isWeakSetToString.working = typeof WeakSet !== "undefined" && isWeakSetToString(/* @__PURE__ */ new WeakSet());
    function isWeakSet(value) {
      return isWeakSetToString(value);
    }
    exports2.isWeakSet = isWeakSet;
    function isArrayBufferToString(value) {
      return ObjectToString(value) === "[object ArrayBuffer]";
    }
    isArrayBufferToString.working = typeof ArrayBuffer !== "undefined" && isArrayBufferToString(new ArrayBuffer());
    function isArrayBuffer(value) {
      if (typeof ArrayBuffer === "undefined") {
        return false;
      }
      return isArrayBufferToString.working ? isArrayBufferToString(value) : value instanceof ArrayBuffer;
    }
    exports2.isArrayBuffer = isArrayBuffer;
    function isDataViewToString(value) {
      return ObjectToString(value) === "[object DataView]";
    }
    isDataViewToString.working = typeof ArrayBuffer !== "undefined" && typeof DataView !== "undefined" && isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1));
    function isDataView(value) {
      if (typeof DataView === "undefined") {
        return false;
      }
      return isDataViewToString.working ? isDataViewToString(value) : value instanceof DataView;
    }
    exports2.isDataView = isDataView;
    var SharedArrayBufferCopy = typeof SharedArrayBuffer !== "undefined" ? SharedArrayBuffer : void 0;
    function isSharedArrayBufferToString(value) {
      return ObjectToString(value) === "[object SharedArrayBuffer]";
    }
    function isSharedArrayBuffer(value) {
      if (typeof SharedArrayBufferCopy === "undefined") {
        return false;
      }
      if (typeof isSharedArrayBufferToString.working === "undefined") {
        isSharedArrayBufferToString.working = isSharedArrayBufferToString(new SharedArrayBufferCopy());
      }
      return isSharedArrayBufferToString.working ? isSharedArrayBufferToString(value) : value instanceof SharedArrayBufferCopy;
    }
    exports2.isSharedArrayBuffer = isSharedArrayBuffer;
    function isAsyncFunction(value) {
      return ObjectToString(value) === "[object AsyncFunction]";
    }
    exports2.isAsyncFunction = isAsyncFunction;
    function isMapIterator(value) {
      return ObjectToString(value) === "[object Map Iterator]";
    }
    exports2.isMapIterator = isMapIterator;
    function isSetIterator(value) {
      return ObjectToString(value) === "[object Set Iterator]";
    }
    exports2.isSetIterator = isSetIterator;
    function isGeneratorObject(value) {
      return ObjectToString(value) === "[object Generator]";
    }
    exports2.isGeneratorObject = isGeneratorObject;
    function isWebAssemblyCompiledModule(value) {
      return ObjectToString(value) === "[object WebAssembly.Module]";
    }
    exports2.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;
    function isNumberObject(value) {
      return checkBoxedPrimitive(value, numberValue);
    }
    exports2.isNumberObject = isNumberObject;
    function isStringObject(value) {
      return checkBoxedPrimitive(value, stringValue);
    }
    exports2.isStringObject = isStringObject;
    function isBooleanObject(value) {
      return checkBoxedPrimitive(value, booleanValue);
    }
    exports2.isBooleanObject = isBooleanObject;
    function isBigIntObject(value) {
      return BigIntSupported && checkBoxedPrimitive(value, bigIntValue);
    }
    exports2.isBigIntObject = isBigIntObject;
    function isSymbolObject(value) {
      return SymbolSupported && checkBoxedPrimitive(value, symbolValue);
    }
    exports2.isSymbolObject = isSymbolObject;
    function isBoxedPrimitive(value) {
      return isNumberObject(value) || isStringObject(value) || isBooleanObject(value) || isBigIntObject(value) || isSymbolObject(value);
    }
    exports2.isBoxedPrimitive = isBoxedPrimitive;
    function isAnyArrayBuffer(value) {
      return typeof Uint8Array !== "undefined" && (isArrayBuffer(value) || isSharedArrayBuffer(value));
    }
    exports2.isAnyArrayBuffer = isAnyArrayBuffer;
    ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(method) {
      Object.defineProperty(exports2, method, {
        enumerable: false,
        value: function() {
          throw new Error(method + " is not supported in userland");
        }
      });
    });
  }
});

// node_modules/util/support/isBufferBrowser.js
var require_isBufferBrowser = __commonJS({
  "node_modules/util/support/isBufferBrowser.js"(exports2, module2) {
    module2.exports = function isBuffer(arg) {
      return arg && typeof arg === "object" && typeof arg.copy === "function" && typeof arg.fill === "function" && typeof arg.readUInt8 === "function";
    };
  }
});

// node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS({
  "node_modules/inherits/inherits_browser.js"(exports2, module2) {
    if (typeof Object.create === "function") {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
  }
});

// node_modules/util/util.js
var require_util = __commonJS({
  "node_modules/util/util.js"(exports2) {
    var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors2(obj) {
      var keys = Object.keys(obj);
      var descriptors = {};
      for (var i = 0; i < keys.length; i++) {
        descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
      }
      return descriptors;
    };
    var formatRegExp = /%[sdj%]/g;
    exports2.format = function(f) {
      if (!isString(f)) {
        var objects = [];
        for (var i = 0; i < arguments.length; i++) {
          objects.push(inspect(arguments[i]));
        }
        return objects.join(" ");
      }
      var i = 1;
      var args = arguments;
      var len = args.length;
      var str = String(f).replace(formatRegExp, function(x2) {
        if (x2 === "%%") return "%";
        if (i >= len) return x2;
        switch (x2) {
          case "%s":
            return String(args[i++]);
          case "%d":
            return Number(args[i++]);
          case "%j":
            try {
              return JSON.stringify(args[i++]);
            } catch (_) {
              return "[Circular]";
            }
          default:
            return x2;
        }
      });
      for (var x = args[i]; i < len; x = args[++i]) {
        if (isNull(x) || !isObject(x)) {
          str += " " + x;
        } else {
          str += " " + inspect(x);
        }
      }
      return str;
    };
    exports2.deprecate = function(fn, msg) {
      if (typeof process !== "undefined" && process.noDeprecation === true) {
        return fn;
      }
      if (typeof process === "undefined") {
        return function() {
          return exports2.deprecate(fn, msg).apply(this, arguments);
        };
      }
      var warned = false;
      function deprecated() {
        if (!warned) {
          if (process.throwDeprecation) {
            throw new Error(msg);
          } else if (process.traceDeprecation) {
            console.trace(msg);
          } else {
            console.error(msg);
          }
          warned = true;
        }
        return fn.apply(this, arguments);
      }
      return deprecated;
    };
    var debugs = {};
    var debugEnvRegex = /^$/;
    if ("") {
      debugEnv = "";
      debugEnv = debugEnv.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase();
      debugEnvRegex = new RegExp("^" + debugEnv + "$", "i");
    }
    var debugEnv;
    exports2.debuglog = function(set) {
      set = set.toUpperCase();
      if (!debugs[set]) {
        if (debugEnvRegex.test(set)) {
          var pid = process.pid;
          debugs[set] = function() {
            var msg = exports2.format.apply(exports2, arguments);
            console.error("%s %d: %s", set, pid, msg);
          };
        } else {
          debugs[set] = function() {
          };
        }
      }
      return debugs[set];
    };
    function inspect(obj, opts) {
      var ctx = {
        seen: [],
        stylize: stylizeNoColor
      };
      if (arguments.length >= 3) ctx.depth = arguments[2];
      if (arguments.length >= 4) ctx.colors = arguments[3];
      if (isBoolean(opts)) {
        ctx.showHidden = opts;
      } else if (opts) {
        exports2._extend(ctx, opts);
      }
      if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
      if (isUndefined(ctx.depth)) ctx.depth = 2;
      if (isUndefined(ctx.colors)) ctx.colors = false;
      if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
      if (ctx.colors) ctx.stylize = stylizeWithColor;
      return formatValue(ctx, obj, ctx.depth);
    }
    exports2.inspect = inspect;
    inspect.colors = {
      "bold": [1, 22],
      "italic": [3, 23],
      "underline": [4, 24],
      "inverse": [7, 27],
      "white": [37, 39],
      "grey": [90, 39],
      "black": [30, 39],
      "blue": [34, 39],
      "cyan": [36, 39],
      "green": [32, 39],
      "magenta": [35, 39],
      "red": [31, 39],
      "yellow": [33, 39]
    };
    inspect.styles = {
      "special": "cyan",
      "number": "yellow",
      "boolean": "yellow",
      "undefined": "grey",
      "null": "bold",
      "string": "green",
      "date": "magenta",
      // "name": intentionally not styling
      "regexp": "red"
    };
    function stylizeWithColor(str, styleType) {
      var style = inspect.styles[styleType];
      if (style) {
        return "\x1B[" + inspect.colors[style][0] + "m" + str + "\x1B[" + inspect.colors[style][1] + "m";
      } else {
        return str;
      }
    }
    function stylizeNoColor(str, styleType) {
      return str;
    }
    function arrayToHash(array) {
      var hash = {};
      array.forEach(function(val, idx) {
        hash[val] = true;
      });
      return hash;
    }
    function formatValue(ctx, value, recurseTimes) {
      if (ctx.customInspect && value && isFunction(value.inspect) && // Filter out the util module, it's inspect function is special
      value.inspect !== exports2.inspect && // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
        var ret = value.inspect(recurseTimes, ctx);
        if (!isString(ret)) {
          ret = formatValue(ctx, ret, recurseTimes);
        }
        return ret;
      }
      var primitive = formatPrimitive(ctx, value);
      if (primitive) {
        return primitive;
      }
      var keys = Object.keys(value);
      var visibleKeys = arrayToHash(keys);
      if (ctx.showHidden) {
        keys = Object.getOwnPropertyNames(value);
      }
      if (isError(value) && (keys.indexOf("message") >= 0 || keys.indexOf("description") >= 0)) {
        return formatError(value);
      }
      if (keys.length === 0) {
        if (isFunction(value)) {
          var name = value.name ? ": " + value.name : "";
          return ctx.stylize("[Function" + name + "]", "special");
        }
        if (isRegExp(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
        }
        if (isDate(value)) {
          return ctx.stylize(Date.prototype.toString.call(value), "date");
        }
        if (isError(value)) {
          return formatError(value);
        }
      }
      var base = "", array = false, braces = ["{", "}"];
      if (isArray(value)) {
        array = true;
        braces = ["[", "]"];
      }
      if (isFunction(value)) {
        var n = value.name ? ": " + value.name : "";
        base = " [Function" + n + "]";
      }
      if (isRegExp(value)) {
        base = " " + RegExp.prototype.toString.call(value);
      }
      if (isDate(value)) {
        base = " " + Date.prototype.toUTCString.call(value);
      }
      if (isError(value)) {
        base = " " + formatError(value);
      }
      if (keys.length === 0 && (!array || value.length == 0)) {
        return braces[0] + base + braces[1];
      }
      if (recurseTimes < 0) {
        if (isRegExp(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
        } else {
          return ctx.stylize("[Object]", "special");
        }
      }
      ctx.seen.push(value);
      var output;
      if (array) {
        output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
      } else {
        output = keys.map(function(key) {
          return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
        });
      }
      ctx.seen.pop();
      return reduceToSingleString(output, base, braces);
    }
    function formatPrimitive(ctx, value) {
      if (isUndefined(value))
        return ctx.stylize("undefined", "undefined");
      if (isString(value)) {
        var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
        return ctx.stylize(simple, "string");
      }
      if (isNumber(value))
        return ctx.stylize("" + value, "number");
      if (isBoolean(value))
        return ctx.stylize("" + value, "boolean");
      if (isNull(value))
        return ctx.stylize("null", "null");
    }
    function formatError(value) {
      return "[" + Error.prototype.toString.call(value) + "]";
    }
    function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
      var output = [];
      for (var i = 0, l = value.length; i < l; ++i) {
        if (hasOwnProperty(value, String(i))) {
          output.push(formatProperty(
            ctx,
            value,
            recurseTimes,
            visibleKeys,
            String(i),
            true
          ));
        } else {
          output.push("");
        }
      }
      keys.forEach(function(key) {
        if (!key.match(/^\d+$/)) {
          output.push(formatProperty(
            ctx,
            value,
            recurseTimes,
            visibleKeys,
            key,
            true
          ));
        }
      });
      return output;
    }
    function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
      var name, str, desc;
      desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
      if (desc.get) {
        if (desc.set) {
          str = ctx.stylize("[Getter/Setter]", "special");
        } else {
          str = ctx.stylize("[Getter]", "special");
        }
      } else {
        if (desc.set) {
          str = ctx.stylize("[Setter]", "special");
        }
      }
      if (!hasOwnProperty(visibleKeys, key)) {
        name = "[" + key + "]";
      }
      if (!str) {
        if (ctx.seen.indexOf(desc.value) < 0) {
          if (isNull(recurseTimes)) {
            str = formatValue(ctx, desc.value, null);
          } else {
            str = formatValue(ctx, desc.value, recurseTimes - 1);
          }
          if (str.indexOf("\n") > -1) {
            if (array) {
              str = str.split("\n").map(function(line) {
                return "  " + line;
              }).join("\n").slice(2);
            } else {
              str = "\n" + str.split("\n").map(function(line) {
                return "   " + line;
              }).join("\n");
            }
          }
        } else {
          str = ctx.stylize("[Circular]", "special");
        }
      }
      if (isUndefined(name)) {
        if (array && key.match(/^\d+$/)) {
          return str;
        }
        name = JSON.stringify("" + key);
        if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
          name = name.slice(1, -1);
          name = ctx.stylize(name, "name");
        } else {
          name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
          name = ctx.stylize(name, "string");
        }
      }
      return name + ": " + str;
    }
    function reduceToSingleString(output, base, braces) {
      var numLinesEst = 0;
      var length = output.reduce(function(prev, cur) {
        numLinesEst++;
        if (cur.indexOf("\n") >= 0) numLinesEst++;
        return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
      }, 0);
      if (length > 60) {
        return braces[0] + (base === "" ? "" : base + "\n ") + " " + output.join(",\n  ") + " " + braces[1];
      }
      return braces[0] + base + " " + output.join(", ") + " " + braces[1];
    }
    exports2.types = require_types();
    function isArray(ar) {
      return Array.isArray(ar);
    }
    exports2.isArray = isArray;
    function isBoolean(arg) {
      return typeof arg === "boolean";
    }
    exports2.isBoolean = isBoolean;
    function isNull(arg) {
      return arg === null;
    }
    exports2.isNull = isNull;
    function isNullOrUndefined(arg) {
      return arg == null;
    }
    exports2.isNullOrUndefined = isNullOrUndefined;
    function isNumber(arg) {
      return typeof arg === "number";
    }
    exports2.isNumber = isNumber;
    function isString(arg) {
      return typeof arg === "string";
    }
    exports2.isString = isString;
    function isSymbol(arg) {
      return typeof arg === "symbol";
    }
    exports2.isSymbol = isSymbol;
    function isUndefined(arg) {
      return arg === void 0;
    }
    exports2.isUndefined = isUndefined;
    function isRegExp(re) {
      return isObject(re) && objectToString(re) === "[object RegExp]";
    }
    exports2.isRegExp = isRegExp;
    exports2.types.isRegExp = isRegExp;
    function isObject(arg) {
      return typeof arg === "object" && arg !== null;
    }
    exports2.isObject = isObject;
    function isDate(d) {
      return isObject(d) && objectToString(d) === "[object Date]";
    }
    exports2.isDate = isDate;
    exports2.types.isDate = isDate;
    function isError(e) {
      return isObject(e) && (objectToString(e) === "[object Error]" || e instanceof Error);
    }
    exports2.isError = isError;
    exports2.types.isNativeError = isError;
    function isFunction(arg) {
      return typeof arg === "function";
    }
    exports2.isFunction = isFunction;
    function isPrimitive(arg) {
      return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || // ES6 symbol
      typeof arg === "undefined";
    }
    exports2.isPrimitive = isPrimitive;
    exports2.isBuffer = require_isBufferBrowser();
    function objectToString(o) {
      return Object.prototype.toString.call(o);
    }
    function pad(n) {
      return n < 10 ? "0" + n.toString(10) : n.toString(10);
    }
    var months = [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec"
    ];
    function timestamp() {
      var d = /* @__PURE__ */ new Date();
      var time = [
        pad(d.getHours()),
        pad(d.getMinutes()),
        pad(d.getSeconds())
      ].join(":");
      return [d.getDate(), months[d.getMonth()], time].join(" ");
    }
    exports2.log = function() {
      console.log("%s - %s", timestamp(), exports2.format.apply(exports2, arguments));
    };
    exports2.inherits = require_inherits_browser();
    exports2._extend = function(origin, add) {
      if (!add || !isObject(add)) return origin;
      var keys = Object.keys(add);
      var i = keys.length;
      while (i--) {
        origin[keys[i]] = add[keys[i]];
      }
      return origin;
    };
    function hasOwnProperty(obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    }
    var kCustomPromisifiedSymbol = typeof Symbol !== "undefined" ? /* @__PURE__ */ Symbol("util.promisify.custom") : void 0;
    exports2.promisify = function promisify(original) {
      if (typeof original !== "function")
        throw new TypeError('The "original" argument must be of type Function');
      if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
        var fn = original[kCustomPromisifiedSymbol];
        if (typeof fn !== "function") {
          throw new TypeError('The "util.promisify.custom" argument must be of type Function');
        }
        Object.defineProperty(fn, kCustomPromisifiedSymbol, {
          value: fn,
          enumerable: false,
          writable: false,
          configurable: true
        });
        return fn;
      }
      function fn() {
        var promiseResolve, promiseReject;
        var promise = new Promise(function(resolve, reject) {
          promiseResolve = resolve;
          promiseReject = reject;
        });
        var args = [];
        for (var i = 0; i < arguments.length; i++) {
          args.push(arguments[i]);
        }
        args.push(function(err, value) {
          if (err) {
            promiseReject(err);
          } else {
            promiseResolve(value);
          }
        });
        try {
          original.apply(this, args);
        } catch (err) {
          promiseReject(err);
        }
        return promise;
      }
      Object.setPrototypeOf(fn, Object.getPrototypeOf(original));
      if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {
        value: fn,
        enumerable: false,
        writable: false,
        configurable: true
      });
      return Object.defineProperties(
        fn,
        getOwnPropertyDescriptors(original)
      );
    };
    exports2.promisify.custom = kCustomPromisifiedSymbol;
    function callbackifyOnRejected(reason, cb) {
      if (!reason) {
        var newReason = new Error("Promise was rejected with a falsy value");
        newReason.reason = reason;
        reason = newReason;
      }
      return cb(reason);
    }
    function callbackify(original) {
      if (typeof original !== "function") {
        throw new TypeError('The "original" argument must be of type Function');
      }
      function callbackified() {
        var args = [];
        for (var i = 0; i < arguments.length; i++) {
          args.push(arguments[i]);
        }
        var maybeCb = args.pop();
        if (typeof maybeCb !== "function") {
          throw new TypeError("The last argument must be of type Function");
        }
        var self2 = this;
        var cb = function() {
          return maybeCb.apply(self2, arguments);
        };
        original.apply(this, args).then(
          function(ret) {
            process.nextTick(cb.bind(null, null, ret));
          },
          function(rej) {
            process.nextTick(callbackifyOnRejected.bind(null, rej, cb));
          }
        );
      }
      Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
      Object.defineProperties(
        callbackified,
        getOwnPropertyDescriptors(original)
      );
      return callbackified;
    }
    exports2.callbackify = callbackify;
  }
});

// lib/sinon/assert.js
var require_assert = __commonJS({
  "lib/sinon/assert.js"(exports2, module2) {
    "use strict";
    var arrayProto = require_lib().prototypes.array;
    var calledInOrder = require_lib().calledInOrder;
    var createMatcher = require_samsam().createMatcher;
    var orderByFirstCall = require_lib().orderByFirstCall;
    var timesInWords = require_times_in_words();
    var inspect = require_util().inspect;
    var stringSlice = require_lib().prototypes.string.slice;
    var globalObject = require_lib().global;
    var arraySlice = arrayProto.slice;
    var concat = arrayProto.concat;
    var forEach = arrayProto.forEach;
    var join = arrayProto.join;
    var splice = arrayProto.splice;
    function applyDefaults(obj, defaults) {
      for (const key of Object.keys(defaults)) {
        const val = obj[key];
        if (val === null || typeof val === "undefined") {
          obj[key] = defaults[key];
        }
      }
    }
    function createAssertObject(opts) {
      const cleanedAssertOptions = opts || {};
      applyDefaults(cleanedAssertOptions, {
        shouldLimitAssertionLogs: false,
        assertionLogLimit: 1e4
      });
      const assert = {
        fail: function fail(message) {
          let msg = message;
          if (cleanedAssertOptions.shouldLimitAssertionLogs) {
            msg = message.substring(
              0,
              cleanedAssertOptions.assertionLogLimit
            );
          }
          const error = new Error(msg);
          error.name = "AssertError";
          throw error;
        },
        pass: function pass() {
          return;
        },
        callOrder: function assertCallOrder() {
          verifyIsStub.apply(null, arguments);
          let expected = "";
          let actual = "";
          if (!calledInOrder(arguments)) {
            try {
              expected = join(arguments, ", ");
              const calls = arraySlice(arguments);
              let i = calls.length;
              while (i) {
                if (!calls[--i].called) {
                  splice(calls, i, 1);
                }
              }
              actual = join(orderByFirstCall(calls), ", ");
            } catch (e) {
            }
            failAssertion(
              this,
              `expected ${expected} to be called in order but were called as ${actual}`
            );
          } else {
            assert.pass("callOrder");
          }
        },
        callCount: function assertCallCount(method, count) {
          verifyIsStub(method);
          let msg;
          if (typeof count !== "number") {
            msg = `expected ${inspect(count)} to be a number but was of type ${typeof count}`;
            failAssertion(this, msg);
          } else if (method.callCount !== count) {
            msg = `expected %n to be called ${timesInWords(count)} but was called %c%C`;
            failAssertion(this, method.printf(msg));
          } else {
            assert.pass("callCount");
          }
        },
        expose: function expose(target, options) {
          if (!target) {
            throw new TypeError("target is null or undefined");
          }
          const o = options || {};
          const prefix = typeof o.prefix === "undefined" && "assert" || o.prefix;
          const includeFail = typeof o.includeFail === "undefined" || Boolean(o.includeFail);
          const instance = this;
          forEach(Object.keys(instance), function(method) {
            if (method !== "expose" && (includeFail || !/^(fail)/.test(method))) {
              target[exposedName(prefix, method)] = instance[method];
            }
          });
          return target;
        },
        match: function match(actual, expectation) {
          const matcher = createMatcher(expectation);
          if (matcher.test(actual)) {
            assert.pass("match");
          } else {
            const formatted = [
              "expected value to match",
              `    expected = ${inspect(expectation)}`,
              `    actual = ${inspect(actual)}`
            ];
            failAssertion(this, join(formatted, "\n"));
          }
        }
      };
      function verifyIsStub() {
        const args = arraySlice(arguments);
        forEach(args, function(method) {
          if (!method) {
            assert.fail("fake is not a spy");
          }
          if (method.proxy && method.proxy.isSinonProxy) {
            verifyIsStub(method.proxy);
          } else {
            if (typeof method !== "function") {
              assert.fail(`${method} is not a function`);
            }
            if (typeof method.getCall !== "function") {
              assert.fail(`${method} is not stubbed`);
            }
          }
        });
      }
      function verifyIsValidAssertion(assertionMethod, assertionArgs) {
        switch (assertionMethod) {
          case "notCalled":
          case "called":
          case "calledOnce":
          case "calledTwice":
          case "calledThrice":
            if (assertionArgs.length !== 0) {
              assert.fail(
                `${assertionMethod} takes 1 argument but was called with ${assertionArgs.length + 1} arguments`
              );
            }
            break;
          default:
            break;
        }
      }
      function failAssertion(object, msg) {
        const obj = object || globalObject;
        const failMethod = obj.fail || assert.fail;
        failMethod.call(obj, msg);
      }
      function mirrorPropAsAssertion(name, method, message) {
        let msg = message;
        let meth = method;
        if (arguments.length === 2) {
          msg = method;
          meth = name;
        }
        assert[name] = function(fake) {
          verifyIsStub(fake);
          const args = arraySlice(arguments, 1);
          let failed = false;
          verifyIsValidAssertion(name, args);
          if (typeof meth === "function") {
            failed = !meth(fake);
          } else {
            failed = typeof fake[meth] === "function" ? !fake[meth].apply(fake, args) : !fake[meth];
          }
          if (failed) {
            failAssertion(
              this,
              (fake.printf || fake.proxy.printf).apply(
                fake,
                concat([msg], args)
              )
            );
          } else {
            assert.pass(name);
          }
        };
      }
      function exposedName(prefix, prop) {
        return !prefix || /^fail/.test(prop) ? prop : prefix + stringSlice(prop, 0, 1).toUpperCase() + stringSlice(prop, 1);
      }
      mirrorPropAsAssertion(
        "called",
        "expected %n to have been called at least once but was never called"
      );
      mirrorPropAsAssertion(
        "notCalled",
        function(spy) {
          return !spy.called;
        },
        "expected %n to not have been called but was called %c%C"
      );
      mirrorPropAsAssertion(
        "calledOnce",
        "expected %n to be called once but was called %c%C"
      );
      mirrorPropAsAssertion(
        "calledTwice",
        "expected %n to be called twice but was called %c%C"
      );
      mirrorPropAsAssertion(
        "calledThrice",
        "expected %n to be called thrice but was called %c%C"
      );
      mirrorPropAsAssertion(
        "calledOn",
        "expected %n to be called with %1 as this but was called with %t"
      );
      mirrorPropAsAssertion(
        "alwaysCalledOn",
        "expected %n to always be called with %1 as this but was called with %t"
      );
      mirrorPropAsAssertion("calledWithNew", "expected %n to be called with new");
      mirrorPropAsAssertion(
        "alwaysCalledWithNew",
        "expected %n to always be called with new"
      );
      mirrorPropAsAssertion(
        "calledWith",
        "expected %n to be called with arguments %D"
      );
      mirrorPropAsAssertion(
        "calledWithMatch",
        "expected %n to be called with match %D"
      );
      mirrorPropAsAssertion(
        "alwaysCalledWith",
        "expected %n to always be called with arguments %D"
      );
      mirrorPropAsAssertion(
        "alwaysCalledWithMatch",
        "expected %n to always be called with match %D"
      );
      mirrorPropAsAssertion(
        "calledWithExactly",
        "expected %n to be called with exact arguments %D"
      );
      mirrorPropAsAssertion(
        "calledOnceWith",
        "expected %n to be called once and with arguments %D"
      );
      mirrorPropAsAssertion(
        "calledOnceWithExactly",
        "expected %n to be called once and with exact arguments %D"
      );
      mirrorPropAsAssertion(
        "calledOnceWithMatch",
        "expected %n to be called once and with match %D"
      );
      mirrorPropAsAssertion(
        "alwaysCalledWithExactly",
        "expected %n to always be called with exact arguments %D"
      );
      mirrorPropAsAssertion(
        "neverCalledWith",
        "expected %n to never be called with arguments %*%C"
      );
      mirrorPropAsAssertion(
        "neverCalledWithMatch",
        "expected %n to never be called with match %*%C"
      );
      mirrorPropAsAssertion("threw", "%n did not throw exception%C");
      mirrorPropAsAssertion("alwaysThrew", "%n did not always throw exception%C");
      return assert;
    }
    module2.exports = createAssertObject();
    module2.exports.createAssertObject = createAssertObject;
  }
});

// node_modules/@sinonjs/fake-timers/src/fake-timers-src.js
var require_fake_timers_src = __commonJS({
  "node_modules/@sinonjs/fake-timers/src/fake-timers-src.js"(exports2, module2) {
    "use strict";
    var globalObject = require_lib().global;
    var timersModule;
    var timersPromisesModule;
    if (typeof require === "function" && typeof module2 === "object") {
      try {
        timersModule = require("timers");
      } catch (e) {
      }
      try {
        timersPromisesModule = require("timers/promises");
      } catch (e) {
      }
    }
    function withGlobal(_global) {
      const maxTimeout = Math.pow(2, 31) - 1;
      const idCounterStart = 1e12;
      const NOOP = function() {
        return void 0;
      };
      const NOOP_ARRAY = function() {
        return [];
      };
      const isPresent = {};
      let timeoutResult, addTimerReturnsObject = false;
      if (_global.setTimeout) {
        isPresent.setTimeout = true;
        timeoutResult = _global.setTimeout(NOOP, 0);
        addTimerReturnsObject = typeof timeoutResult === "object";
      }
      isPresent.clearTimeout = Boolean(_global.clearTimeout);
      isPresent.setInterval = Boolean(_global.setInterval);
      isPresent.clearInterval = Boolean(_global.clearInterval);
      isPresent.hrtime = _global.process && typeof _global.process.hrtime === "function";
      isPresent.hrtimeBigint = isPresent.hrtime && typeof _global.process.hrtime.bigint === "function";
      isPresent.nextTick = _global.process && typeof _global.process.nextTick === "function";
      const utilPromisify = _global.process && require_util().promisify;
      isPresent.performance = _global.performance && typeof _global.performance.now === "function";
      const hasPerformancePrototype = _global.Performance && (typeof _global.Performance).match(/^(function|object)$/);
      const hasPerformanceConstructorPrototype = _global.performance && _global.performance.constructor && _global.performance.constructor.prototype;
      isPresent.queueMicrotask = _global.hasOwnProperty("queueMicrotask");
      isPresent.requestAnimationFrame = _global.requestAnimationFrame && typeof _global.requestAnimationFrame === "function";
      isPresent.cancelAnimationFrame = _global.cancelAnimationFrame && typeof _global.cancelAnimationFrame === "function";
      isPresent.requestIdleCallback = _global.requestIdleCallback && typeof _global.requestIdleCallback === "function";
      isPresent.cancelIdleCallbackPresent = _global.cancelIdleCallback && typeof _global.cancelIdleCallback === "function";
      isPresent.setImmediate = _global.setImmediate && typeof _global.setImmediate === "function";
      isPresent.clearImmediate = _global.clearImmediate && typeof _global.clearImmediate === "function";
      isPresent.Intl = _global.Intl && typeof _global.Intl === "object";
      if (_global.clearTimeout) {
        _global.clearTimeout(timeoutResult);
      }
      const NativeDate = _global.Date;
      const NativeIntl = isPresent.Intl ? Object.defineProperties(
        /* @__PURE__ */ Object.create(null),
        Object.getOwnPropertyDescriptors(_global.Intl)
      ) : void 0;
      let uniqueTimerId = idCounterStart;
      if (NativeDate === void 0) {
        throw new Error(
          "The global scope doesn't have a `Date` object (see https://github.com/sinonjs/sinon/issues/1852#issuecomment-419622780)"
        );
      }
      isPresent.Date = true;
      class FakePerformanceEntry {
        constructor(name, entryType, startTime, duration) {
          this.name = name;
          this.entryType = entryType;
          this.startTime = startTime;
          this.duration = duration;
        }
        toJSON() {
          return JSON.stringify({ ...this });
        }
      }
      function isNumberFinite(num) {
        if (Number.isFinite) {
          return Number.isFinite(num);
        }
        return isFinite(num);
      }
      let isNearInfiniteLimit = false;
      function checkIsNearInfiniteLimit(clock, i) {
        if (clock.loopLimit && i === clock.loopLimit - 1) {
          isNearInfiniteLimit = true;
        }
      }
      function resetIsNearInfiniteLimit() {
        isNearInfiniteLimit = false;
      }
      function parseTime(str) {
        if (!str) {
          return 0;
        }
        const strings = str.split(":");
        const l = strings.length;
        let i = l;
        let ms = 0;
        let parsed;
        if (l > 3 || !/^(\d\d:){0,2}\d\d?$/.test(str)) {
          throw new Error(
            "tick only understands numbers, 'm:s' and 'h:m:s'. Each part must be two digits"
          );
        }
        while (i--) {
          parsed = parseInt(strings[i], 10);
          if (parsed >= 60) {
            throw new Error(`Invalid time ${str}`);
          }
          ms += parsed * Math.pow(60, l - i - 1);
        }
        return ms * 1e3;
      }
      function nanoRemainder(msFloat) {
        const modulo = 1e6;
        const remainder = msFloat * 1e6 % modulo;
        const positiveRemainder = remainder < 0 ? remainder + modulo : remainder;
        return Math.floor(positiveRemainder);
      }
      function getEpoch(epoch) {
        if (!epoch) {
          return 0;
        }
        if (typeof epoch.getTime === "function") {
          return epoch.getTime();
        }
        if (typeof epoch === "number") {
          return epoch;
        }
        throw new TypeError("now should be milliseconds since UNIX epoch");
      }
      function inRange(from, to, timer) {
        return timer && timer.callAt >= from && timer.callAt <= to;
      }
      function getInfiniteLoopError(clock, job) {
        const infiniteLoopError = new Error(
          `Aborting after running ${clock.loopLimit} timers, assuming an infinite loop!`
        );
        if (!job.error) {
          return infiniteLoopError;
        }
        const computedTargetPattern = /target\.*[<|(|[].*?[>|\]|)]\s*/;
        let clockMethodPattern = new RegExp(
          String(Object.keys(clock).join("|"))
        );
        if (addTimerReturnsObject) {
          clockMethodPattern = new RegExp(
            `\\s+at (Object\\.)?(?:${Object.keys(clock).join("|")})\\s+`
          );
        }
        let matchedLineIndex = -1;
        job.error.stack.split("\n").some(function(line, i) {
          const matchedComputedTarget = line.match(computedTargetPattern);
          if (matchedComputedTarget) {
            matchedLineIndex = i;
            return true;
          }
          const matchedClockMethod = line.match(clockMethodPattern);
          if (matchedClockMethod) {
            matchedLineIndex = i;
            return false;
          }
          return matchedLineIndex >= 0;
        });
        const stack = `${infiniteLoopError}
${job.type || "Microtask"} - ${job.func.name || "anonymous"}
${job.error.stack.split("\n").slice(matchedLineIndex + 1).join("\n")}`;
        try {
          Object.defineProperty(infiniteLoopError, "stack", {
            value: stack
          });
        } catch (e) {
        }
        return infiniteLoopError;
      }
      function createDate() {
        class ClockDate extends NativeDate {
          /**
           * @param {number} year
           * @param {number} month
           * @param {number} date
           * @param {number} hour
           * @param {number} minute
           * @param {number} second
           * @param {number} ms
           * @returns void
           */
          // eslint-disable-next-line no-unused-vars
          constructor(year, month, date, hour, minute, second, ms) {
            if (arguments.length === 0) {
              super(ClockDate.clock.now);
            } else {
              super(...arguments);
            }
            Object.defineProperty(this, "constructor", {
              value: NativeDate,
              enumerable: false
            });
          }
          static [Symbol.hasInstance](instance) {
            return instance instanceof NativeDate;
          }
        }
        ClockDate.isFake = true;
        if (NativeDate.now) {
          ClockDate.now = function now() {
            return ClockDate.clock.now;
          };
        }
        if (NativeDate.toSource) {
          ClockDate.toSource = function toSource() {
            return NativeDate.toSource();
          };
        }
        ClockDate.toString = function toString() {
          return NativeDate.toString();
        };
        const ClockDateProxy = new Proxy(ClockDate, {
          // handler for [[Call]] invocations (i.e. not using `new`)
          apply() {
            if (this instanceof ClockDate) {
              throw new TypeError(
                "A Proxy should only capture `new` calls with the `construct` handler. This is not supposed to be possible, so check the logic."
              );
            }
            return new NativeDate(ClockDate.clock.now).toString();
          }
        });
        return ClockDateProxy;
      }
      function createIntl() {
        const ClockIntl = {};
        Object.getOwnPropertyNames(NativeIntl).forEach(
          (property) => ClockIntl[property] = NativeIntl[property]
        );
        ClockIntl.DateTimeFormat = function(...args) {
          const realFormatter = new NativeIntl.DateTimeFormat(...args);
          const formatter = {};
          ["formatRange", "formatRangeToParts", "resolvedOptions"].forEach(
            (method) => {
              formatter[method] = realFormatter[method].bind(realFormatter);
            }
          );
          ["format", "formatToParts"].forEach((method) => {
            formatter[method] = function(date) {
              return realFormatter[method](date || ClockIntl.clock.now);
            };
          });
          return formatter;
        };
        ClockIntl.DateTimeFormat.prototype = Object.create(
          NativeIntl.DateTimeFormat.prototype
        );
        ClockIntl.DateTimeFormat.supportedLocalesOf = NativeIntl.DateTimeFormat.supportedLocalesOf;
        return ClockIntl;
      }
      function enqueueJob(clock, job) {
        if (!clock.jobs) {
          clock.jobs = [];
        }
        clock.jobs.push(job);
      }
      function runJobs(clock) {
        if (!clock.jobs) {
          return;
        }
        for (let i = 0; i < clock.jobs.length; i++) {
          const job = clock.jobs[i];
          job.func.apply(null, job.args);
          checkIsNearInfiniteLimit(clock, i);
          if (clock.loopLimit && i > clock.loopLimit) {
            throw getInfiniteLoopError(clock, job);
          }
        }
        resetIsNearInfiniteLimit();
        clock.jobs = [];
      }
      function addTimer(clock, timer) {
        if (timer.func === void 0) {
          throw new Error("Callback must be provided to timer calls");
        }
        if (addTimerReturnsObject) {
          if (typeof timer.func !== "function") {
            throw new TypeError(
              `[ERR_INVALID_CALLBACK]: Callback must be a function. Received ${timer.func} of type ${typeof timer.func}`
            );
          }
        }
        if (isNearInfiniteLimit) {
          timer.error = new Error();
        }
        timer.type = timer.immediate ? "Immediate" : "Timeout";
        if (timer.hasOwnProperty("delay")) {
          if (typeof timer.delay !== "number") {
            timer.delay = parseInt(timer.delay, 10);
          }
          if (!isNumberFinite(timer.delay)) {
            timer.delay = 0;
          }
          timer.delay = timer.delay > maxTimeout ? 1 : timer.delay;
          timer.delay = Math.max(0, timer.delay);
        }
        if (timer.hasOwnProperty("interval")) {
          timer.type = "Interval";
          timer.interval = timer.interval > maxTimeout ? 1 : timer.interval;
        }
        if (timer.hasOwnProperty("animation")) {
          timer.type = "AnimationFrame";
          timer.animation = true;
        }
        if (timer.hasOwnProperty("idleCallback")) {
          timer.type = "IdleCallback";
          timer.idleCallback = true;
        }
        if (!clock.timers) {
          clock.timers = {};
        }
        timer.id = uniqueTimerId++;
        timer.createdAt = clock.now;
        timer.callAt = clock.now + (parseInt(timer.delay) || (clock.duringTick ? 1 : 0));
        clock.timers[timer.id] = timer;
        if (addTimerReturnsObject) {
          const res = {
            refed: true,
            ref: function() {
              this.refed = true;
              return res;
            },
            unref: function() {
              this.refed = false;
              return res;
            },
            hasRef: function() {
              return this.refed;
            },
            refresh: function() {
              timer.callAt = clock.now + (parseInt(timer.delay) || (clock.duringTick ? 1 : 0));
              clock.timers[timer.id] = timer;
              return res;
            },
            [Symbol.toPrimitive]: function() {
              return timer.id;
            }
          };
          return res;
        }
        return timer.id;
      }
      function compareTimers(a, b) {
        if (a.callAt < b.callAt) {
          return -1;
        }
        if (a.callAt > b.callAt) {
          return 1;
        }
        if (a.immediate && !b.immediate) {
          return -1;
        }
        if (!a.immediate && b.immediate) {
          return 1;
        }
        if (a.createdAt < b.createdAt) {
          return -1;
        }
        if (a.createdAt > b.createdAt) {
          return 1;
        }
        if (a.id < b.id) {
          return -1;
        }
        if (a.id > b.id) {
          return 1;
        }
      }
      function firstTimerInRange(clock, from, to) {
        const timers2 = clock.timers;
        let timer = null;
        let id, isInRange;
        for (id in timers2) {
          if (timers2.hasOwnProperty(id)) {
            isInRange = inRange(from, to, timers2[id]);
            if (isInRange && (!timer || compareTimers(timer, timers2[id]) === 1)) {
              timer = timers2[id];
            }
          }
        }
        return timer;
      }
      function firstTimer(clock) {
        const timers2 = clock.timers;
        let timer = null;
        let id;
        for (id in timers2) {
          if (timers2.hasOwnProperty(id)) {
            if (!timer || compareTimers(timer, timers2[id]) === 1) {
              timer = timers2[id];
            }
          }
        }
        return timer;
      }
      function lastTimer(clock) {
        const timers2 = clock.timers;
        let timer = null;
        let id;
        for (id in timers2) {
          if (timers2.hasOwnProperty(id)) {
            if (!timer || compareTimers(timer, timers2[id]) === -1) {
              timer = timers2[id];
            }
          }
        }
        return timer;
      }
      function callTimer(clock, timer) {
        if (typeof timer.interval === "number") {
          clock.timers[timer.id].callAt += timer.interval;
        } else {
          delete clock.timers[timer.id];
        }
        if (typeof timer.func === "function") {
          timer.func.apply(null, timer.args);
        } else {
          const eval2 = eval;
          (function() {
            eval2(timer.func);
          })();
        }
      }
      function getClearHandler(ttype) {
        if (ttype === "IdleCallback" || ttype === "AnimationFrame") {
          return `cancel${ttype}`;
        }
        return `clear${ttype}`;
      }
      function getScheduleHandler(ttype) {
        if (ttype === "IdleCallback" || ttype === "AnimationFrame") {
          return `request${ttype}`;
        }
        return `set${ttype}`;
      }
      function createWarnOnce() {
        let calls = 0;
        return function(msg) {
          !calls++ && console.warn(msg);
        };
      }
      const warnOnce = createWarnOnce();
      function clearTimer(clock, timerId, ttype) {
        if (!timerId) {
          return;
        }
        if (!clock.timers) {
          clock.timers = {};
        }
        const id = Number(timerId);
        if (Number.isNaN(id) || id < idCounterStart) {
          const handlerName = getClearHandler(ttype);
          if (clock.shouldClearNativeTimers === true) {
            const nativeHandler = clock[`_${handlerName}`];
            return typeof nativeHandler === "function" ? nativeHandler(timerId) : void 0;
          }
          const stackTrace = new Error().stack.split("\n").slice(1).join("\n");
          warnOnce(
            `FakeTimers: ${handlerName} was invoked to clear a native timer instead of one created by this library.
To automatically clean-up native timers, use \`shouldClearNativeTimers\`.
${stackTrace}`
          );
        }
        if (clock.timers.hasOwnProperty(id)) {
          const timer = clock.timers[id];
          if (timer.type === ttype || timer.type === "Timeout" && ttype === "Interval" || timer.type === "Interval" && ttype === "Timeout") {
            delete clock.timers[id];
          } else {
            const clear = getClearHandler(ttype);
            const schedule = getScheduleHandler(timer.type);
            throw new Error(
              `Cannot clear timer: timer created with ${schedule}() but cleared with ${clear}()`
            );
          }
        }
      }
      function uninstall(clock) {
        let method, i, l;
        const installedHrTime = "_hrtime";
        const installedNextTick = "_nextTick";
        for (i = 0, l = clock.methods.length; i < l; i++) {
          method = clock.methods[i];
          if (method === "hrtime" && _global.process) {
            _global.process.hrtime = clock[installedHrTime];
          } else if (method === "nextTick" && _global.process) {
            _global.process.nextTick = clock[installedNextTick];
          } else if (method === "performance") {
            const originalPerfDescriptor = Object.getOwnPropertyDescriptor(
              clock,
              `_${method}`
            );
            if (originalPerfDescriptor && originalPerfDescriptor.get && !originalPerfDescriptor.set) {
              Object.defineProperty(
                _global,
                method,
                originalPerfDescriptor
              );
            } else if (originalPerfDescriptor.configurable) {
              _global[method] = clock[`_${method}`];
            }
          } else {
            if (_global[method] && _global[method].hadOwnProperty) {
              _global[method] = clock[`_${method}`];
            } else {
              try {
                delete _global[method];
              } catch (ignore) {
              }
            }
          }
          if (clock.timersModuleMethods !== void 0) {
            for (let j = 0; j < clock.timersModuleMethods.length; j++) {
              const entry = clock.timersModuleMethods[j];
              timersModule[entry.methodName] = entry.original;
            }
          }
          if (clock.timersPromisesModuleMethods !== void 0) {
            for (let j = 0; j < clock.timersPromisesModuleMethods.length; j++) {
              const entry = clock.timersPromisesModuleMethods[j];
              timersPromisesModule[entry.methodName] = entry.original;
            }
          }
        }
        clock.setTickMode("manual");
        clock.methods = [];
        for (const [listener, signal] of clock.abortListenerMap.entries()) {
          signal.removeEventListener("abort", listener);
          clock.abortListenerMap.delete(listener);
        }
        if (!clock.timers) {
          return [];
        }
        return Object.keys(clock.timers).map(function mapper(key) {
          return clock.timers[key];
        });
      }
      function hijackMethod(target, method, clock) {
        clock[method].hadOwnProperty = Object.prototype.hasOwnProperty.call(
          target,
          method
        );
        clock[`_${method}`] = target[method];
        if (method === "Date") {
          target[method] = clock[method];
        } else if (method === "Intl") {
          target[method] = clock[method];
        } else if (method === "performance") {
          const originalPerfDescriptor = Object.getOwnPropertyDescriptor(
            target,
            method
          );
          if (originalPerfDescriptor && originalPerfDescriptor.get && !originalPerfDescriptor.set) {
            Object.defineProperty(
              clock,
              `_${method}`,
              originalPerfDescriptor
            );
            const perfDescriptor = Object.getOwnPropertyDescriptor(
              clock,
              method
            );
            Object.defineProperty(target, method, perfDescriptor);
          } else {
            target[method] = clock[method];
          }
        } else {
          target[method] = function() {
            return clock[method].apply(clock, arguments);
          };
          Object.defineProperties(
            target[method],
            Object.getOwnPropertyDescriptors(clock[method])
          );
        }
        target[method].clock = clock;
      }
      function doIntervalTick(clock, advanceTimeDelta) {
        clock.tick(advanceTimeDelta);
      }
      const timers = {
        setTimeout: _global.setTimeout,
        clearTimeout: _global.clearTimeout,
        setInterval: _global.setInterval,
        clearInterval: _global.clearInterval,
        Date: _global.Date
      };
      if (isPresent.setImmediate) {
        timers.setImmediate = _global.setImmediate;
      }
      if (isPresent.clearImmediate) {
        timers.clearImmediate = _global.clearImmediate;
      }
      if (isPresent.hrtime) {
        timers.hrtime = _global.process.hrtime;
      }
      if (isPresent.nextTick) {
        timers.nextTick = _global.process.nextTick;
      }
      if (isPresent.performance) {
        timers.performance = _global.performance;
      }
      if (isPresent.requestAnimationFrame) {
        timers.requestAnimationFrame = _global.requestAnimationFrame;
      }
      if (isPresent.queueMicrotask) {
        timers.queueMicrotask = _global.queueMicrotask;
      }
      if (isPresent.cancelAnimationFrame) {
        timers.cancelAnimationFrame = _global.cancelAnimationFrame;
      }
      if (isPresent.requestIdleCallback) {
        timers.requestIdleCallback = _global.requestIdleCallback;
      }
      if (isPresent.cancelIdleCallback) {
        timers.cancelIdleCallback = _global.cancelIdleCallback;
      }
      if (isPresent.Intl) {
        timers.Intl = NativeIntl;
      }
      const originalSetTimeout = _global.setImmediate || _global.setTimeout;
      const originalClearInterval = _global.clearInterval;
      const originalSetInterval = _global.setInterval;
      function createClock(start, loopLimit) {
        start = Math.floor(getEpoch(start));
        loopLimit = loopLimit || 1e3;
        let nanos = 0;
        const adjustedSystemTime = [0, 0];
        const clock = {
          now: start,
          Date: createDate(),
          loopLimit,
          tickMode: { mode: "manual", counter: 0, delta: void 0 }
        };
        clock.Date.clock = clock;
        function getTimeToNextFrame() {
          return 16 - (clock.now - start) % 16;
        }
        function hrtime(prev) {
          const millisSinceStart = clock.now - adjustedSystemTime[0] - start;
          const secsSinceStart = Math.floor(millisSinceStart / 1e3);
          const remainderInNanos = (millisSinceStart - secsSinceStart * 1e3) * 1e6 + nanos - adjustedSystemTime[1];
          if (Array.isArray(prev)) {
            if (prev[1] > 1e9) {
              throw new TypeError(
                "Number of nanoseconds can't exceed a billion"
              );
            }
            const oldSecs = prev[0];
            let nanoDiff = remainderInNanos - prev[1];
            let secDiff = secsSinceStart - oldSecs;
            if (nanoDiff < 0) {
              nanoDiff += 1e9;
              secDiff -= 1;
            }
            return [secDiff, nanoDiff];
          }
          return [secsSinceStart, remainderInNanos];
        }
        function fakePerformanceNow() {
          const hrt = hrtime();
          const millis = hrt[0] * 1e3 + hrt[1] / 1e6;
          return millis;
        }
        if (isPresent.hrtimeBigint) {
          hrtime.bigint = function() {
            const parts = hrtime();
            return BigInt(parts[0]) * BigInt(1e9) + BigInt(parts[1]);
          };
        }
        if (isPresent.Intl) {
          clock.Intl = createIntl();
          clock.Intl.clock = clock;
        }
        clock.setTickMode = function(tickModeConfig) {
          const { mode: newMode, delta: newDelta } = tickModeConfig;
          const { mode: oldMode, delta: oldDelta } = clock.tickMode;
          if (newMode === oldMode && newDelta === oldDelta) {
            return;
          }
          if (oldMode === "interval") {
            originalClearInterval(clock.attachedInterval);
          }
          clock.tickMode = {
            counter: clock.tickMode.counter + 1,
            mode: newMode,
            delta: newDelta
          };
          if (newMode === "nextAsync") {
            advanceUntilModeChanges();
          } else if (newMode === "interval") {
            createIntervalTick(clock, newDelta || 20);
          }
        };
        async function advanceUntilModeChanges() {
          async function newMacrotask() {
            const channel = new MessageChannel();
            await new Promise((resolve) => {
              channel.port1.onmessage = () => {
                resolve();
                channel.port1.close();
              };
              channel.port2.postMessage(void 0);
            });
            channel.port1.close();
            channel.port2.close();
            await new Promise((resolve) => {
              originalSetTimeout(resolve);
            });
          }
          const { counter } = clock.tickMode;
          while (clock.tickMode.counter === counter) {
            await newMacrotask();
            if (clock.tickMode.counter !== counter) {
              return;
            }
            clock.next();
          }
        }
        function pauseAutoTickUntilFinished(promise) {
          if (clock.tickMode.mode !== "nextAsync") {
            return promise;
          }
          clock.setTickMode({ mode: "manual" });
          return promise.finally(() => {
            clock.setTickMode({ mode: "nextAsync" });
          });
        }
        clock.requestIdleCallback = function requestIdleCallback(func, timeout) {
          let timeToNextIdlePeriod = 0;
          if (clock.countTimers() > 0) {
            timeToNextIdlePeriod = 50;
          }
          const result = addTimer(clock, {
            func,
            args: Array.prototype.slice.call(arguments, 2),
            delay: typeof timeout === "undefined" ? timeToNextIdlePeriod : Math.min(timeout, timeToNextIdlePeriod),
            idleCallback: true
          });
          return Number(result);
        };
        clock.cancelIdleCallback = function cancelIdleCallback(timerId) {
          return clearTimer(clock, timerId, "IdleCallback");
        };
        clock.setTimeout = function setTimeout2(func, timeout) {
          return addTimer(clock, {
            func,
            args: Array.prototype.slice.call(arguments, 2),
            delay: timeout
          });
        };
        if (typeof _global.Promise !== "undefined" && utilPromisify) {
          clock.setTimeout[utilPromisify.custom] = function promisifiedSetTimeout(timeout, arg) {
            return new _global.Promise(function setTimeoutExecutor(resolve) {
              addTimer(clock, {
                func: resolve,
                args: [arg],
                delay: timeout
              });
            });
          };
        }
        clock.clearTimeout = function clearTimeout2(timerId) {
          return clearTimer(clock, timerId, "Timeout");
        };
        clock.nextTick = function nextTick(func) {
          return enqueueJob(clock, {
            func,
            args: Array.prototype.slice.call(arguments, 1),
            error: isNearInfiniteLimit ? new Error() : null
          });
        };
        clock.queueMicrotask = function queueMicrotask(func) {
          return clock.nextTick(func);
        };
        clock.setInterval = function setInterval2(func, timeout) {
          timeout = parseInt(timeout, 10);
          return addTimer(clock, {
            func,
            args: Array.prototype.slice.call(arguments, 2),
            delay: timeout,
            interval: timeout
          });
        };
        clock.clearInterval = function clearInterval2(timerId) {
          return clearTimer(clock, timerId, "Interval");
        };
        if (isPresent.setImmediate) {
          clock.setImmediate = function setImmediate(func) {
            return addTimer(clock, {
              func,
              args: Array.prototype.slice.call(arguments, 1),
              immediate: true
            });
          };
          if (typeof _global.Promise !== "undefined" && utilPromisify) {
            clock.setImmediate[utilPromisify.custom] = function promisifiedSetImmediate(arg) {
              return new _global.Promise(
                function setImmediateExecutor(resolve) {
                  addTimer(clock, {
                    func: resolve,
                    args: [arg],
                    immediate: true
                  });
                }
              );
            };
          }
          clock.clearImmediate = function clearImmediate(timerId) {
            return clearTimer(clock, timerId, "Immediate");
          };
        }
        clock.countTimers = function countTimers() {
          return Object.keys(clock.timers || {}).length + (clock.jobs || []).length;
        };
        clock.requestAnimationFrame = function requestAnimationFrame(func) {
          const result = addTimer(clock, {
            func,
            delay: getTimeToNextFrame(),
            get args() {
              return [fakePerformanceNow()];
            },
            animation: true
          });
          return Number(result);
        };
        clock.cancelAnimationFrame = function cancelAnimationFrame(timerId) {
          return clearTimer(clock, timerId, "AnimationFrame");
        };
        clock.runMicrotasks = function runMicrotasks() {
          runJobs(clock);
        };
        function doTick(tickValue, isAsync, resolve, reject) {
          const msFloat = typeof tickValue === "number" ? tickValue : parseTime(tickValue);
          const ms = Math.floor(msFloat);
          const remainder = nanoRemainder(msFloat);
          let nanosTotal = nanos + remainder;
          let tickTo = clock.now + ms;
          if (msFloat < 0) {
            throw new TypeError("Negative ticks are not supported");
          }
          if (nanosTotal >= 1e6) {
            tickTo += 1;
            nanosTotal -= 1e6;
          }
          nanos = nanosTotal;
          let tickFrom = clock.now;
          let previous = clock.now;
          let timer, firstException, oldNow, nextPromiseTick, compensationCheck, postTimerCall;
          clock.duringTick = true;
          oldNow = clock.now;
          runJobs(clock);
          if (oldNow !== clock.now) {
            tickFrom += clock.now - oldNow;
            tickTo += clock.now - oldNow;
          }
          function doTickInner() {
            timer = firstTimerInRange(clock, tickFrom, tickTo);
            while (timer && tickFrom <= tickTo) {
              if (clock.timers[timer.id]) {
                tickFrom = timer.callAt;
                clock.now = timer.callAt;
                oldNow = clock.now;
                try {
                  runJobs(clock);
                  callTimer(clock, timer);
                } catch (e) {
                  firstException = firstException || e;
                }
                if (isAsync) {
                  originalSetTimeout(nextPromiseTick);
                  return;
                }
                compensationCheck();
              }
              postTimerCall();
            }
            oldNow = clock.now;
            runJobs(clock);
            if (oldNow !== clock.now) {
              tickFrom += clock.now - oldNow;
              tickTo += clock.now - oldNow;
            }
            clock.duringTick = false;
            timer = firstTimerInRange(clock, tickFrom, tickTo);
            if (timer) {
              try {
                clock.tick(tickTo - clock.now);
              } catch (e) {
                firstException = firstException || e;
              }
            } else {
              clock.now = tickTo;
              nanos = nanosTotal;
            }
            if (firstException) {
              throw firstException;
            }
            if (isAsync) {
              resolve(clock.now);
            } else {
              return clock.now;
            }
          }
          nextPromiseTick = isAsync && function() {
            try {
              compensationCheck();
              postTimerCall();
              doTickInner();
            } catch (e) {
              reject(e);
            }
          };
          compensationCheck = function() {
            if (oldNow !== clock.now) {
              tickFrom += clock.now - oldNow;
              tickTo += clock.now - oldNow;
              previous += clock.now - oldNow;
            }
          };
          postTimerCall = function() {
            timer = firstTimerInRange(clock, previous, tickTo);
            previous = tickFrom;
          };
          return doTickInner();
        }
        clock.tick = function tick(tickValue) {
          return doTick(tickValue, false);
        };
        if (typeof _global.Promise !== "undefined") {
          clock.tickAsync = function tickAsync(tickValue) {
            return pauseAutoTickUntilFinished(
              new _global.Promise(function(resolve, reject) {
                originalSetTimeout(function() {
                  try {
                    doTick(tickValue, true, resolve, reject);
                  } catch (e) {
                    reject(e);
                  }
                });
              })
            );
          };
        }
        clock.next = function next() {
          runJobs(clock);
          const timer = firstTimer(clock);
          if (!timer) {
            return clock.now;
          }
          clock.duringTick = true;
          try {
            clock.now = timer.callAt;
            callTimer(clock, timer);
            runJobs(clock);
            return clock.now;
          } finally {
            clock.duringTick = false;
          }
        };
        if (typeof _global.Promise !== "undefined") {
          clock.nextAsync = function nextAsync() {
            return pauseAutoTickUntilFinished(
              new _global.Promise(function(resolve, reject) {
                originalSetTimeout(function() {
                  try {
                    const timer = firstTimer(clock);
                    if (!timer) {
                      resolve(clock.now);
                      return;
                    }
                    let err;
                    clock.duringTick = true;
                    clock.now = timer.callAt;
                    try {
                      callTimer(clock, timer);
                    } catch (e) {
                      err = e;
                    }
                    clock.duringTick = false;
                    originalSetTimeout(function() {
                      if (err) {
                        reject(err);
                      } else {
                        resolve(clock.now);
                      }
                    });
                  } catch (e) {
                    reject(e);
                  }
                });
              })
            );
          };
        }
        clock.runAll = function runAll() {
          let numTimers, i;
          runJobs(clock);
          for (i = 0; i < clock.loopLimit; i++) {
            if (!clock.timers) {
              resetIsNearInfiniteLimit();
              return clock.now;
            }
            numTimers = Object.keys(clock.timers).length;
            if (numTimers === 0) {
              resetIsNearInfiniteLimit();
              return clock.now;
            }
            clock.next();
            checkIsNearInfiniteLimit(clock, i);
          }
          const excessJob = firstTimer(clock);
          throw getInfiniteLoopError(clock, excessJob);
        };
        clock.runToFrame = function runToFrame() {
          return clock.tick(getTimeToNextFrame());
        };
        if (typeof _global.Promise !== "undefined") {
          clock.runAllAsync = function runAllAsync() {
            return pauseAutoTickUntilFinished(
              new _global.Promise(function(resolve, reject) {
                let i = 0;
                function doRun() {
                  originalSetTimeout(function() {
                    try {
                      runJobs(clock);
                      let numTimers;
                      if (i < clock.loopLimit) {
                        if (!clock.timers) {
                          resetIsNearInfiniteLimit();
                          resolve(clock.now);
                          return;
                        }
                        numTimers = Object.keys(
                          clock.timers
                        ).length;
                        if (numTimers === 0) {
                          resetIsNearInfiniteLimit();
                          resolve(clock.now);
                          return;
                        }
                        clock.next();
                        i++;
                        doRun();
                        checkIsNearInfiniteLimit(clock, i);
                        return;
                      }
                      const excessJob = firstTimer(clock);
                      reject(
                        getInfiniteLoopError(clock, excessJob)
                      );
                    } catch (e) {
                      reject(e);
                    }
                  });
                }
                doRun();
              })
            );
          };
        }
        clock.runToLast = function runToLast() {
          const timer = lastTimer(clock);
          if (!timer) {
            runJobs(clock);
            return clock.now;
          }
          return clock.tick(timer.callAt - clock.now);
        };
        if (typeof _global.Promise !== "undefined") {
          clock.runToLastAsync = function runToLastAsync() {
            return pauseAutoTickUntilFinished(
              new _global.Promise(function(resolve, reject) {
                originalSetTimeout(function() {
                  try {
                    const timer = lastTimer(clock);
                    if (!timer) {
                      runJobs(clock);
                      resolve(clock.now);
                    }
                    resolve(
                      clock.tickAsync(timer.callAt - clock.now)
                    );
                  } catch (e) {
                    reject(e);
                  }
                });
              })
            );
          };
        }
        clock.reset = function reset() {
          nanos = 0;
          clock.timers = {};
          clock.jobs = [];
          clock.now = start;
        };
        clock.setSystemTime = function setSystemTime(systemTime) {
          const newNow = getEpoch(systemTime);
          const difference = newNow - clock.now;
          let id, timer;
          adjustedSystemTime[0] = adjustedSystemTime[0] + difference;
          adjustedSystemTime[1] = adjustedSystemTime[1] + nanos;
          clock.now = newNow;
          nanos = 0;
          for (id in clock.timers) {
            if (clock.timers.hasOwnProperty(id)) {
              timer = clock.timers[id];
              timer.createdAt += difference;
              timer.callAt += difference;
            }
          }
        };
        clock.jump = function jump(tickValue) {
          const msFloat = typeof tickValue === "number" ? tickValue : parseTime(tickValue);
          const ms = Math.floor(msFloat);
          for (const timer of Object.values(clock.timers)) {
            if (clock.now + ms > timer.callAt) {
              timer.callAt = clock.now + ms;
            }
          }
          clock.tick(ms);
        };
        if (isPresent.performance) {
          clock.performance = /* @__PURE__ */ Object.create(null);
          clock.performance.now = fakePerformanceNow;
        }
        if (isPresent.hrtime) {
          clock.hrtime = hrtime;
        }
        return clock;
      }
      function createIntervalTick(clock, delta) {
        const intervalTick = doIntervalTick.bind(null, clock, delta);
        const intervalId = originalSetInterval(intervalTick, delta);
        clock.attachedInterval = intervalId;
      }
      function install(config) {
        if (arguments.length > 1 || config instanceof Date || Array.isArray(config) || typeof config === "number") {
          throw new TypeError(
            `FakeTimers.install called with ${String(
              config
            )} install requires an object parameter`
          );
        }
        if (_global.Date.isFake === true) {
          throw new TypeError(
            "Can't install fake timers twice on the same global object."
          );
        }
        config = typeof config !== "undefined" ? config : {};
        config.shouldAdvanceTime = config.shouldAdvanceTime || false;
        config.advanceTimeDelta = config.advanceTimeDelta || 20;
        config.shouldClearNativeTimers = config.shouldClearNativeTimers || false;
        if (config.target) {
          throw new TypeError(
            "config.target is no longer supported. Use `withGlobal(target)` instead."
          );
        }
        function handleMissingTimer(timer) {
          if (config.ignoreMissingTimers) {
            return;
          }
          throw new ReferenceError(
            `non-existent timers and/or objects cannot be faked: '${timer}'`
          );
        }
        let i, l;
        const clock = createClock(config.now, config.loopLimit);
        clock.shouldClearNativeTimers = config.shouldClearNativeTimers;
        clock.uninstall = function() {
          return uninstall(clock);
        };
        clock.abortListenerMap = /* @__PURE__ */ new Map();
        clock.methods = config.toFake || [];
        if (clock.methods.length === 0) {
          clock.methods = Object.keys(timers);
        }
        if (config.shouldAdvanceTime === true) {
          clock.setTickMode({
            mode: "interval",
            delta: config.advanceTimeDelta
          });
        }
        if (clock.methods.includes("performance")) {
          const proto = (() => {
            if (hasPerformanceConstructorPrototype) {
              return _global.performance.constructor.prototype;
            }
            if (hasPerformancePrototype) {
              return _global.Performance.prototype;
            }
          })();
          if (proto) {
            Object.getOwnPropertyNames(proto).forEach(function(name) {
              if (name !== "now") {
                clock.performance[name] = name.indexOf("getEntries") === 0 ? NOOP_ARRAY : NOOP;
              }
            });
            clock.performance.mark = (name) => new FakePerformanceEntry(name, "mark", 0, 0);
            clock.performance.measure = (name) => new FakePerformanceEntry(name, "measure", 0, 100);
            clock.performance.timeOrigin = getEpoch(config.now);
          } else if ((config.toFake || []).includes("performance")) {
            return handleMissingTimer("performance");
          }
        }
        if (_global === globalObject && timersModule) {
          clock.timersModuleMethods = [];
        }
        if (_global === globalObject && timersPromisesModule) {
          clock.timersPromisesModuleMethods = [];
        }
        for (i = 0, l = clock.methods.length; i < l; i++) {
          const nameOfMethodToReplace = clock.methods[i];
          if (!isPresent[nameOfMethodToReplace]) {
            handleMissingTimer(nameOfMethodToReplace);
            continue;
          }
          if (nameOfMethodToReplace === "hrtime") {
            if (_global.process && typeof _global.process.hrtime === "function") {
              hijackMethod(_global.process, nameOfMethodToReplace, clock);
            }
          } else if (nameOfMethodToReplace === "nextTick") {
            if (_global.process && typeof _global.process.nextTick === "function") {
              hijackMethod(_global.process, nameOfMethodToReplace, clock);
            }
          } else {
            hijackMethod(_global, nameOfMethodToReplace, clock);
          }
          if (clock.timersModuleMethods !== void 0 && timersModule[nameOfMethodToReplace]) {
            const original = timersModule[nameOfMethodToReplace];
            clock.timersModuleMethods.push({
              methodName: nameOfMethodToReplace,
              original
            });
            timersModule[nameOfMethodToReplace] = _global[nameOfMethodToReplace];
          }
          if (clock.timersPromisesModuleMethods !== void 0) {
            if (nameOfMethodToReplace === "setTimeout") {
              clock.timersPromisesModuleMethods.push({
                methodName: "setTimeout",
                original: timersPromisesModule.setTimeout
              });
              timersPromisesModule.setTimeout = (delay, value, options = {}) => new Promise((resolve, reject) => {
                const abort = () => {
                  options.signal.removeEventListener(
                    "abort",
                    abort
                  );
                  clock.abortListenerMap.delete(abort);
                  clock.clearTimeout(handle);
                  reject(options.signal.reason);
                };
                const handle = clock.setTimeout(() => {
                  if (options.signal) {
                    options.signal.removeEventListener(
                      "abort",
                      abort
                    );
                    clock.abortListenerMap.delete(abort);
                  }
                  resolve(value);
                }, delay);
                if (options.signal) {
                  if (options.signal.aborted) {
                    abort();
                  } else {
                    options.signal.addEventListener(
                      "abort",
                      abort
                    );
                    clock.abortListenerMap.set(
                      abort,
                      options.signal
                    );
                  }
                }
              });
            } else if (nameOfMethodToReplace === "setImmediate") {
              clock.timersPromisesModuleMethods.push({
                methodName: "setImmediate",
                original: timersPromisesModule.setImmediate
              });
              timersPromisesModule.setImmediate = (value, options = {}) => new Promise((resolve, reject) => {
                const abort = () => {
                  options.signal.removeEventListener(
                    "abort",
                    abort
                  );
                  clock.abortListenerMap.delete(abort);
                  clock.clearImmediate(handle);
                  reject(options.signal.reason);
                };
                const handle = clock.setImmediate(() => {
                  if (options.signal) {
                    options.signal.removeEventListener(
                      "abort",
                      abort
                    );
                    clock.abortListenerMap.delete(abort);
                  }
                  resolve(value);
                });
                if (options.signal) {
                  if (options.signal.aborted) {
                    abort();
                  } else {
                    options.signal.addEventListener(
                      "abort",
                      abort
                    );
                    clock.abortListenerMap.set(
                      abort,
                      options.signal
                    );
                  }
                }
              });
            } else if (nameOfMethodToReplace === "setInterval") {
              clock.timersPromisesModuleMethods.push({
                methodName: "setInterval",
                original: timersPromisesModule.setInterval
              });
              timersPromisesModule.setInterval = (delay, value, options = {}) => ({
                [Symbol.asyncIterator]: () => {
                  const createResolvable = () => {
                    let resolve, reject;
                    const promise = new Promise((res, rej) => {
                      resolve = res;
                      reject = rej;
                    });
                    promise.resolve = resolve;
                    promise.reject = reject;
                    return promise;
                  };
                  let done = false;
                  let hasThrown = false;
                  let returnCall;
                  let nextAvailable = 0;
                  const nextQueue = [];
                  const handle = clock.setInterval(() => {
                    if (nextQueue.length > 0) {
                      nextQueue.shift().resolve();
                    } else {
                      nextAvailable++;
                    }
                  }, delay);
                  const abort = () => {
                    options.signal.removeEventListener(
                      "abort",
                      abort
                    );
                    clock.abortListenerMap.delete(abort);
                    clock.clearInterval(handle);
                    done = true;
                    for (const resolvable of nextQueue) {
                      resolvable.resolve();
                    }
                  };
                  if (options.signal) {
                    if (options.signal.aborted) {
                      done = true;
                    } else {
                      options.signal.addEventListener(
                        "abort",
                        abort
                      );
                      clock.abortListenerMap.set(
                        abort,
                        options.signal
                      );
                    }
                  }
                  return {
                    next: async () => {
                      if (options.signal?.aborted && !hasThrown) {
                        hasThrown = true;
                        throw options.signal.reason;
                      }
                      if (done) {
                        return { done: true, value: void 0 };
                      }
                      if (nextAvailable > 0) {
                        nextAvailable--;
                        return { done: false, value };
                      }
                      const resolvable = createResolvable();
                      nextQueue.push(resolvable);
                      await resolvable;
                      if (returnCall && nextQueue.length === 0) {
                        returnCall.resolve();
                      }
                      if (options.signal?.aborted && !hasThrown) {
                        hasThrown = true;
                        throw options.signal.reason;
                      }
                      if (done) {
                        return { done: true, value: void 0 };
                      }
                      return { done: false, value };
                    },
                    return: async () => {
                      if (done) {
                        return { done: true, value: void 0 };
                      }
                      if (nextQueue.length > 0) {
                        returnCall = createResolvable();
                        await returnCall;
                      }
                      clock.clearInterval(handle);
                      done = true;
                      if (options.signal) {
                        options.signal.removeEventListener(
                          "abort",
                          abort
                        );
                        clock.abortListenerMap.delete(abort);
                      }
                      return { done: true, value: void 0 };
                    }
                  };
                }
              });
            }
          }
        }
        return clock;
      }
      return {
        timers,
        createClock,
        install,
        withGlobal
      };
    }
    var defaultImplementation = withGlobal(globalObject);
    exports2.timers = defaultImplementation.timers;
    exports2.createClock = defaultImplementation.createClock;
    exports2.install = defaultImplementation.install;
    exports2.withGlobal = withGlobal;
  }
});

// lib/sinon/util/fake-timers.js
var require_fake_timers = __commonJS({
  "lib/sinon/util/fake-timers.js"(exports2) {
    "use strict";
    var extend = require_extend();
    var FakeTimers = require_fake_timers_src();
    var globalObject = require_lib().global;
    function createClock(config, globalCtx) {
      let FakeTimersCtx = FakeTimers;
      if (globalCtx !== null && typeof globalCtx === "object") {
        FakeTimersCtx = FakeTimers.withGlobal(globalCtx);
      }
      const clock = FakeTimersCtx.install(config);
      clock.restore = clock.uninstall;
      return clock;
    }
    function addIfDefined(obj, globalPropName) {
      const globalProp = globalObject[globalPropName];
      if (typeof globalProp !== "undefined") {
        obj[globalPropName] = globalProp;
      }
    }
    exports2.useFakeTimers = function(dateOrConfig) {
      const hasArguments = typeof dateOrConfig !== "undefined";
      const argumentIsDateLike = (typeof dateOrConfig === "number" || dateOrConfig instanceof Date) && arguments.length === 1;
      const argumentIsObject = dateOrConfig !== null && typeof dateOrConfig === "object" && arguments.length === 1;
      if (!hasArguments) {
        return createClock({
          now: 0
        });
      }
      if (argumentIsDateLike) {
        return createClock({
          now: dateOrConfig
        });
      }
      if (argumentIsObject) {
        const config = extend.nonEnum({}, dateOrConfig);
        const globalCtx = config.global;
        delete config.global;
        return createClock(config, globalCtx);
      }
      throw new TypeError(
        "useFakeTimers expected epoch or config object. See https://github.com/sinonjs/sinon"
      );
    };
    exports2.clock = {
      create: function(now) {
        return FakeTimers.createClock(now);
      }
    };
    var timers = {
      setTimeout,
      clearTimeout,
      setInterval,
      clearInterval,
      Date
    };
    addIfDefined(timers, "setImmediate");
    addIfDefined(timers, "clearImmediate");
    exports2.timers = timers;
  }
});

// lib/sinon/proxy-call-util.js
var require_proxy_call_util = __commonJS({
  "lib/sinon/proxy-call-util.js"(exports2) {
    "use strict";
    var push = require_lib().prototypes.array.push;
    exports2.incrementCallCount = function incrementCallCount(proxy) {
      proxy.called = true;
      proxy.callCount += 1;
      proxy.notCalled = false;
      proxy.calledOnce = proxy.callCount === 1;
      proxy.calledTwice = proxy.callCount === 2;
      proxy.calledThrice = proxy.callCount === 3;
    };
    exports2.createCallProperties = function createCallProperties(proxy) {
      proxy.firstCall = proxy.getCall(0);
      proxy.secondCall = proxy.getCall(1);
      proxy.thirdCall = proxy.getCall(2);
      proxy.lastCall = proxy.getCall(proxy.callCount - 1);
    };
    exports2.delegateToCalls = function delegateToCalls(proxy, method, matchAny, actual, returnsValues, notCalled, totalCallCount) {
      proxy[method] = function() {
        if (!this.called) {
          if (notCalled) {
            return notCalled.apply(this, arguments);
          }
          return false;
        }
        if (totalCallCount !== void 0 && this.callCount !== totalCallCount) {
          return false;
        }
        let currentCall;
        let matches = 0;
        const returnValues = [];
        for (let i = 0, l = this.callCount; i < l; i += 1) {
          currentCall = this.getCall(i);
          const returnValue = currentCall[actual || method].apply(
            currentCall,
            arguments
          );
          push(returnValues, returnValue);
          if (returnValue) {
            matches += 1;
            if (matchAny) {
              return true;
            }
          }
        }
        if (returnsValues) {
          return returnValues;
        }
        return matches === this.callCount;
      };
    };
  }
});

// lib/sinon/proxy-invoke.js
var require_proxy_invoke = __commonJS({
  "lib/sinon/proxy-invoke.js"(exports2, module2) {
    "use strict";
    var arrayProto = require_lib().prototypes.array;
    var proxyCallUtil = require_proxy_call_util();
    var push = arrayProto.push;
    var forEach = arrayProto.forEach;
    var concat = arrayProto.concat;
    var ErrorConstructor = Error.prototype.constructor;
    var bind = Function.prototype.bind;
    var callId = 0;
    module2.exports = function invoke(func, thisValue, args) {
      const matchings = this.matchingFakes(args);
      const currentCallId = callId++;
      let exception, returnValue;
      proxyCallUtil.incrementCallCount(this);
      push(this.thisValues, thisValue);
      push(this.args, args);
      push(this.callIds, currentCallId);
      forEach(matchings, function(matching) {
        proxyCallUtil.incrementCallCount(matching);
        push(matching.thisValues, thisValue);
        push(matching.args, args);
        push(matching.callIds, currentCallId);
      });
      proxyCallUtil.createCallProperties(this);
      forEach(matchings, proxyCallUtil.createCallProperties);
      try {
        this.invoking = true;
        const thisCall = this.getCall(this.callCount - 1);
        if (thisCall.calledWithNew()) {
          returnValue = new (bind.apply(
            this.func || func,
            concat([thisValue], args)
          ))();
          if (typeof returnValue !== "object" && typeof returnValue !== "function") {
            returnValue = thisValue;
          }
        } else {
          returnValue = (this.func || func).apply(thisValue, args);
        }
      } catch (e) {
        exception = e;
      } finally {
        delete this.invoking;
      }
      push(this.exceptions, exception);
      push(this.returnValues, returnValue);
      forEach(matchings, function(matching) {
        push(matching.exceptions, exception);
        push(matching.returnValues, returnValue);
      });
      const err = new ErrorConstructor();
      try {
        throw err;
      } catch (e) {
      }
      push(this.errorsWithCallStack, err);
      forEach(matchings, function(matching) {
        push(matching.errorsWithCallStack, err);
      });
      proxyCallUtil.createCallProperties(this);
      forEach(matchings, proxyCallUtil.createCallProperties);
      if (exception !== void 0) {
        throw exception;
      }
      return returnValue;
    };
  }
});

// lib/sinon/proxy-call.js
var require_proxy_call = __commonJS({
  "lib/sinon/proxy-call.js"(exports2, module2) {
    "use strict";
    var arrayProto = require_lib().prototypes.array;
    var match = require_samsam().createMatcher;
    var deepEqual = require_samsam().deepEqual;
    var functionName = require_lib().functionName;
    var inspect = require_util().inspect;
    var valueToString = require_lib().valueToString;
    var concat = arrayProto.concat;
    var filter = arrayProto.filter;
    var join = arrayProto.join;
    var map = arrayProto.map;
    var reduce = arrayProto.reduce;
    var slice = arrayProto.slice;
    function throwYieldError(proxy, text, args) {
      let msg = functionName(proxy) + text;
      if (args.length) {
        msg += ` Received [${join(slice(args), ", ")}]`;
      }
      throw new Error(msg);
    }
    var callProto = {
      calledOn: function calledOn(thisValue) {
        if (match.isMatcher(thisValue)) {
          return thisValue.test(this.thisValue);
        }
        return this.thisValue === thisValue;
      },
      calledWith: function calledWith() {
        const self2 = this;
        const calledWithArgs = slice(arguments);
        if (calledWithArgs.length > self2.args.length) {
          return false;
        }
        return reduce(
          calledWithArgs,
          function(prev, arg, i) {
            return prev && deepEqual(self2.args[i], arg);
          },
          true
        );
      },
      calledWithMatch: function calledWithMatch() {
        const self2 = this;
        const calledWithMatchArgs = slice(arguments);
        if (calledWithMatchArgs.length > self2.args.length) {
          return false;
        }
        return reduce(
          calledWithMatchArgs,
          function(prev, expectation, i) {
            const actual = self2.args[i];
            return prev && match(expectation).test(actual);
          },
          true
        );
      },
      calledWithExactly: function calledWithExactly() {
        return arguments.length === this.args.length && this.calledWith.apply(this, arguments);
      },
      notCalledWith: function notCalledWith() {
        return !this.calledWith.apply(this, arguments);
      },
      notCalledWithMatch: function notCalledWithMatch() {
        return !this.calledWithMatch.apply(this, arguments);
      },
      returned: function returned(value) {
        return deepEqual(this.returnValue, value);
      },
      threw: function threw(error) {
        if (typeof error === "undefined" || !this.exception) {
          return Boolean(this.exception);
        }
        return this.exception === error || this.exception.name === error;
      },
      calledWithNew: function calledWithNew() {
        return this.proxy.prototype && this.thisValue instanceof this.proxy;
      },
      calledBefore: function(other) {
        return this.callId < other.callId;
      },
      calledAfter: function(other) {
        return this.callId > other.callId;
      },
      calledImmediatelyBefore: function(other) {
        return this.callId === other.callId - 1;
      },
      calledImmediatelyAfter: function(other) {
        return this.callId === other.callId + 1;
      },
      callArg: function(pos) {
        this.ensureArgIsAFunction(pos);
        return this.args[pos]();
      },
      callArgOn: function(pos, thisValue) {
        this.ensureArgIsAFunction(pos);
        return this.args[pos].apply(thisValue);
      },
      callArgWith: function(pos) {
        return this.callArgOnWith.apply(
          this,
          concat([pos, null], slice(arguments, 1))
        );
      },
      callArgOnWith: function(pos, thisValue) {
        this.ensureArgIsAFunction(pos);
        const args = slice(arguments, 2);
        return this.args[pos].apply(thisValue, args);
      },
      throwArg: function(pos) {
        if (pos > this.args.length) {
          throw new TypeError(
            `Not enough arguments: ${pos} required but only ${this.args.length} present`
          );
        }
        throw this.args[pos];
      },
      yield: function() {
        return this.yieldOn.apply(this, concat([null], slice(arguments, 0)));
      },
      yieldOn: function(thisValue) {
        const args = slice(this.args);
        const yieldFn = filter(args, function(arg) {
          return typeof arg === "function";
        })[0];
        if (!yieldFn) {
          throwYieldError(
            this.proxy,
            " cannot yield since no callback was passed.",
            args
          );
        }
        return yieldFn.apply(thisValue, slice(arguments, 1));
      },
      yieldTo: function(prop) {
        return this.yieldToOn.apply(
          this,
          concat([prop, null], slice(arguments, 1))
        );
      },
      yieldToOn: function(prop, thisValue) {
        const args = slice(this.args);
        const yieldArg = filter(args, function(arg) {
          return arg && typeof arg[prop] === "function";
        })[0];
        const yieldFn = yieldArg && yieldArg[prop];
        if (!yieldFn) {
          throwYieldError(
            this.proxy,
            ` cannot yield to '${valueToString(
              prop
            )}' since no callback was passed.`,
            args
          );
        }
        return yieldFn.apply(thisValue, slice(arguments, 2));
      },
      toString: function() {
        if (!this.args) {
          return ":(";
        }
        let callStr = this.proxy ? `${String(this.proxy)}(` : "";
        const formattedArgs = map(this.args, function(arg) {
          return inspect(arg);
        });
        callStr = `${callStr + join(formattedArgs, ", ")})`;
        if (typeof this.returnValue !== "undefined") {
          callStr += ` => ${inspect(this.returnValue)}`;
        }
        if (this.exception) {
          callStr += ` !${this.exception.name}`;
          if (this.exception.message) {
            callStr += `(${this.exception.message})`;
          }
        }
        if (this.stack) {
          callStr += (this.stack.split("\n")[3] || "unknown").replace(
            /^\s*(?:at\s+|@)?/,
            " at "
          );
        }
        return callStr;
      },
      ensureArgIsAFunction: function(pos) {
        if (typeof this.args[pos] !== "function") {
          throw new TypeError(
            `Expected argument at position ${pos} to be a Function, but was ${typeof this.args[pos]}`
          );
        }
      }
    };
    Object.defineProperty(callProto, "stack", {
      enumerable: true,
      configurable: true,
      get: function() {
        return this.errorWithCallStack && this.errorWithCallStack.stack || "";
      }
    });
    callProto.invokeCallback = callProto.yield;
    function createProxyCall(proxy, thisValue, args, returnValue, exception, id, errorWithCallStack) {
      if (typeof id !== "number") {
        throw new TypeError("Call id is not a number");
      }
      let firstArg, lastArg;
      if (args.length > 0) {
        firstArg = args[0];
        lastArg = args[args.length - 1];
      }
      const proxyCall = Object.create(callProto);
      const callback = lastArg && typeof lastArg === "function" ? lastArg : void 0;
      proxyCall.proxy = proxy;
      proxyCall.thisValue = thisValue;
      proxyCall.args = args;
      proxyCall.firstArg = firstArg;
      proxyCall.lastArg = lastArg;
      proxyCall.callback = callback;
      proxyCall.returnValue = returnValue;
      proxyCall.exception = exception;
      proxyCall.callId = id;
      proxyCall.errorWithCallStack = errorWithCallStack;
      return proxyCall;
    }
    createProxyCall.toString = callProto.toString;
    module2.exports = createProxyCall;
  }
});

// lib/sinon/default-behaviors.js
var require_default_behaviors = __commonJS({
  "lib/sinon/default-behaviors.js"(exports2, module2) {
    "use strict";
    var arrayProto = require_lib().prototypes.array;
    var isPropertyConfigurable = require_is_property_configurable();
    var exportAsyncBehaviors = require_export_async_behaviors();
    var extend = require_extend();
    var slice = arrayProto.slice;
    var useLeftMostCallback = -1;
    var useRightMostCallback = -2;
    function throwsException(fake, error, message) {
      if (typeof error === "function") {
        fake.exceptionCreator = error;
      } else if (typeof error === "string") {
        fake.exceptionCreator = function() {
          const newException = new Error(
            message || `Sinon-provided ${error}`
          );
          newException.name = error;
          return newException;
        };
      } else if (!error) {
        fake.exceptionCreator = function() {
          return new Error("Error");
        };
      } else {
        fake.exception = error;
      }
    }
    var defaultBehaviors = {
      callsFake: function callsFake(fake, fn) {
        fake.fakeFn = fn;
        fake.exception = void 0;
        fake.exceptionCreator = void 0;
        fake.callsThrough = false;
      },
      callsArg: function callsArg(fake, index) {
        if (typeof index !== "number") {
          throw new TypeError("argument index is not number");
        }
        fake.callArgAt = index;
        fake.callbackArguments = [];
        fake.callbackContext = void 0;
        fake.callArgProp = void 0;
        fake.callbackAsync = false;
        fake.callsThrough = false;
      },
      callsArgOn: function callsArgOn(fake, index, context) {
        if (typeof index !== "number") {
          throw new TypeError("argument index is not number");
        }
        fake.callArgAt = index;
        fake.callbackArguments = [];
        fake.callbackContext = context;
        fake.callArgProp = void 0;
        fake.callbackAsync = false;
        fake.callsThrough = false;
      },
      callsArgWith: function callsArgWith(fake, index) {
        if (typeof index !== "number") {
          throw new TypeError("argument index is not number");
        }
        fake.callArgAt = index;
        fake.callbackArguments = slice(arguments, 2);
        fake.callbackContext = void 0;
        fake.callArgProp = void 0;
        fake.callbackAsync = false;
        fake.callsThrough = false;
      },
      callsArgOnWith: function callsArgWith(fake, index, context) {
        if (typeof index !== "number") {
          throw new TypeError("argument index is not number");
        }
        fake.callArgAt = index;
        fake.callbackArguments = slice(arguments, 3);
        fake.callbackContext = context;
        fake.callArgProp = void 0;
        fake.callbackAsync = false;
        fake.callsThrough = false;
      },
      yields: function(fake) {
        fake.callArgAt = useLeftMostCallback;
        fake.callbackArguments = slice(arguments, 1);
        fake.callbackContext = void 0;
        fake.callArgProp = void 0;
        fake.callbackAsync = false;
        fake.fakeFn = void 0;
        fake.callsThrough = false;
      },
      yieldsRight: function(fake) {
        fake.callArgAt = useRightMostCallback;
        fake.callbackArguments = slice(arguments, 1);
        fake.callbackContext = void 0;
        fake.callArgProp = void 0;
        fake.callbackAsync = false;
        fake.callsThrough = false;
        fake.fakeFn = void 0;
      },
      yieldsOn: function(fake, context) {
        fake.callArgAt = useLeftMostCallback;
        fake.callbackArguments = slice(arguments, 2);
        fake.callbackContext = context;
        fake.callArgProp = void 0;
        fake.callbackAsync = false;
        fake.callsThrough = false;
        fake.fakeFn = void 0;
      },
      yieldsTo: function(fake, prop) {
        fake.callArgAt = useLeftMostCallback;
        fake.callbackArguments = slice(arguments, 2);
        fake.callbackContext = void 0;
        fake.callArgProp = prop;
        fake.callbackAsync = false;
        fake.callsThrough = false;
        fake.fakeFn = void 0;
      },
      yieldsToOn: function(fake, prop, context) {
        fake.callArgAt = useLeftMostCallback;
        fake.callbackArguments = slice(arguments, 3);
        fake.callbackContext = context;
        fake.callArgProp = prop;
        fake.callbackAsync = false;
        fake.fakeFn = void 0;
      },
      throws: throwsException,
      throwsException,
      returns: function returns(fake, value) {
        fake.callsThrough = false;
        fake.returnValue = value;
        fake.resolve = false;
        fake.reject = false;
        fake.returnValueDefined = true;
        fake.exception = void 0;
        fake.exceptionCreator = void 0;
        fake.fakeFn = void 0;
      },
      returnsArg: function returnsArg(fake, index) {
        if (typeof index !== "number") {
          throw new TypeError("argument index is not number");
        }
        fake.callsThrough = false;
        fake.returnArgAt = index;
      },
      throwsArg: function throwsArg(fake, index) {
        if (typeof index !== "number") {
          throw new TypeError("argument index is not number");
        }
        fake.callsThrough = false;
        fake.throwArgAt = index;
      },
      returnsThis: function returnsThis(fake) {
        fake.returnThis = true;
        fake.callsThrough = false;
      },
      resolves: function resolves(fake, value) {
        fake.returnValue = value;
        fake.resolve = true;
        fake.resolveThis = false;
        fake.reject = false;
        fake.returnValueDefined = true;
        fake.exception = void 0;
        fake.exceptionCreator = void 0;
        fake.fakeFn = void 0;
        fake.callsThrough = false;
      },
      resolvesArg: function resolvesArg(fake, index) {
        if (typeof index !== "number") {
          throw new TypeError("argument index is not number");
        }
        fake.resolveArgAt = index;
        fake.returnValue = void 0;
        fake.resolve = true;
        fake.resolveThis = false;
        fake.reject = false;
        fake.returnValueDefined = false;
        fake.exception = void 0;
        fake.exceptionCreator = void 0;
        fake.fakeFn = void 0;
        fake.callsThrough = false;
      },
      rejects: function rejects(fake, error, message) {
        let reason;
        if (typeof error === "string") {
          reason = new Error(message || "");
          reason.name = error;
        } else if (!error) {
          reason = new Error("Error");
        } else {
          reason = error;
        }
        fake.returnValue = reason;
        fake.resolve = false;
        fake.resolveThis = false;
        fake.reject = true;
        fake.returnValueDefined = true;
        fake.exception = void 0;
        fake.exceptionCreator = void 0;
        fake.fakeFn = void 0;
        fake.callsThrough = false;
        return fake;
      },
      resolvesThis: function resolvesThis(fake) {
        fake.returnValue = void 0;
        fake.resolve = false;
        fake.resolveThis = true;
        fake.reject = false;
        fake.returnValueDefined = false;
        fake.exception = void 0;
        fake.exceptionCreator = void 0;
        fake.fakeFn = void 0;
        fake.callsThrough = false;
      },
      callThrough: function callThrough(fake) {
        fake.callsThrough = true;
      },
      callThroughWithNew: function callThroughWithNew(fake) {
        fake.callsThroughWithNew = true;
      },
      get: function get(fake, getterFunction) {
        const rootStub = fake.stub || fake;
        Object.defineProperty(rootStub.rootObj, rootStub.propName, {
          get: getterFunction,
          configurable: isPropertyConfigurable(
            rootStub.rootObj,
            rootStub.propName
          )
        });
        return fake;
      },
      set: function set(fake, setterFunction) {
        const rootStub = fake.stub || fake;
        Object.defineProperty(
          rootStub.rootObj,
          rootStub.propName,
          // eslint-disable-next-line accessor-pairs
          {
            set: setterFunction,
            configurable: isPropertyConfigurable(
              rootStub.rootObj,
              rootStub.propName
            )
          }
        );
        return fake;
      },
      value: function value(fake, newVal) {
        const rootStub = fake.stub || fake;
        Object.defineProperty(rootStub.rootObj, rootStub.propName, {
          value: newVal,
          enumerable: true,
          writable: true,
          configurable: rootStub.shadowsPropOnPrototype || isPropertyConfigurable(rootStub.rootObj, rootStub.propName)
        });
        return fake;
      }
    };
    var asyncBehaviors = exportAsyncBehaviors(defaultBehaviors);
    module2.exports = extend({}, defaultBehaviors, asyncBehaviors);
  }
});

// lib/sinon/util/core/function-to-string.js
var require_function_to_string = __commonJS({
  "lib/sinon/util/core/function-to-string.js"(exports2, module2) {
    "use strict";
    module2.exports = function toString() {
      let i, prop, thisValue;
      if (this.getCall && this.callCount) {
        i = this.callCount;
        while (i--) {
          thisValue = this.getCall(i).thisValue;
          for (prop in thisValue) {
            try {
              if (thisValue[prop] === this) {
                return prop;
              }
            } catch (e) {
            }
          }
        }
      }
      return this.displayName || "sinon fake";
    };
  }
});

// node_modules/supports-color/browser.js
var require_browser = __commonJS({
  "node_modules/supports-color/browser.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      stdout: false,
      stderr: false
    };
  }
});

// lib/sinon/colorizer.js
var require_colorizer = __commonJS({
  "lib/sinon/colorizer.js"(exports2, module2) {
    "use strict";
    module2.exports = class Colorizer {
      constructor(supportsColor = require_browser()) {
        this.supportsColor = supportsColor;
      }
      /**
       * Should be renamed to true #privateField
       * when we can ensure ES2022 support
       *
       * @private
       */
      colorize(str, color) {
        if (this.supportsColor.stdout === false) {
          return str;
        }
        return `\x1B[${color}m${str}\x1B[0m`;
      }
      red(str) {
        return this.colorize(str, 31);
      }
      green(str) {
        return this.colorize(str, 32);
      }
      cyan(str) {
        return this.colorize(str, 96);
      }
      white(str) {
        return this.colorize(str, 39);
      }
      bold(str) {
        return this.colorize(str, 1);
      }
    };
  }
});

// node_modules/diff/libcjs/diff/base.js
var require_base = __commonJS({
  "node_modules/diff/libcjs/diff/base.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var Diff = (
      /** @class */
      (function() {
        function Diff2() {
        }
        Diff2.prototype.diff = function(oldStr, newStr, options) {
          if (options === void 0) {
            options = {};
          }
          var callback;
          if (typeof options === "function") {
            callback = options;
            options = {};
          } else if ("callback" in options) {
            callback = options.callback;
          }
          var oldString = this.castInput(oldStr, options);
          var newString = this.castInput(newStr, options);
          var oldTokens = this.removeEmpty(this.tokenize(oldString, options));
          var newTokens = this.removeEmpty(this.tokenize(newString, options));
          return this.diffWithOptionsObj(oldTokens, newTokens, options, callback);
        };
        Diff2.prototype.diffWithOptionsObj = function(oldTokens, newTokens, options, callback) {
          var _this = this;
          var _a;
          var done = function(value) {
            value = _this.postProcess(value, options);
            if (callback) {
              setTimeout(function() {
                callback(value);
              }, 0);
              return void 0;
            } else {
              return value;
            }
          };
          var newLen = newTokens.length, oldLen = oldTokens.length;
          var editLength = 1;
          var maxEditLength = newLen + oldLen;
          if (options.maxEditLength != null) {
            maxEditLength = Math.min(maxEditLength, options.maxEditLength);
          }
          var maxExecutionTime = (_a = options.timeout) !== null && _a !== void 0 ? _a : Infinity;
          var abortAfterTimestamp = Date.now() + maxExecutionTime;
          var bestPath = [{ oldPos: -1, lastComponent: void 0 }];
          var newPos = this.extractCommon(bestPath[0], newTokens, oldTokens, 0, options);
          if (bestPath[0].oldPos + 1 >= oldLen && newPos + 1 >= newLen) {
            return done(this.buildValues(bestPath[0].lastComponent, newTokens, oldTokens));
          }
          var minDiagonalToConsider = -Infinity, maxDiagonalToConsider = Infinity;
          var execEditLength = function() {
            for (var diagonalPath = Math.max(minDiagonalToConsider, -editLength); diagonalPath <= Math.min(maxDiagonalToConsider, editLength); diagonalPath += 2) {
              var basePath = void 0;
              var removePath = bestPath[diagonalPath - 1], addPath = bestPath[diagonalPath + 1];
              if (removePath) {
                bestPath[diagonalPath - 1] = void 0;
              }
              var canAdd = false;
              if (addPath) {
                var addPathNewPos = addPath.oldPos - diagonalPath;
                canAdd = addPath && 0 <= addPathNewPos && addPathNewPos < newLen;
              }
              var canRemove = removePath && removePath.oldPos + 1 < oldLen;
              if (!canAdd && !canRemove) {
                bestPath[diagonalPath] = void 0;
                continue;
              }
              if (!canRemove || canAdd && removePath.oldPos < addPath.oldPos) {
                basePath = _this.addToPath(addPath, true, false, 0, options);
              } else {
                basePath = _this.addToPath(removePath, false, true, 1, options);
              }
              newPos = _this.extractCommon(basePath, newTokens, oldTokens, diagonalPath, options);
              if (basePath.oldPos + 1 >= oldLen && newPos + 1 >= newLen) {
                return done(_this.buildValues(basePath.lastComponent, newTokens, oldTokens)) || true;
              } else {
                bestPath[diagonalPath] = basePath;
                if (basePath.oldPos + 1 >= oldLen) {
                  maxDiagonalToConsider = Math.min(maxDiagonalToConsider, diagonalPath - 1);
                }
                if (newPos + 1 >= newLen) {
                  minDiagonalToConsider = Math.max(minDiagonalToConsider, diagonalPath + 1);
                }
              }
            }
            editLength++;
          };
          if (callback) {
            (function exec() {
              setTimeout(function() {
                if (editLength > maxEditLength || Date.now() > abortAfterTimestamp) {
                  return callback(void 0);
                }
                if (!execEditLength()) {
                  exec();
                }
              }, 0);
            })();
          } else {
            while (editLength <= maxEditLength && Date.now() <= abortAfterTimestamp) {
              var ret = execEditLength();
              if (ret) {
                return ret;
              }
            }
          }
        };
        Diff2.prototype.addToPath = function(path, added, removed, oldPosInc, options) {
          var last = path.lastComponent;
          if (last && !options.oneChangePerToken && last.added === added && last.removed === removed) {
            return {
              oldPos: path.oldPos + oldPosInc,
              lastComponent: { count: last.count + 1, added, removed, previousComponent: last.previousComponent }
            };
          } else {
            return {
              oldPos: path.oldPos + oldPosInc,
              lastComponent: { count: 1, added, removed, previousComponent: last }
            };
          }
        };
        Diff2.prototype.extractCommon = function(basePath, newTokens, oldTokens, diagonalPath, options) {
          var newLen = newTokens.length, oldLen = oldTokens.length;
          var oldPos = basePath.oldPos, newPos = oldPos - diagonalPath, commonCount = 0;
          while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(oldTokens[oldPos + 1], newTokens[newPos + 1], options)) {
            newPos++;
            oldPos++;
            commonCount++;
            if (options.oneChangePerToken) {
              basePath.lastComponent = { count: 1, previousComponent: basePath.lastComponent, added: false, removed: false };
            }
          }
          if (commonCount && !options.oneChangePerToken) {
            basePath.lastComponent = { count: commonCount, previousComponent: basePath.lastComponent, added: false, removed: false };
          }
          basePath.oldPos = oldPos;
          return newPos;
        };
        Diff2.prototype.equals = function(left, right, options) {
          if (options.comparator) {
            return options.comparator(left, right);
          } else {
            return left === right || !!options.ignoreCase && left.toLowerCase() === right.toLowerCase();
          }
        };
        Diff2.prototype.removeEmpty = function(array) {
          var ret = [];
          for (var i = 0; i < array.length; i++) {
            if (array[i]) {
              ret.push(array[i]);
            }
          }
          return ret;
        };
        Diff2.prototype.castInput = function(value, options) {
          return value;
        };
        Diff2.prototype.tokenize = function(value, options) {
          return Array.from(value);
        };
        Diff2.prototype.join = function(chars) {
          return chars.join("");
        };
        Diff2.prototype.postProcess = function(changeObjects, options) {
          return changeObjects;
        };
        Object.defineProperty(Diff2.prototype, "useLongestToken", {
          get: function() {
            return false;
          },
          enumerable: false,
          configurable: true
        });
        Diff2.prototype.buildValues = function(lastComponent, newTokens, oldTokens) {
          var components = [];
          var nextComponent;
          while (lastComponent) {
            components.push(lastComponent);
            nextComponent = lastComponent.previousComponent;
            delete lastComponent.previousComponent;
            lastComponent = nextComponent;
          }
          components.reverse();
          var componentLen = components.length;
          var componentPos = 0, newPos = 0, oldPos = 0;
          for (; componentPos < componentLen; componentPos++) {
            var component = components[componentPos];
            if (!component.removed) {
              if (!component.added && this.useLongestToken) {
                var value = newTokens.slice(newPos, newPos + component.count);
                value = value.map(function(value2, i) {
                  var oldValue = oldTokens[oldPos + i];
                  return oldValue.length > value2.length ? oldValue : value2;
                });
                component.value = this.join(value);
              } else {
                component.value = this.join(newTokens.slice(newPos, newPos + component.count));
              }
              newPos += component.count;
              if (!component.added) {
                oldPos += component.count;
              }
            } else {
              component.value = this.join(oldTokens.slice(oldPos, oldPos + component.count));
              oldPos += component.count;
            }
          }
          return components;
        };
        return Diff2;
      })()
    );
    exports2.default = Diff;
  }
});

// node_modules/diff/libcjs/diff/character.js
var require_character = __commonJS({
  "node_modules/diff/libcjs/diff/character.js"(exports2) {
    "use strict";
    var __extends = exports2 && exports2.__extends || /* @__PURE__ */ (function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    })();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.characterDiff = void 0;
    exports2.diffChars = diffChars;
    var base_js_1 = require_base();
    var CharacterDiff = (
      /** @class */
      (function(_super) {
        __extends(CharacterDiff2, _super);
        function CharacterDiff2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        return CharacterDiff2;
      })(base_js_1.default)
    );
    exports2.characterDiff = new CharacterDiff();
    function diffChars(oldStr, newStr, options) {
      return exports2.characterDiff.diff(oldStr, newStr, options);
    }
  }
});

// node_modules/diff/libcjs/util/string.js
var require_string2 = __commonJS({
  "node_modules/diff/libcjs/util/string.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.longestCommonPrefix = longestCommonPrefix;
    exports2.longestCommonSuffix = longestCommonSuffix;
    exports2.replacePrefix = replacePrefix;
    exports2.replaceSuffix = replaceSuffix;
    exports2.removePrefix = removePrefix;
    exports2.removeSuffix = removeSuffix;
    exports2.maximumOverlap = maximumOverlap;
    exports2.hasOnlyWinLineEndings = hasOnlyWinLineEndings;
    exports2.hasOnlyUnixLineEndings = hasOnlyUnixLineEndings;
    exports2.trailingWs = trailingWs;
    exports2.leadingWs = leadingWs;
    function longestCommonPrefix(str1, str2) {
      var i;
      for (i = 0; i < str1.length && i < str2.length; i++) {
        if (str1[i] != str2[i]) {
          return str1.slice(0, i);
        }
      }
      return str1.slice(0, i);
    }
    function longestCommonSuffix(str1, str2) {
      var i;
      if (!str1 || !str2 || str1[str1.length - 1] != str2[str2.length - 1]) {
        return "";
      }
      for (i = 0; i < str1.length && i < str2.length; i++) {
        if (str1[str1.length - (i + 1)] != str2[str2.length - (i + 1)]) {
          return str1.slice(-i);
        }
      }
      return str1.slice(-i);
    }
    function replacePrefix(string, oldPrefix, newPrefix) {
      if (string.slice(0, oldPrefix.length) != oldPrefix) {
        throw Error("string ".concat(JSON.stringify(string), " doesn't start with prefix ").concat(JSON.stringify(oldPrefix), "; this is a bug"));
      }
      return newPrefix + string.slice(oldPrefix.length);
    }
    function replaceSuffix(string, oldSuffix, newSuffix) {
      if (!oldSuffix) {
        return string + newSuffix;
      }
      if (string.slice(-oldSuffix.length) != oldSuffix) {
        throw Error("string ".concat(JSON.stringify(string), " doesn't end with suffix ").concat(JSON.stringify(oldSuffix), "; this is a bug"));
      }
      return string.slice(0, -oldSuffix.length) + newSuffix;
    }
    function removePrefix(string, oldPrefix) {
      return replacePrefix(string, oldPrefix, "");
    }
    function removeSuffix(string, oldSuffix) {
      return replaceSuffix(string, oldSuffix, "");
    }
    function maximumOverlap(string1, string2) {
      return string2.slice(0, overlapCount(string1, string2));
    }
    function overlapCount(a, b) {
      var startA = 0;
      if (a.length > b.length) {
        startA = a.length - b.length;
      }
      var endB = b.length;
      if (a.length < b.length) {
        endB = a.length;
      }
      var map = Array(endB);
      var k = 0;
      map[0] = 0;
      for (var j = 1; j < endB; j++) {
        if (b[j] == b[k]) {
          map[j] = map[k];
        } else {
          map[j] = k;
        }
        while (k > 0 && b[j] != b[k]) {
          k = map[k];
        }
        if (b[j] == b[k]) {
          k++;
        }
      }
      k = 0;
      for (var i = startA; i < a.length; i++) {
        while (k > 0 && a[i] != b[k]) {
          k = map[k];
        }
        if (a[i] == b[k]) {
          k++;
        }
      }
      return k;
    }
    function hasOnlyWinLineEndings(string) {
      return string.includes("\r\n") && !string.startsWith("\n") && !string.match(/[^\r]\n/);
    }
    function hasOnlyUnixLineEndings(string) {
      return !string.includes("\r\n") && string.includes("\n");
    }
    function trailingWs(string) {
      var i;
      for (i = string.length - 1; i >= 0; i--) {
        if (!string[i].match(/\s/)) {
          break;
        }
      }
      return string.substring(i + 1);
    }
    function leadingWs(string) {
      var match = string.match(/^\s*/);
      return match ? match[0] : "";
    }
  }
});

// node_modules/diff/libcjs/diff/word.js
var require_word = __commonJS({
  "node_modules/diff/libcjs/diff/word.js"(exports2) {
    "use strict";
    var __extends = exports2 && exports2.__extends || /* @__PURE__ */ (function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    })();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.wordsWithSpaceDiff = exports2.wordDiff = void 0;
    exports2.diffWords = diffWords;
    exports2.diffWordsWithSpace = diffWordsWithSpace;
    var base_js_1 = require_base();
    var string_js_1 = require_string2();
    var extendedWordChars = "a-zA-Z0-9_\\u{C0}-\\u{FF}\\u{D8}-\\u{F6}\\u{F8}-\\u{2C6}\\u{2C8}-\\u{2D7}\\u{2DE}-\\u{2FF}\\u{1E00}-\\u{1EFF}";
    var tokenizeIncludingWhitespace = new RegExp("[".concat(extendedWordChars, "]+|\\s+|[^").concat(extendedWordChars, "]"), "ug");
    var WordDiff = (
      /** @class */
      (function(_super) {
        __extends(WordDiff2, _super);
        function WordDiff2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        WordDiff2.prototype.equals = function(left, right, options) {
          if (options.ignoreCase) {
            left = left.toLowerCase();
            right = right.toLowerCase();
          }
          return left.trim() === right.trim();
        };
        WordDiff2.prototype.tokenize = function(value, options) {
          if (options === void 0) {
            options = {};
          }
          var parts;
          if (options.intlSegmenter) {
            var segmenter = options.intlSegmenter;
            if (segmenter.resolvedOptions().granularity != "word") {
              throw new Error('The segmenter passed must have a granularity of "word"');
            }
            parts = Array.from(segmenter.segment(value), function(segment) {
              return segment.segment;
            });
          } else {
            parts = value.match(tokenizeIncludingWhitespace) || [];
          }
          var tokens = [];
          var prevPart = null;
          parts.forEach(function(part) {
            if (/\s/.test(part)) {
              if (prevPart == null) {
                tokens.push(part);
              } else {
                tokens.push(tokens.pop() + part);
              }
            } else if (prevPart != null && /\s/.test(prevPart)) {
              if (tokens[tokens.length - 1] == prevPart) {
                tokens.push(tokens.pop() + part);
              } else {
                tokens.push(prevPart + part);
              }
            } else {
              tokens.push(part);
            }
            prevPart = part;
          });
          return tokens;
        };
        WordDiff2.prototype.join = function(tokens) {
          return tokens.map(function(token, i) {
            if (i == 0) {
              return token;
            } else {
              return token.replace(/^\s+/, "");
            }
          }).join("");
        };
        WordDiff2.prototype.postProcess = function(changes, options) {
          if (!changes || options.oneChangePerToken) {
            return changes;
          }
          var lastKeep = null;
          var insertion = null;
          var deletion = null;
          changes.forEach(function(change) {
            if (change.added) {
              insertion = change;
            } else if (change.removed) {
              deletion = change;
            } else {
              if (insertion || deletion) {
                dedupeWhitespaceInChangeObjects(lastKeep, deletion, insertion, change);
              }
              lastKeep = change;
              insertion = null;
              deletion = null;
            }
          });
          if (insertion || deletion) {
            dedupeWhitespaceInChangeObjects(lastKeep, deletion, insertion, null);
          }
          return changes;
        };
        return WordDiff2;
      })(base_js_1.default)
    );
    exports2.wordDiff = new WordDiff();
    function diffWords(oldStr, newStr, options) {
      if ((options === null || options === void 0 ? void 0 : options.ignoreWhitespace) != null && !options.ignoreWhitespace) {
        return diffWordsWithSpace(oldStr, newStr, options);
      }
      return exports2.wordDiff.diff(oldStr, newStr, options);
    }
    function dedupeWhitespaceInChangeObjects(startKeep, deletion, insertion, endKeep) {
      if (deletion && insertion) {
        var oldWsPrefix = (0, string_js_1.leadingWs)(deletion.value);
        var oldWsSuffix = (0, string_js_1.trailingWs)(deletion.value);
        var newWsPrefix = (0, string_js_1.leadingWs)(insertion.value);
        var newWsSuffix = (0, string_js_1.trailingWs)(insertion.value);
        if (startKeep) {
          var commonWsPrefix = (0, string_js_1.longestCommonPrefix)(oldWsPrefix, newWsPrefix);
          startKeep.value = (0, string_js_1.replaceSuffix)(startKeep.value, newWsPrefix, commonWsPrefix);
          deletion.value = (0, string_js_1.removePrefix)(deletion.value, commonWsPrefix);
          insertion.value = (0, string_js_1.removePrefix)(insertion.value, commonWsPrefix);
        }
        if (endKeep) {
          var commonWsSuffix = (0, string_js_1.longestCommonSuffix)(oldWsSuffix, newWsSuffix);
          endKeep.value = (0, string_js_1.replacePrefix)(endKeep.value, newWsSuffix, commonWsSuffix);
          deletion.value = (0, string_js_1.removeSuffix)(deletion.value, commonWsSuffix);
          insertion.value = (0, string_js_1.removeSuffix)(insertion.value, commonWsSuffix);
        }
      } else if (insertion) {
        if (startKeep) {
          var ws = (0, string_js_1.leadingWs)(insertion.value);
          insertion.value = insertion.value.substring(ws.length);
        }
        if (endKeep) {
          var ws = (0, string_js_1.leadingWs)(endKeep.value);
          endKeep.value = endKeep.value.substring(ws.length);
        }
      } else if (startKeep && endKeep) {
        var newWsFull = (0, string_js_1.leadingWs)(endKeep.value), delWsStart = (0, string_js_1.leadingWs)(deletion.value), delWsEnd = (0, string_js_1.trailingWs)(deletion.value);
        var newWsStart = (0, string_js_1.longestCommonPrefix)(newWsFull, delWsStart);
        deletion.value = (0, string_js_1.removePrefix)(deletion.value, newWsStart);
        var newWsEnd = (0, string_js_1.longestCommonSuffix)((0, string_js_1.removePrefix)(newWsFull, newWsStart), delWsEnd);
        deletion.value = (0, string_js_1.removeSuffix)(deletion.value, newWsEnd);
        endKeep.value = (0, string_js_1.replacePrefix)(endKeep.value, newWsFull, newWsEnd);
        startKeep.value = (0, string_js_1.replaceSuffix)(startKeep.value, newWsFull, newWsFull.slice(0, newWsFull.length - newWsEnd.length));
      } else if (endKeep) {
        var endKeepWsPrefix = (0, string_js_1.leadingWs)(endKeep.value);
        var deletionWsSuffix = (0, string_js_1.trailingWs)(deletion.value);
        var overlap = (0, string_js_1.maximumOverlap)(deletionWsSuffix, endKeepWsPrefix);
        deletion.value = (0, string_js_1.removeSuffix)(deletion.value, overlap);
      } else if (startKeep) {
        var startKeepWsSuffix = (0, string_js_1.trailingWs)(startKeep.value);
        var deletionWsPrefix = (0, string_js_1.leadingWs)(deletion.value);
        var overlap = (0, string_js_1.maximumOverlap)(startKeepWsSuffix, deletionWsPrefix);
        deletion.value = (0, string_js_1.removePrefix)(deletion.value, overlap);
      }
    }
    var WordsWithSpaceDiff = (
      /** @class */
      (function(_super) {
        __extends(WordsWithSpaceDiff2, _super);
        function WordsWithSpaceDiff2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        WordsWithSpaceDiff2.prototype.tokenize = function(value) {
          var regex = new RegExp("(\\r?\\n)|[".concat(extendedWordChars, "]+|[^\\S\\n\\r]+|[^").concat(extendedWordChars, "]"), "ug");
          return value.match(regex) || [];
        };
        return WordsWithSpaceDiff2;
      })(base_js_1.default)
    );
    exports2.wordsWithSpaceDiff = new WordsWithSpaceDiff();
    function diffWordsWithSpace(oldStr, newStr, options) {
      return exports2.wordsWithSpaceDiff.diff(oldStr, newStr, options);
    }
  }
});

// node_modules/diff/libcjs/util/params.js
var require_params = __commonJS({
  "node_modules/diff/libcjs/util/params.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.generateOptions = generateOptions;
    function generateOptions(options, defaults) {
      if (typeof options === "function") {
        defaults.callback = options;
      } else if (options) {
        for (var name in options) {
          if (Object.prototype.hasOwnProperty.call(options, name)) {
            defaults[name] = options[name];
          }
        }
      }
      return defaults;
    }
  }
});

// node_modules/diff/libcjs/diff/line.js
var require_line = __commonJS({
  "node_modules/diff/libcjs/diff/line.js"(exports2) {
    "use strict";
    var __extends = exports2 && exports2.__extends || /* @__PURE__ */ (function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    })();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.lineDiff = void 0;
    exports2.diffLines = diffLines;
    exports2.diffTrimmedLines = diffTrimmedLines;
    exports2.tokenize = tokenize;
    var base_js_1 = require_base();
    var params_js_1 = require_params();
    var LineDiff = (
      /** @class */
      (function(_super) {
        __extends(LineDiff2, _super);
        function LineDiff2() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this.tokenize = tokenize;
          return _this;
        }
        LineDiff2.prototype.equals = function(left, right, options) {
          if (options.ignoreWhitespace) {
            if (!options.newlineIsToken || !left.includes("\n")) {
              left = left.trim();
            }
            if (!options.newlineIsToken || !right.includes("\n")) {
              right = right.trim();
            }
          } else if (options.ignoreNewlineAtEof && !options.newlineIsToken) {
            if (left.endsWith("\n")) {
              left = left.slice(0, -1);
            }
            if (right.endsWith("\n")) {
              right = right.slice(0, -1);
            }
          }
          return _super.prototype.equals.call(this, left, right, options);
        };
        return LineDiff2;
      })(base_js_1.default)
    );
    exports2.lineDiff = new LineDiff();
    function diffLines(oldStr, newStr, options) {
      return exports2.lineDiff.diff(oldStr, newStr, options);
    }
    function diffTrimmedLines(oldStr, newStr, options) {
      options = (0, params_js_1.generateOptions)(options, { ignoreWhitespace: true });
      return exports2.lineDiff.diff(oldStr, newStr, options);
    }
    function tokenize(value, options) {
      if (options.stripTrailingCr) {
        value = value.replace(/\r\n/g, "\n");
      }
      var retLines = [], linesAndNewlines = value.split(/(\n|\r\n)/);
      if (!linesAndNewlines[linesAndNewlines.length - 1]) {
        linesAndNewlines.pop();
      }
      for (var i = 0; i < linesAndNewlines.length; i++) {
        var line = linesAndNewlines[i];
        if (i % 2 && !options.newlineIsToken) {
          retLines[retLines.length - 1] += line;
        } else {
          retLines.push(line);
        }
      }
      return retLines;
    }
  }
});

// node_modules/diff/libcjs/diff/sentence.js
var require_sentence = __commonJS({
  "node_modules/diff/libcjs/diff/sentence.js"(exports2) {
    "use strict";
    var __extends = exports2 && exports2.__extends || /* @__PURE__ */ (function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    })();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.sentenceDiff = void 0;
    exports2.diffSentences = diffSentences;
    var base_js_1 = require_base();
    function isSentenceEndPunct(char) {
      return char == "." || char == "!" || char == "?";
    }
    var SentenceDiff = (
      /** @class */
      (function(_super) {
        __extends(SentenceDiff2, _super);
        function SentenceDiff2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        SentenceDiff2.prototype.tokenize = function(value) {
          var _a;
          var result = [];
          var tokenStartI = 0;
          for (var i = 0; i < value.length; i++) {
            if (i == value.length - 1) {
              result.push(value.slice(tokenStartI));
              break;
            }
            if (isSentenceEndPunct(value[i]) && value[i + 1].match(/\s/)) {
              result.push(value.slice(tokenStartI, i + 1));
              i = tokenStartI = i + 1;
              while ((_a = value[i + 1]) === null || _a === void 0 ? void 0 : _a.match(/\s/)) {
                i++;
              }
              result.push(value.slice(tokenStartI, i + 1));
              tokenStartI = i + 1;
            }
          }
          return result;
        };
        return SentenceDiff2;
      })(base_js_1.default)
    );
    exports2.sentenceDiff = new SentenceDiff();
    function diffSentences(oldStr, newStr, options) {
      return exports2.sentenceDiff.diff(oldStr, newStr, options);
    }
  }
});

// node_modules/diff/libcjs/diff/css.js
var require_css = __commonJS({
  "node_modules/diff/libcjs/diff/css.js"(exports2) {
    "use strict";
    var __extends = exports2 && exports2.__extends || /* @__PURE__ */ (function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    })();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.cssDiff = void 0;
    exports2.diffCss = diffCss;
    var base_js_1 = require_base();
    var CssDiff = (
      /** @class */
      (function(_super) {
        __extends(CssDiff2, _super);
        function CssDiff2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        CssDiff2.prototype.tokenize = function(value) {
          return value.split(/([{}:;,]|\s+)/);
        };
        return CssDiff2;
      })(base_js_1.default)
    );
    exports2.cssDiff = new CssDiff();
    function diffCss(oldStr, newStr, options) {
      return exports2.cssDiff.diff(oldStr, newStr, options);
    }
  }
});

// node_modules/diff/libcjs/diff/json.js
var require_json = __commonJS({
  "node_modules/diff/libcjs/diff/json.js"(exports2) {
    "use strict";
    var __extends = exports2 && exports2.__extends || /* @__PURE__ */ (function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    })();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.jsonDiff = void 0;
    exports2.diffJson = diffJson;
    exports2.canonicalize = canonicalize;
    var base_js_1 = require_base();
    var line_js_1 = require_line();
    var JsonDiff = (
      /** @class */
      (function(_super) {
        __extends(JsonDiff2, _super);
        function JsonDiff2() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this.tokenize = line_js_1.tokenize;
          return _this;
        }
        Object.defineProperty(JsonDiff2.prototype, "useLongestToken", {
          get: function() {
            return true;
          },
          enumerable: false,
          configurable: true
        });
        JsonDiff2.prototype.castInput = function(value, options) {
          var undefinedReplacement = options.undefinedReplacement, _a = options.stringifyReplacer, stringifyReplacer = _a === void 0 ? function(k, v) {
            return typeof v === "undefined" ? undefinedReplacement : v;
          } : _a;
          return typeof value === "string" ? value : JSON.stringify(canonicalize(value, null, null, stringifyReplacer), null, "  ");
        };
        JsonDiff2.prototype.equals = function(left, right, options) {
          return _super.prototype.equals.call(this, left.replace(/,([\r\n])/g, "$1"), right.replace(/,([\r\n])/g, "$1"), options);
        };
        return JsonDiff2;
      })(base_js_1.default)
    );
    exports2.jsonDiff = new JsonDiff();
    function diffJson(oldStr, newStr, options) {
      return exports2.jsonDiff.diff(oldStr, newStr, options);
    }
    function canonicalize(obj, stack, replacementStack, replacer, key) {
      stack = stack || [];
      replacementStack = replacementStack || [];
      if (replacer) {
        obj = replacer(key === void 0 ? "" : key, obj);
      }
      var i;
      for (i = 0; i < stack.length; i += 1) {
        if (stack[i] === obj) {
          return replacementStack[i];
        }
      }
      var canonicalizedObj;
      if ("[object Array]" === Object.prototype.toString.call(obj)) {
        stack.push(obj);
        canonicalizedObj = new Array(obj.length);
        replacementStack.push(canonicalizedObj);
        for (i = 0; i < obj.length; i += 1) {
          canonicalizedObj[i] = canonicalize(obj[i], stack, replacementStack, replacer, String(i));
        }
        stack.pop();
        replacementStack.pop();
        return canonicalizedObj;
      }
      if (obj && obj.toJSON) {
        obj = obj.toJSON();
      }
      if (typeof obj === "object" && obj !== null) {
        stack.push(obj);
        canonicalizedObj = {};
        replacementStack.push(canonicalizedObj);
        var sortedKeys = [];
        var key_1;
        for (key_1 in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key_1)) {
            sortedKeys.push(key_1);
          }
        }
        sortedKeys.sort();
        for (i = 0; i < sortedKeys.length; i += 1) {
          key_1 = sortedKeys[i];
          canonicalizedObj[key_1] = canonicalize(obj[key_1], stack, replacementStack, replacer, key_1);
        }
        stack.pop();
        replacementStack.pop();
      } else {
        canonicalizedObj = obj;
      }
      return canonicalizedObj;
    }
  }
});

// node_modules/diff/libcjs/diff/array.js
var require_array2 = __commonJS({
  "node_modules/diff/libcjs/diff/array.js"(exports2) {
    "use strict";
    var __extends = exports2 && exports2.__extends || /* @__PURE__ */ (function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    })();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.arrayDiff = void 0;
    exports2.diffArrays = diffArrays;
    var base_js_1 = require_base();
    var ArrayDiff = (
      /** @class */
      (function(_super) {
        __extends(ArrayDiff2, _super);
        function ArrayDiff2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        ArrayDiff2.prototype.tokenize = function(value) {
          return value.slice();
        };
        ArrayDiff2.prototype.join = function(value) {
          return value;
        };
        ArrayDiff2.prototype.removeEmpty = function(value) {
          return value;
        };
        return ArrayDiff2;
      })(base_js_1.default)
    );
    exports2.arrayDiff = new ArrayDiff();
    function diffArrays(oldArr, newArr, options) {
      return exports2.arrayDiff.diff(oldArr, newArr, options);
    }
  }
});

// node_modules/diff/libcjs/patch/line-endings.js
var require_line_endings = __commonJS({
  "node_modules/diff/libcjs/patch/line-endings.js"(exports2) {
    "use strict";
    var __assign = exports2 && exports2.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.unixToWin = unixToWin;
    exports2.winToUnix = winToUnix;
    exports2.isUnix = isUnix;
    exports2.isWin = isWin;
    function unixToWin(patch) {
      if (Array.isArray(patch)) {
        return patch.map(function(p) {
          return unixToWin(p);
        });
      }
      return __assign(__assign({}, patch), { hunks: patch.hunks.map(function(hunk) {
        return __assign(__assign({}, hunk), { lines: hunk.lines.map(function(line, i) {
          var _a;
          return line.startsWith("\\") || line.endsWith("\r") || ((_a = hunk.lines[i + 1]) === null || _a === void 0 ? void 0 : _a.startsWith("\\")) ? line : line + "\r";
        }) });
      }) });
    }
    function winToUnix(patch) {
      if (Array.isArray(patch)) {
        return patch.map(function(p) {
          return winToUnix(p);
        });
      }
      return __assign(__assign({}, patch), { hunks: patch.hunks.map(function(hunk) {
        return __assign(__assign({}, hunk), { lines: hunk.lines.map(function(line) {
          return line.endsWith("\r") ? line.substring(0, line.length - 1) : line;
        }) });
      }) });
    }
    function isUnix(patch) {
      if (!Array.isArray(patch)) {
        patch = [patch];
      }
      return !patch.some(function(index) {
        return index.hunks.some(function(hunk) {
          return hunk.lines.some(function(line) {
            return !line.startsWith("\\") && line.endsWith("\r");
          });
        });
      });
    }
    function isWin(patch) {
      if (!Array.isArray(patch)) {
        patch = [patch];
      }
      return patch.some(function(index) {
        return index.hunks.some(function(hunk) {
          return hunk.lines.some(function(line) {
            return line.endsWith("\r");
          });
        });
      }) && patch.every(function(index) {
        return index.hunks.every(function(hunk) {
          return hunk.lines.every(function(line, i) {
            var _a;
            return line.startsWith("\\") || line.endsWith("\r") || ((_a = hunk.lines[i + 1]) === null || _a === void 0 ? void 0 : _a.startsWith("\\"));
          });
        });
      });
    }
  }
});

// node_modules/diff/libcjs/patch/parse.js
var require_parse = __commonJS({
  "node_modules/diff/libcjs/patch/parse.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parsePatch = parsePatch;
    function parsePatch(uniDiff) {
      var diffstr = uniDiff.split(/\n/), list = [];
      var i = 0;
      function parseIndex() {
        var index = {};
        list.push(index);
        while (i < diffstr.length) {
          var line = diffstr[i];
          if (/^(---|\+\+\+|@@)\s/.test(line)) {
            break;
          }
          var header = /^(?:Index:|diff(?: -r \w+)+)\s+(.+?)\s*$/.exec(line);
          if (header) {
            index.index = header[1];
          }
          i++;
        }
        parseFileHeader(index);
        parseFileHeader(index);
        index.hunks = [];
        while (i < diffstr.length) {
          var line = diffstr[i];
          if (/^(Index:\s|diff\s|---\s|\+\+\+\s|===================================================================)/.test(line)) {
            break;
          } else if (/^@@/.test(line)) {
            index.hunks.push(parseHunk());
          } else if (line) {
            throw new Error("Unknown line " + (i + 1) + " " + JSON.stringify(line));
          } else {
            i++;
          }
        }
      }
      function parseFileHeader(index) {
        var fileHeader = /^(---|\+\+\+)\s+(.*)\r?$/.exec(diffstr[i]);
        if (fileHeader) {
          var data = fileHeader[2].split("	", 2), header = (data[1] || "").trim();
          var fileName = data[0].replace(/\\\\/g, "\\");
          if (/^".*"$/.test(fileName)) {
            fileName = fileName.substr(1, fileName.length - 2);
          }
          if (fileHeader[1] === "---") {
            index.oldFileName = fileName;
            index.oldHeader = header;
          } else {
            index.newFileName = fileName;
            index.newHeader = header;
          }
          i++;
        }
      }
      function parseHunk() {
        var _a;
        var chunkHeaderIndex = i, chunkHeaderLine = diffstr[i++], chunkHeader = chunkHeaderLine.split(/@@ -(\d+)(?:,(\d+))? \+(\d+)(?:,(\d+))? @@/);
        var hunk = {
          oldStart: +chunkHeader[1],
          oldLines: typeof chunkHeader[2] === "undefined" ? 1 : +chunkHeader[2],
          newStart: +chunkHeader[3],
          newLines: typeof chunkHeader[4] === "undefined" ? 1 : +chunkHeader[4],
          lines: []
        };
        if (hunk.oldLines === 0) {
          hunk.oldStart += 1;
        }
        if (hunk.newLines === 0) {
          hunk.newStart += 1;
        }
        var addCount = 0, removeCount = 0;
        for (; i < diffstr.length && (removeCount < hunk.oldLines || addCount < hunk.newLines || ((_a = diffstr[i]) === null || _a === void 0 ? void 0 : _a.startsWith("\\"))); i++) {
          var operation = diffstr[i].length == 0 && i != diffstr.length - 1 ? " " : diffstr[i][0];
          if (operation === "+" || operation === "-" || operation === " " || operation === "\\") {
            hunk.lines.push(diffstr[i]);
            if (operation === "+") {
              addCount++;
            } else if (operation === "-") {
              removeCount++;
            } else if (operation === " ") {
              addCount++;
              removeCount++;
            }
          } else {
            throw new Error("Hunk at line ".concat(chunkHeaderIndex + 1, " contained invalid line ").concat(diffstr[i]));
          }
        }
        if (!addCount && hunk.newLines === 1) {
          hunk.newLines = 0;
        }
        if (!removeCount && hunk.oldLines === 1) {
          hunk.oldLines = 0;
        }
        if (addCount !== hunk.newLines) {
          throw new Error("Added line count did not match for hunk at line " + (chunkHeaderIndex + 1));
        }
        if (removeCount !== hunk.oldLines) {
          throw new Error("Removed line count did not match for hunk at line " + (chunkHeaderIndex + 1));
        }
        return hunk;
      }
      while (i < diffstr.length) {
        parseIndex();
      }
      return list;
    }
  }
});

// node_modules/diff/libcjs/util/distance-iterator.js
var require_distance_iterator = __commonJS({
  "node_modules/diff/libcjs/util/distance-iterator.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = default_1;
    function default_1(start, minLine, maxLine) {
      var wantForward = true, backwardExhausted = false, forwardExhausted = false, localOffset = 1;
      return function iterator() {
        if (wantForward && !forwardExhausted) {
          if (backwardExhausted) {
            localOffset++;
          } else {
            wantForward = false;
          }
          if (start + localOffset <= maxLine) {
            return start + localOffset;
          }
          forwardExhausted = true;
        }
        if (!backwardExhausted) {
          if (!forwardExhausted) {
            wantForward = true;
          }
          if (minLine <= start - localOffset) {
            return start - localOffset++;
          }
          backwardExhausted = true;
          return iterator();
        }
        return void 0;
      };
    }
  }
});

// node_modules/diff/libcjs/patch/apply.js
var require_apply = __commonJS({
  "node_modules/diff/libcjs/patch/apply.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.applyPatch = applyPatch;
    exports2.applyPatches = applyPatches;
    var string_js_1 = require_string2();
    var line_endings_js_1 = require_line_endings();
    var parse_js_1 = require_parse();
    var distance_iterator_js_1 = require_distance_iterator();
    function applyPatch(source, patch, options) {
      if (options === void 0) {
        options = {};
      }
      var patches;
      if (typeof patch === "string") {
        patches = (0, parse_js_1.parsePatch)(patch);
      } else if (Array.isArray(patch)) {
        patches = patch;
      } else {
        patches = [patch];
      }
      if (patches.length > 1) {
        throw new Error("applyPatch only works with a single input.");
      }
      return applyStructuredPatch(source, patches[0], options);
    }
    function applyStructuredPatch(source, patch, options) {
      if (options === void 0) {
        options = {};
      }
      if (options.autoConvertLineEndings || options.autoConvertLineEndings == null) {
        if ((0, string_js_1.hasOnlyWinLineEndings)(source) && (0, line_endings_js_1.isUnix)(patch)) {
          patch = (0, line_endings_js_1.unixToWin)(patch);
        } else if ((0, string_js_1.hasOnlyUnixLineEndings)(source) && (0, line_endings_js_1.isWin)(patch)) {
          patch = (0, line_endings_js_1.winToUnix)(patch);
        }
      }
      var lines = source.split("\n"), hunks = patch.hunks, compareLine = options.compareLine || (function(lineNumber, line2, operation, patchContent) {
        return line2 === patchContent;
      }), fuzzFactor = options.fuzzFactor || 0;
      var minLine = 0;
      if (fuzzFactor < 0 || !Number.isInteger(fuzzFactor)) {
        throw new Error("fuzzFactor must be a non-negative integer");
      }
      if (!hunks.length) {
        return source;
      }
      var prevLine = "", removeEOFNL = false, addEOFNL = false;
      for (var i = 0; i < hunks[hunks.length - 1].lines.length; i++) {
        var line = hunks[hunks.length - 1].lines[i];
        if (line[0] == "\\") {
          if (prevLine[0] == "+") {
            removeEOFNL = true;
          } else if (prevLine[0] == "-") {
            addEOFNL = true;
          }
        }
        prevLine = line;
      }
      if (removeEOFNL) {
        if (addEOFNL) {
          if (!fuzzFactor && lines[lines.length - 1] == "") {
            return false;
          }
        } else if (lines[lines.length - 1] == "") {
          lines.pop();
        } else if (!fuzzFactor) {
          return false;
        }
      } else if (addEOFNL) {
        if (lines[lines.length - 1] != "") {
          lines.push("");
        } else if (!fuzzFactor) {
          return false;
        }
      }
      function applyHunk(hunkLines, toPos2, maxErrors2, hunkLinesI, lastContextLineMatched, patchedLines, patchedLinesLength) {
        if (hunkLinesI === void 0) {
          hunkLinesI = 0;
        }
        if (lastContextLineMatched === void 0) {
          lastContextLineMatched = true;
        }
        if (patchedLines === void 0) {
          patchedLines = [];
        }
        if (patchedLinesLength === void 0) {
          patchedLinesLength = 0;
        }
        var nConsecutiveOldContextLines = 0;
        var nextContextLineMustMatch = false;
        for (; hunkLinesI < hunkLines.length; hunkLinesI++) {
          var hunkLine = hunkLines[hunkLinesI], operation = hunkLine.length > 0 ? hunkLine[0] : " ", content = hunkLine.length > 0 ? hunkLine.substr(1) : hunkLine;
          if (operation === "-") {
            if (compareLine(toPos2 + 1, lines[toPos2], operation, content)) {
              toPos2++;
              nConsecutiveOldContextLines = 0;
            } else {
              if (!maxErrors2 || lines[toPos2] == null) {
                return null;
              }
              patchedLines[patchedLinesLength] = lines[toPos2];
              return applyHunk(hunkLines, toPos2 + 1, maxErrors2 - 1, hunkLinesI, false, patchedLines, patchedLinesLength + 1);
            }
          }
          if (operation === "+") {
            if (!lastContextLineMatched) {
              return null;
            }
            patchedLines[patchedLinesLength] = content;
            patchedLinesLength++;
            nConsecutiveOldContextLines = 0;
            nextContextLineMustMatch = true;
          }
          if (operation === " ") {
            nConsecutiveOldContextLines++;
            patchedLines[patchedLinesLength] = lines[toPos2];
            if (compareLine(toPos2 + 1, lines[toPos2], operation, content)) {
              patchedLinesLength++;
              lastContextLineMatched = true;
              nextContextLineMustMatch = false;
              toPos2++;
            } else {
              if (nextContextLineMustMatch || !maxErrors2) {
                return null;
              }
              return lines[toPos2] && (applyHunk(hunkLines, toPos2 + 1, maxErrors2 - 1, hunkLinesI + 1, false, patchedLines, patchedLinesLength + 1) || applyHunk(hunkLines, toPos2 + 1, maxErrors2 - 1, hunkLinesI, false, patchedLines, patchedLinesLength + 1)) || applyHunk(hunkLines, toPos2, maxErrors2 - 1, hunkLinesI + 1, false, patchedLines, patchedLinesLength);
            }
          }
        }
        patchedLinesLength -= nConsecutiveOldContextLines;
        toPos2 -= nConsecutiveOldContextLines;
        patchedLines.length = patchedLinesLength;
        return {
          patchedLines,
          oldLineLastI: toPos2 - 1
        };
      }
      var resultLines = [];
      var prevHunkOffset = 0;
      for (var i = 0; i < hunks.length; i++) {
        var hunk = hunks[i];
        var hunkResult = void 0;
        var maxLine = lines.length - hunk.oldLines + fuzzFactor;
        var toPos = void 0;
        for (var maxErrors = 0; maxErrors <= fuzzFactor; maxErrors++) {
          toPos = hunk.oldStart + prevHunkOffset - 1;
          var iterator = (0, distance_iterator_js_1.default)(toPos, minLine, maxLine);
          for (; toPos !== void 0; toPos = iterator()) {
            hunkResult = applyHunk(hunk.lines, toPos, maxErrors);
            if (hunkResult) {
              break;
            }
          }
          if (hunkResult) {
            break;
          }
        }
        if (!hunkResult) {
          return false;
        }
        for (var i_1 = minLine; i_1 < toPos; i_1++) {
          resultLines.push(lines[i_1]);
        }
        for (var i_2 = 0; i_2 < hunkResult.patchedLines.length; i_2++) {
          var line = hunkResult.patchedLines[i_2];
          resultLines.push(line);
        }
        minLine = hunkResult.oldLineLastI + 1;
        prevHunkOffset = toPos + 1 - hunk.oldStart;
      }
      for (var i = minLine; i < lines.length; i++) {
        resultLines.push(lines[i]);
      }
      return resultLines.join("\n");
    }
    function applyPatches(uniDiff, options) {
      var spDiff = typeof uniDiff === "string" ? (0, parse_js_1.parsePatch)(uniDiff) : uniDiff;
      var currentIndex = 0;
      function processIndex() {
        var index = spDiff[currentIndex++];
        if (!index) {
          return options.complete();
        }
        options.loadFile(index, function(err, data) {
          if (err) {
            return options.complete(err);
          }
          var updatedContent = applyPatch(data, index, options);
          options.patched(index, updatedContent, function(err2) {
            if (err2) {
              return options.complete(err2);
            }
            processIndex();
          });
        });
      }
      processIndex();
    }
  }
});

// node_modules/diff/libcjs/patch/reverse.js
var require_reverse = __commonJS({
  "node_modules/diff/libcjs/patch/reverse.js"(exports2) {
    "use strict";
    var __assign = exports2 && exports2.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.reversePatch = reversePatch;
    function reversePatch(structuredPatch) {
      if (Array.isArray(structuredPatch)) {
        return structuredPatch.map(function(patch) {
          return reversePatch(patch);
        }).reverse();
      }
      return __assign(__assign({}, structuredPatch), { oldFileName: structuredPatch.newFileName, oldHeader: structuredPatch.newHeader, newFileName: structuredPatch.oldFileName, newHeader: structuredPatch.oldHeader, hunks: structuredPatch.hunks.map(function(hunk) {
        return {
          oldLines: hunk.newLines,
          oldStart: hunk.newStart,
          newLines: hunk.oldLines,
          newStart: hunk.oldStart,
          lines: hunk.lines.map(function(l) {
            if (l.startsWith("-")) {
              return "+".concat(l.slice(1));
            }
            if (l.startsWith("+")) {
              return "-".concat(l.slice(1));
            }
            return l;
          })
        };
      }) });
    }
  }
});

// node_modules/diff/libcjs/patch/create.js
var require_create = __commonJS({
  "node_modules/diff/libcjs/patch/create.js"(exports2) {
    "use strict";
    var __assign = exports2 && exports2.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.structuredPatch = structuredPatch;
    exports2.formatPatch = formatPatch;
    exports2.createTwoFilesPatch = createTwoFilesPatch;
    exports2.createPatch = createPatch;
    var line_js_1 = require_line();
    function structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {
      var optionsObj;
      if (!options) {
        optionsObj = {};
      } else if (typeof options === "function") {
        optionsObj = { callback: options };
      } else {
        optionsObj = options;
      }
      if (typeof optionsObj.context === "undefined") {
        optionsObj.context = 4;
      }
      var context = optionsObj.context;
      if (optionsObj.newlineIsToken) {
        throw new Error("newlineIsToken may not be used with patch-generation functions, only with diffing functions");
      }
      if (!optionsObj.callback) {
        return diffLinesResultToPatch((0, line_js_1.diffLines)(oldStr, newStr, optionsObj));
      } else {
        var callback_1 = optionsObj.callback;
        (0, line_js_1.diffLines)(oldStr, newStr, __assign(__assign({}, optionsObj), { callback: function(diff) {
          var patch = diffLinesResultToPatch(diff);
          callback_1(patch);
        } }));
      }
      function diffLinesResultToPatch(diff) {
        if (!diff) {
          return;
        }
        diff.push({ value: "", lines: [] });
        function contextLines(lines2) {
          return lines2.map(function(entry) {
            return " " + entry;
          });
        }
        var hunks = [];
        var oldRangeStart = 0, newRangeStart = 0, curRange = [], oldLine = 1, newLine = 1;
        for (var i = 0; i < diff.length; i++) {
          var current = diff[i], lines = current.lines || splitLines(current.value);
          current.lines = lines;
          if (current.added || current.removed) {
            if (!oldRangeStart) {
              var prev = diff[i - 1];
              oldRangeStart = oldLine;
              newRangeStart = newLine;
              if (prev) {
                curRange = context > 0 ? contextLines(prev.lines.slice(-context)) : [];
                oldRangeStart -= curRange.length;
                newRangeStart -= curRange.length;
              }
            }
            for (var _i = 0, lines_1 = lines; _i < lines_1.length; _i++) {
              var line = lines_1[_i];
              curRange.push((current.added ? "+" : "-") + line);
            }
            if (current.added) {
              newLine += lines.length;
            } else {
              oldLine += lines.length;
            }
          } else {
            if (oldRangeStart) {
              if (lines.length <= context * 2 && i < diff.length - 2) {
                for (var _a = 0, _b = contextLines(lines); _a < _b.length; _a++) {
                  var line = _b[_a];
                  curRange.push(line);
                }
              } else {
                var contextSize = Math.min(lines.length, context);
                for (var _c = 0, _d = contextLines(lines.slice(0, contextSize)); _c < _d.length; _c++) {
                  var line = _d[_c];
                  curRange.push(line);
                }
                var hunk = {
                  oldStart: oldRangeStart,
                  oldLines: oldLine - oldRangeStart + contextSize,
                  newStart: newRangeStart,
                  newLines: newLine - newRangeStart + contextSize,
                  lines: curRange
                };
                hunks.push(hunk);
                oldRangeStart = 0;
                newRangeStart = 0;
                curRange = [];
              }
            }
            oldLine += lines.length;
            newLine += lines.length;
          }
        }
        for (var _e = 0, hunks_1 = hunks; _e < hunks_1.length; _e++) {
          var hunk = hunks_1[_e];
          for (var i = 0; i < hunk.lines.length; i++) {
            if (hunk.lines[i].endsWith("\n")) {
              hunk.lines[i] = hunk.lines[i].slice(0, -1);
            } else {
              hunk.lines.splice(i + 1, 0, "\\ No newline at end of file");
              i++;
            }
          }
        }
        return {
          oldFileName,
          newFileName,
          oldHeader,
          newHeader,
          hunks
        };
      }
    }
    function formatPatch(patch) {
      if (Array.isArray(patch)) {
        return patch.map(formatPatch).join("\n");
      }
      var ret = [];
      if (patch.oldFileName == patch.newFileName) {
        ret.push("Index: " + patch.oldFileName);
      }
      ret.push("===================================================================");
      ret.push("--- " + patch.oldFileName + (typeof patch.oldHeader === "undefined" ? "" : "	" + patch.oldHeader));
      ret.push("+++ " + patch.newFileName + (typeof patch.newHeader === "undefined" ? "" : "	" + patch.newHeader));
      for (var i = 0; i < patch.hunks.length; i++) {
        var hunk = patch.hunks[i];
        if (hunk.oldLines === 0) {
          hunk.oldStart -= 1;
        }
        if (hunk.newLines === 0) {
          hunk.newStart -= 1;
        }
        ret.push("@@ -" + hunk.oldStart + "," + hunk.oldLines + " +" + hunk.newStart + "," + hunk.newLines + " @@");
        for (var _i = 0, _a = hunk.lines; _i < _a.length; _i++) {
          var line = _a[_i];
          ret.push(line);
        }
      }
      return ret.join("\n") + "\n";
    }
    function createTwoFilesPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {
      if (typeof options === "function") {
        options = { callback: options };
      }
      if (!(options === null || options === void 0 ? void 0 : options.callback)) {
        var patchObj = structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options);
        if (!patchObj) {
          return;
        }
        return formatPatch(patchObj);
      } else {
        var callback_2 = options.callback;
        structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, __assign(__assign({}, options), { callback: function(patchObj2) {
          if (!patchObj2) {
            callback_2(void 0);
          } else {
            callback_2(formatPatch(patchObj2));
          }
        } }));
      }
    }
    function createPatch(fileName, oldStr, newStr, oldHeader, newHeader, options) {
      return createTwoFilesPatch(fileName, fileName, oldStr, newStr, oldHeader, newHeader, options);
    }
    function splitLines(text) {
      var hasTrailingNl = text.endsWith("\n");
      var result = text.split("\n").map(function(line) {
        return line + "\n";
      });
      if (hasTrailingNl) {
        result.pop();
      } else {
        result.push(result.pop().slice(0, -1));
      }
      return result;
    }
  }
});

// node_modules/diff/libcjs/convert/dmp.js
var require_dmp = __commonJS({
  "node_modules/diff/libcjs/convert/dmp.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.convertChangesToDMP = convertChangesToDMP;
    function convertChangesToDMP(changes) {
      var ret = [];
      var change, operation;
      for (var i = 0; i < changes.length; i++) {
        change = changes[i];
        if (change.added) {
          operation = 1;
        } else if (change.removed) {
          operation = -1;
        } else {
          operation = 0;
        }
        ret.push([operation, change.value]);
      }
      return ret;
    }
  }
});

// node_modules/diff/libcjs/convert/xml.js
var require_xml = __commonJS({
  "node_modules/diff/libcjs/convert/xml.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.convertChangesToXML = convertChangesToXML;
    function convertChangesToXML(changes) {
      var ret = [];
      for (var i = 0; i < changes.length; i++) {
        var change = changes[i];
        if (change.added) {
          ret.push("<ins>");
        } else if (change.removed) {
          ret.push("<del>");
        }
        ret.push(escapeHTML(change.value));
        if (change.added) {
          ret.push("</ins>");
        } else if (change.removed) {
          ret.push("</del>");
        }
      }
      return ret.join("");
    }
    function escapeHTML(s) {
      var n = s;
      n = n.replace(/&/g, "&amp;");
      n = n.replace(/</g, "&lt;");
      n = n.replace(/>/g, "&gt;");
      n = n.replace(/"/g, "&quot;");
      return n;
    }
  }
});

// node_modules/diff/libcjs/index.js
var require_libcjs = __commonJS({
  "node_modules/diff/libcjs/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.canonicalize = exports2.convertChangesToXML = exports2.convertChangesToDMP = exports2.reversePatch = exports2.parsePatch = exports2.applyPatches = exports2.applyPatch = exports2.formatPatch = exports2.createPatch = exports2.createTwoFilesPatch = exports2.structuredPatch = exports2.arrayDiff = exports2.diffArrays = exports2.jsonDiff = exports2.diffJson = exports2.cssDiff = exports2.diffCss = exports2.sentenceDiff = exports2.diffSentences = exports2.diffTrimmedLines = exports2.lineDiff = exports2.diffLines = exports2.wordsWithSpaceDiff = exports2.diffWordsWithSpace = exports2.wordDiff = exports2.diffWords = exports2.characterDiff = exports2.diffChars = exports2.Diff = void 0;
    var base_js_1 = require_base();
    exports2.Diff = base_js_1.default;
    var character_js_1 = require_character();
    Object.defineProperty(exports2, "diffChars", { enumerable: true, get: function() {
      return character_js_1.diffChars;
    } });
    Object.defineProperty(exports2, "characterDiff", { enumerable: true, get: function() {
      return character_js_1.characterDiff;
    } });
    var word_js_1 = require_word();
    Object.defineProperty(exports2, "diffWords", { enumerable: true, get: function() {
      return word_js_1.diffWords;
    } });
    Object.defineProperty(exports2, "diffWordsWithSpace", { enumerable: true, get: function() {
      return word_js_1.diffWordsWithSpace;
    } });
    Object.defineProperty(exports2, "wordDiff", { enumerable: true, get: function() {
      return word_js_1.wordDiff;
    } });
    Object.defineProperty(exports2, "wordsWithSpaceDiff", { enumerable: true, get: function() {
      return word_js_1.wordsWithSpaceDiff;
    } });
    var line_js_1 = require_line();
    Object.defineProperty(exports2, "diffLines", { enumerable: true, get: function() {
      return line_js_1.diffLines;
    } });
    Object.defineProperty(exports2, "diffTrimmedLines", { enumerable: true, get: function() {
      return line_js_1.diffTrimmedLines;
    } });
    Object.defineProperty(exports2, "lineDiff", { enumerable: true, get: function() {
      return line_js_1.lineDiff;
    } });
    var sentence_js_1 = require_sentence();
    Object.defineProperty(exports2, "diffSentences", { enumerable: true, get: function() {
      return sentence_js_1.diffSentences;
    } });
    Object.defineProperty(exports2, "sentenceDiff", { enumerable: true, get: function() {
      return sentence_js_1.sentenceDiff;
    } });
    var css_js_1 = require_css();
    Object.defineProperty(exports2, "diffCss", { enumerable: true, get: function() {
      return css_js_1.diffCss;
    } });
    Object.defineProperty(exports2, "cssDiff", { enumerable: true, get: function() {
      return css_js_1.cssDiff;
    } });
    var json_js_1 = require_json();
    Object.defineProperty(exports2, "diffJson", { enumerable: true, get: function() {
      return json_js_1.diffJson;
    } });
    Object.defineProperty(exports2, "canonicalize", { enumerable: true, get: function() {
      return json_js_1.canonicalize;
    } });
    Object.defineProperty(exports2, "jsonDiff", { enumerable: true, get: function() {
      return json_js_1.jsonDiff;
    } });
    var array_js_1 = require_array2();
    Object.defineProperty(exports2, "diffArrays", { enumerable: true, get: function() {
      return array_js_1.diffArrays;
    } });
    Object.defineProperty(exports2, "arrayDiff", { enumerable: true, get: function() {
      return array_js_1.arrayDiff;
    } });
    var apply_js_1 = require_apply();
    Object.defineProperty(exports2, "applyPatch", { enumerable: true, get: function() {
      return apply_js_1.applyPatch;
    } });
    Object.defineProperty(exports2, "applyPatches", { enumerable: true, get: function() {
      return apply_js_1.applyPatches;
    } });
    var parse_js_1 = require_parse();
    Object.defineProperty(exports2, "parsePatch", { enumerable: true, get: function() {
      return parse_js_1.parsePatch;
    } });
    var reverse_js_1 = require_reverse();
    Object.defineProperty(exports2, "reversePatch", { enumerable: true, get: function() {
      return reverse_js_1.reversePatch;
    } });
    var create_js_1 = require_create();
    Object.defineProperty(exports2, "structuredPatch", { enumerable: true, get: function() {
      return create_js_1.structuredPatch;
    } });
    Object.defineProperty(exports2, "createTwoFilesPatch", { enumerable: true, get: function() {
      return create_js_1.createTwoFilesPatch;
    } });
    Object.defineProperty(exports2, "createPatch", { enumerable: true, get: function() {
      return create_js_1.createPatch;
    } });
    Object.defineProperty(exports2, "formatPatch", { enumerable: true, get: function() {
      return create_js_1.formatPatch;
    } });
    var dmp_js_1 = require_dmp();
    Object.defineProperty(exports2, "convertChangesToDMP", { enumerable: true, get: function() {
      return dmp_js_1.convertChangesToDMP;
    } });
    var xml_js_1 = require_xml();
    Object.defineProperty(exports2, "convertChangesToXML", { enumerable: true, get: function() {
      return xml_js_1.convertChangesToXML;
    } });
  }
});

// lib/sinon/spy-formatters.js
var require_spy_formatters = __commonJS({
  "lib/sinon/spy-formatters.js"(exports2, module2) {
    "use strict";
    var arrayProto = require_lib().prototypes.array;
    var Colorizer = require_colorizer();
    var colororizer = new Colorizer();
    var match = require_samsam().createMatcher;
    var timesInWords = require_times_in_words();
    var inspect = require_util().inspect;
    var jsDiff = require_libcjs();
    var join = arrayProto.join;
    var map = arrayProto.map;
    var push = arrayProto.push;
    var slice = arrayProto.slice;
    function colorSinonMatchText(matcher, calledArg, calledArgMessage) {
      let calledArgumentMessage = calledArgMessage;
      let matcherMessage = matcher.message;
      if (!matcher.test(calledArg)) {
        matcherMessage = colororizer.red(matcher.message);
        if (calledArgumentMessage) {
          calledArgumentMessage = colororizer.green(calledArgumentMessage);
        }
      }
      return `${calledArgumentMessage} ${matcherMessage}`;
    }
    function colorDiffText(diff) {
      const objects = map(diff, function(part) {
        let text = part.value;
        if (part.added) {
          text = colororizer.green(text);
        } else if (part.removed) {
          text = colororizer.red(text);
        }
        if (diff.length === 2) {
          text += " ";
        }
        return text;
      });
      return join(objects, "");
    }
    function quoteStringValue(value) {
      if (typeof value === "string") {
        return JSON.stringify(value);
      }
      return value;
    }
    module2.exports = {
      c: function(spyInstance) {
        return timesInWords(spyInstance.callCount);
      },
      n: function(spyInstance) {
        return spyInstance.toString();
      },
      D: function(spyInstance, args) {
        let message = "";
        for (let i = 0, l = spyInstance.callCount; i < l; ++i) {
          if (l > 1) {
            message += `
Call ${i + 1}:`;
          }
          const calledArgs = spyInstance.getCall(i).args;
          const expectedArgs = slice(args);
          for (let j = 0; j < calledArgs.length || j < expectedArgs.length; ++j) {
            let calledArg = calledArgs[j];
            let expectedArg = expectedArgs[j];
            if (calledArg) {
              calledArg = quoteStringValue(calledArg);
            }
            if (expectedArg) {
              expectedArg = quoteStringValue(expectedArg);
            }
            message += "\n";
            const calledArgMessage = j < calledArgs.length ? inspect(calledArg) : "";
            if (match.isMatcher(expectedArg)) {
              message += colorSinonMatchText(
                expectedArg,
                calledArg,
                calledArgMessage
              );
            } else {
              const expectedArgMessage = j < expectedArgs.length ? inspect(expectedArg) : "";
              const diff = jsDiff.diffJson(
                calledArgMessage,
                expectedArgMessage
              );
              message += colorDiffText(diff);
            }
          }
        }
        return message;
      },
      C: function(spyInstance) {
        const calls = [];
        for (let i = 0, l = spyInstance.callCount; i < l; ++i) {
          let stringifiedCall = `    ${spyInstance.getCall(i).toString()}`;
          if (/\n/.test(calls[i - 1])) {
            stringifiedCall = `
${stringifiedCall}`;
          }
          push(calls, stringifiedCall);
        }
        return calls.length > 0 ? `
${join(calls, "\n")}` : "";
      },
      t: function(spyInstance) {
        const objects = [];
        for (let i = 0, l = spyInstance.callCount; i < l; ++i) {
          push(objects, inspect(spyInstance.thisValues[i]));
        }
        return join(objects, ", ");
      },
      "*": function(spyInstance, args) {
        return join(
          map(args, function(arg) {
            return inspect(arg);
          }),
          ", "
        );
      }
    };
  }
});

// lib/sinon/proxy.js
var require_proxy = __commonJS({
  "lib/sinon/proxy.js"(exports2, module2) {
    "use strict";
    var arrayProto = require_lib().prototypes.array;
    var extend = require_extend();
    var functionToString = require_function_to_string();
    var proxyCall = require_proxy_call();
    var proxyCallUtil = require_proxy_call_util();
    var proxyInvoke = require_proxy_invoke();
    var inspect = require_util().inspect;
    var push = arrayProto.push;
    var forEach = arrayProto.forEach;
    var slice = arrayProto.slice;
    var emptyFakes = Object.freeze([]);
    var proxyApi = {
      toString: functionToString,
      named: function named(name) {
        this.displayName = name;
        const nameDescriptor = Object.getOwnPropertyDescriptor(this, "name");
        if (nameDescriptor && nameDescriptor.configurable) {
          nameDescriptor.value = name;
          Object.defineProperty(this, "name", nameDescriptor);
        }
        return this;
      },
      invoke: proxyInvoke,
      /*
       * Hook for derived implementation to return fake instances matching the
       * given arguments.
       */
      matchingFakes: function() {
        return emptyFakes;
      },
      getCall: function getCall(index) {
        let i = index;
        if (i < 0) {
          i += this.callCount;
        }
        if (i < 0 || i >= this.callCount) {
          return null;
        }
        return proxyCall(
          this,
          this.thisValues[i],
          this.args[i],
          this.returnValues[i],
          this.exceptions[i],
          this.callIds[i],
          this.errorsWithCallStack[i]
        );
      },
      getCalls: function() {
        const calls = [];
        let i;
        for (i = 0; i < this.callCount; i++) {
          push(calls, this.getCall(i));
        }
        return calls;
      },
      calledBefore: function calledBefore(proxy) {
        if (!this.called) {
          return false;
        }
        if (!proxy.called) {
          return true;
        }
        return this.callIds[0] < proxy.callIds[proxy.callIds.length - 1];
      },
      calledAfter: function calledAfter(proxy) {
        if (!this.called || !proxy.called) {
          return false;
        }
        return this.callIds[this.callCount - 1] > proxy.callIds[0];
      },
      calledImmediatelyBefore: function calledImmediatelyBefore(proxy) {
        if (!this.called || !proxy.called) {
          return false;
        }
        return this.callIds[this.callCount - 1] === proxy.callIds[proxy.callCount - 1] - 1;
      },
      calledImmediatelyAfter: function calledImmediatelyAfter(proxy) {
        if (!this.called || !proxy.called) {
          return false;
        }
        return this.callIds[this.callCount - 1] === proxy.callIds[proxy.callCount - 1] + 1;
      },
      formatters: require_spy_formatters(),
      printf: function(format) {
        const spyInstance = this;
        const args = slice(arguments, 1);
        let formatter;
        return (format || "").replace(/%(.)/g, function(match, specifier) {
          formatter = proxyApi.formatters[specifier];
          if (typeof formatter === "function") {
            return String(formatter(spyInstance, args));
          } else if (!isNaN(parseInt(specifier, 10))) {
            return inspect(args[specifier - 1]);
          }
          return `%${specifier}`;
        });
      },
      resetHistory: function() {
        if (this.invoking) {
          const err = new Error(
            "Cannot reset Sinon function while invoking it. Move the call to .resetHistory outside of the callback."
          );
          err.name = "InvalidResetException";
          throw err;
        }
        this.called = false;
        this.notCalled = true;
        this.calledOnce = false;
        this.calledTwice = false;
        this.calledThrice = false;
        this.callCount = 0;
        this.firstCall = null;
        this.secondCall = null;
        this.thirdCall = null;
        this.lastCall = null;
        this.args = [];
        this.firstArg = null;
        this.lastArg = null;
        this.returnValues = [];
        this.thisValues = [];
        this.exceptions = [];
        this.callIds = [];
        this.errorsWithCallStack = [];
        if (this.fakes) {
          forEach(this.fakes, function(fake) {
            fake.resetHistory();
          });
        }
        return this;
      }
    };
    var delegateToCalls = proxyCallUtil.delegateToCalls;
    delegateToCalls(proxyApi, "calledOn", true);
    delegateToCalls(proxyApi, "alwaysCalledOn", false, "calledOn");
    delegateToCalls(proxyApi, "calledWith", true);
    delegateToCalls(
      proxyApi,
      "calledOnceWith",
      true,
      "calledWith",
      false,
      void 0,
      1
    );
    delegateToCalls(proxyApi, "calledWithMatch", true);
    delegateToCalls(proxyApi, "alwaysCalledWith", false, "calledWith");
    delegateToCalls(proxyApi, "alwaysCalledWithMatch", false, "calledWithMatch");
    delegateToCalls(proxyApi, "calledWithExactly", true);
    delegateToCalls(
      proxyApi,
      "calledOnceWithExactly",
      true,
      "calledWithExactly",
      false,
      void 0,
      1
    );
    delegateToCalls(
      proxyApi,
      "calledOnceWithMatch",
      true,
      "calledWithMatch",
      false,
      void 0,
      1
    );
    delegateToCalls(
      proxyApi,
      "alwaysCalledWithExactly",
      false,
      "calledWithExactly"
    );
    delegateToCalls(
      proxyApi,
      "neverCalledWith",
      false,
      "notCalledWith",
      false,
      function() {
        return true;
      }
    );
    delegateToCalls(
      proxyApi,
      "neverCalledWithMatch",
      false,
      "notCalledWithMatch",
      false,
      function() {
        return true;
      }
    );
    delegateToCalls(proxyApi, "threw", true);
    delegateToCalls(proxyApi, "alwaysThrew", false, "threw");
    delegateToCalls(proxyApi, "returned", true);
    delegateToCalls(proxyApi, "alwaysReturned", false, "returned");
    delegateToCalls(proxyApi, "calledWithNew", true);
    delegateToCalls(proxyApi, "alwaysCalledWithNew", false, "calledWithNew");
    function createProxy(func, originalFunc) {
      const proxy = wrapFunction(func, originalFunc);
      extend(proxy, func);
      proxy.prototype = func.prototype;
      extend.nonEnum(proxy, proxyApi);
      return proxy;
    }
    function wrapFunction(func, originalFunc) {
      const arity = originalFunc.length;
      let p;
      switch (arity) {
        /*eslint-disable no-unused-vars, max-len*/
        case 0:
          p = function proxy() {
            return p.invoke(func, this, slice(arguments));
          };
          break;
        case 1:
          p = function proxy(a) {
            return p.invoke(func, this, slice(arguments));
          };
          break;
        case 2:
          p = function proxy(a, b) {
            return p.invoke(func, this, slice(arguments));
          };
          break;
        case 3:
          p = function proxy(a, b, c) {
            return p.invoke(func, this, slice(arguments));
          };
          break;
        case 4:
          p = function proxy(a, b, c, d) {
            return p.invoke(func, this, slice(arguments));
          };
          break;
        case 5:
          p = function proxy(a, b, c, d, e) {
            return p.invoke(func, this, slice(arguments));
          };
          break;
        case 6:
          p = function proxy(a, b, c, d, e, f) {
            return p.invoke(func, this, slice(arguments));
          };
          break;
        case 7:
          p = function proxy(a, b, c, d, e, f, g) {
            return p.invoke(func, this, slice(arguments));
          };
          break;
        case 8:
          p = function proxy(a, b, c, d, e, f, g, h) {
            return p.invoke(func, this, slice(arguments));
          };
          break;
        case 9:
          p = function proxy(a, b, c, d, e, f, g, h, i) {
            return p.invoke(func, this, slice(arguments));
          };
          break;
        case 10:
          p = function proxy(a, b, c, d, e, f, g, h, i, j) {
            return p.invoke(func, this, slice(arguments));
          };
          break;
        case 11:
          p = function proxy(a, b, c, d, e, f, g, h, i, j, k) {
            return p.invoke(func, this, slice(arguments));
          };
          break;
        case 12:
          p = function proxy(a, b, c, d, e, f, g, h, i, j, k, l) {
            return p.invoke(func, this, slice(arguments));
          };
          break;
        default:
          p = function proxy() {
            return p.invoke(func, this, slice(arguments));
          };
          break;
      }
      const nameDescriptor = Object.getOwnPropertyDescriptor(
        originalFunc,
        "name"
      );
      if (nameDescriptor && nameDescriptor.configurable) {
        Object.defineProperty(p, "name", nameDescriptor);
      }
      extend.nonEnum(p, {
        isSinonProxy: true,
        called: false,
        notCalled: true,
        calledOnce: false,
        calledTwice: false,
        calledThrice: false,
        callCount: 0,
        firstCall: null,
        firstArg: null,
        secondCall: null,
        thirdCall: null,
        lastCall: null,
        lastArg: null,
        args: [],
        returnValues: [],
        thisValues: [],
        exceptions: [],
        callIds: [],
        errorsWithCallStack: []
      });
      return p;
    }
    module2.exports = createProxy;
  }
});

// lib/sinon/util/core/is-non-existent-property.js
var require_is_non_existent_property = __commonJS({
  "lib/sinon/util/core/is-non-existent-property.js"(exports2, module2) {
    "use strict";
    function isNonExistentProperty(object, property) {
      return Boolean(
        object && typeof property !== "undefined" && !(property in object)
      );
    }
    module2.exports = isNonExistentProperty;
  }
});

// lib/sinon/util/core/is-es-module.js
var require_is_es_module = __commonJS({
  "lib/sinon/util/core/is-es-module.js"(exports2, module2) {
    "use strict";
    module2.exports = function(object) {
      return object && typeof Symbol !== "undefined" && object[Symbol.toStringTag] === "Module" && Object.isSealed(object);
    };
  }
});

// lib/sinon/util/core/walk-object.js
var require_walk_object = __commonJS({
  "lib/sinon/util/core/walk-object.js"(exports2, module2) {
    "use strict";
    var functionName = require_lib().functionName;
    var getPropertyDescriptor = require_get_property_descriptor();
    var walk = require_walk();
    function walkObject(mutator, object, filter) {
      let called = false;
      const name = functionName(mutator);
      if (!object) {
        throw new Error(
          `Trying to ${name} object but received ${String(object)}`
        );
      }
      walk(object, function(prop, propOwner) {
        if (propOwner !== Object.prototype && prop !== "constructor" && typeof getPropertyDescriptor(propOwner, prop).value === "function") {
          if (filter) {
            if (filter(object, prop)) {
              called = true;
              mutator(object, prop);
            }
          } else {
            called = true;
            mutator(object, prop);
          }
        }
      });
      if (!called) {
        throw new Error(
          `Found no methods on object to which we could apply mutations`
        );
      }
      return object;
    }
    module2.exports = walkObject;
  }
});

// lib/sinon/util/core/sinon-type.js
var require_sinon_type = __commonJS({
  "lib/sinon/util/core/sinon-type.js"(exports2, module2) {
    "use strict";
    var sinonTypeSymbolProperty = /* @__PURE__ */ Symbol("SinonType");
    module2.exports = {
      /**
       * Set the type of a Sinon object to make it possible to identify it later at runtime
       *
       * @param {object|Function} object  object/function to set the type on
       * @param {string} type the named type of the object/function
       */
      set(object, type) {
        Object.defineProperty(object, sinonTypeSymbolProperty, {
          value: type,
          configurable: false,
          enumerable: false
        });
      },
      get(object) {
        return object && object[sinonTypeSymbolProperty];
      }
    };
  }
});

// lib/sinon/util/core/wrap-method.js
var require_wrap_method = __commonJS({
  "lib/sinon/util/core/wrap-method.js"(exports2, module2) {
    "use strict";
    var noop = () => {
    };
    var getPropertyDescriptor = require_get_property_descriptor();
    var extend = require_extend();
    var sinonType = require_sinon_type();
    var hasOwnProperty = require_lib().prototypes.object.hasOwnProperty;
    var valueToString = require_lib().valueToString;
    var push = require_lib().prototypes.array.push;
    function isFunction(obj) {
      return typeof obj === "function" || Boolean(obj && obj.constructor && obj.call && obj.apply);
    }
    function mirrorProperties(target, source) {
      for (const prop in source) {
        if (!hasOwnProperty(target, prop)) {
          target[prop] = source[prop];
        }
      }
    }
    function getAccessor(object, property, method) {
      const accessors = ["get", "set"];
      const descriptor = getPropertyDescriptor(object, property);
      for (let i = 0; i < accessors.length; i++) {
        if (descriptor[accessors[i]] && descriptor[accessors[i]].name === method.name) {
          return accessors[i];
        }
      }
      return null;
    }
    var hasES5Support = "keys" in Object;
    module2.exports = function wrapMethod(object, property, method) {
      if (!object) {
        throw new TypeError("Should wrap property of object");
      }
      if (typeof method !== "function" && typeof method !== "object") {
        throw new TypeError(
          "Method wrapper should be a function or a property descriptor"
        );
      }
      function checkWrappedMethod(wrappedMethod2) {
        let error2;
        if (!isFunction(wrappedMethod2)) {
          error2 = new TypeError(
            `Attempted to wrap ${typeof wrappedMethod2} property ${valueToString(
              property
            )} as function`
          );
        } else if (wrappedMethod2.restore && wrappedMethod2.restore.sinon) {
          error2 = new TypeError(
            `Attempted to wrap ${valueToString(
              property
            )} which is already wrapped`
          );
        } else if (wrappedMethod2.calledBefore) {
          const verb = wrappedMethod2.returns ? "stubbed" : "spied on";
          error2 = new TypeError(
            `Attempted to wrap ${valueToString(
              property
            )} which is already ${verb}`
          );
        }
        if (error2) {
          if (wrappedMethod2 && wrappedMethod2.stackTraceError) {
            error2.stack += `
--------------
${wrappedMethod2.stackTraceError.stack}`;
          }
          throw error2;
        }
      }
      let error, wrappedMethod, i, wrappedMethodDesc, target, accessor;
      const wrappedMethods = [];
      function simplePropertyAssignment() {
        wrappedMethod = object[property];
        checkWrappedMethod(wrappedMethod);
        object[property] = method;
        method.displayName = property;
      }
      const owned = object.hasOwnProperty ? object.hasOwnProperty(property) : hasOwnProperty(object, property);
      if (hasES5Support) {
        const methodDesc = typeof method === "function" ? { value: method } : method;
        wrappedMethodDesc = getPropertyDescriptor(object, property);
        if (!wrappedMethodDesc) {
          error = new TypeError(
            `Attempted to wrap ${typeof wrappedMethod} property ${property} as function`
          );
        } else if (wrappedMethodDesc.restore && wrappedMethodDesc.restore.sinon) {
          error = new TypeError(
            `Attempted to wrap ${property} which is already wrapped`
          );
        }
        if (error) {
          if (wrappedMethodDesc && wrappedMethodDesc.stackTraceError) {
            error.stack += `
--------------
${wrappedMethodDesc.stackTraceError.stack}`;
          }
          throw error;
        }
        const types = Object.keys(methodDesc);
        for (i = 0; i < types.length; i++) {
          wrappedMethod = wrappedMethodDesc[types[i]];
          checkWrappedMethod(wrappedMethod);
          push(wrappedMethods, wrappedMethod);
        }
        mirrorProperties(methodDesc, wrappedMethodDesc);
        for (i = 0; i < types.length; i++) {
          mirrorProperties(methodDesc[types[i]], wrappedMethodDesc[types[i]]);
        }
        if (!owned) {
          methodDesc.configurable = true;
        }
        Object.defineProperty(object, property, methodDesc);
        if (typeof method === "function" && object[property] !== method) {
          delete object[property];
          simplePropertyAssignment();
        }
      } else {
        simplePropertyAssignment();
      }
      extendObjectWithWrappedMethods();
      function extendObjectWithWrappedMethods() {
        for (i = 0; i < wrappedMethods.length; i++) {
          accessor = getAccessor(object, property, wrappedMethods[i]);
          target = accessor ? method[accessor] : method;
          extend.nonEnum(target, {
            displayName: property,
            wrappedMethod: wrappedMethods[i],
            // Set up an Error object for a stack trace which can be used later to find what line of
            // code the original method was created on.
            stackTraceError: new Error("Stack Trace for original"),
            restore
          });
          target.restore.sinon = true;
          if (!hasES5Support) {
            mirrorProperties(target, wrappedMethod);
          }
        }
      }
      function restore() {
        accessor = getAccessor(object, property, this.wrappedMethod);
        let descriptor;
        if (accessor) {
          if (!owned) {
            try {
              delete object[property][accessor];
            } catch (e) {
            }
          } else if (hasES5Support) {
            descriptor = getPropertyDescriptor(object, property);
            descriptor[accessor] = wrappedMethodDesc[accessor];
            Object.defineProperty(object, property, descriptor);
          }
          if (hasES5Support) {
            descriptor = getPropertyDescriptor(object, property);
            if (descriptor && descriptor.value === target) {
              object[property][accessor] = this.wrappedMethod;
            }
          } else {
            if (object[property][accessor] === target) {
              object[property][accessor] = this.wrappedMethod;
            }
          }
        } else {
          if (!owned) {
            try {
              delete object[property];
            } catch (e) {
            }
          } else if (hasES5Support) {
            Object.defineProperty(object, property, wrappedMethodDesc);
          }
          if (hasES5Support) {
            descriptor = getPropertyDescriptor(object, property);
            if (descriptor && descriptor.value === target) {
              object[property] = this.wrappedMethod;
            }
          } else {
            if (object[property] === target) {
              object[property] = this.wrappedMethod;
            }
          }
        }
        if (sinonType.get(object) === "stub-instance") {
          object[property] = noop;
        }
      }
      return method;
    };
  }
});

// lib/sinon/spy.js
var require_spy = __commonJS({
  "lib/sinon/spy.js"(exports2, module2) {
    "use strict";
    var arrayProto = require_lib().prototypes.array;
    var createProxy = require_proxy();
    var extend = require_extend();
    var functionName = require_lib().functionName;
    var getPropertyDescriptor = require_get_property_descriptor();
    var deepEqual = require_samsam().deepEqual;
    var isEsModule = require_is_es_module();
    var proxyCallUtil = require_proxy_call_util();
    var walkObject = require_walk_object();
    var wrapMethod = require_wrap_method();
    var valueToString = require_lib().valueToString;
    var forEach = arrayProto.forEach;
    var pop = arrayProto.pop;
    var push = arrayProto.push;
    var slice = arrayProto.slice;
    var filter = Array.prototype.filter;
    var uuid = 0;
    function matches(fake, args, strict) {
      const margs = fake.matchingArguments;
      if (margs.length <= args.length && deepEqual(slice(args, 0, margs.length), margs)) {
        return !strict || margs.length === args.length;
      }
      return false;
    }
    var spyApi = {
      withArgs: function() {
        const args = slice(arguments);
        const matching = pop(this.matchingFakes(args, true));
        if (matching) {
          return matching;
        }
        const original = this;
        const fake = this.instantiateFake();
        fake.matchingArguments = args;
        fake.parent = this;
        push(this.fakes, fake);
        fake.withArgs = function() {
          return original.withArgs.apply(original, arguments);
        };
        forEach(original.args, function(arg, i) {
          if (!matches(fake, arg)) {
            return;
          }
          proxyCallUtil.incrementCallCount(fake);
          push(fake.thisValues, original.thisValues[i]);
          push(fake.args, arg);
          push(fake.returnValues, original.returnValues[i]);
          push(fake.exceptions, original.exceptions[i]);
          push(fake.callIds, original.callIds[i]);
        });
        proxyCallUtil.createCallProperties(fake);
        return fake;
      },
      // Override proxy default implementation
      matchingFakes: function(args, strict) {
        return filter.call(this.fakes, function(fake) {
          return matches(fake, args, strict);
        });
      }
    };
    var delegateToCalls = proxyCallUtil.delegateToCalls;
    delegateToCalls(spyApi, "callArg", false, "callArgWith", true, function() {
      throw new Error(
        `${this.toString()} cannot call arg since it was not yet invoked.`
      );
    });
    spyApi.callArgWith = spyApi.callArg;
    delegateToCalls(spyApi, "callArgOn", false, "callArgOnWith", true, function() {
      throw new Error(
        `${this.toString()} cannot call arg since it was not yet invoked.`
      );
    });
    spyApi.callArgOnWith = spyApi.callArgOn;
    delegateToCalls(spyApi, "throwArg", false, "throwArg", false, function() {
      throw new Error(
        `${this.toString()} cannot throw arg since it was not yet invoked.`
      );
    });
    delegateToCalls(spyApi, "yield", false, "yield", true, function() {
      throw new Error(
        `${this.toString()} cannot yield since it was not yet invoked.`
      );
    });
    spyApi.invokeCallback = spyApi.yield;
    delegateToCalls(spyApi, "yieldOn", false, "yieldOn", true, function() {
      throw new Error(
        `${this.toString()} cannot yield since it was not yet invoked.`
      );
    });
    delegateToCalls(spyApi, "yieldTo", false, "yieldTo", true, function(property) {
      throw new Error(
        `${this.toString()} cannot yield to '${valueToString(
          property
        )}' since it was not yet invoked.`
      );
    });
    delegateToCalls(
      spyApi,
      "yieldToOn",
      false,
      "yieldToOn",
      true,
      function(property) {
        throw new Error(
          `${this.toString()} cannot yield to '${valueToString(
            property
          )}' since it was not yet invoked.`
        );
      }
    );
    function createSpy(func) {
      let name;
      let funk = func;
      if (typeof funk !== "function") {
        funk = function() {
          return;
        };
      } else {
        name = functionName(funk);
      }
      const proxy = createProxy(funk, funk);
      extend.nonEnum(proxy, spyApi);
      extend.nonEnum(proxy, {
        displayName: name || "spy",
        fakes: [],
        instantiateFake: createSpy,
        id: `spy#${uuid++}`
      });
      return proxy;
    }
    function spy(object, property, types) {
      if (isEsModule(object)) {
        throw new TypeError("ES Modules cannot be spied");
      }
      if (!property && typeof object === "function") {
        return createSpy(object);
      }
      if (!property && typeof object === "object") {
        return walkObject(spy, object);
      }
      if (!object && !property) {
        return createSpy(function() {
          return;
        });
      }
      if (!types) {
        return wrapMethod(object, property, createSpy(object[property]));
      }
      const descriptor = {};
      const methodDesc = getPropertyDescriptor(object, property);
      forEach(types, function(type) {
        descriptor[type] = createSpy(methodDesc[type]);
      });
      return wrapMethod(object, property, descriptor);
    }
    extend(spy, spyApi);
    module2.exports = spy;
  }
});

// lib/sinon/throw-on-falsy-object.js
var require_throw_on_falsy_object = __commonJS({
  "lib/sinon/throw-on-falsy-object.js"(exports2, module2) {
    "use strict";
    var valueToString = require_lib().valueToString;
    function throwOnFalsyObject(object, property) {
      if (property && !object) {
        const type = object === null ? "null" : "undefined";
        throw new Error(
          `Trying to stub property '${valueToString(property)}' of ${type}`
        );
      }
    }
    module2.exports = throwOnFalsyObject;
  }
});

// lib/sinon/stub.js
var require_stub = __commonJS({
  "lib/sinon/stub.js"(exports2, module2) {
    "use strict";
    var arrayProto = require_lib().prototypes.array;
    var behavior = require_behavior();
    var behaviors = require_default_behaviors();
    var createProxy = require_proxy();
    var functionName = require_lib().functionName;
    var hasOwnProperty = require_lib().prototypes.object.hasOwnProperty;
    var isNonExistentProperty = require_is_non_existent_property();
    var spy = require_spy();
    var extend = require_extend();
    var getPropertyDescriptor = require_get_property_descriptor();
    var isEsModule = require_is_es_module();
    var sinonType = require_sinon_type();
    var wrapMethod = require_wrap_method();
    var throwOnFalsyObject = require_throw_on_falsy_object();
    var valueToString = require_lib().valueToString;
    var walkObject = require_walk_object();
    var forEach = arrayProto.forEach;
    var pop = arrayProto.pop;
    var slice = arrayProto.slice;
    var sort = arrayProto.sort;
    var uuid = 0;
    function createStub(originalFunc) {
      let proxy;
      function functionStub() {
        const args = slice(arguments);
        const matchings = proxy.matchingFakes(args);
        const fnStub = pop(
          sort(matchings, function(a, b) {
            return a.matchingArguments.length - b.matchingArguments.length;
          })
        ) || proxy;
        return getCurrentBehavior(fnStub).invoke(this, arguments);
      }
      proxy = createProxy(functionStub, originalFunc || functionStub);
      extend.nonEnum(proxy, spy);
      extend.nonEnum(proxy, stub);
      const name = originalFunc ? functionName(originalFunc) : null;
      extend.nonEnum(proxy, {
        fakes: [],
        instantiateFake: createStub,
        displayName: name || "stub",
        defaultBehavior: null,
        behaviors: [],
        id: `stub#${uuid++}`
      });
      sinonType.set(proxy, "stub");
      return proxy;
    }
    function stub(object, property) {
      if (arguments.length > 2) {
        throw new TypeError(
          "stub(obj, 'meth', fn) has been removed, see documentation"
        );
      }
      if (isEsModule(object)) {
        throw new TypeError("ES Modules cannot be stubbed");
      }
      throwOnFalsyObject.apply(null, arguments);
      if (isNonExistentProperty(object, property)) {
        throw new TypeError(
          `Cannot stub non-existent property ${valueToString(property)}`
        );
      }
      const actualDescriptor = getPropertyDescriptor(object, property);
      assertValidPropertyDescriptor(actualDescriptor, property);
      const isObjectOrFunction = typeof object === "object" || typeof object === "function";
      const isStubbingEntireObject = typeof property === "undefined" && isObjectOrFunction;
      const isCreatingNewStub = !object && typeof property === "undefined";
      const isStubbingNonFuncProperty = isObjectOrFunction && typeof property !== "undefined" && (typeof actualDescriptor === "undefined" || typeof actualDescriptor.value !== "function");
      if (isStubbingEntireObject) {
        return walkObject(stub, object);
      }
      if (isCreatingNewStub) {
        return createStub();
      }
      const func = typeof actualDescriptor.value === "function" ? actualDescriptor.value : null;
      const s = createStub(func);
      extend.nonEnum(s, {
        rootObj: object,
        propName: property,
        shadowsPropOnPrototype: !actualDescriptor.isOwn,
        restore: function restore() {
          if (actualDescriptor !== void 0 && actualDescriptor.isOwn) {
            Object.defineProperty(object, property, actualDescriptor);
            return;
          }
          delete object[property];
        }
      });
      return isStubbingNonFuncProperty ? s : wrapMethod(object, property, s);
    }
    function assertValidPropertyDescriptor(descriptor, property) {
      if (!descriptor || !property) {
        return;
      }
      if (descriptor.isOwn && !descriptor.configurable && !descriptor.writable) {
        throw new TypeError(
          `The descriptor for property \`${property}\` is non-configurable and non-writable. Sinon cannot stub properties that are immutable. See https://sinonjs.org/faq#property-descriptor-errors for help fixing this issue.`
        );
      }
      if ((descriptor.get || descriptor.set) && !descriptor.configurable) {
        throw new TypeError(
          `Descriptor for accessor property ${property} is non-configurable`
        );
      }
      if (isDataDescriptor(descriptor) && !descriptor.writable) {
        throw new TypeError(
          `Descriptor for data property ${property} is non-writable`
        );
      }
    }
    function isDataDescriptor(descriptor) {
      return !descriptor.value && !descriptor.writable && !descriptor.set && !descriptor.get;
    }
    function getParentBehaviour(stubInstance) {
      return stubInstance.parent && getCurrentBehavior(stubInstance.parent);
    }
    function getDefaultBehavior(stubInstance) {
      return stubInstance.defaultBehavior || getParentBehaviour(stubInstance) || behavior.create(stubInstance);
    }
    function getCurrentBehavior(stubInstance) {
      const currentBehavior = stubInstance.behaviors[stubInstance.callCount - 1];
      return currentBehavior && currentBehavior.isPresent() ? currentBehavior : getDefaultBehavior(stubInstance);
    }
    var proto = {
      resetBehavior: function() {
        this.defaultBehavior = null;
        this.behaviors = [];
        delete this.returnValue;
        delete this.returnArgAt;
        delete this.throwArgAt;
        delete this.resolveArgAt;
        delete this.fakeFn;
        this.returnThis = false;
        this.resolveThis = false;
        forEach(this.fakes, function(fake) {
          fake.resetBehavior();
        });
      },
      reset: function() {
        this.resetHistory();
        this.resetBehavior();
      },
      onCall: function onCall(index) {
        if (!this.behaviors[index]) {
          this.behaviors[index] = behavior.create(this);
        }
        return this.behaviors[index];
      },
      onFirstCall: function onFirstCall() {
        return this.onCall(0);
      },
      onSecondCall: function onSecondCall() {
        return this.onCall(1);
      },
      onThirdCall: function onThirdCall() {
        return this.onCall(2);
      },
      withArgs: function withArgs() {
        const fake = spy.withArgs.apply(this, arguments);
        if (this.defaultBehavior && this.defaultBehavior.promiseLibrary) {
          fake.defaultBehavior = fake.defaultBehavior || behavior.create(fake);
          fake.defaultBehavior.promiseLibrary = this.defaultBehavior.promiseLibrary;
        }
        return fake;
      }
    };
    forEach(Object.keys(behavior), function(method) {
      if (hasOwnProperty(behavior, method) && !hasOwnProperty(proto, method) && method !== "create" && method !== "invoke") {
        proto[method] = behavior.createBehavior(method);
      }
    });
    forEach(Object.keys(behaviors), function(method) {
      if (hasOwnProperty(behaviors, method) && !hasOwnProperty(proto, method)) {
        behavior.addBehavior(stub, method, behaviors[method]);
      }
    });
    extend(stub, proto);
    module2.exports = stub;
  }
});

// lib/sinon/mock-expectation.js
var require_mock_expectation = __commonJS({
  "lib/sinon/mock-expectation.js"(exports2, module2) {
    "use strict";
    var arrayProto = require_lib().prototypes.array;
    var proxyInvoke = require_proxy_invoke();
    var proxyCallToString = require_proxy_call().toString;
    var timesInWords = require_times_in_words();
    var extend = require_extend();
    var match = require_samsam().createMatcher;
    var stub = require_stub();
    var assert = require_assert();
    var deepEqual = require_samsam().deepEqual;
    var inspect = require_util().inspect;
    var valueToString = require_lib().valueToString;
    var every = arrayProto.every;
    var forEach = arrayProto.forEach;
    var push = arrayProto.push;
    var slice = arrayProto.slice;
    function callCountInWords(callCount) {
      if (callCount === 0) {
        return "never called";
      }
      return `called ${timesInWords(callCount)}`;
    }
    function expectedCallCountInWords(expectation) {
      const min = expectation.minCalls;
      const max = expectation.maxCalls;
      if (typeof min === "number" && typeof max === "number") {
        let str = timesInWords(min);
        if (min !== max) {
          str = `at least ${str} and at most ${timesInWords(max)}`;
        }
        return str;
      }
      if (typeof min === "number") {
        return `at least ${timesInWords(min)}`;
      }
      return `at most ${timesInWords(max)}`;
    }
    function receivedMinCalls(expectation) {
      const hasMinLimit = typeof expectation.minCalls === "number";
      return !hasMinLimit || expectation.callCount >= expectation.minCalls;
    }
    function receivedMaxCalls(expectation) {
      if (typeof expectation.maxCalls !== "number") {
        return false;
      }
      return expectation.callCount === expectation.maxCalls;
    }
    function verifyMatcher(possibleMatcher, arg) {
      const isMatcher = match.isMatcher(possibleMatcher);
      return isMatcher && possibleMatcher.test(arg) || true;
    }
    var mockExpectation = {
      minCalls: 1,
      maxCalls: 1,
      create: function create(methodName) {
        const expectation = extend.nonEnum(stub(), mockExpectation);
        delete expectation.create;
        expectation.method = methodName;
        return expectation;
      },
      invoke: function invoke(func, thisValue, args) {
        this.verifyCallAllowed(thisValue, args);
        return proxyInvoke.apply(this, arguments);
      },
      atLeast: function atLeast(num) {
        if (typeof num !== "number") {
          throw new TypeError(`'${valueToString(num)}' is not number`);
        }
        if (!this.limitsSet) {
          this.maxCalls = null;
          this.limitsSet = true;
        }
        this.minCalls = num;
        return this;
      },
      atMost: function atMost(num) {
        if (typeof num !== "number") {
          throw new TypeError(`'${valueToString(num)}' is not number`);
        }
        if (!this.limitsSet) {
          this.minCalls = null;
          this.limitsSet = true;
        }
        this.maxCalls = num;
        return this;
      },
      never: function never() {
        return this.exactly(0);
      },
      once: function once() {
        return this.exactly(1);
      },
      twice: function twice() {
        return this.exactly(2);
      },
      thrice: function thrice() {
        return this.exactly(3);
      },
      exactly: function exactly(num) {
        if (typeof num !== "number") {
          throw new TypeError(`'${valueToString(num)}' is not a number`);
        }
        this.atLeast(num);
        return this.atMost(num);
      },
      met: function met() {
        return !this.failed && receivedMinCalls(this);
      },
      verifyCallAllowed: function verifyCallAllowed(thisValue, args) {
        const expectedArguments = this.expectedArguments;
        if (receivedMaxCalls(this)) {
          this.failed = true;
          mockExpectation.fail(
            `${this.method} already called ${timesInWords(this.maxCalls)}`
          );
        }
        if ("expectedThis" in this && this.expectedThis !== thisValue) {
          mockExpectation.fail(
            `${this.method} called with ${valueToString(
              thisValue
            )} as thisValue, expected ${valueToString(this.expectedThis)}`
          );
        }
        if (!("expectedArguments" in this)) {
          return;
        }
        if (!args) {
          mockExpectation.fail(
            `${this.method} received no arguments, expected ${inspect(
              expectedArguments
            )}`
          );
        }
        if (args.length < expectedArguments.length) {
          mockExpectation.fail(
            `${this.method} received too few arguments (${inspect(
              args
            )}), expected ${inspect(expectedArguments)}`
          );
        }
        if (this.expectsExactArgCount && args.length !== expectedArguments.length) {
          mockExpectation.fail(
            `${this.method} received too many arguments (${inspect(
              args
            )}), expected ${inspect(expectedArguments)}`
          );
        }
        forEach(
          expectedArguments,
          function(expectedArgument, i) {
            if (!verifyMatcher(expectedArgument, args[i])) {
              mockExpectation.fail(
                `${this.method} received wrong arguments ${inspect(
                  args
                )}, didn't match ${String(expectedArguments)}`
              );
            }
            if (!deepEqual(args[i], expectedArgument)) {
              mockExpectation.fail(
                `${this.method} received wrong arguments ${inspect(
                  args
                )}, expected ${inspect(expectedArguments)}`
              );
            }
          },
          this
        );
      },
      allowsCall: function allowsCall(thisValue, args) {
        const expectedArguments = this.expectedArguments;
        if (this.met() && receivedMaxCalls(this)) {
          return false;
        }
        if ("expectedThis" in this && this.expectedThis !== thisValue) {
          return false;
        }
        if (!("expectedArguments" in this)) {
          return true;
        }
        const _args = args || [];
        if (_args.length < expectedArguments.length) {
          return false;
        }
        if (this.expectsExactArgCount && _args.length !== expectedArguments.length) {
          return false;
        }
        return every(expectedArguments, function(expectedArgument, i) {
          if (!verifyMatcher(expectedArgument, _args[i])) {
            return false;
          }
          if (!deepEqual(_args[i], expectedArgument)) {
            return false;
          }
          return true;
        });
      },
      withArgs: function withArgs() {
        this.expectedArguments = slice(arguments);
        return this;
      },
      withExactArgs: function withExactArgs() {
        this.withArgs.apply(this, arguments);
        this.expectsExactArgCount = true;
        return this;
      },
      on: function on(thisValue) {
        this.expectedThis = thisValue;
        return this;
      },
      toString: function() {
        const args = slice(this.expectedArguments || []);
        if (!this.expectsExactArgCount) {
          push(args, "[...]");
        }
        const callStr = proxyCallToString.call({
          proxy: this.method || "anonymous mock expectation",
          args
        });
        const message = `${callStr.replace(
          ", [...",
          "[, ..."
        )} ${expectedCallCountInWords(this)}`;
        if (this.met()) {
          return `Expectation met: ${message}`;
        }
        return `Expected ${message} (${callCountInWords(this.callCount)})`;
      },
      verify: function verify() {
        if (!this.met()) {
          mockExpectation.fail(String(this));
        } else {
          mockExpectation.pass(String(this));
        }
        return true;
      },
      pass: function pass(message) {
        assert.pass(message);
      },
      fail: function fail(message) {
        const exception = new Error(message);
        exception.name = "ExpectationError";
        throw exception;
      }
    };
    module2.exports = mockExpectation;
  }
});

// lib/sinon/mock.js
var require_mock = __commonJS({
  "lib/sinon/mock.js"(exports2, module2) {
    "use strict";
    var arrayProto = require_lib().prototypes.array;
    var mockExpectation = require_mock_expectation();
    var proxyCallToString = require_proxy_call().toString;
    var extend = require_extend();
    var deepEqual = require_samsam().deepEqual;
    var wrapMethod = require_wrap_method();
    var concat = arrayProto.concat;
    var filter = arrayProto.filter;
    var forEach = arrayProto.forEach;
    var every = arrayProto.every;
    var join = arrayProto.join;
    var push = arrayProto.push;
    var slice = arrayProto.slice;
    var unshift = arrayProto.unshift;
    function mock(object) {
      if (!object || typeof object === "string") {
        return mockExpectation.create(object ? object : "Anonymous mock");
      }
      return mock.create(object);
    }
    function each(collection, callback) {
      const col = collection || [];
      forEach(col, callback);
    }
    function arrayEquals(arr1, arr2, compareLength) {
      if (compareLength && arr1.length !== arr2.length) {
        return false;
      }
      return every(arr1, function(element, i) {
        return deepEqual(arr2[i], element);
      });
    }
    extend(mock, {
      create: function create(object) {
        if (!object) {
          throw new TypeError("object is null");
        }
        const mockObject = extend.nonEnum({}, mock, { object });
        delete mockObject.create;
        return mockObject;
      },
      expects: function expects(method) {
        if (!method) {
          throw new TypeError("method is falsy");
        }
        if (!this.expectations) {
          this.expectations = {};
          this.proxies = [];
          this.failures = [];
        }
        if (!this.expectations[method]) {
          this.expectations[method] = [];
          const mockObject = this;
          wrapMethod(this.object, method, function() {
            return mockObject.invokeMethod(method, this, arguments);
          });
          push(this.proxies, method);
        }
        const expectation = mockExpectation.create(method);
        expectation.wrappedMethod = this.object[method].wrappedMethod;
        push(this.expectations[method], expectation);
        return expectation;
      },
      restore: function restore() {
        const object = this.object;
        each(this.proxies, function(proxy) {
          if (typeof object[proxy].restore === "function") {
            object[proxy].restore();
          }
        });
      },
      verify: function verify() {
        const expectations = this.expectations || {};
        const messages = this.failures ? slice(this.failures) : [];
        const met = [];
        each(this.proxies, function(proxy) {
          each(expectations[proxy], function(expectation) {
            if (!expectation.met()) {
              push(messages, String(expectation));
            } else {
              push(met, String(expectation));
            }
          });
        });
        this.restore();
        if (messages.length > 0) {
          mockExpectation.fail(join(concat(messages, met), "\n"));
        } else if (met.length > 0) {
          mockExpectation.pass(join(concat(messages, met), "\n"));
        }
        return true;
      },
      invokeMethod: function invokeMethod(method, thisValue, args) {
        const expectations = this.expectations && this.expectations[method] ? this.expectations[method] : [];
        const currentArgs = args || [];
        let available;
        const expectationsWithMatchingArgs = filter(
          expectations,
          function(expectation) {
            const expectedArgs = expectation.expectedArguments || [];
            return arrayEquals(
              expectedArgs,
              currentArgs,
              expectation.expectsExactArgCount
            );
          }
        );
        const expectationsToApply = filter(
          expectationsWithMatchingArgs,
          function(expectation) {
            return !expectation.met() && expectation.allowsCall(thisValue, args);
          }
        );
        if (expectationsToApply.length > 0) {
          return expectationsToApply[0].apply(thisValue, args);
        }
        const messages = [];
        let exhausted = 0;
        forEach(expectationsWithMatchingArgs, function(expectation) {
          if (expectation.allowsCall(thisValue, args)) {
            available = available || expectation;
          } else {
            exhausted += 1;
          }
        });
        if (available && exhausted === 0) {
          return available.apply(thisValue, args);
        }
        forEach(expectations, function(expectation) {
          push(messages, `    ${String(expectation)}`);
        });
        unshift(
          messages,
          `Unexpected call: ${proxyCallToString.call({
            proxy: method,
            args
          })}`
        );
        const err = new Error();
        if (!err.stack) {
          try {
            throw err;
          } catch (e) {
          }
        }
        push(
          this.failures,
          `Unexpected call: ${proxyCallToString.call({
            proxy: method,
            args,
            stack: err.stack
          })}`
        );
        mockExpectation.fail(join(messages, "\n"));
      }
    });
    module2.exports = mock;
  }
});

// lib/sinon/create-stub-instance.js
var require_create_stub_instance = __commonJS({
  "lib/sinon/create-stub-instance.js"(exports2, module2) {
    "use strict";
    var stub = require_stub();
    var sinonType = require_sinon_type();
    var forEach = require_lib().prototypes.array.forEach;
    function isStub(value) {
      return sinonType.get(value) === "stub";
    }
    module2.exports = function createStubInstance(constructor, overrides) {
      if (typeof constructor !== "function") {
        throw new TypeError("The constructor should be a function.");
      }
      const stubInstance = Object.create(constructor.prototype);
      sinonType.set(stubInstance, "stub-instance");
      const stubbedObject = stub(stubInstance);
      forEach(Object.keys(overrides || {}), function(propertyName) {
        if (propertyName in stubbedObject) {
          const value = overrides[propertyName];
          if (isStub(value)) {
            stubbedObject[propertyName] = value;
          } else {
            stubbedObject[propertyName].returns(value);
          }
        } else {
          throw new Error(
            `Cannot stub ${propertyName}. Property does not exist!`
          );
        }
      });
      return stubbedObject;
    };
  }
});

// lib/sinon/fake.js
var require_fake = __commonJS({
  "lib/sinon/fake.js"(exports2, module2) {
    "use strict";
    var arrayProto = require_lib().prototypes.array;
    var createProxy = require_proxy();
    var nextTick = require_next_tick();
    var slice = arrayProto.slice;
    module2.exports = fake;
    function fake(f) {
      if (arguments.length > 0 && typeof f !== "function") {
        throw new TypeError("Expected f argument to be a Function");
      }
      return wrapFunc(f);
    }
    fake.returns = function returns(value) {
      function f() {
        return value;
      }
      return wrapFunc(f);
    };
    fake.throws = function throws(value) {
      function f() {
        throw getError(value);
      }
      return wrapFunc(f);
    };
    fake.resolves = function resolves(value) {
      function f() {
        return Promise.resolve(value);
      }
      return wrapFunc(f);
    };
    fake.rejects = function rejects(value) {
      function f() {
        return Promise.reject(getError(value));
      }
      return wrapFunc(f);
    };
    fake.yields = function yields() {
      const values = slice(arguments);
      function f() {
        const callback = arguments[arguments.length - 1];
        if (typeof callback !== "function") {
          throw new TypeError("Expected last argument to be a function");
        }
        callback.apply(null, values);
      }
      return wrapFunc(f);
    };
    fake.yieldsAsync = function yieldsAsync() {
      const values = slice(arguments);
      function f() {
        const callback = arguments[arguments.length - 1];
        if (typeof callback !== "function") {
          throw new TypeError("Expected last argument to be a function");
        }
        nextTick(function() {
          callback.apply(null, values);
        });
      }
      return wrapFunc(f);
    };
    var uuid = 0;
    function wrapFunc(f) {
      const fakeInstance = function() {
        let firstArg, lastArg;
        if (arguments.length > 0) {
          firstArg = arguments[0];
          lastArg = arguments[arguments.length - 1];
        }
        const callback = lastArg && typeof lastArg === "function" ? lastArg : void 0;
        proxy.firstArg = firstArg;
        proxy.lastArg = lastArg;
        proxy.callback = callback;
        return f && f.apply(this, arguments);
      };
      const proxy = createProxy(fakeInstance, f || fakeInstance);
      proxy.displayName = "fake";
      proxy.id = `fake#${uuid++}`;
      return proxy;
    }
    function getError(value) {
      return value instanceof Error ? value : new Error(value);
    }
  }
});

// lib/sinon/sandbox.js
var require_sandbox = __commonJS({
  "lib/sinon/sandbox.js"(exports2, module2) {
    "use strict";
    var arrayProto = require_lib().prototypes.array;
    var logger = require_lib().deprecated;
    var collectOwnMethods = require_collect_own_methods();
    var getPropertyDescriptor = require_get_property_descriptor();
    var isPropertyConfigurable = require_is_property_configurable();
    var match = require_samsam().createMatcher;
    var sinonAssert = require_assert();
    var sinonClock = require_fake_timers();
    var sinonMock = require_mock();
    var sinonSpy = require_spy();
    var sinonStub = require_stub();
    var sinonCreateStubInstance = require_create_stub_instance();
    var sinonFake = require_fake();
    var valueToString = require_lib().valueToString;
    var DEFAULT_LEAK_THRESHOLD = 1e4;
    var filter = arrayProto.filter;
    var forEach = arrayProto.forEach;
    var push = arrayProto.push;
    var reverse = arrayProto.reverse;
    function applyOnEach(fakes, method) {
      const matchingFakes = filter(fakes, function(fake) {
        return typeof fake[method] === "function";
      });
      forEach(matchingFakes, function(fake) {
        fake[method]();
      });
    }
    function throwOnAccessors(descriptor) {
      if (typeof descriptor.get === "function") {
        throw new Error("Use sandbox.replaceGetter for replacing getters");
      }
      if (typeof descriptor.set === "function") {
        throw new Error("Use sandbox.replaceSetter for replacing setters");
      }
    }
    function verifySameType(object, property, replacement) {
      if (typeof object[property] !== typeof replacement) {
        throw new TypeError(
          `Cannot replace ${typeof object[property]} with ${typeof replacement}`
        );
      }
    }
    function checkForValidArguments(descriptor, property, replacement) {
      if (typeof descriptor === "undefined") {
        throw new TypeError(
          `Cannot replace non-existent property ${valueToString(
            property
          )}. Perhaps you meant sandbox.define()?`
        );
      }
      if (typeof replacement === "undefined") {
        throw new TypeError("Expected replacement argument to be defined");
      }
    }
    function Sandbox(opts = {}) {
      const sandbox = this;
      const assertOptions = opts.assertOptions || {};
      let fakeRestorers = [];
      let collection = [];
      let loggedLeakWarning = false;
      sandbox.leakThreshold = DEFAULT_LEAK_THRESHOLD;
      function addToCollection(object) {
        if (push(collection, object) > sandbox.leakThreshold && !loggedLeakWarning) {
          logger.printWarning(
            "Potential memory leak detected; be sure to call restore() to clean up your sandbox. To suppress this warning, modify the leakThreshold property of your sandbox."
          );
          loggedLeakWarning = true;
        }
      }
      sandbox.assert = sinonAssert.createAssertObject(assertOptions);
      sandbox.getFakes = function getFakes() {
        return collection;
      };
      sandbox.createStubInstance = function createStubInstance() {
        const stubbed = sinonCreateStubInstance.apply(null, arguments);
        const ownMethods = collectOwnMethods(stubbed);
        forEach(ownMethods, function(method) {
          addToCollection(method);
        });
        return stubbed;
      };
      sandbox.inject = function inject(obj) {
        obj.spy = function() {
          return sandbox.spy.apply(null, arguments);
        };
        obj.stub = function() {
          return sandbox.stub.apply(null, arguments);
        };
        obj.mock = function() {
          return sandbox.mock.apply(null, arguments);
        };
        obj.createStubInstance = function() {
          return sandbox.createStubInstance.apply(sandbox, arguments);
        };
        obj.fake = function() {
          return sandbox.fake.apply(null, arguments);
        };
        obj.define = function() {
          return sandbox.define.apply(null, arguments);
        };
        obj.replace = function() {
          return sandbox.replace.apply(null, arguments);
        };
        obj.replaceSetter = function() {
          return sandbox.replaceSetter.apply(null, arguments);
        };
        obj.replaceGetter = function() {
          return sandbox.replaceGetter.apply(null, arguments);
        };
        if (sandbox.clock) {
          obj.clock = sandbox.clock;
        }
        obj.match = match;
        return obj;
      };
      sandbox.mock = function mock() {
        const m = sinonMock.apply(null, arguments);
        addToCollection(m);
        return m;
      };
      sandbox.reset = function reset() {
        applyOnEach(collection, "reset");
        applyOnEach(collection, "resetHistory");
      };
      sandbox.resetBehavior = function resetBehavior() {
        applyOnEach(collection, "resetBehavior");
      };
      sandbox.resetHistory = function resetHistory() {
        function privateResetHistory(f) {
          const method = f.resetHistory || f.reset;
          if (method) {
            method.call(f);
          }
        }
        forEach(collection, privateResetHistory);
      };
      sandbox.restore = function restore() {
        if (arguments.length) {
          throw new Error(
            "sandbox.restore() does not take any parameters. Perhaps you meant stub.restore()"
          );
        }
        reverse(collection);
        applyOnEach(collection, "restore");
        collection = [];
        forEach(fakeRestorers, function(restorer) {
          restorer();
        });
        fakeRestorers = [];
        sandbox.restoreContext();
      };
      sandbox.restoreContext = function restoreContext() {
        if (!sandbox.injectedKeys) {
          return;
        }
        forEach(sandbox.injectedKeys, function(injectedKey) {
          delete sandbox.injectInto[injectedKey];
        });
        sandbox.injectedKeys.length = 0;
      };
      function getFakeRestorer(object, property, forceAssignment = false) {
        const descriptor = getPropertyDescriptor(object, property);
        const value = forceAssignment && object[property];
        function restorer() {
          if (forceAssignment) {
            object[property] = value;
          } else if (descriptor?.isOwn) {
            Object.defineProperty(object, property, descriptor);
          } else {
            delete object[property];
          }
        }
        restorer.object = object;
        restorer.property = property;
        return restorer;
      }
      function verifyNotReplaced(object, property) {
        forEach(fakeRestorers, function(fakeRestorer) {
          if (fakeRestorer.object === object && fakeRestorer.property === property) {
            throw new TypeError(
              `Attempted to replace ${property} which is already replaced`
            );
          }
        });
      }
      sandbox.replace = function replace(object, property, replacement) {
        const descriptor = getPropertyDescriptor(object, property);
        checkForValidArguments(descriptor, property, replacement);
        throwOnAccessors(descriptor);
        verifySameType(object, property, replacement);
        verifyNotReplaced(object, property);
        push(fakeRestorers, getFakeRestorer(object, property));
        object[property] = replacement;
        return replacement;
      };
      sandbox.replace.usingAccessor = function replaceUsingAccessor(object, property, replacement) {
        const descriptor = getPropertyDescriptor(object, property);
        checkForValidArguments(descriptor, property, replacement);
        verifySameType(object, property, replacement);
        verifyNotReplaced(object, property);
        push(fakeRestorers, getFakeRestorer(object, property, true));
        object[property] = replacement;
        return replacement;
      };
      sandbox.define = function define2(object, property, value) {
        const descriptor = getPropertyDescriptor(object, property);
        if (descriptor) {
          throw new TypeError(
            `Cannot define the already existing property ${valueToString(
              property
            )}. Perhaps you meant sandbox.replace()?`
          );
        }
        if (typeof value === "undefined") {
          throw new TypeError("Expected value argument to be defined");
        }
        verifyNotReplaced(object, property);
        push(fakeRestorers, getFakeRestorer(object, property));
        object[property] = value;
        return value;
      };
      sandbox.replaceGetter = function replaceGetter(object, property, replacement) {
        const descriptor = getPropertyDescriptor(object, property);
        if (typeof descriptor === "undefined") {
          throw new TypeError(
            `Cannot replace non-existent property ${valueToString(
              property
            )}`
          );
        }
        if (typeof replacement !== "function") {
          throw new TypeError(
            "Expected replacement argument to be a function"
          );
        }
        if (typeof descriptor.get !== "function") {
          throw new Error("`object.property` is not a getter");
        }
        verifyNotReplaced(object, property);
        push(fakeRestorers, getFakeRestorer(object, property));
        Object.defineProperty(object, property, {
          get: replacement,
          configurable: isPropertyConfigurable(object, property)
        });
        return replacement;
      };
      sandbox.replaceSetter = function replaceSetter(object, property, replacement) {
        const descriptor = getPropertyDescriptor(object, property);
        if (typeof descriptor === "undefined") {
          throw new TypeError(
            `Cannot replace non-existent property ${valueToString(
              property
            )}`
          );
        }
        if (typeof replacement !== "function") {
          throw new TypeError(
            "Expected replacement argument to be a function"
          );
        }
        if (typeof descriptor.set !== "function") {
          throw new Error("`object.property` is not a setter");
        }
        verifyNotReplaced(object, property);
        push(fakeRestorers, getFakeRestorer(object, property));
        Object.defineProperty(object, property, {
          set: replacement,
          configurable: isPropertyConfigurable(object, property)
        });
        return replacement;
      };
      function commonPostInitSetup(args, spy) {
        const [object, property, types] = args;
        const isSpyingOnEntireObject = typeof property === "undefined" && (typeof object === "object" || typeof object === "function");
        if (isSpyingOnEntireObject) {
          const ownMethods = collectOwnMethods(spy);
          forEach(ownMethods, function(method) {
            addToCollection(method);
          });
        } else if (Array.isArray(types)) {
          for (const accessorType of types) {
            addToCollection(spy[accessorType]);
          }
        } else {
          addToCollection(spy);
        }
        return spy;
      }
      sandbox.spy = function spy() {
        const createdSpy = sinonSpy.apply(sinonSpy, arguments);
        return commonPostInitSetup(arguments, createdSpy);
      };
      sandbox.stub = function stub() {
        const createdStub = sinonStub.apply(sinonStub, arguments);
        return commonPostInitSetup(arguments, createdStub);
      };
      sandbox.fake = function fake(f) {
        const s = sinonFake.apply(sinonFake, arguments);
        addToCollection(s);
        return s;
      };
      forEach(Object.keys(sinonFake), function(key) {
        const fakeBehavior = sinonFake[key];
        if (typeof fakeBehavior === "function") {
          sandbox.fake[key] = function() {
            const s = fakeBehavior.apply(fakeBehavior, arguments);
            addToCollection(s);
            return s;
          };
        }
      });
      sandbox.useFakeTimers = function useFakeTimers(args) {
        const clock = sinonClock.useFakeTimers.call(null, args);
        sandbox.clock = clock;
        addToCollection(clock);
        return clock;
      };
      sandbox.verify = function verify() {
        applyOnEach(collection, "verify");
      };
      sandbox.verifyAndRestore = function verifyAndRestore() {
        let exception;
        try {
          sandbox.verify();
        } catch (e) {
          exception = e;
        }
        sandbox.restore();
        if (exception) {
          throw exception;
        }
      };
    }
    Sandbox.prototype.match = match;
    module2.exports = Sandbox;
  }
});

// lib/sinon/create-sandbox.js
var require_create_sandbox = __commonJS({
  "lib/sinon/create-sandbox.js"(exports2, module2) {
    "use strict";
    var arrayProto = require_lib().prototypes.array;
    var Sandbox = require_sandbox();
    var forEach = arrayProto.forEach;
    var push = arrayProto.push;
    function prepareSandboxFromConfig(config) {
      const sandbox = new Sandbox({ assertOptions: config.assertOptions });
      if (config.useFakeTimers) {
        if (typeof config.useFakeTimers === "object") {
          sandbox.useFakeTimers(config.useFakeTimers);
        } else {
          sandbox.useFakeTimers();
        }
      }
      return sandbox;
    }
    function exposeValue(sandbox, config, key, value) {
      if (!value) {
        return;
      }
      if (config.injectInto && !(key in config.injectInto)) {
        config.injectInto[key] = value;
        push(sandbox.injectedKeys, key);
      } else {
        push(sandbox.args, value);
      }
    }
    function createSandbox(config) {
      if (!config) {
        return new Sandbox();
      }
      const configuredSandbox = prepareSandboxFromConfig(config);
      configuredSandbox.args = configuredSandbox.args || [];
      configuredSandbox.injectedKeys = [];
      configuredSandbox.injectInto = config.injectInto;
      const exposed = configuredSandbox.inject({});
      if (config.properties) {
        forEach(config.properties, function(prop) {
          const value = exposed[prop] || prop === "sandbox" && configuredSandbox;
          exposeValue(configuredSandbox, config, prop, value);
        });
      } else {
        exposeValue(configuredSandbox, config, "sandbox");
      }
      return configuredSandbox;
    }
    module2.exports = createSandbox;
  }
});

// lib/sinon/util/core/is-restorable.js
var require_is_restorable = __commonJS({
  "lib/sinon/util/core/is-restorable.js"(exports2, module2) {
    "use strict";
    function isRestorable(obj) {
      return typeof obj === "function" && typeof obj.restore === "function" && obj.restore.sinon;
    }
    module2.exports = isRestorable;
  }
});

// lib/sinon/promise.js
var require_promise = __commonJS({
  "lib/sinon/promise.js"(exports2, module2) {
    "use strict";
    var fake = require_fake();
    var isRestorable = require_is_restorable();
    var STATUS_PENDING = "pending";
    var STATUS_RESOLVED = "resolved";
    var STATUS_REJECTED = "rejected";
    function getFakeExecutor(executor) {
      if (isRestorable(executor)) {
        return executor;
      }
      if (executor) {
        return fake(executor);
      }
      return fake();
    }
    function promise(executor) {
      const fakeExecutor = getFakeExecutor(executor);
      const sinonPromise = new Promise(fakeExecutor);
      sinonPromise.status = STATUS_PENDING;
      sinonPromise.then(function(value) {
        sinonPromise.status = STATUS_RESOLVED;
        sinonPromise.resolvedValue = value;
      }).catch(function(reason) {
        sinonPromise.status = STATUS_REJECTED;
        sinonPromise.rejectedValue = reason;
      });
      function finalize(status, value, callback) {
        if (sinonPromise.status !== STATUS_PENDING) {
          throw new Error(`Promise already ${sinonPromise.status}`);
        }
        sinonPromise.status = status;
        callback(value);
      }
      sinonPromise.resolve = function(value) {
        finalize(STATUS_RESOLVED, value, fakeExecutor.firstCall.args[0]);
        return sinonPromise;
      };
      sinonPromise.reject = function(reason) {
        finalize(STATUS_REJECTED, reason, fakeExecutor.firstCall.args[1]);
        return new Promise(function(resolve) {
          sinonPromise.catch(() => resolve());
        });
      };
      return sinonPromise;
    }
    module2.exports = promise;
  }
});

// lib/sinon/restore-object.js
var require_restore_object = __commonJS({
  "lib/sinon/restore-object.js"(exports2, module2) {
    "use strict";
    var walkObject = require_walk_object();
    function filter(object, property) {
      return object[property].restore && object[property].restore.sinon;
    }
    function restore(object, property) {
      object[property].restore();
    }
    function restoreObject(object) {
      return walkObject(restore, object, filter);
    }
    module2.exports = restoreObject;
  }
});

// lib/create-sinon-api.js
var require_create_sinon_api = __commonJS({
  "lib/create-sinon-api.js"(exports2, module2) {
    "use strict";
    var behavior = require_behavior();
    var createSandbox = require_create_sandbox();
    var extend = require_extend();
    var fakeTimers = require_fake_timers();
    var Sandbox = require_sandbox();
    var stub = require_stub();
    var promise = require_promise();
    module2.exports = function createApi2() {
      const apiMethods = {
        createSandbox,
        match: require_samsam().createMatcher,
        restoreObject: require_restore_object(),
        expectation: require_mock_expectation(),
        // fake timers
        timers: fakeTimers.timers,
        addBehavior: function(name, fn) {
          behavior.addBehavior(stub, name, fn);
        },
        // fake promise
        promise
      };
      const sandbox = new Sandbox();
      return extend(sandbox, apiMethods);
    };
  }
});

// lib/sinon.js
var createApi = require_create_sinon_api();
module.exports = createApi();

if(__exports != exports)module.exports = exports;return module.exports}));
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsibm9kZV9tb2R1bGVzL0BzaW5vbmpzL2NvbW1vbnMvbGliL2dsb2JhbC5qcyIsICJub2RlX21vZHVsZXMvQHNpbm9uanMvY29tbW9ucy9saWIvcHJvdG90eXBlcy90aHJvd3Mtb24tcHJvdG8uanMiLCAibm9kZV9tb2R1bGVzL0BzaW5vbmpzL2NvbW1vbnMvbGliL3Byb3RvdHlwZXMvY29weS1wcm90b3R5cGUtbWV0aG9kcy5qcyIsICJub2RlX21vZHVsZXMvQHNpbm9uanMvY29tbW9ucy9saWIvcHJvdG90eXBlcy9hcnJheS5qcyIsICJub2RlX21vZHVsZXMvQHNpbm9uanMvY29tbW9ucy9saWIvY2FsbGVkLWluLW9yZGVyLmpzIiwgIm5vZGVfbW9kdWxlcy9Ac2lub25qcy9jb21tb25zL2xpYi9jbGFzcy1uYW1lLmpzIiwgIm5vZGVfbW9kdWxlcy9Ac2lub25qcy9jb21tb25zL2xpYi9kZXByZWNhdGVkLmpzIiwgIm5vZGVfbW9kdWxlcy9Ac2lub25qcy9jb21tb25zL2xpYi9ldmVyeS5qcyIsICJub2RlX21vZHVsZXMvQHNpbm9uanMvY29tbW9ucy9saWIvZnVuY3Rpb24tbmFtZS5qcyIsICJub2RlX21vZHVsZXMvQHNpbm9uanMvY29tbW9ucy9saWIvb3JkZXItYnktZmlyc3QtY2FsbC5qcyIsICJub2RlX21vZHVsZXMvQHNpbm9uanMvY29tbW9ucy9saWIvcHJvdG90eXBlcy9mdW5jdGlvbi5qcyIsICJub2RlX21vZHVsZXMvQHNpbm9uanMvY29tbW9ucy9saWIvcHJvdG90eXBlcy9tYXAuanMiLCAibm9kZV9tb2R1bGVzL0BzaW5vbmpzL2NvbW1vbnMvbGliL3Byb3RvdHlwZXMvb2JqZWN0LmpzIiwgIm5vZGVfbW9kdWxlcy9Ac2lub25qcy9jb21tb25zL2xpYi9wcm90b3R5cGVzL3NldC5qcyIsICJub2RlX21vZHVsZXMvQHNpbm9uanMvY29tbW9ucy9saWIvcHJvdG90eXBlcy9zdHJpbmcuanMiLCAibm9kZV9tb2R1bGVzL0BzaW5vbmpzL2NvbW1vbnMvbGliL3Byb3RvdHlwZXMvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL3R5cGUtZGV0ZWN0L3R5cGUtZGV0ZWN0LmpzIiwgIm5vZGVfbW9kdWxlcy9Ac2lub25qcy9jb21tb25zL2xpYi90eXBlLW9mLmpzIiwgIm5vZGVfbW9kdWxlcy9Ac2lub25qcy9jb21tb25zL2xpYi92YWx1ZS10by1zdHJpbmcuanMiLCAibm9kZV9tb2R1bGVzL0BzaW5vbmpzL2NvbW1vbnMvbGliL2luZGV4LmpzIiwgImxpYi9zaW5vbi91dGlsL2NvcmUvZXh0ZW5kLmpzIiwgImxpYi9zaW5vbi91dGlsL2NvcmUvZ2V0LW5leHQtdGljay5qcyIsICJsaWIvc2lub24vdXRpbC9jb3JlL25leHQtdGljay5qcyIsICJsaWIvc2lub24vdXRpbC9jb3JlL2V4cG9ydC1hc3luYy1iZWhhdmlvcnMuanMiLCAibGliL3Npbm9uL2JlaGF2aW9yLmpzIiwgImxpYi9zaW5vbi91dGlsL2NvcmUvd2Fsay5qcyIsICJsaWIvc2lub24vdXRpbC9jb3JlL2dldC1wcm9wZXJ0eS1kZXNjcmlwdG9yLmpzIiwgImxpYi9zaW5vbi9jb2xsZWN0LW93bi1tZXRob2RzLmpzIiwgImxpYi9zaW5vbi91dGlsL2NvcmUvaXMtcHJvcGVydHktY29uZmlndXJhYmxlLmpzIiwgIm5vZGVfbW9kdWxlcy9Ac2lub25qcy9zYW1zYW0vbGliL2lzLW5hbi5qcyIsICJub2RlX21vZHVsZXMvQHNpbm9uanMvc2Ftc2FtL2xpYi9pcy1uZWctemVyby5qcyIsICJub2RlX21vZHVsZXMvQHNpbm9uanMvc2Ftc2FtL2xpYi9pZGVudGljYWwuanMiLCAibm9kZV9tb2R1bGVzL0BzaW5vbmpzL3NhbXNhbS9saWIvZ2V0LWNsYXNzLmpzIiwgIm5vZGVfbW9kdWxlcy9Ac2lub25qcy9zYW1zYW0vbGliL2lzLWFyZ3VtZW50cy5qcyIsICJub2RlX21vZHVsZXMvQHNpbm9uanMvc2Ftc2FtL2xpYi9pcy1lbGVtZW50LmpzIiwgIm5vZGVfbW9kdWxlcy9Ac2lub25qcy9zYW1zYW0vbGliL2lzLXNldC5qcyIsICJub2RlX21vZHVsZXMvQHNpbm9uanMvc2Ftc2FtL2xpYi9pcy1tYXAuanMiLCAibm9kZV9tb2R1bGVzL0BzaW5vbmpzL3NhbXNhbS9ub2RlX21vZHVsZXMvdHlwZS1kZXRlY3QvdHlwZS1kZXRlY3QuanMiLCAibm9kZV9tb2R1bGVzL0BzaW5vbmpzL3NhbXNhbS9saWIvYXJyYXktdHlwZXMuanMiLCAibm9kZV9tb2R1bGVzL0BzaW5vbmpzL3NhbXNhbS9saWIvaXMtYXJyYXktdHlwZS5qcyIsICJub2RlX21vZHVsZXMvQHNpbm9uanMvc2Ftc2FtL2xpYi9pcy1kYXRlLmpzIiwgIm5vZGVfbW9kdWxlcy9Ac2lub25qcy9zYW1zYW0vbGliL2lzLWl0ZXJhYmxlLmpzIiwgIm5vZGVfbW9kdWxlcy9Ac2lub25qcy9zYW1zYW0vbGliL2lzLW9iamVjdC5qcyIsICJub2RlX21vZHVsZXMvQHNpbm9uanMvc2Ftc2FtL2xpYi9pcy1zdWJzZXQuanMiLCAibm9kZV9tb2R1bGVzL0BzaW5vbmpzL3NhbXNhbS9saWIvZGVlcC1lcXVhbC5qcyIsICJub2RlX21vZHVsZXMvQHNpbm9uanMvc2Ftc2FtL2xpYi9pdGVyYWJsZS10by1zdHJpbmcuanMiLCAibm9kZV9tb2R1bGVzL0BzaW5vbmpzL3NhbXNhbS9saWIvY3JlYXRlLW1hdGNoZXIvbWF0Y2hlci1wcm90b3R5cGUuanMiLCAibm9kZV9tb2R1bGVzL0BzaW5vbmpzL3NhbXNhbS9saWIvY3JlYXRlLW1hdGNoZXIvaXMtbWF0Y2hlci5qcyIsICJub2RlX21vZHVsZXMvQHNpbm9uanMvc2Ftc2FtL2xpYi9jcmVhdGUtbWF0Y2hlci9hc3NlcnQtbWF0Y2hlci5qcyIsICJub2RlX21vZHVsZXMvQHNpbm9uanMvc2Ftc2FtL2xpYi9jcmVhdGUtbWF0Y2hlci9hc3NlcnQtbWV0aG9kLWV4aXN0cy5qcyIsICJub2RlX21vZHVsZXMvQHNpbm9uanMvc2Ftc2FtL2xpYi9jcmVhdGUtbWF0Y2hlci9hc3NlcnQtdHlwZS5qcyIsICJub2RlX21vZHVsZXMvQHNpbm9uanMvc2Ftc2FtL2xpYi9jcmVhdGUtbWF0Y2hlci9pcy1pdGVyYWJsZS5qcyIsICJub2RlX21vZHVsZXMvQHNpbm9uanMvc2Ftc2FtL2xpYi9jcmVhdGUtbWF0Y2hlci9tYXRjaC1vYmplY3QuanMiLCAibm9kZV9tb2R1bGVzL0BzaW5vbmpzL3NhbXNhbS9saWIvY3JlYXRlLW1hdGNoZXIvdHlwZS1tYXAuanMiLCAibm9kZV9tb2R1bGVzL0BzaW5vbmpzL3NhbXNhbS9saWIvY3JlYXRlLW1hdGNoZXIuanMiLCAibm9kZV9tb2R1bGVzL0BzaW5vbmpzL3NhbXNhbS9saWIvbWF0Y2guanMiLCAibm9kZV9tb2R1bGVzL0BzaW5vbmpzL3NhbXNhbS9saWIvc2Ftc2FtLmpzIiwgImxpYi9zaW5vbi91dGlsL2NvcmUvdGltZXMtaW4td29yZHMuanMiLCAibm9kZV9tb2R1bGVzL2hhcy1zeW1ib2xzL3NoYW1zLmpzIiwgIm5vZGVfbW9kdWxlcy9oYXMtdG9zdHJpbmd0YWcvc2hhbXMuanMiLCAibm9kZV9tb2R1bGVzL2VzLWVycm9ycy9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvZXMtZXJyb3JzL2V2YWwuanMiLCAibm9kZV9tb2R1bGVzL2VzLWVycm9ycy9yYW5nZS5qcyIsICJub2RlX21vZHVsZXMvZXMtZXJyb3JzL3JlZi5qcyIsICJub2RlX21vZHVsZXMvZXMtZXJyb3JzL3N5bnRheC5qcyIsICJub2RlX21vZHVsZXMvZXMtZXJyb3JzL3R5cGUuanMiLCAibm9kZV9tb2R1bGVzL2VzLWVycm9ycy91cmkuanMiLCAibm9kZV9tb2R1bGVzL2hhcy1zeW1ib2xzL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9oYXMtcHJvdG8vaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL2Z1bmN0aW9uLWJpbmQvaW1wbGVtZW50YXRpb24uanMiLCAibm9kZV9tb2R1bGVzL2Z1bmN0aW9uLWJpbmQvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL2hhc293bi9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvZ2V0LWludHJpbnNpYy9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvZXMtZGVmaW5lLXByb3BlcnR5L2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9nb3BkL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9kZWZpbmUtZGF0YS1wcm9wZXJ0eS9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvaGFzLXByb3BlcnR5LWRlc2NyaXB0b3JzL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9zZXQtZnVuY3Rpb24tbGVuZ3RoL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9jYWxsLWJpbmQvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL2NhbGwtYmluZC9jYWxsQm91bmQuanMiLCAibm9kZV9tb2R1bGVzL2lzLWFyZ3VtZW50cy9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvaXMtZ2VuZXJhdG9yLWZ1bmN0aW9uL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9pcy1jYWxsYWJsZS9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvZm9yLWVhY2gvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL3Bvc3NpYmxlLXR5cGVkLWFycmF5LW5hbWVzL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9hdmFpbGFibGUtdHlwZWQtYXJyYXlzL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy93aGljaC10eXBlZC1hcnJheS9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvaXMtdHlwZWQtYXJyYXkvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL3V0aWwvc3VwcG9ydC90eXBlcy5qcyIsICJub2RlX21vZHVsZXMvdXRpbC9zdXBwb3J0L2lzQnVmZmVyQnJvd3Nlci5qcyIsICJub2RlX21vZHVsZXMvaW5oZXJpdHMvaW5oZXJpdHNfYnJvd3Nlci5qcyIsICJub2RlX21vZHVsZXMvdXRpbC91dGlsLmpzIiwgImxpYi9zaW5vbi9hc3NlcnQuanMiLCAibm9kZV9tb2R1bGVzL0BzaW5vbmpzL2Zha2UtdGltZXJzL3NyYy9mYWtlLXRpbWVycy1zcmMuanMiLCAibGliL3Npbm9uL3V0aWwvZmFrZS10aW1lcnMuanMiLCAibGliL3Npbm9uL3Byb3h5LWNhbGwtdXRpbC5qcyIsICJsaWIvc2lub24vcHJveHktaW52b2tlLmpzIiwgImxpYi9zaW5vbi9wcm94eS1jYWxsLmpzIiwgImxpYi9zaW5vbi9kZWZhdWx0LWJlaGF2aW9ycy5qcyIsICJsaWIvc2lub24vdXRpbC9jb3JlL2Z1bmN0aW9uLXRvLXN0cmluZy5qcyIsICJub2RlX21vZHVsZXMvc3VwcG9ydHMtY29sb3IvYnJvd3Nlci5qcyIsICJsaWIvc2lub24vY29sb3JpemVyLmpzIiwgIm5vZGVfbW9kdWxlcy9kaWZmL2xpYmNqcy9kaWZmL2Jhc2UuanMiLCAibm9kZV9tb2R1bGVzL2RpZmYvbGliY2pzL2RpZmYvY2hhcmFjdGVyLmpzIiwgIm5vZGVfbW9kdWxlcy9kaWZmL2xpYmNqcy91dGlsL3N0cmluZy5qcyIsICJub2RlX21vZHVsZXMvZGlmZi9saWJjanMvZGlmZi93b3JkLmpzIiwgIm5vZGVfbW9kdWxlcy9kaWZmL2xpYmNqcy91dGlsL3BhcmFtcy5qcyIsICJub2RlX21vZHVsZXMvZGlmZi9saWJjanMvZGlmZi9saW5lLmpzIiwgIm5vZGVfbW9kdWxlcy9kaWZmL2xpYmNqcy9kaWZmL3NlbnRlbmNlLmpzIiwgIm5vZGVfbW9kdWxlcy9kaWZmL2xpYmNqcy9kaWZmL2Nzcy5qcyIsICJub2RlX21vZHVsZXMvZGlmZi9saWJjanMvZGlmZi9qc29uLmpzIiwgIm5vZGVfbW9kdWxlcy9kaWZmL2xpYmNqcy9kaWZmL2FycmF5LmpzIiwgIm5vZGVfbW9kdWxlcy9kaWZmL2xpYmNqcy9wYXRjaC9saW5lLWVuZGluZ3MuanMiLCAibm9kZV9tb2R1bGVzL2RpZmYvbGliY2pzL3BhdGNoL3BhcnNlLmpzIiwgIm5vZGVfbW9kdWxlcy9kaWZmL2xpYmNqcy91dGlsL2Rpc3RhbmNlLWl0ZXJhdG9yLmpzIiwgIm5vZGVfbW9kdWxlcy9kaWZmL2xpYmNqcy9wYXRjaC9hcHBseS5qcyIsICJub2RlX21vZHVsZXMvZGlmZi9saWJjanMvcGF0Y2gvcmV2ZXJzZS5qcyIsICJub2RlX21vZHVsZXMvZGlmZi9saWJjanMvcGF0Y2gvY3JlYXRlLmpzIiwgIm5vZGVfbW9kdWxlcy9kaWZmL2xpYmNqcy9jb252ZXJ0L2RtcC5qcyIsICJub2RlX21vZHVsZXMvZGlmZi9saWJjanMvY29udmVydC94bWwuanMiLCAibm9kZV9tb2R1bGVzL2RpZmYvbGliY2pzL2luZGV4LmpzIiwgImxpYi9zaW5vbi9zcHktZm9ybWF0dGVycy5qcyIsICJsaWIvc2lub24vcHJveHkuanMiLCAibGliL3Npbm9uL3V0aWwvY29yZS9pcy1ub24tZXhpc3RlbnQtcHJvcGVydHkuanMiLCAibGliL3Npbm9uL3V0aWwvY29yZS9pcy1lcy1tb2R1bGUuanMiLCAibGliL3Npbm9uL3V0aWwvY29yZS93YWxrLW9iamVjdC5qcyIsICJsaWIvc2lub24vdXRpbC9jb3JlL3Npbm9uLXR5cGUuanMiLCAibGliL3Npbm9uL3V0aWwvY29yZS93cmFwLW1ldGhvZC5qcyIsICJsaWIvc2lub24vc3B5LmpzIiwgImxpYi9zaW5vbi90aHJvdy1vbi1mYWxzeS1vYmplY3QuanMiLCAibGliL3Npbm9uL3N0dWIuanMiLCAibGliL3Npbm9uL21vY2stZXhwZWN0YXRpb24uanMiLCAibGliL3Npbm9uL21vY2suanMiLCAibGliL3Npbm9uL2NyZWF0ZS1zdHViLWluc3RhbmNlLmpzIiwgImxpYi9zaW5vbi9mYWtlLmpzIiwgImxpYi9zaW5vbi9zYW5kYm94LmpzIiwgImxpYi9zaW5vbi9jcmVhdGUtc2FuZGJveC5qcyIsICJsaWIvc2lub24vdXRpbC9jb3JlL2lzLXJlc3RvcmFibGUuanMiLCAibGliL3Npbm9uL3Byb21pc2UuanMiLCAibGliL3Npbm9uL3Jlc3RvcmUtb2JqZWN0LmpzIiwgImxpYi9jcmVhdGUtc2lub24tYXBpLmpzIiwgImxpYi9zaW5vbi5qcyJdLAogICJzb3VyY2VzQ29udGVudCI6IFsiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogQSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3RcbiAqIEB0eXBlIHtvYmplY3R9IGdsb2JhbE9iamVjdFxuICovXG52YXIgZ2xvYmFsT2JqZWN0O1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuaWYgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAvLyBOb2RlXG4gICAgZ2xvYmFsT2JqZWN0ID0gZ2xvYmFsO1xufSBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgLy8gQnJvd3NlclxuICAgIGdsb2JhbE9iamVjdCA9IHdpbmRvdztcbn0gZWxzZSB7XG4gICAgLy8gV2ViV29ya2VyXG4gICAgZ2xvYmFsT2JqZWN0ID0gc2VsZjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnbG9iYWxPYmplY3Q7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogSXMgdHJ1ZSB3aGVuIHRoZSBlbnZpcm9ubWVudCBjYXVzZXMgYW4gZXJyb3IgdG8gYmUgdGhyb3duIGZvciBhY2Nlc3NpbmcgdGhlXG4gKiBfX3Byb3RvX18gcHJvcGVydHkuXG4gKiBUaGlzIGlzIG5lY2Vzc2FyeSBpbiBvcmRlciB0byBzdXBwb3J0IGBub2RlIC0tZGlzYWJsZS1wcm90bz10aHJvd2AuXG4gKlxuICogU2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9wcm90b1xuICogQHR5cGUge2Jvb2xlYW59XG4gKi9cbmxldCB0aHJvd3NPblByb3RvO1xudHJ5IHtcbiAgICBjb25zdCBvYmplY3QgPSB7fTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG8sIG5vLXVudXNlZC1leHByZXNzaW9uc1xuICAgIG9iamVjdC5fX3Byb3RvX187XG4gICAgdGhyb3dzT25Qcm90byA9IGZhbHNlO1xufSBjYXRjaCAoXykge1xuICAgIC8vIFRoaXMgYnJhbmNoIGlzIGNvdmVyZWQgd2hlbiB0ZXN0cyBhcmUgcnVuIHdpdGggYC0tZGlzYWJsZS1wcm90bz10aHJvd2AsXG4gICAgLy8gaG93ZXZlciB3ZSBjYW4gdGVzdCBib3RoIGJyYW5jaGVzIGF0IHRoZSBzYW1lIHRpbWUsIHNvIHRoaXMgaXMgaWdub3JlZFxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgdGhyb3dzT25Qcm90byA9IHRydWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdGhyb3dzT25Qcm90bztcbiIsICJcInVzZSBzdHJpY3RcIjtcblxudmFyIGNhbGwgPSBGdW5jdGlvbi5jYWxsO1xudmFyIHRocm93c09uUHJvdG8gPSByZXF1aXJlKFwiLi90aHJvd3Mtb24tcHJvdG9cIik7XG5cbnZhciBkaXNhbGxvd2VkUHJvcGVydGllcyA9IFtcbiAgICAvLyBpZ25vcmUgc2l6ZSBiZWNhdXNlIGl0IHRocm93cyBmcm9tIE1hcFxuICAgIFwic2l6ZVwiLFxuICAgIFwiY2FsbGVyXCIsXG4gICAgXCJjYWxsZWVcIixcbiAgICBcImFyZ3VtZW50c1wiLFxuXTtcblxuLy8gVGhpcyBicmFuY2ggaXMgY292ZXJlZCB3aGVuIHRlc3RzIGFyZSBydW4gd2l0aCBgLS1kaXNhYmxlLXByb3RvPXRocm93YCxcbi8vIGhvd2V2ZXIgd2UgY2FuIHRlc3QgYm90aCBicmFuY2hlcyBhdCB0aGUgc2FtZSB0aW1lLCBzbyB0aGlzIGlzIGlnbm9yZWRcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5pZiAodGhyb3dzT25Qcm90bykge1xuICAgIGRpc2FsbG93ZWRQcm9wZXJ0aWVzLnB1c2goXCJfX3Byb3RvX19cIik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY29weVByb3RvdHlwZU1ldGhvZHMocHJvdG90eXBlKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEBzaW5vbmpzL25vLXByb3RvdHlwZS1tZXRob2RzL25vLXByb3RvdHlwZS1tZXRob2RzXG4gICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHByb3RvdHlwZSkucmVkdWNlKGZ1bmN0aW9uIChcbiAgICAgICAgcmVzdWx0LFxuICAgICAgICBuYW1lXG4gICAgKSB7XG4gICAgICAgIGlmIChkaXNhbGxvd2VkUHJvcGVydGllcy5pbmNsdWRlcyhuYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgcHJvdG90eXBlW25hbWVdICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHRbbmFtZV0gPSBjYWxsLmJpbmQocHJvdG90eXBlW25hbWVdKTtcblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG4gICAgT2JqZWN0LmNyZWF0ZShudWxsKSk7XG59O1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG52YXIgY29weVByb3RvdHlwZSA9IHJlcXVpcmUoXCIuL2NvcHktcHJvdG90eXBlLW1ldGhvZHNcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gY29weVByb3RvdHlwZShBcnJheS5wcm90b3R5cGUpO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG52YXIgZXZlcnkgPSByZXF1aXJlKFwiLi9wcm90b3R5cGVzL2FycmF5XCIpLmV2ZXJ5O1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGhhc0NhbGxzTGVmdChjYWxsTWFwLCBzcHkpIHtcbiAgICBpZiAoY2FsbE1hcFtzcHkuaWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY2FsbE1hcFtzcHkuaWRdID0gMDtcbiAgICB9XG5cbiAgICByZXR1cm4gY2FsbE1hcFtzcHkuaWRdIDwgc3B5LmNhbGxDb3VudDtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjaGVja0FkamFjZW50Q2FsbHMoY2FsbE1hcCwgc3B5LCBpbmRleCwgc3BpZXMpIHtcbiAgICB2YXIgY2FsbGVkQmVmb3JlTmV4dCA9IHRydWU7XG5cbiAgICBpZiAoaW5kZXggIT09IHNwaWVzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgY2FsbGVkQmVmb3JlTmV4dCA9IHNweS5jYWxsZWRCZWZvcmUoc3BpZXNbaW5kZXggKyAxXSk7XG4gICAgfVxuXG4gICAgaWYgKGhhc0NhbGxzTGVmdChjYWxsTWFwLCBzcHkpICYmIGNhbGxlZEJlZm9yZU5leHQpIHtcbiAgICAgICAgY2FsbE1hcFtzcHkuaWRdICs9IDE7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBBIFNpbm9uIHByb3h5IG9iamVjdCAoZmFrZSwgc3B5LCBzdHViKVxuICogQHR5cGVkZWYge29iamVjdH0gU2lub25Qcm94eVxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gY2FsbGVkQmVmb3JlIC0gQSBtZXRob2QgdGhhdCBkZXRlcm1pbmVzIGlmIHRoaXMgcHJveHkgd2FzIGNhbGxlZCBiZWZvcmUgYW5vdGhlciBvbmVcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBpZCAtIFNvbWUgaWRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjYWxsQ291bnQgLSBOdW1iZXIgb2YgdGltZXMgdGhpcyBwcm94eSBoYXMgYmVlbiBjYWxsZWRcbiAqL1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSB3aGVuIHRoZSBzcGllcyBoYXZlIGJlZW4gY2FsbGVkIGluIHRoZSBvcmRlciB0aGV5IHdlcmUgc3VwcGxpZWQgaW5cbiAqIEBwYXJhbSAge1Npbm9uUHJveHlbXSB8IFNpbm9uUHJveHl9IHNwaWVzIEFuIGFycmF5IG9mIHByb3hpZXMsIG9yIHNldmVyYWwgcHJveGllcyBhcyBhcmd1bWVudHNcbiAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIHdoZW4gc3BpZXMgYXJlIGNhbGxlZCBpbiBvcmRlciwgZmFsc2Ugb3RoZXJ3aXNlXG4gKi9cbmZ1bmN0aW9uIGNhbGxlZEluT3JkZXIoc3BpZXMpIHtcbiAgICB2YXIgY2FsbE1hcCA9IHt9O1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlcnNjb3JlLWRhbmdsZVxuICAgIHZhciBfc3BpZXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50cyA6IHNwaWVzO1xuXG4gICAgcmV0dXJuIGV2ZXJ5KF9zcGllcywgY2hlY2tBZGphY2VudENhbGxzLmJpbmQobnVsbCwgY2FsbE1hcCkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNhbGxlZEluT3JkZXI7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogUmV0dXJucyBhIGRpc3BsYXkgbmFtZSBmb3IgYSB2YWx1ZSBmcm9tIGEgY29uc3RydWN0b3JcbiAqIEBwYXJhbSAge29iamVjdH0gdmFsdWUgQSB2YWx1ZSB0byBleGFtaW5lXG4gKiBAcmV0dXJucyB7KHN0cmluZ3xudWxsKX0gQSBzdHJpbmcgb3IgbnVsbFxuICovXG5mdW5jdGlvbiBjbGFzc05hbWUodmFsdWUpIHtcbiAgICBjb25zdCBuYW1lID0gdmFsdWUuY29uc3RydWN0b3IgJiYgdmFsdWUuY29uc3RydWN0b3IubmFtZTtcbiAgICByZXR1cm4gbmFtZSB8fCBudWxsO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzTmFtZTtcbiIsICIvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25zb2xlICovXG5cInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCB3aWxsIGludm9rZSB0aGUgc3VwcGxpZWQgZnVuY3Rpb24gYW5kIHByaW50IGFcbiAqIGRlcHJlY2F0aW9uIHdhcm5pbmcgdG8gdGhlIGNvbnNvbGUgZWFjaCB0aW1lIGl0IGlzIGNhbGxlZC5cbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBmdW5jXG4gKiBAcGFyYW0gIHtzdHJpbmd9IG1zZ1xuICogQHJldHVybnMge0Z1bmN0aW9ufVxuICovXG5leHBvcnRzLndyYXAgPSBmdW5jdGlvbiAoZnVuYywgbXNnKSB7XG4gICAgdmFyIHdyYXBwZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGV4cG9ydHMucHJpbnRXYXJuaW5nKG1zZyk7XG4gICAgICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgICBpZiAoZnVuYy5wcm90b3R5cGUpIHtcbiAgICAgICAgd3JhcHBlZC5wcm90b3R5cGUgPSBmdW5jLnByb3RvdHlwZTtcbiAgICB9XG4gICAgcmV0dXJuIHdyYXBwZWQ7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBzdHJpbmcgd2hpY2ggY2FuIGJlIHN1cHBsaWVkIHRvIGB3cmFwKClgIHRvIG5vdGlmeSB0aGUgdXNlciB0aGF0IGFcbiAqIHBhcnRpY3VsYXIgcGFydCBvZiB0aGUgc2lub24gQVBJIGhhcyBiZWVuIGRlcHJlY2F0ZWQuXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHBhY2thZ2VOYW1lXG4gKiBAcGFyYW0gIHtzdHJpbmd9IGZ1bmNOYW1lXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5leHBvcnRzLmRlZmF1bHRNc2cgPSBmdW5jdGlvbiAocGFja2FnZU5hbWUsIGZ1bmNOYW1lKSB7XG4gICAgcmV0dXJuIGAke3BhY2thZ2VOYW1lfS4ke2Z1bmNOYW1lfSBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgZnJvbSB0aGUgcHVibGljIEFQSSBpbiBhIGZ1dHVyZSB2ZXJzaW9uIG9mICR7cGFja2FnZU5hbWV9LmA7XG59O1xuXG4vKipcbiAqIFByaW50cyBhIHdhcm5pbmcgb24gdGhlIGNvbnNvbGUsIHdoZW4gaXQgZXhpc3RzXG4gKiBAcGFyYW0gIHtzdHJpbmd9IG1zZ1xuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqL1xuZXhwb3J0cy5wcmludFdhcm5pbmcgPSBmdW5jdGlvbiAobXNnKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBpZiAodHlwZW9mIHByb2Nlc3MgPT09IFwib2JqZWN0XCIgJiYgcHJvY2Vzcy5lbWl0V2FybmluZykge1xuICAgICAgICAvLyBFbWl0IFdhcm5pbmdzIGluIE5vZGVcbiAgICAgICAgcHJvY2Vzcy5lbWl0V2FybmluZyhtc2cpO1xuICAgIH0gZWxzZSBpZiAoY29uc29sZS5pbmZvKSB7XG4gICAgICAgIGNvbnNvbGUuaW5mbyhtc2cpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUubG9nKG1zZyk7XG4gICAgfVxufTtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgd2hlbiBmbiByZXR1cm5zIHRydWUgZm9yIGFsbCBtZW1iZXJzIG9mIG9iai5cbiAqIFRoaXMgaXMgYW4gZXZlcnkgaW1wbGVtZW50YXRpb24gdGhhdCB3b3JrcyBmb3IgYWxsIGl0ZXJhYmxlc1xuICogQHBhcmFtICB7b2JqZWN0fSAgIG9ialxuICogQHBhcmFtICB7RnVuY3Rpb259IGZuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBldmVyeShvYmosIGZuKSB7XG4gICAgdmFyIHBhc3MgPSB0cnVlO1xuXG4gICAgdHJ5IHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEBzaW5vbmpzL25vLXByb3RvdHlwZS1tZXRob2RzL25vLXByb3RvdHlwZS1tZXRob2RzXG4gICAgICAgIG9iai5mb3JFYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKSkge1xuICAgICAgICAgICAgICAgIC8vIFRocm93aW5nIGFuIGVycm9yIGlzIHRoZSBvbmx5IHdheSB0byBicmVhayBgZm9yRWFjaGBcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBwYXNzID0gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhc3M7XG59O1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIFJldHVybnMgYSBkaXNwbGF5IG5hbWUgZm9yIGEgZnVuY3Rpb25cbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBmdW5jXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGZ1bmN0aW9uTmFtZShmdW5jKSB7XG4gICAgaWYgKCFmdW5jKSB7XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBmdW5jLmRpc3BsYXlOYW1lIHx8XG4gICAgICAgICAgICBmdW5jLm5hbWUgfHxcbiAgICAgICAgICAgIC8vIFVzZSBmdW5jdGlvbiBkZWNvbXBvc2l0aW9uIGFzIGEgbGFzdCByZXNvcnQgdG8gZ2V0IGZ1bmN0aW9uXG4gICAgICAgICAgICAvLyBuYW1lLiBEb2VzIG5vdCByZWx5IG9uIGZ1bmN0aW9uIGRlY29tcG9zaXRpb24gdG8gd29yayAtIGlmIGl0XG4gICAgICAgICAgICAvLyBkb2Vzbid0IGRlYnVnZ2luZyB3aWxsIGJlIHNsaWdodGx5IGxlc3MgaW5mb3JtYXRpdmVcbiAgICAgICAgICAgIC8vIChpLmUuIHRvU3RyaW5nIHdpbGwgc2F5ICdzcHknIHJhdGhlciB0aGFuICdteUZ1bmMnKS5cbiAgICAgICAgICAgIChTdHJpbmcoZnVuYykubWF0Y2goL2Z1bmN0aW9uIChbXlxccyhdKykvKSB8fCBbXSlbMV1cbiAgICAgICAgKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIFN0cmluZ2lmeSBtYXkgZmFpbCBhbmQgd2UgbWlnaHQgZ2V0IGFuIGV4Y2VwdGlvbiwgYXMgYSBsYXN0LWxhc3RcbiAgICAgICAgLy8gcmVzb3J0IGZhbGwgYmFjayB0byBlbXB0eSBzdHJpbmcuXG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbn07XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBzb3J0ID0gcmVxdWlyZShcIi4vcHJvdG90eXBlcy9hcnJheVwiKS5zb3J0O1xudmFyIHNsaWNlID0gcmVxdWlyZShcIi4vcHJvdG90eXBlcy9hcnJheVwiKS5zbGljZTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjb21wYXJhdG9yKGEsIGIpIHtcbiAgICAvLyB1dWlkLCB3b24ndCBldmVyIGJlIGVxdWFsXG4gICAgdmFyIGFDYWxsID0gYS5nZXRDYWxsKDApO1xuICAgIHZhciBiQ2FsbCA9IGIuZ2V0Q2FsbCgwKTtcbiAgICB2YXIgYUlkID0gKGFDYWxsICYmIGFDYWxsLmNhbGxJZCkgfHwgLTE7XG4gICAgdmFyIGJJZCA9IChiQ2FsbCAmJiBiQ2FsbC5jYWxsSWQpIHx8IC0xO1xuXG4gICAgcmV0dXJuIGFJZCA8IGJJZCA/IC0xIDogMTtcbn1cblxuLyoqXG4gKiBBIFNpbm9uIHByb3h5IG9iamVjdCAoZmFrZSwgc3B5LCBzdHViKVxuICogQHR5cGVkZWYge29iamVjdH0gU2lub25Qcm94eVxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gZ2V0Q2FsbCAtIEEgbWV0aG9kIHRoYXQgY2FuIHJldHVybiB0aGUgZmlyc3QgY2FsbFxuICovXG5cbi8qKlxuICogU29ydHMgYW4gYXJyYXkgb2YgU2lub25Qcm94eSBpbnN0YW5jZXMgKGZha2UsIHNweSwgc3R1YikgYnkgdGhlaXIgZmlyc3QgY2FsbFxuICogQHBhcmFtICB7U2lub25Qcm94eVtdIHwgU2lub25Qcm94eX0gc3BpZXNcbiAqIEByZXR1cm5zIHtTaW5vblByb3h5W119XG4gKi9cbmZ1bmN0aW9uIG9yZGVyQnlGaXJzdENhbGwoc3BpZXMpIHtcbiAgICByZXR1cm4gc29ydChzbGljZShzcGllcyksIGNvbXBhcmF0b3IpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG9yZGVyQnlGaXJzdENhbGw7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBjb3B5UHJvdG90eXBlID0gcmVxdWlyZShcIi4vY29weS1wcm90b3R5cGUtbWV0aG9kc1wiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBjb3B5UHJvdG90eXBlKEZ1bmN0aW9uLnByb3RvdHlwZSk7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBjb3B5UHJvdG90eXBlID0gcmVxdWlyZShcIi4vY29weS1wcm90b3R5cGUtbWV0aG9kc1wiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBjb3B5UHJvdG90eXBlKE1hcC5wcm90b3R5cGUpO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG52YXIgY29weVByb3RvdHlwZSA9IHJlcXVpcmUoXCIuL2NvcHktcHJvdG90eXBlLW1ldGhvZHNcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gY29weVByb3RvdHlwZShPYmplY3QucHJvdG90eXBlKTtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxudmFyIGNvcHlQcm90b3R5cGUgPSByZXF1aXJlKFwiLi9jb3B5LXByb3RvdHlwZS1tZXRob2RzXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNvcHlQcm90b3R5cGUoU2V0LnByb3RvdHlwZSk7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBjb3B5UHJvdG90eXBlID0gcmVxdWlyZShcIi4vY29weS1wcm90b3R5cGUtbWV0aG9kc1wiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBjb3B5UHJvdG90eXBlKFN0cmluZy5wcm90b3R5cGUpO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBhcnJheTogcmVxdWlyZShcIi4vYXJyYXlcIiksXG4gICAgZnVuY3Rpb246IHJlcXVpcmUoXCIuL2Z1bmN0aW9uXCIpLFxuICAgIG1hcDogcmVxdWlyZShcIi4vbWFwXCIpLFxuICAgIG9iamVjdDogcmVxdWlyZShcIi4vb2JqZWN0XCIpLFxuICAgIHNldDogcmVxdWlyZShcIi4vc2V0XCIpLFxuICAgIHN0cmluZzogcmVxdWlyZShcIi4vc3RyaW5nXCIpLFxufTtcbiIsICIoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuXHR0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKSA6XG5cdHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShmYWN0b3J5KSA6XG5cdChnbG9iYWwudHlwZURldGVjdCA9IGZhY3RvcnkoKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcblxuLyogIVxuICogdHlwZS1kZXRlY3RcbiAqIENvcHlyaWdodChjKSAyMDEzIGpha2UgbHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cbnZhciBwcm9taXNlRXhpc3RzID0gdHlwZW9mIFByb21pc2UgPT09ICdmdW5jdGlvbic7XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXVuZGVmICovXG52YXIgZ2xvYmFsT2JqZWN0ID0gdHlwZW9mIHNlbGYgPT09ICdvYmplY3QnID8gc2VsZiA6IGdsb2JhbDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBpZC1ibGFja2xpc3RcblxudmFyIHN5bWJvbEV4aXN0cyA9IHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnO1xudmFyIG1hcEV4aXN0cyA9IHR5cGVvZiBNYXAgIT09ICd1bmRlZmluZWQnO1xudmFyIHNldEV4aXN0cyA9IHR5cGVvZiBTZXQgIT09ICd1bmRlZmluZWQnO1xudmFyIHdlYWtNYXBFeGlzdHMgPSB0eXBlb2YgV2Vha01hcCAhPT0gJ3VuZGVmaW5lZCc7XG52YXIgd2Vha1NldEV4aXN0cyA9IHR5cGVvZiBXZWFrU2V0ICE9PSAndW5kZWZpbmVkJztcbnZhciBkYXRhVmlld0V4aXN0cyA9IHR5cGVvZiBEYXRhVmlldyAhPT0gJ3VuZGVmaW5lZCc7XG52YXIgc3ltYm9sSXRlcmF0b3JFeGlzdHMgPSBzeW1ib2xFeGlzdHMgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciAhPT0gJ3VuZGVmaW5lZCc7XG52YXIgc3ltYm9sVG9TdHJpbmdUYWdFeGlzdHMgPSBzeW1ib2xFeGlzdHMgJiYgdHlwZW9mIFN5bWJvbC50b1N0cmluZ1RhZyAhPT0gJ3VuZGVmaW5lZCc7XG52YXIgc2V0RW50cmllc0V4aXN0cyA9IHNldEV4aXN0cyAmJiB0eXBlb2YgU2V0LnByb3RvdHlwZS5lbnRyaWVzID09PSAnZnVuY3Rpb24nO1xudmFyIG1hcEVudHJpZXNFeGlzdHMgPSBtYXBFeGlzdHMgJiYgdHlwZW9mIE1hcC5wcm90b3R5cGUuZW50cmllcyA9PT0gJ2Z1bmN0aW9uJztcbnZhciBzZXRJdGVyYXRvclByb3RvdHlwZSA9IHNldEVudHJpZXNFeGlzdHMgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKG5ldyBTZXQoKS5lbnRyaWVzKCkpO1xudmFyIG1hcEl0ZXJhdG9yUHJvdG90eXBlID0gbWFwRW50cmllc0V4aXN0cyAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YobmV3IE1hcCgpLmVudHJpZXMoKSk7XG52YXIgYXJyYXlJdGVyYXRvckV4aXN0cyA9IHN5bWJvbEl0ZXJhdG9yRXhpc3RzICYmIHR5cGVvZiBBcnJheS5wcm90b3R5cGVbU3ltYm9sLml0ZXJhdG9yXSA9PT0gJ2Z1bmN0aW9uJztcbnZhciBhcnJheUl0ZXJhdG9yUHJvdG90eXBlID0gYXJyYXlJdGVyYXRvckV4aXN0cyAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoW11bU3ltYm9sLml0ZXJhdG9yXSgpKTtcbnZhciBzdHJpbmdJdGVyYXRvckV4aXN0cyA9IHN5bWJvbEl0ZXJhdG9yRXhpc3RzICYmIHR5cGVvZiBTdHJpbmcucHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl0gPT09ICdmdW5jdGlvbic7XG52YXIgc3RyaW5nSXRlcmF0b3JQcm90b3R5cGUgPSBzdHJpbmdJdGVyYXRvckV4aXN0cyAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoJydbU3ltYm9sLml0ZXJhdG9yXSgpKTtcbnZhciB0b1N0cmluZ0xlZnRTbGljZUxlbmd0aCA9IDg7XG52YXIgdG9TdHJpbmdSaWdodFNsaWNlTGVuZ3RoID0gLTE7XG4vKipcbiAqICMjIyB0eXBlT2YgKG9iailcbiAqXG4gKiBVc2VzIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYCB0byBkZXRlcm1pbmUgdGhlIHR5cGUgb2YgYW4gb2JqZWN0LFxuICogbm9ybWFsaXNpbmcgYmVoYXZpb3VyIGFjcm9zcyBlbmdpbmUgdmVyc2lvbnMgJiB3ZWxsIG9wdGltaXNlZC5cbiAqXG4gKiBAcGFyYW0ge01peGVkfSBvYmplY3RcbiAqIEByZXR1cm4ge1N0cmluZ30gb2JqZWN0IHR5cGVcbiAqIEBhcGkgcHVibGljXG4gKi9cbmZ1bmN0aW9uIHR5cGVEZXRlY3Qob2JqKSB7XG4gIC8qICEgU3BlZWQgb3B0aW1pc2F0aW9uXG4gICAqIFByZTpcbiAgICogICBzdHJpbmcgbGl0ZXJhbCAgICAgeCAzLDAzOSwwMzUgb3BzL3NlYyBcdTAwQjExLjYyJSAoNzggcnVucyBzYW1wbGVkKVxuICAgKiAgIGJvb2xlYW4gbGl0ZXJhbCAgICB4IDEsNDI0LDEzOCBvcHMvc2VjIFx1MDBCMTQuNTQlICg3NSBydW5zIHNhbXBsZWQpXG4gICAqICAgbnVtYmVyIGxpdGVyYWwgICAgIHggMSw2NTMsMTUzIG9wcy9zZWMgXHUwMEIxMS45MSUgKDgyIHJ1bnMgc2FtcGxlZClcbiAgICogICB1bmRlZmluZWQgICAgICAgICAgeCA5LDk3OCw2NjAgb3BzL3NlYyBcdTAwQjExLjkyJSAoNzUgcnVucyBzYW1wbGVkKVxuICAgKiAgIGZ1bmN0aW9uICAgICAgICAgICB4IDIsNTU2LDc2OSBvcHMvc2VjIFx1MDBCMTEuNzMlICg3NyBydW5zIHNhbXBsZWQpXG4gICAqIFBvc3Q6XG4gICAqICAgc3RyaW5nIGxpdGVyYWwgICAgIHggMzgsNTY0LDc5NiBvcHMvc2VjIFx1MDBCMTEuMTUlICg3OSBydW5zIHNhbXBsZWQpXG4gICAqICAgYm9vbGVhbiBsaXRlcmFsICAgIHggMzEsMTQ4LDk0MCBvcHMvc2VjIFx1MDBCMTEuMTAlICg3OSBydW5zIHNhbXBsZWQpXG4gICAqICAgbnVtYmVyIGxpdGVyYWwgICAgIHggMzIsNjc5LDMzMCBvcHMvc2VjIFx1MDBCMTEuOTAlICg3OCBydW5zIHNhbXBsZWQpXG4gICAqICAgdW5kZWZpbmVkICAgICAgICAgIHggMzIsMzYzLDM2OCBvcHMvc2VjIFx1MDBCMTEuMDclICg4MiBydW5zIHNhbXBsZWQpXG4gICAqICAgZnVuY3Rpb24gICAgICAgICAgIHggMzEsMjk2LDg3MCBvcHMvc2VjIFx1MDBCMTAuOTYlICg4MyBydW5zIHNhbXBsZWQpXG4gICAqL1xuICB2YXIgdHlwZW9mT2JqID0gdHlwZW9mIG9iajtcbiAgaWYgKHR5cGVvZk9iaiAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gdHlwZW9mT2JqO1xuICB9XG5cbiAgLyogISBTcGVlZCBvcHRpbWlzYXRpb25cbiAgICogUHJlOlxuICAgKiAgIG51bGwgICAgICAgICAgICAgICB4IDI4LDY0NSw3NjUgb3BzL3NlYyBcdTAwQjExLjE3JSAoODIgcnVucyBzYW1wbGVkKVxuICAgKiBQb3N0OlxuICAgKiAgIG51bGwgICAgICAgICAgICAgICB4IDM2LDQyOCw5NjIgb3BzL3NlYyBcdTAwQjExLjM3JSAoODQgcnVucyBzYW1wbGVkKVxuICAgKi9cbiAgaWYgKG9iaiA9PT0gbnVsbCkge1xuICAgIHJldHVybiAnbnVsbCc7XG4gIH1cblxuICAvKiAhIFNwZWMgQ29uZm9ybWFuY2VcbiAgICogVGVzdDogYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh3aW5kb3cpYGBcbiAgICogIC0gTm9kZSA9PT0gXCJbb2JqZWN0IGdsb2JhbF1cIlxuICAgKiAgLSBDaHJvbWUgPT09IFwiW29iamVjdCBnbG9iYWxdXCJcbiAgICogIC0gRmlyZWZveCA9PT0gXCJbb2JqZWN0IFdpbmRvd11cIlxuICAgKiAgLSBQaGFudG9tSlMgPT09IFwiW29iamVjdCBXaW5kb3ddXCJcbiAgICogIC0gU2FmYXJpID09PSBcIltvYmplY3QgV2luZG93XVwiXG4gICAqICAtIElFIDExID09PSBcIltvYmplY3QgV2luZG93XVwiXG4gICAqICAtIElFIEVkZ2UgPT09IFwiW29iamVjdCBXaW5kb3ddXCJcbiAgICogVGVzdDogYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0aGlzKWBgXG4gICAqICAtIENocm9tZSBXb3JrZXIgPT09IFwiW29iamVjdCBnbG9iYWxdXCJcbiAgICogIC0gRmlyZWZveCBXb3JrZXIgPT09IFwiW29iamVjdCBEZWRpY2F0ZWRXb3JrZXJHbG9iYWxTY29wZV1cIlxuICAgKiAgLSBTYWZhcmkgV29ya2VyID09PSBcIltvYmplY3QgRGVkaWNhdGVkV29ya2VyR2xvYmFsU2NvcGVdXCJcbiAgICogIC0gSUUgMTEgV29ya2VyID09PSBcIltvYmplY3QgV29ya2VyR2xvYmFsU2NvcGVdXCJcbiAgICogIC0gSUUgRWRnZSBXb3JrZXIgPT09IFwiW29iamVjdCBXb3JrZXJHbG9iYWxTY29wZV1cIlxuICAgKi9cbiAgaWYgKG9iaiA9PT0gZ2xvYmFsT2JqZWN0KSB7XG4gICAgcmV0dXJuICdnbG9iYWwnO1xuICB9XG5cbiAgLyogISBTcGVlZCBvcHRpbWlzYXRpb25cbiAgICogUHJlOlxuICAgKiAgIGFycmF5IGxpdGVyYWwgICAgICB4IDIsODg4LDM1MiBvcHMvc2VjIFx1MDBCMTAuNjclICg4MiBydW5zIHNhbXBsZWQpXG4gICAqIFBvc3Q6XG4gICAqICAgYXJyYXkgbGl0ZXJhbCAgICAgIHggMjIsNDc5LDY1MCBvcHMvc2VjIFx1MDBCMTAuOTYlICg4MSBydW5zIHNhbXBsZWQpXG4gICAqL1xuICBpZiAoXG4gICAgQXJyYXkuaXNBcnJheShvYmopICYmXG4gICAgKHN5bWJvbFRvU3RyaW5nVGFnRXhpc3RzID09PSBmYWxzZSB8fCAhKFN5bWJvbC50b1N0cmluZ1RhZyBpbiBvYmopKVxuICApIHtcbiAgICByZXR1cm4gJ0FycmF5JztcbiAgfVxuXG4gIC8vIE5vdCBjYWNoaW5nIGV4aXN0ZW5jZSBvZiBgd2luZG93YCBhbmQgcmVsYXRlZCBwcm9wZXJ0aWVzIGR1ZSB0byBwb3RlbnRpYWxcbiAgLy8gZm9yIGB3aW5kb3dgIHRvIGJlIHVuc2V0IGJlZm9yZSB0ZXN0cyBpbiBxdWFzaS1icm93c2VyIGVudmlyb25tZW50cy5cbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnICYmIHdpbmRvdyAhPT0gbnVsbCkge1xuICAgIC8qICEgU3BlYyBDb25mb3JtYW5jZVxuICAgICAqIChodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9icm93c2Vycy5odG1sI2xvY2F0aW9uKVxuICAgICAqIFdoYXRXRyBIVE1MJDcuNy4zIC0gVGhlIGBMb2NhdGlvbmAgaW50ZXJmYWNlXG4gICAgICogVGVzdDogYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh3aW5kb3cubG9jYXRpb24pYGBcbiAgICAgKiAgLSBJRSA8PTExID09PSBcIltvYmplY3QgT2JqZWN0XVwiXG4gICAgICogIC0gSUUgRWRnZSA8PTEzID09PSBcIltvYmplY3QgT2JqZWN0XVwiXG4gICAgICovXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cubG9jYXRpb24gPT09ICdvYmplY3QnICYmIG9iaiA9PT0gd2luZG93LmxvY2F0aW9uKSB7XG4gICAgICByZXR1cm4gJ0xvY2F0aW9uJztcbiAgICB9XG5cbiAgICAvKiAhIFNwZWMgQ29uZm9ybWFuY2VcbiAgICAgKiAoaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy8jZG9jdW1lbnQpXG4gICAgICogV2hhdFdHIEhUTUwkMy4xLjEgLSBUaGUgYERvY3VtZW50YCBvYmplY3RcbiAgICAgKiBOb3RlOiBNb3N0IGJyb3dzZXJzIGN1cnJlbnRseSBhZGhlciB0byB0aGUgVzNDIERPTSBMZXZlbCAyIHNwZWNcbiAgICAgKiAgICAgICAoaHR0cHM6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0yLUhUTUwvaHRtbC5odG1sI0lELTI2ODA5MjY4KVxuICAgICAqICAgICAgIHdoaWNoIHN1Z2dlc3RzIHRoYXQgYnJvd3NlcnMgc2hvdWxkIHVzZSBIVE1MVGFibGVDZWxsRWxlbWVudCBmb3JcbiAgICAgKiAgICAgICBib3RoIFREIGFuZCBUSCBlbGVtZW50cy4gV2hhdFdHIHNlcGFyYXRlcyB0aGVzZS5cbiAgICAgKiAgICAgICBXaGF0V0cgSFRNTCBzdGF0ZXM6XG4gICAgICogICAgICAgICA+IEZvciBoaXN0b3JpY2FsIHJlYXNvbnMsIFdpbmRvdyBvYmplY3RzIG11c3QgYWxzbyBoYXZlIGFcbiAgICAgKiAgICAgICAgID4gd3JpdGFibGUsIGNvbmZpZ3VyYWJsZSwgbm9uLWVudW1lcmFibGUgcHJvcGVydHkgbmFtZWRcbiAgICAgKiAgICAgICAgID4gSFRNTERvY3VtZW50IHdob3NlIHZhbHVlIGlzIHRoZSBEb2N1bWVudCBpbnRlcmZhY2Ugb2JqZWN0LlxuICAgICAqIFRlc3Q6IGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZG9jdW1lbnQpYGBcbiAgICAgKiAgLSBDaHJvbWUgPT09IFwiW29iamVjdCBIVE1MRG9jdW1lbnRdXCJcbiAgICAgKiAgLSBGaXJlZm94ID09PSBcIltvYmplY3QgSFRNTERvY3VtZW50XVwiXG4gICAgICogIC0gU2FmYXJpID09PSBcIltvYmplY3QgSFRNTERvY3VtZW50XVwiXG4gICAgICogIC0gSUUgPD0xMCA9PT0gXCJbb2JqZWN0IERvY3VtZW50XVwiXG4gICAgICogIC0gSUUgMTEgPT09IFwiW29iamVjdCBIVE1MRG9jdW1lbnRdXCJcbiAgICAgKiAgLSBJRSBFZGdlIDw9MTMgPT09IFwiW29iamVjdCBIVE1MRG9jdW1lbnRdXCJcbiAgICAgKi9cbiAgICBpZiAodHlwZW9mIHdpbmRvdy5kb2N1bWVudCA9PT0gJ29iamVjdCcgJiYgb2JqID09PSB3aW5kb3cuZG9jdW1lbnQpIHtcbiAgICAgIHJldHVybiAnRG9jdW1lbnQnO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygd2luZG93Lm5hdmlnYXRvciA9PT0gJ29iamVjdCcpIHtcbiAgICAgIC8qICEgU3BlYyBDb25mb3JtYW5jZVxuICAgICAgICogKGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3dlYmFwcGFwaXMuaHRtbCNtaW1ldHlwZWFycmF5KVxuICAgICAgICogV2hhdFdHIEhUTUwkOC42LjEuNSAtIFBsdWdpbnMgLSBJbnRlcmZhY2UgTWltZVR5cGVBcnJheVxuICAgICAgICogVGVzdDogYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChuYXZpZ2F0b3IubWltZVR5cGVzKWBgXG4gICAgICAgKiAgLSBJRSA8PTEwID09PSBcIltvYmplY3QgTVNNaW1lVHlwZXNDb2xsZWN0aW9uXVwiXG4gICAgICAgKi9cbiAgICAgIGlmICh0eXBlb2Ygd2luZG93Lm5hdmlnYXRvci5taW1lVHlwZXMgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgb2JqID09PSB3aW5kb3cubmF2aWdhdG9yLm1pbWVUeXBlcykge1xuICAgICAgICByZXR1cm4gJ01pbWVUeXBlQXJyYXknO1xuICAgICAgfVxuXG4gICAgICAvKiAhIFNwZWMgQ29uZm9ybWFuY2VcbiAgICAgICAqIChodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS93ZWJhcHBhcGlzLmh0bWwjcGx1Z2luYXJyYXkpXG4gICAgICAgKiBXaGF0V0cgSFRNTCQ4LjYuMS41IC0gUGx1Z2lucyAtIEludGVyZmFjZSBQbHVnaW5BcnJheVxuICAgICAgICogVGVzdDogYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChuYXZpZ2F0b3IucGx1Z2lucylgYFxuICAgICAgICogIC0gSUUgPD0xMCA9PT0gXCJbb2JqZWN0IE1TUGx1Z2luc0NvbGxlY3Rpb25dXCJcbiAgICAgICAqL1xuICAgICAgaWYgKHR5cGVvZiB3aW5kb3cubmF2aWdhdG9yLnBsdWdpbnMgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgb2JqID09PSB3aW5kb3cubmF2aWdhdG9yLnBsdWdpbnMpIHtcbiAgICAgICAgcmV0dXJuICdQbHVnaW5BcnJheSc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCh0eXBlb2Ygd2luZG93LkhUTUxFbGVtZW50ID09PSAnZnVuY3Rpb24nIHx8XG4gICAgICAgIHR5cGVvZiB3aW5kb3cuSFRNTEVsZW1lbnQgPT09ICdvYmplY3QnKSAmJlxuICAgICAgICBvYmogaW5zdGFuY2VvZiB3aW5kb3cuSFRNTEVsZW1lbnQpIHtcbiAgICAgIC8qICEgU3BlYyBDb25mb3JtYW5jZVxuICAgICAgKiAoaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvd2ViYXBwYXBpcy5odG1sI3BsdWdpbmFycmF5KVxuICAgICAgKiBXaGF0V0cgSFRNTCQ0LjQuNCAtIFRoZSBgYmxvY2txdW90ZWAgZWxlbWVudCAtIEludGVyZmFjZSBgSFRNTFF1b3RlRWxlbWVudGBcbiAgICAgICogVGVzdDogYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdibG9ja3F1b3RlJykpYGBcbiAgICAgICogIC0gSUUgPD0xMCA9PT0gXCJbb2JqZWN0IEhUTUxCbG9ja0VsZW1lbnRdXCJcbiAgICAgICovXG4gICAgICBpZiAob2JqLnRhZ05hbWUgPT09ICdCTE9DS1FVT1RFJykge1xuICAgICAgICByZXR1cm4gJ0hUTUxRdW90ZUVsZW1lbnQnO1xuICAgICAgfVxuXG4gICAgICAvKiAhIFNwZWMgQ29uZm9ybWFuY2VcbiAgICAgICAqIChodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnLyNodG1sdGFibGVkYXRhY2VsbGVsZW1lbnQpXG4gICAgICAgKiBXaGF0V0cgSFRNTCQ0LjkuOSAtIFRoZSBgdGRgIGVsZW1lbnQgLSBJbnRlcmZhY2UgYEhUTUxUYWJsZURhdGFDZWxsRWxlbWVudGBcbiAgICAgICAqIE5vdGU6IE1vc3QgYnJvd3NlcnMgY3VycmVudGx5IGFkaGVyIHRvIHRoZSBXM0MgRE9NIExldmVsIDIgc3BlY1xuICAgICAgICogICAgICAgKGh0dHBzOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMi1IVE1ML2h0bWwuaHRtbCNJRC04MjkxNTA3NSlcbiAgICAgICAqICAgICAgIHdoaWNoIHN1Z2dlc3RzIHRoYXQgYnJvd3NlcnMgc2hvdWxkIHVzZSBIVE1MVGFibGVDZWxsRWxlbWVudCBmb3JcbiAgICAgICAqICAgICAgIGJvdGggVEQgYW5kIFRIIGVsZW1lbnRzLiBXaGF0V0cgc2VwYXJhdGVzIHRoZXNlLlxuICAgICAgICogVGVzdDogT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RkJykpXG4gICAgICAgKiAgLSBDaHJvbWUgPT09IFwiW29iamVjdCBIVE1MVGFibGVDZWxsRWxlbWVudF1cIlxuICAgICAgICogIC0gRmlyZWZveCA9PT0gXCJbb2JqZWN0IEhUTUxUYWJsZUNlbGxFbGVtZW50XVwiXG4gICAgICAgKiAgLSBTYWZhcmkgPT09IFwiW29iamVjdCBIVE1MVGFibGVDZWxsRWxlbWVudF1cIlxuICAgICAgICovXG4gICAgICBpZiAob2JqLnRhZ05hbWUgPT09ICdURCcpIHtcbiAgICAgICAgcmV0dXJuICdIVE1MVGFibGVEYXRhQ2VsbEVsZW1lbnQnO1xuICAgICAgfVxuXG4gICAgICAvKiAhIFNwZWMgQ29uZm9ybWFuY2VcbiAgICAgICAqIChodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnLyNodG1sdGFibGVoZWFkZXJjZWxsZWxlbWVudClcbiAgICAgICAqIFdoYXRXRyBIVE1MJDQuOS45IC0gVGhlIGB0ZGAgZWxlbWVudCAtIEludGVyZmFjZSBgSFRNTFRhYmxlSGVhZGVyQ2VsbEVsZW1lbnRgXG4gICAgICAgKiBOb3RlOiBNb3N0IGJyb3dzZXJzIGN1cnJlbnRseSBhZGhlciB0byB0aGUgVzNDIERPTSBMZXZlbCAyIHNwZWNcbiAgICAgICAqICAgICAgIChodHRwczovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTItSFRNTC9odG1sLmh0bWwjSUQtODI5MTUwNzUpXG4gICAgICAgKiAgICAgICB3aGljaCBzdWdnZXN0cyB0aGF0IGJyb3dzZXJzIHNob3VsZCB1c2UgSFRNTFRhYmxlQ2VsbEVsZW1lbnQgZm9yXG4gICAgICAgKiAgICAgICBib3RoIFREIGFuZCBUSCBlbGVtZW50cy4gV2hhdFdHIHNlcGFyYXRlcyB0aGVzZS5cbiAgICAgICAqIFRlc3Q6IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0aCcpKVxuICAgICAgICogIC0gQ2hyb21lID09PSBcIltvYmplY3QgSFRNTFRhYmxlQ2VsbEVsZW1lbnRdXCJcbiAgICAgICAqICAtIEZpcmVmb3ggPT09IFwiW29iamVjdCBIVE1MVGFibGVDZWxsRWxlbWVudF1cIlxuICAgICAgICogIC0gU2FmYXJpID09PSBcIltvYmplY3QgSFRNTFRhYmxlQ2VsbEVsZW1lbnRdXCJcbiAgICAgICAqL1xuICAgICAgaWYgKG9iai50YWdOYW1lID09PSAnVEgnKSB7XG4gICAgICAgIHJldHVybiAnSFRNTFRhYmxlSGVhZGVyQ2VsbEVsZW1lbnQnO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qICEgU3BlZWQgb3B0aW1pc2F0aW9uXG4gICogUHJlOlxuICAqICAgRmxvYXQ2NEFycmF5ICAgICAgIHggNjI1LDY0NCBvcHMvc2VjIFx1MDBCMTEuNTglICg4MCBydW5zIHNhbXBsZWQpXG4gICogICBGbG9hdDMyQXJyYXkgICAgICAgeCAxLDI3OSw4NTIgb3BzL3NlYyBcdTAwQjEyLjkxJSAoNzcgcnVucyBzYW1wbGVkKVxuICAqICAgVWludDMyQXJyYXkgICAgICAgIHggMSwxNzgsMTg1IG9wcy9zZWMgXHUwMEIxMS45NSUgKDgzIHJ1bnMgc2FtcGxlZClcbiAgKiAgIFVpbnQxNkFycmF5ICAgICAgICB4IDEsMDA4LDM4MCBvcHMvc2VjIFx1MDBCMTIuMjUlICg4MCBydW5zIHNhbXBsZWQpXG4gICogICBVaW50OEFycmF5ICAgICAgICAgeCAxLDEyOCwwNDAgb3BzL3NlYyBcdTAwQjEyLjExJSAoODEgcnVucyBzYW1wbGVkKVxuICAqICAgSW50MzJBcnJheSAgICAgICAgIHggMSwxNzAsMTE5IG9wcy9zZWMgXHUwMEIxMi44OCUgKDgwIHJ1bnMgc2FtcGxlZClcbiAgKiAgIEludDE2QXJyYXkgICAgICAgICB4IDEsMTc2LDM0OCBvcHMvc2VjIFx1MDBCMTUuNzklICg4NiBydW5zIHNhbXBsZWQpXG4gICogICBJbnQ4QXJyYXkgICAgICAgICAgeCAxLDA1OCw3MDcgb3BzL3NlYyBcdTAwQjE0Ljk0JSAoNzcgcnVucyBzYW1wbGVkKVxuICAqICAgVWludDhDbGFtcGVkQXJyYXkgIHggMSwxMTAsNjMzIG9wcy9zZWMgXHUwMEIxNC4yMCUgKDgwIHJ1bnMgc2FtcGxlZClcbiAgKiBQb3N0OlxuICAqICAgRmxvYXQ2NEFycmF5ICAgICAgIHggNywxMDUsNjcxIG9wcy9zZWMgXHUwMEIxMTMuNDclICg2NCBydW5zIHNhbXBsZWQpXG4gICogICBGbG9hdDMyQXJyYXkgICAgICAgeCA1LDg4Nyw5MTIgb3BzL3NlYyBcdTAwQjExLjQ2JSAoODIgcnVucyBzYW1wbGVkKVxuICAqICAgVWludDMyQXJyYXkgICAgICAgIHggNiw0OTEsNjYxIG9wcy9zZWMgXHUwMEIxMS43NiUgKDc5IHJ1bnMgc2FtcGxlZClcbiAgKiAgIFVpbnQxNkFycmF5ICAgICAgICB4IDYsNTU5LDc5NSBvcHMvc2VjIFx1MDBCMTEuNjclICg4MiBydW5zIHNhbXBsZWQpXG4gICogICBVaW50OEFycmF5ICAgICAgICAgeCA2LDQ2Myw5NjYgb3BzL3NlYyBcdTAwQjExLjQzJSAoODUgcnVucyBzYW1wbGVkKVxuICAqICAgSW50MzJBcnJheSAgICAgICAgIHggNSw2NDEsODQxIG9wcy9zZWMgXHUwMEIxMy40OSUgKDgxIHJ1bnMgc2FtcGxlZClcbiAgKiAgIEludDE2QXJyYXkgICAgICAgICB4IDYsNTgzLDUxMSBvcHMvc2VjIFx1MDBCMTEuOTglICg4MCBydW5zIHNhbXBsZWQpXG4gICogICBJbnQ4QXJyYXkgICAgICAgICAgeCA2LDYwNiwwNzggb3BzL3NlYyBcdTAwQjExLjc0JSAoODEgcnVucyBzYW1wbGVkKVxuICAqICAgVWludDhDbGFtcGVkQXJyYXkgIHggNiw2MDIsMjI0IG9wcy9zZWMgXHUwMEIxMS43NyUgKDgzIHJ1bnMgc2FtcGxlZClcbiAgKi9cbiAgdmFyIHN0cmluZ1RhZyA9IChzeW1ib2xUb1N0cmluZ1RhZ0V4aXN0cyAmJiBvYmpbU3ltYm9sLnRvU3RyaW5nVGFnXSk7XG4gIGlmICh0eXBlb2Ygc3RyaW5nVGFnID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBzdHJpbmdUYWc7XG4gIH1cblxuICB2YXIgb2JqUHJvdG90eXBlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iaik7XG4gIC8qICEgU3BlZWQgb3B0aW1pc2F0aW9uXG4gICogUHJlOlxuICAqICAgcmVnZXggbGl0ZXJhbCAgICAgIHggMSw3NzIsMzg1IG9wcy9zZWMgXHUwMEIxMS44NSUgKDc3IHJ1bnMgc2FtcGxlZClcbiAgKiAgIHJlZ2V4IGNvbnN0cnVjdG9yICB4IDIsMTQzLDYzNCBvcHMvc2VjIFx1MDBCMTIuNDYlICg3OCBydW5zIHNhbXBsZWQpXG4gICogUG9zdDpcbiAgKiAgIHJlZ2V4IGxpdGVyYWwgICAgICB4IDMsOTI4LDAwOSBvcHMvc2VjIFx1MDBCMTAuNjUlICg3OCBydW5zIHNhbXBsZWQpXG4gICogICByZWdleCBjb25zdHJ1Y3RvciAgeCAzLDkzMSwxMDggb3BzL3NlYyBcdTAwQjEwLjU4JSAoODQgcnVucyBzYW1wbGVkKVxuICAqL1xuICBpZiAob2JqUHJvdG90eXBlID09PSBSZWdFeHAucHJvdG90eXBlKSB7XG4gICAgcmV0dXJuICdSZWdFeHAnO1xuICB9XG5cbiAgLyogISBTcGVlZCBvcHRpbWlzYXRpb25cbiAgKiBQcmU6XG4gICogICBkYXRlICAgICAgICAgICAgICAgeCAyLDEzMCwwNzQgb3BzL3NlYyBcdTAwQjE0LjQyJSAoNjggcnVucyBzYW1wbGVkKVxuICAqIFBvc3Q6XG4gICogICBkYXRlICAgICAgICAgICAgICAgeCAzLDk1Myw3Nzkgb3BzL3NlYyBcdTAwQjExLjM1JSAoNzcgcnVucyBzYW1wbGVkKVxuICAqL1xuICBpZiAob2JqUHJvdG90eXBlID09PSBEYXRlLnByb3RvdHlwZSkge1xuICAgIHJldHVybiAnRGF0ZSc7XG4gIH1cblxuICAvKiAhIFNwZWMgQ29uZm9ybWFuY2VcbiAgICogKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvaW5kZXguaHRtbCNzZWMtcHJvbWlzZS5wcm90b3R5cGUtQEB0b3N0cmluZ3RhZylcbiAgICogRVM2JDI1LjQuNS40IC0gUHJvbWlzZS5wcm90b3R5cGVbQEB0b1N0cmluZ1RhZ10gc2hvdWxkIGJlIFwiUHJvbWlzZVwiOlxuICAgKiBUZXN0OiBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKFByb21pc2UucmVzb2x2ZSgpKWBgXG4gICAqICAtIENocm9tZSA8PTQ3ID09PSBcIltvYmplY3QgT2JqZWN0XVwiXG4gICAqICAtIEVkZ2UgPD0yMCA9PT0gXCJbb2JqZWN0IE9iamVjdF1cIlxuICAgKiAgLSBGaXJlZm94IDI5LUxhdGVzdCA9PT0gXCJbb2JqZWN0IFByb21pc2VdXCJcbiAgICogIC0gU2FmYXJpIDcuMS1MYXRlc3QgPT09IFwiW29iamVjdCBQcm9taXNlXVwiXG4gICAqL1xuICBpZiAocHJvbWlzZUV4aXN0cyAmJiBvYmpQcm90b3R5cGUgPT09IFByb21pc2UucHJvdG90eXBlKSB7XG4gICAgcmV0dXJuICdQcm9taXNlJztcbiAgfVxuXG4gIC8qICEgU3BlZWQgb3B0aW1pc2F0aW9uXG4gICogUHJlOlxuICAqICAgc2V0ICAgICAgICAgICAgICAgIHggMiwyMjIsMTg2IG9wcy9zZWMgXHUwMEIxMS4zMSUgKDgyIHJ1bnMgc2FtcGxlZClcbiAgKiBQb3N0OlxuICAqICAgc2V0ICAgICAgICAgICAgICAgIHggNCw1NDUsODc5IG9wcy9zZWMgXHUwMEIxMS4xMyUgKDgzIHJ1bnMgc2FtcGxlZClcbiAgKi9cbiAgaWYgKHNldEV4aXN0cyAmJiBvYmpQcm90b3R5cGUgPT09IFNldC5wcm90b3R5cGUpIHtcbiAgICByZXR1cm4gJ1NldCc7XG4gIH1cblxuICAvKiAhIFNwZWVkIG9wdGltaXNhdGlvblxuICAqIFByZTpcbiAgKiAgIG1hcCAgICAgICAgICAgICAgICB4IDIsMzk2LDg0MiBvcHMvc2VjIFx1MDBCMTEuNTklICg4MSBydW5zIHNhbXBsZWQpXG4gICogUG9zdDpcbiAgKiAgIG1hcCAgICAgICAgICAgICAgICB4IDQsMTgzLDk0NSBvcHMvc2VjIFx1MDBCMTYuNTklICg4MiBydW5zIHNhbXBsZWQpXG4gICovXG4gIGlmIChtYXBFeGlzdHMgJiYgb2JqUHJvdG90eXBlID09PSBNYXAucHJvdG90eXBlKSB7XG4gICAgcmV0dXJuICdNYXAnO1xuICB9XG5cbiAgLyogISBTcGVlZCBvcHRpbWlzYXRpb25cbiAgKiBQcmU6XG4gICogICB3ZWFrc2V0ICAgICAgICAgICAgeCAxLDMyMywyMjAgb3BzL3NlYyBcdTAwQjEyLjE3JSAoNzYgcnVucyBzYW1wbGVkKVxuICAqIFBvc3Q6XG4gICogICB3ZWFrc2V0ICAgICAgICAgICAgeCA0LDIzNyw1MTAgb3BzL3NlYyBcdTAwQjEyLjAxJSAoNzcgcnVucyBzYW1wbGVkKVxuICAqL1xuICBpZiAod2Vha1NldEV4aXN0cyAmJiBvYmpQcm90b3R5cGUgPT09IFdlYWtTZXQucHJvdG90eXBlKSB7XG4gICAgcmV0dXJuICdXZWFrU2V0JztcbiAgfVxuXG4gIC8qICEgU3BlZWQgb3B0aW1pc2F0aW9uXG4gICogUHJlOlxuICAqICAgd2Vha21hcCAgICAgICAgICAgIHggMSw1MDAsMjYwIG9wcy9zZWMgXHUwMEIxMi4wMiUgKDc4IHJ1bnMgc2FtcGxlZClcbiAgKiBQb3N0OlxuICAqICAgd2Vha21hcCAgICAgICAgICAgIHggMyw4ODEsMzg0IG9wcy9zZWMgXHUwMEIxMS40NSUgKDgyIHJ1bnMgc2FtcGxlZClcbiAgKi9cbiAgaWYgKHdlYWtNYXBFeGlzdHMgJiYgb2JqUHJvdG90eXBlID09PSBXZWFrTWFwLnByb3RvdHlwZSkge1xuICAgIHJldHVybiAnV2Vha01hcCc7XG4gIH1cblxuICAvKiAhIFNwZWMgQ29uZm9ybWFuY2VcbiAgICogKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvaW5kZXguaHRtbCNzZWMtZGF0YXZpZXcucHJvdG90eXBlLUBAdG9zdHJpbmd0YWcpXG4gICAqIEVTNiQyNC4yLjQuMjEgLSBEYXRhVmlldy5wcm90b3R5cGVbQEB0b1N0cmluZ1RhZ10gc2hvdWxkIGJlIFwiRGF0YVZpZXdcIjpcbiAgICogVGVzdDogYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChuZXcgRGF0YVZpZXcobmV3IEFycmF5QnVmZmVyKDEpKSlgYFxuICAgKiAgLSBFZGdlIDw9MTMgPT09IFwiW29iamVjdCBPYmplY3RdXCJcbiAgICovXG4gIGlmIChkYXRhVmlld0V4aXN0cyAmJiBvYmpQcm90b3R5cGUgPT09IERhdGFWaWV3LnByb3RvdHlwZSkge1xuICAgIHJldHVybiAnRGF0YVZpZXcnO1xuICB9XG5cbiAgLyogISBTcGVjIENvbmZvcm1hbmNlXG4gICAqIChodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wL2luZGV4Lmh0bWwjc2VjLSVtYXBpdGVyYXRvcnByb3RvdHlwZSUtQEB0b3N0cmluZ3RhZylcbiAgICogRVM2JDIzLjEuNS4yLjIgLSAlTWFwSXRlcmF0b3JQcm90b3R5cGUlW0BAdG9TdHJpbmdUYWddIHNob3VsZCBiZSBcIk1hcCBJdGVyYXRvclwiOlxuICAgKiBUZXN0OiBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG5ldyBNYXAoKS5lbnRyaWVzKCkpYGBcbiAgICogIC0gRWRnZSA8PTEzID09PSBcIltvYmplY3QgT2JqZWN0XVwiXG4gICAqL1xuICBpZiAobWFwRXhpc3RzICYmIG9ialByb3RvdHlwZSA9PT0gbWFwSXRlcmF0b3JQcm90b3R5cGUpIHtcbiAgICByZXR1cm4gJ01hcCBJdGVyYXRvcic7XG4gIH1cblxuICAvKiAhIFNwZWMgQ29uZm9ybWFuY2VcbiAgICogKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvaW5kZXguaHRtbCNzZWMtJXNldGl0ZXJhdG9ycHJvdG90eXBlJS1AQHRvc3RyaW5ndGFnKVxuICAgKiBFUzYkMjMuMi41LjIuMiAtICVTZXRJdGVyYXRvclByb3RvdHlwZSVbQEB0b1N0cmluZ1RhZ10gc2hvdWxkIGJlIFwiU2V0IEl0ZXJhdG9yXCI6XG4gICAqIFRlc3Q6IGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobmV3IFNldCgpLmVudHJpZXMoKSlgYFxuICAgKiAgLSBFZGdlIDw9MTMgPT09IFwiW29iamVjdCBPYmplY3RdXCJcbiAgICovXG4gIGlmIChzZXRFeGlzdHMgJiYgb2JqUHJvdG90eXBlID09PSBzZXRJdGVyYXRvclByb3RvdHlwZSkge1xuICAgIHJldHVybiAnU2V0IEl0ZXJhdG9yJztcbiAgfVxuXG4gIC8qICEgU3BlYyBDb25mb3JtYW5jZVxuICAgKiAoaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC9pbmRleC5odG1sI3NlYy0lYXJyYXlpdGVyYXRvcnByb3RvdHlwZSUtQEB0b3N0cmluZ3RhZylcbiAgICogRVM2JDIyLjEuNS4yLjIgLSAlQXJyYXlJdGVyYXRvclByb3RvdHlwZSVbQEB0b1N0cmluZ1RhZ10gc2hvdWxkIGJlIFwiQXJyYXkgSXRlcmF0b3JcIjpcbiAgICogVGVzdDogYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChbXVtTeW1ib2wuaXRlcmF0b3JdKCkpYGBcbiAgICogIC0gRWRnZSA8PTEzID09PSBcIltvYmplY3QgT2JqZWN0XVwiXG4gICAqL1xuICBpZiAoYXJyYXlJdGVyYXRvckV4aXN0cyAmJiBvYmpQcm90b3R5cGUgPT09IGFycmF5SXRlcmF0b3JQcm90b3R5cGUpIHtcbiAgICByZXR1cm4gJ0FycmF5IEl0ZXJhdG9yJztcbiAgfVxuXG4gIC8qICEgU3BlYyBDb25mb3JtYW5jZVxuICAgKiAoaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC9pbmRleC5odG1sI3NlYy0lc3RyaW5naXRlcmF0b3Jwcm90b3R5cGUlLUBAdG9zdHJpbmd0YWcpXG4gICAqIEVTNiQyMS4xLjUuMi4yIC0gJVN0cmluZ0l0ZXJhdG9yUHJvdG90eXBlJVtAQHRvU3RyaW5nVGFnXSBzaG91bGQgYmUgXCJTdHJpbmcgSXRlcmF0b3JcIjpcbiAgICogVGVzdDogYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCgnJ1tTeW1ib2wuaXRlcmF0b3JdKCkpYGBcbiAgICogIC0gRWRnZSA8PTEzID09PSBcIltvYmplY3QgT2JqZWN0XVwiXG4gICAqL1xuICBpZiAoc3RyaW5nSXRlcmF0b3JFeGlzdHMgJiYgb2JqUHJvdG90eXBlID09PSBzdHJpbmdJdGVyYXRvclByb3RvdHlwZSkge1xuICAgIHJldHVybiAnU3RyaW5nIEl0ZXJhdG9yJztcbiAgfVxuXG4gIC8qICEgU3BlZWQgb3B0aW1pc2F0aW9uXG4gICogUHJlOlxuICAqICAgb2JqZWN0IGZyb20gbnVsbCAgIHggMiw0MjQsMzIwIG9wcy9zZWMgXHUwMEIxMS42NyUgKDc2IHJ1bnMgc2FtcGxlZClcbiAgKiBQb3N0OlxuICAqICAgb2JqZWN0IGZyb20gbnVsbCAgIHggNSw4MzgsMDAwIG9wcy9zZWMgXHUwMEIxMC45OSUgKDg0IHJ1bnMgc2FtcGxlZClcbiAgKi9cbiAgaWYgKG9ialByb3RvdHlwZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiAnT2JqZWN0JztcbiAgfVxuXG4gIHJldHVybiBPYmplY3RcbiAgICAucHJvdG90eXBlXG4gICAgLnRvU3RyaW5nXG4gICAgLmNhbGwob2JqKVxuICAgIC5zbGljZSh0b1N0cmluZ0xlZnRTbGljZUxlbmd0aCwgdG9TdHJpbmdSaWdodFNsaWNlTGVuZ3RoKTtcbn1cblxucmV0dXJuIHR5cGVEZXRlY3Q7XG5cbn0pKSk7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciB0eXBlID0gcmVxdWlyZShcInR5cGUtZGV0ZWN0XCIpO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGxvd2VyLWNhc2UgcmVzdWx0IG9mIHJ1bm5pbmcgdHlwZSBmcm9tIHR5cGUtZGV0ZWN0IG9uIHRoZSB2YWx1ZVxuICogQHBhcmFtICB7Kn0gdmFsdWVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdHlwZU9mKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGUodmFsdWUpLnRvTG93ZXJDYXNlKCk7XG59O1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHZhbHVlXG4gKiBAcGFyYW0gIHsqfSB2YWx1ZVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gdmFsdWVUb1N0cmluZyh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSAmJiB2YWx1ZS50b1N0cmluZykge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHNpbm9uanMvbm8tcHJvdG90eXBlLW1ldGhvZHMvbm8tcHJvdG90eXBlLW1ldGhvZHNcbiAgICAgICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIHJldHVybiBTdHJpbmcodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHZhbHVlVG9TdHJpbmc7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIGdsb2JhbDogcmVxdWlyZShcIi4vZ2xvYmFsXCIpLFxuICAgIGNhbGxlZEluT3JkZXI6IHJlcXVpcmUoXCIuL2NhbGxlZC1pbi1vcmRlclwiKSxcbiAgICBjbGFzc05hbWU6IHJlcXVpcmUoXCIuL2NsYXNzLW5hbWVcIiksXG4gICAgZGVwcmVjYXRlZDogcmVxdWlyZShcIi4vZGVwcmVjYXRlZFwiKSxcbiAgICBldmVyeTogcmVxdWlyZShcIi4vZXZlcnlcIiksXG4gICAgZnVuY3Rpb25OYW1lOiByZXF1aXJlKFwiLi9mdW5jdGlvbi1uYW1lXCIpLFxuICAgIG9yZGVyQnlGaXJzdENhbGw6IHJlcXVpcmUoXCIuL29yZGVyLWJ5LWZpcnN0LWNhbGxcIiksXG4gICAgcHJvdG90eXBlczogcmVxdWlyZShcIi4vcHJvdG90eXBlc1wiKSxcbiAgICB0eXBlT2Y6IHJlcXVpcmUoXCIuL3R5cGUtb2ZcIiksXG4gICAgdmFsdWVUb1N0cmluZzogcmVxdWlyZShcIi4vdmFsdWUtdG8tc3RyaW5nXCIpLFxufTtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuY29uc3QgYXJyYXlQcm90byA9IHJlcXVpcmUoXCJAc2lub25qcy9jb21tb25zXCIpLnByb3RvdHlwZXMuYXJyYXk7XG5jb25zdCBoYXNPd25Qcm9wZXJ0eSA9XG4gICAgcmVxdWlyZShcIkBzaW5vbmpzL2NvbW1vbnNcIikucHJvdG90eXBlcy5vYmplY3QuaGFzT3duUHJvcGVydHk7XG5cbmNvbnN0IGpvaW4gPSBhcnJheVByb3RvLmpvaW47XG5jb25zdCBwdXNoID0gYXJyYXlQcm90by5wdXNoO1xuXG4vLyBBZGFwdGVkIGZyb20gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9FQ01BU2NyaXB0X0RvbnRFbnVtX2F0dHJpYnV0ZSNKU2NyaXB0X0RvbnRFbnVtX0J1Z1xuY29uc3QgaGFzRG9udEVudW1CdWcgPSAoZnVuY3Rpb24gKCkge1xuICAgIGNvbnN0IG9iaiA9IHtcbiAgICAgICAgY29uc3RydWN0b3I6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBcIjBcIjtcbiAgICAgICAgfSxcbiAgICAgICAgdG9TdHJpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBcIjFcIjtcbiAgICAgICAgfSxcbiAgICAgICAgdmFsdWVPZjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIFwiMlwiO1xuICAgICAgICB9LFxuICAgICAgICB0b0xvY2FsZVN0cmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIFwiM1wiO1xuICAgICAgICB9LFxuICAgICAgICBwcm90b3R5cGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBcIjRcIjtcbiAgICAgICAgfSxcbiAgICAgICAgaXNQcm90b3R5cGVPZjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIFwiNVwiO1xuICAgICAgICB9LFxuICAgICAgICBwcm9wZXJ0eUlzRW51bWVyYWJsZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIFwiNlwiO1xuICAgICAgICB9LFxuICAgICAgICBoYXNPd25Qcm9wZXJ0eTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIFwiN1wiO1xuICAgICAgICB9LFxuICAgICAgICBsZW5ndGg6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBcIjhcIjtcbiAgICAgICAgfSxcbiAgICAgICAgdW5pcXVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gXCI5XCI7XG4gICAgICAgIH0sXG4gICAgfTtcblxuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGZvciAoY29uc3QgcHJvcCBpbiBvYmopIHtcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5KG9iaiwgcHJvcCkpIHtcbiAgICAgICAgICAgIHB1c2gocmVzdWx0LCBvYmpbcHJvcF0oKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGpvaW4ocmVzdWx0LCBcIlwiKSAhPT0gXCIwMTIzNDU2Nzg5XCI7XG59KSgpO1xuXG4vKipcbiAqXG4gKiBAcGFyYW0gdGFyZ2V0XG4gKiBAcGFyYW0gc291cmNlc1xuICogQHBhcmFtIGRvQ29weVxuICogQHJldHVybnMgeyp9IHRhcmdldFxuICovXG5mdW5jdGlvbiBleHRlbmRDb21tb24odGFyZ2V0LCBzb3VyY2VzLCBkb0NvcHkpIHtcbiAgICBsZXQgc291cmNlLCBpLCBwcm9wO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHNvdXJjZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc291cmNlID0gc291cmNlc1tpXTtcblxuICAgICAgICBmb3IgKHByb3AgaW4gc291cmNlKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkoc291cmNlLCBwcm9wKSkge1xuICAgICAgICAgICAgICAgIGRvQ29weSh0YXJnZXQsIHNvdXJjZSwgcHJvcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBNYWtlIHN1cmUgd2UgY29weSAob3duKSB0b1N0cmluZyBtZXRob2QgZXZlbiB3aGVuIGluIEpTY3JpcHQgd2l0aCBEb250RW51bSBidWdcbiAgICAgICAgLy8gU2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRUNNQVNjcmlwdF9Eb250RW51bV9hdHRyaWJ1dGUjSlNjcmlwdF9Eb250RW51bV9CdWdcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgaGFzRG9udEVudW1CdWcgJiZcbiAgICAgICAgICAgIGhhc093blByb3BlcnR5KHNvdXJjZSwgXCJ0b1N0cmluZ1wiKSAmJlxuICAgICAgICAgICAgc291cmNlLnRvU3RyaW5nICE9PSB0YXJnZXQudG9TdHJpbmdcbiAgICAgICAgKSB7XG4gICAgICAgICAgICB0YXJnZXQudG9TdHJpbmcgPSBzb3VyY2UudG9TdHJpbmc7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xufVxuXG4vKipcbiAqIFB1YmxpYzogRXh0ZW5kIHRhcmdldCBpbiBwbGFjZSB3aXRoIGFsbCAob3duKSBwcm9wZXJ0aWVzLCBleGNlcHQgJ25hbWUnIHdoZW4gW1t3cml0YWJsZV1dIGlzIGZhbHNlLFxuICogICAgICAgICBmcm9tIHNvdXJjZXMgaW4tb3JkZXIuIFRodXMsIGxhc3Qgc291cmNlIHdpbGwgb3ZlcnJpZGUgcHJvcGVydGllcyBpbiBwcmV2aW91cyBzb3VyY2VzLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSB0YXJnZXQgLSBUaGUgT2JqZWN0IHRvIGV4dGVuZFxuICogQHBhcmFtIHtvYmplY3RbXX0gc291cmNlcyAtIE9iamVjdHMgdG8gY29weSBwcm9wZXJ0aWVzIGZyb20uXG4gKiBAcmV0dXJucyB7b2JqZWN0fSB0aGUgZXh0ZW5kZWQgdGFyZ2V0XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZXh0ZW5kKHRhcmdldCwgLi4uc291cmNlcykge1xuICAgIHJldHVybiBleHRlbmRDb21tb24oXG4gICAgICAgIHRhcmdldCxcbiAgICAgICAgc291cmNlcyxcbiAgICAgICAgZnVuY3Rpb24gY29weVZhbHVlKGRlc3QsIHNvdXJjZSwgcHJvcCkge1xuICAgICAgICAgICAgY29uc3QgZGVzdE93blByb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoXG4gICAgICAgICAgICAgICAgZGVzdCxcbiAgICAgICAgICAgICAgICBwcm9wLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGNvbnN0IHNvdXJjZU93blByb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoXG4gICAgICAgICAgICAgICAgc291cmNlLFxuICAgICAgICAgICAgICAgIHByb3AsXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBpZiAocHJvcCA9PT0gXCJuYW1lXCIgJiYgIWRlc3RPd25Qcm9wZXJ0eURlc2NyaXB0b3Iud3JpdGFibGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBkZXNjcmlwdG9ycyA9IHtcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHNvdXJjZU93blByb3BlcnR5RGVzY3JpcHRvci5jb25maWd1cmFibGUsXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogc291cmNlT3duUHJvcGVydHlEZXNjcmlwdG9yLmVudW1lcmFibGUsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICBpZiB0aGUgc291cmNlIGhhcyBhbiBBY2Nlc3NvciBwcm9wZXJ0eSBjb3B5IG92ZXIgdGhlIGFjY2Vzc29yIGZ1bmN0aW9ucyAoZ2V0IGFuZCBzZXQpXG4gICAgICAgICAgICAgICAgZGF0YSBwcm9wZXJ0aWVzIGhhcyB3cml0YWJsZSBhdHRyaWJ1dGUgd2hlcmUgYXMgYWNjZXNzb3IgcHJvcGVydHkgZG9uJ3RcbiAgICAgICAgICAgICAgICBSRUY6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvRGF0YV9zdHJ1Y3R1cmVzI3Byb3BlcnRpZXNcbiAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eShzb3VyY2VPd25Qcm9wZXJ0eURlc2NyaXB0b3IsIFwid3JpdGFibGVcIikpIHtcbiAgICAgICAgICAgICAgICBkZXNjcmlwdG9ycy53cml0YWJsZSA9IHNvdXJjZU93blByb3BlcnR5RGVzY3JpcHRvci53cml0YWJsZTtcbiAgICAgICAgICAgICAgICBkZXNjcmlwdG9ycy52YWx1ZSA9IHNvdXJjZU93blByb3BlcnR5RGVzY3JpcHRvci52YWx1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZU93blByb3BlcnR5RGVzY3JpcHRvci5nZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRvcnMuZ2V0ID1cbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZU93blByb3BlcnR5RGVzY3JpcHRvci5nZXQuYmluZChkZXN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZU93blByb3BlcnR5RGVzY3JpcHRvci5zZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRvcnMuc2V0ID1cbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZU93blByb3BlcnR5RGVzY3JpcHRvci5zZXQuYmluZChkZXN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZGVzdCwgcHJvcCwgZGVzY3JpcHRvcnMpO1xuICAgICAgICB9LFxuICAgICk7XG59O1xuXG4vKipcbiAqIFB1YmxpYzogRXh0ZW5kIHRhcmdldCBpbiBwbGFjZSB3aXRoIGFsbCAob3duKSBwcm9wZXJ0aWVzIGZyb20gc291cmNlcyBpbi1vcmRlci4gVGh1cywgbGFzdCBzb3VyY2Ugd2lsbFxuICogICAgICAgICBvdmVycmlkZSBwcm9wZXJ0aWVzIGluIHByZXZpb3VzIHNvdXJjZXMuIERlZmluZSB0aGUgcHJvcGVydGllcyBhcyBub24gZW51bWVyYWJsZS5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gdGFyZ2V0IC0gVGhlIE9iamVjdCB0byBleHRlbmRcbiAqIEBwYXJhbSB7b2JqZWN0W119IHNvdXJjZXMgLSBPYmplY3RzIHRvIGNvcHkgcHJvcGVydGllcyBmcm9tLlxuICogQHJldHVybnMge29iamVjdH0gdGhlIGV4dGVuZGVkIHRhcmdldFxuICovXG5tb2R1bGUuZXhwb3J0cy5ub25FbnVtID0gZnVuY3Rpb24gZXh0ZW5kTm9uRW51bSh0YXJnZXQsIC4uLnNvdXJjZXMpIHtcbiAgICByZXR1cm4gZXh0ZW5kQ29tbW9uKFxuICAgICAgICB0YXJnZXQsXG4gICAgICAgIHNvdXJjZXMsXG4gICAgICAgIGZ1bmN0aW9uIGNvcHlQcm9wZXJ0eShkZXN0LCBzb3VyY2UsIHByb3ApIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShkZXN0LCBwcm9wLCB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHNvdXJjZVtwcm9wXSxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICApO1xufTtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgOiBub3QgdGVzdGluZyB0aGF0IHNldFRpbWVvdXQgd29ya3MgKi9cbmZ1bmN0aW9uIG5leHRUaWNrKGNhbGxiYWNrKSB7XG4gICAgc2V0VGltZW91dChjYWxsYmFjaywgMCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2V0TmV4dFRpY2socHJvY2Vzcywgc2V0SW1tZWRpYXRlKSB7XG4gICAgaWYgKHR5cGVvZiBwcm9jZXNzID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBwcm9jZXNzLm5leHRUaWNrID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2s7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBzZXRJbW1lZGlhdGUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gc2V0SW1tZWRpYXRlO1xuICAgIH1cblxuICAgIHJldHVybiBuZXh0VGljaztcbn07XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmNvbnN0IGdsb2JhbE9iamVjdCA9IHJlcXVpcmUoXCJAc2lub25qcy9jb21tb25zXCIpLmdsb2JhbDtcbmNvbnN0IGdldE5leHRUaWNrID0gcmVxdWlyZShcIi4vZ2V0LW5leHQtdGlja1wiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBnZXROZXh0VGljayhnbG9iYWxPYmplY3QucHJvY2VzcywgZ2xvYmFsT2JqZWN0LnNldEltbWVkaWF0ZSk7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmNvbnN0IGFycmF5UHJvdG8gPSByZXF1aXJlKFwiQHNpbm9uanMvY29tbW9uc1wiKS5wcm90b3R5cGVzLmFycmF5O1xuY29uc3QgcmVkdWNlID0gYXJyYXlQcm90by5yZWR1Y2U7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZXhwb3J0QXN5bmNCZWhhdmlvcnMoYmVoYXZpb3JNZXRob2RzKSB7XG4gICAgcmV0dXJuIHJlZHVjZShcbiAgICAgICAgT2JqZWN0LmtleXMoYmVoYXZpb3JNZXRob2RzKSxcbiAgICAgICAgZnVuY3Rpb24gKGFjYywgbWV0aG9kKSB7XG4gICAgICAgICAgICAvLyBuZWVkIHRvIGF2b2lkIGNyZWF0aW5nIGFub3RoZXIgYXN5bmMgdmVyc2lvbnMgb2YgdGhlIG5ld2x5IGFkZGVkIGFzeW5jIG1ldGhvZHNcbiAgICAgICAgICAgIGlmIChtZXRob2QubWF0Y2goL14oY2FsbHNBcmd8eWllbGRzKS8pICYmICFtZXRob2QubWF0Y2goL0FzeW5jLykpIHtcbiAgICAgICAgICAgICAgICBhY2NbYCR7bWV0aG9kfUFzeW5jYF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGJlaGF2aW9yTWV0aG9kc1ttZXRob2RdLmFwcGx5KFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50cyxcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYWxsYmFja0FzeW5jID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgfSxcbiAgICAgICAge30sXG4gICAgKTtcbn07XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmNvbnN0IGFycmF5UHJvdG8gPSByZXF1aXJlKFwiQHNpbm9uanMvY29tbW9uc1wiKS5wcm90b3R5cGVzLmFycmF5O1xuY29uc3QgZXh0ZW5kID0gcmVxdWlyZShcIi4vdXRpbC9jb3JlL2V4dGVuZFwiKTtcbmNvbnN0IGZ1bmN0aW9uTmFtZSA9IHJlcXVpcmUoXCJAc2lub25qcy9jb21tb25zXCIpLmZ1bmN0aW9uTmFtZTtcbmNvbnN0IG5leHRUaWNrID0gcmVxdWlyZShcIi4vdXRpbC9jb3JlL25leHQtdGlja1wiKTtcbmNvbnN0IHZhbHVlVG9TdHJpbmcgPSByZXF1aXJlKFwiQHNpbm9uanMvY29tbW9uc1wiKS52YWx1ZVRvU3RyaW5nO1xuY29uc3QgZXhwb3J0QXN5bmNCZWhhdmlvcnMgPSByZXF1aXJlKFwiLi91dGlsL2NvcmUvZXhwb3J0LWFzeW5jLWJlaGF2aW9yc1wiKTtcblxuY29uc3QgY29uY2F0ID0gYXJyYXlQcm90by5jb25jYXQ7XG5jb25zdCBqb2luID0gYXJyYXlQcm90by5qb2luO1xuY29uc3QgcmV2ZXJzZSA9IGFycmF5UHJvdG8ucmV2ZXJzZTtcbmNvbnN0IHNsaWNlID0gYXJyYXlQcm90by5zbGljZTtcblxuY29uc3QgdXNlTGVmdE1vc3RDYWxsYmFjayA9IC0xO1xuY29uc3QgdXNlUmlnaHRNb3N0Q2FsbGJhY2sgPSAtMjtcblxuZnVuY3Rpb24gZ2V0Q2FsbGJhY2soYmVoYXZpb3IsIGFyZ3MpIHtcbiAgICBjb25zdCBjYWxsQXJnQXQgPSBiZWhhdmlvci5jYWxsQXJnQXQ7XG5cbiAgICBpZiAoY2FsbEFyZ0F0ID49IDApIHtcbiAgICAgICAgcmV0dXJuIGFyZ3NbY2FsbEFyZ0F0XTtcbiAgICB9XG5cbiAgICBsZXQgYXJndW1lbnRMaXN0O1xuXG4gICAgaWYgKGNhbGxBcmdBdCA9PT0gdXNlTGVmdE1vc3RDYWxsYmFjaykge1xuICAgICAgICBhcmd1bWVudExpc3QgPSBhcmdzO1xuICAgIH1cblxuICAgIGlmIChjYWxsQXJnQXQgPT09IHVzZVJpZ2h0TW9zdENhbGxiYWNrKSB7XG4gICAgICAgIGFyZ3VtZW50TGlzdCA9IHJldmVyc2Uoc2xpY2UoYXJncykpO1xuICAgIH1cblxuICAgIGNvbnN0IGNhbGxBcmdQcm9wID0gYmVoYXZpb3IuY2FsbEFyZ1Byb3A7XG5cbiAgICBmb3IgKGxldCBpID0gMCwgbCA9IGFyZ3VtZW50TGlzdC5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgaWYgKCFjYWxsQXJnUHJvcCAmJiB0eXBlb2YgYXJndW1lbnRMaXN0W2ldID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBhcmd1bWVudExpc3RbaV07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoXG4gICAgICAgICAgICBjYWxsQXJnUHJvcCAmJlxuICAgICAgICAgICAgYXJndW1lbnRMaXN0W2ldICYmXG4gICAgICAgICAgICB0eXBlb2YgYXJndW1lbnRMaXN0W2ldW2NhbGxBcmdQcm9wXSA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuIGFyZ3VtZW50TGlzdFtpXVtjYWxsQXJnUHJvcF07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gZ2V0Q2FsbGJhY2tFcnJvcihiZWhhdmlvciwgZnVuYywgYXJncykge1xuICAgIGlmIChiZWhhdmlvci5jYWxsQXJnQXQgPCAwKSB7XG4gICAgICAgIGxldCBtc2c7XG5cbiAgICAgICAgaWYgKGJlaGF2aW9yLmNhbGxBcmdQcm9wKSB7XG4gICAgICAgICAgICBtc2cgPSBgJHtmdW5jdGlvbk5hbWUoXG4gICAgICAgICAgICAgICAgYmVoYXZpb3Iuc3R1YixcbiAgICAgICAgICAgICl9IGV4cGVjdGVkIHRvIHlpZWxkIHRvICcke3ZhbHVlVG9TdHJpbmcoXG4gICAgICAgICAgICAgICAgYmVoYXZpb3IuY2FsbEFyZ1Byb3AsXG4gICAgICAgICAgICApfScsIGJ1dCBubyBvYmplY3Qgd2l0aCBzdWNoIGEgcHJvcGVydHkgd2FzIHBhc3NlZC5gO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbXNnID0gYCR7ZnVuY3Rpb25OYW1lKFxuICAgICAgICAgICAgICAgIGJlaGF2aW9yLnN0dWIsXG4gICAgICAgICAgICApfSBleHBlY3RlZCB0byB5aWVsZCwgYnV0IG5vIGNhbGxiYWNrIHdhcyBwYXNzZWQuYDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhcmdzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIG1zZyArPSBgIFJlY2VpdmVkIFske2pvaW4oYXJncywgXCIsIFwiKX1dYDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtc2c7XG4gICAgfVxuXG4gICAgcmV0dXJuIGBhcmd1bWVudCBhdCBpbmRleCAke2JlaGF2aW9yLmNhbGxBcmdBdH0gaXMgbm90IGEgZnVuY3Rpb246ICR7ZnVuY31gO1xufVxuXG5mdW5jdGlvbiBlbnN1cmVBcmdzKG5hbWUsIGJlaGF2aW9yLCBhcmdzKSB7XG4gICAgLy8gbWFwIGZ1bmN0aW9uIG5hbWUgdG8gaW50ZXJuYWwgcHJvcGVydHlcbiAgICAvLyAgIGNhbGxzQXJnID0+IGNhbGxBcmdBdFxuICAgIGNvbnN0IHByb3BlcnR5ID0gbmFtZS5yZXBsYWNlKC9zQXJnLywgXCJBcmdBdFwiKTtcbiAgICBjb25zdCBpbmRleCA9IGJlaGF2aW9yW3Byb3BlcnR5XTtcblxuICAgIGlmIChpbmRleCA+PSBhcmdzLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgYCR7bmFtZX0gZmFpbGVkOiAke2luZGV4ICsgMX0gYXJndW1lbnRzIHJlcXVpcmVkIGJ1dCBvbmx5ICR7XG4gICAgICAgICAgICAgICAgYXJncy5sZW5ndGhcbiAgICAgICAgICAgIH0gcHJlc2VudGAsXG4gICAgICAgICk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBjYWxsQ2FsbGJhY2soYmVoYXZpb3IsIGFyZ3MpIHtcbiAgICBpZiAodHlwZW9mIGJlaGF2aW9yLmNhbGxBcmdBdCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICBlbnN1cmVBcmdzKFwiY2FsbHNBcmdcIiwgYmVoYXZpb3IsIGFyZ3MpO1xuICAgICAgICBjb25zdCBmdW5jID0gZ2V0Q2FsbGJhY2soYmVoYXZpb3IsIGFyZ3MpO1xuXG4gICAgICAgIGlmICh0eXBlb2YgZnVuYyAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGdldENhbGxiYWNrRXJyb3IoYmVoYXZpb3IsIGZ1bmMsIGFyZ3MpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChiZWhhdmlvci5jYWxsYmFja0FzeW5jKSB7XG4gICAgICAgICAgICBuZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZnVuYy5hcHBseShcbiAgICAgICAgICAgICAgICAgICAgYmVoYXZpb3IuY2FsbGJhY2tDb250ZXh0LFxuICAgICAgICAgICAgICAgICAgICBiZWhhdmlvci5jYWxsYmFja0FyZ3VtZW50cyxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuYy5hcHBseShcbiAgICAgICAgICAgICAgICBiZWhhdmlvci5jYWxsYmFja0NvbnRleHQsXG4gICAgICAgICAgICAgICAgYmVoYXZpb3IuY2FsbGJhY2tBcmd1bWVudHMsXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuY29uc3QgcHJvdG8gPSB7XG4gICAgY3JlYXRlOiBmdW5jdGlvbiBjcmVhdGUoc3R1Yikge1xuICAgICAgICBjb25zdCBiZWhhdmlvciA9IGV4dGVuZCh7fSwgcHJvdG8pO1xuICAgICAgICBkZWxldGUgYmVoYXZpb3IuY3JlYXRlO1xuICAgICAgICBkZWxldGUgYmVoYXZpb3IuYWRkQmVoYXZpb3I7XG4gICAgICAgIGRlbGV0ZSBiZWhhdmlvci5jcmVhdGVCZWhhdmlvcjtcbiAgICAgICAgYmVoYXZpb3Iuc3R1YiA9IHN0dWI7XG5cbiAgICAgICAgaWYgKHN0dWIuZGVmYXVsdEJlaGF2aW9yICYmIHN0dWIuZGVmYXVsdEJlaGF2aW9yLnByb21pc2VMaWJyYXJ5KSB7XG4gICAgICAgICAgICBiZWhhdmlvci5wcm9taXNlTGlicmFyeSA9IHN0dWIuZGVmYXVsdEJlaGF2aW9yLnByb21pc2VMaWJyYXJ5O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGJlaGF2aW9yO1xuICAgIH0sXG5cbiAgICBpc1ByZXNlbnQ6IGZ1bmN0aW9uIGlzUHJlc2VudCgpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHR5cGVvZiB0aGlzLmNhbGxBcmdBdCA9PT0gXCJudW1iZXJcIiB8fFxuICAgICAgICAgICAgdGhpcy5leGNlcHRpb24gfHxcbiAgICAgICAgICAgIHRoaXMuZXhjZXB0aW9uQ3JlYXRvciB8fFxuICAgICAgICAgICAgdHlwZW9mIHRoaXMucmV0dXJuQXJnQXQgPT09IFwibnVtYmVyXCIgfHxcbiAgICAgICAgICAgIHRoaXMucmV0dXJuVGhpcyB8fFxuICAgICAgICAgICAgdHlwZW9mIHRoaXMucmVzb2x2ZUFyZ0F0ID09PSBcIm51bWJlclwiIHx8XG4gICAgICAgICAgICB0aGlzLnJlc29sdmVUaGlzIHx8XG4gICAgICAgICAgICB0eXBlb2YgdGhpcy50aHJvd0FyZ0F0ID09PSBcIm51bWJlclwiIHx8XG4gICAgICAgICAgICB0aGlzLmZha2VGbiB8fFxuICAgICAgICAgICAgdGhpcy5yZXR1cm5WYWx1ZURlZmluZWRcbiAgICAgICAgKTtcbiAgICB9LFxuXG4gICAgLyplc2xpbnQgY29tcGxleGl0eTogW1wiZXJyb3JcIiwgMjBdKi9cbiAgICBpbnZva2U6IGZ1bmN0aW9uIGludm9rZShjb250ZXh0LCBhcmdzKSB7XG4gICAgICAgIC8qXG4gICAgICAgICAqIGNhbGxDYWxsYmFjayAoY29uZGl0aW9uYWxseSkgY2FsbHMgZW5zdXJlQXJnc1xuICAgICAgICAgKlxuICAgICAgICAgKiBOb3RlOiBjYWxsQ2FsbGJhY2sgaW50ZW50aW9uYWxseSBoYXBwZW5zIGJlZm9yZVxuICAgICAgICAgKiBldmVyeXRoaW5nIGVsc2UgYW5kIGNhbm5vdCBiZSBtb3ZlZCBsb3dlclxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3QgcmV0dXJuVmFsdWUgPSBjYWxsQ2FsbGJhY2sodGhpcywgYXJncyk7XG5cbiAgICAgICAgaWYgKHRoaXMuZXhjZXB0aW9uKSB7XG4gICAgICAgICAgICB0aHJvdyB0aGlzLmV4Y2VwdGlvbjtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmV4Y2VwdGlvbkNyZWF0b3IpIHtcbiAgICAgICAgICAgIHRoaXMuZXhjZXB0aW9uID0gdGhpcy5leGNlcHRpb25DcmVhdG9yKCk7XG4gICAgICAgICAgICB0aGlzLmV4Y2VwdGlvbkNyZWF0b3IgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aHJvdyB0aGlzLmV4Y2VwdGlvbjtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdGhpcy5yZXR1cm5BcmdBdCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgZW5zdXJlQXJncyhcInJldHVybnNBcmdcIiwgdGhpcywgYXJncyk7XG4gICAgICAgICAgICByZXR1cm4gYXJnc1t0aGlzLnJldHVybkFyZ0F0XTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnJldHVyblRoaXMpIHtcbiAgICAgICAgICAgIHJldHVybiBjb250ZXh0O1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aGlzLnRocm93QXJnQXQgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIGVuc3VyZUFyZ3MoXCJ0aHJvd3NBcmdcIiwgdGhpcywgYXJncyk7XG4gICAgICAgICAgICB0aHJvdyBhcmdzW3RoaXMudGhyb3dBcmdBdF07XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5mYWtlRm4pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZha2VGbi5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdGhpcy5yZXNvbHZlQXJnQXQgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIGVuc3VyZUFyZ3MoXCJyZXNvbHZlc0FyZ1wiLCB0aGlzLCBhcmdzKTtcbiAgICAgICAgICAgIHJldHVybiAodGhpcy5wcm9taXNlTGlicmFyeSB8fCBQcm9taXNlKS5yZXNvbHZlKFxuICAgICAgICAgICAgICAgIGFyZ3NbdGhpcy5yZXNvbHZlQXJnQXRdLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnJlc29sdmVUaGlzKSB7XG4gICAgICAgICAgICByZXR1cm4gKHRoaXMucHJvbWlzZUxpYnJhcnkgfHwgUHJvbWlzZSkucmVzb2x2ZShjb250ZXh0KTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnJlc29sdmUpIHtcbiAgICAgICAgICAgIHJldHVybiAodGhpcy5wcm9taXNlTGlicmFyeSB8fCBQcm9taXNlKS5yZXNvbHZlKHRoaXMucmV0dXJuVmFsdWUpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMucmVqZWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gKHRoaXMucHJvbWlzZUxpYnJhcnkgfHwgUHJvbWlzZSkucmVqZWN0KHRoaXMucmV0dXJuVmFsdWUpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuY2FsbHNUaHJvdWdoKSB7XG4gICAgICAgICAgICBjb25zdCB3cmFwcGVkTWV0aG9kID0gdGhpcy5lZmZlY3RpdmVXcmFwcGVkTWV0aG9kKCk7XG5cbiAgICAgICAgICAgIHJldHVybiB3cmFwcGVkTWV0aG9kLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuY2FsbHNUaHJvdWdoV2l0aE5ldykge1xuICAgICAgICAgICAgLy8gR2V0IHRoZSBvcmlnaW5hbCBtZXRob2QgKGFzc3VtZWQgdG8gYmUgYSBjb25zdHJ1Y3RvciBpbiB0aGlzIGNhc2UpXG4gICAgICAgICAgICBjb25zdCBXcmFwcGVkQ2xhc3MgPSB0aGlzLmVmZmVjdGl2ZVdyYXBwZWRNZXRob2QoKTtcbiAgICAgICAgICAgIC8vIFR1cm4gdGhlIGFyZ3VtZW50cyBvYmplY3QgaW50byBhIG5vcm1hbCBhcnJheVxuICAgICAgICAgICAgY29uc3QgYXJnc0FycmF5ID0gc2xpY2UoYXJncyk7XG4gICAgICAgICAgICAvLyBDYWxsIHRoZSBjb25zdHJ1Y3RvclxuICAgICAgICAgICAgY29uc3QgRiA9IFdyYXBwZWRDbGFzcy5iaW5kLmFwcGx5KFxuICAgICAgICAgICAgICAgIFdyYXBwZWRDbGFzcyxcbiAgICAgICAgICAgICAgICBjb25jYXQoW251bGxdLCBhcmdzQXJyYXkpLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRigpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aGlzLnJldHVyblZhbHVlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXR1cm5WYWx1ZTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdGhpcy5jYWxsQXJnQXQgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLnJldHVyblZhbHVlO1xuICAgIH0sXG5cbiAgICBlZmZlY3RpdmVXcmFwcGVkTWV0aG9kOiBmdW5jdGlvbiBlZmZlY3RpdmVXcmFwcGVkTWV0aG9kKCkge1xuICAgICAgICBmb3IgKGxldCBzdHViYiA9IHRoaXMuc3R1Yjsgc3R1YmI7IHN0dWJiID0gc3R1YmIucGFyZW50KSB7XG4gICAgICAgICAgICBpZiAoc3R1YmIud3JhcHBlZE1ldGhvZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdHViYi53cmFwcGVkTWV0aG9kO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBmaW5kIHdyYXBwZWQgbWV0aG9kXCIpO1xuICAgIH0sXG5cbiAgICBvbkNhbGw6IGZ1bmN0aW9uIG9uQ2FsbChpbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdHViLm9uQ2FsbChpbmRleCk7XG4gICAgfSxcblxuICAgIG9uRmlyc3RDYWxsOiBmdW5jdGlvbiBvbkZpcnN0Q2FsbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3R1Yi5vbkZpcnN0Q2FsbCgpO1xuICAgIH0sXG5cbiAgICBvblNlY29uZENhbGw6IGZ1bmN0aW9uIG9uU2Vjb25kQ2FsbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3R1Yi5vblNlY29uZENhbGwoKTtcbiAgICB9LFxuXG4gICAgb25UaGlyZENhbGw6IGZ1bmN0aW9uIG9uVGhpcmRDYWxsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdHViLm9uVGhpcmRDYWxsKCk7XG4gICAgfSxcblxuICAgIHdpdGhBcmdzOiBmdW5jdGlvbiB3aXRoQXJncygvKiBhcmd1bWVudHMgKi8pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgJ0RlZmluaW5nIGEgc3R1YiBieSBpbnZva2luZyBcInN0dWIub25DYWxsKC4uLikud2l0aEFyZ3MoLi4uKVwiICcgK1xuICAgICAgICAgICAgICAgICdpcyBub3Qgc3VwcG9ydGVkLiBVc2UgXCJzdHViLndpdGhBcmdzKC4uLikub25DYWxsKC4uLilcIiAnICtcbiAgICAgICAgICAgICAgICBcInRvIGRlZmluZSBzZXF1ZW50aWFsIGJlaGF2aW9yIGZvciBjYWxscyB3aXRoIGNlcnRhaW4gYXJndW1lbnRzLlwiLFxuICAgICAgICApO1xuICAgIH0sXG59O1xuXG5mdW5jdGlvbiBjcmVhdGVCZWhhdmlvcihiZWhhdmlvck1ldGhvZCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZGVmYXVsdEJlaGF2aW9yID0gdGhpcy5kZWZhdWx0QmVoYXZpb3IgfHwgcHJvdG8uY3JlYXRlKHRoaXMpO1xuICAgICAgICB0aGlzLmRlZmF1bHRCZWhhdmlvcltiZWhhdmlvck1ldGhvZF0uYXBwbHkoXG4gICAgICAgICAgICB0aGlzLmRlZmF1bHRCZWhhdmlvcixcbiAgICAgICAgICAgIGFyZ3VtZW50cyxcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gYWRkQmVoYXZpb3Ioc3R1YiwgbmFtZSwgZm4pIHtcbiAgICBwcm90b1tuYW1lXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm4uYXBwbHkodGhpcywgY29uY2F0KFt0aGlzXSwgc2xpY2UoYXJndW1lbnRzKSkpO1xuICAgICAgICByZXR1cm4gdGhpcy5zdHViIHx8IHRoaXM7XG4gICAgfTtcblxuICAgIHN0dWJbbmFtZV0gPSBjcmVhdGVCZWhhdmlvcihuYW1lKTtcbn1cblxucHJvdG8uYWRkQmVoYXZpb3IgPSBhZGRCZWhhdmlvcjtcbnByb3RvLmNyZWF0ZUJlaGF2aW9yID0gY3JlYXRlQmVoYXZpb3I7XG5cbmNvbnN0IGFzeW5jQmVoYXZpb3JzID0gZXhwb3J0QXN5bmNCZWhhdmlvcnMocHJvdG8pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4dGVuZC5ub25FbnVtKHt9LCBwcm90bywgYXN5bmNCZWhhdmlvcnMpO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5jb25zdCBmb3JFYWNoID0gcmVxdWlyZShcIkBzaW5vbmpzL2NvbW1vbnNcIikucHJvdG90eXBlcy5hcnJheS5mb3JFYWNoO1xuXG5mdW5jdGlvbiB3YWxrSW50ZXJuYWwob2JqLCBpdGVyYXRvciwgY29udGV4dCwgb3JpZ2luYWxPYmosIHNlZW4pIHtcbiAgICBsZXQgcHJvcDtcbiAgICBjb25zdCBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmopO1xuXG4gICAgaWYgKHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIC8vIFdlIGV4cGxpY2l0bHkgd2FudCB0byBlbnVtZXJhdGUgdGhyb3VnaCBhbGwgb2YgdGhlIHByb3RvdHlwZSdzIHByb3BlcnRpZXNcbiAgICAgICAgLy8gaW4gdGhpcyBjYXNlLCB0aGVyZWZvcmUgd2UgZGVsaWJlcmF0ZWx5IGxlYXZlIG91dCBhbiBvd24gcHJvcGVydHkgY2hlY2suXG4gICAgICAgIC8qIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBndWFyZC1mb3ItaW4gKi9cbiAgICAgICAgZm9yIChwcm9wIGluIG9iaikge1xuICAgICAgICAgICAgaXRlcmF0b3IuY2FsbChjb250ZXh0LCBvYmpbcHJvcF0sIHByb3AsIG9iaik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZm9yRWFjaChPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmopLCBmdW5jdGlvbiAoaykge1xuICAgICAgICBpZiAoc2VlbltrXSAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgc2VlbltrXSA9IHRydWU7XG4gICAgICAgICAgICBjb25zdCB0YXJnZXQgPVxuICAgICAgICAgICAgICAgIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwgaykuZ2V0ID09PVxuICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIlxuICAgICAgICAgICAgICAgICAgICA/IG9yaWdpbmFsT2JqXG4gICAgICAgICAgICAgICAgICAgIDogb2JqO1xuICAgICAgICAgICAgaXRlcmF0b3IuY2FsbChjb250ZXh0LCBrLCB0YXJnZXQpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAocHJvdG8pIHtcbiAgICAgICAgd2Fsa0ludGVybmFsKHByb3RvLCBpdGVyYXRvciwgY29udGV4dCwgb3JpZ2luYWxPYmosIHNlZW4pO1xuICAgIH1cbn1cblxuLyogV2Fsa3MgdGhlIHByb3RvdHlwZSBjaGFpbiBvZiBhbiBvYmplY3QgYW5kIGl0ZXJhdGVzIG92ZXIgZXZlcnkgb3duIHByb3BlcnR5XG4gKiBuYW1lIGVuY291bnRlcmVkLiBUaGUgaXRlcmF0b3IgaXMgY2FsbGVkIGluIHRoZSBzYW1lIGZhc2hpb24gdGhhdCBBcnJheS5wcm90b3R5cGUuZm9yRWFjaFxuICogd29ya3MsIHdoZXJlIGl0IGlzIHBhc3NlZCB0aGUgdmFsdWUsIGtleSwgYW5kIG93biBvYmplY3QgYXMgdGhlIDFzdCwgMm5kLCBhbmQgM3JkIHBvc2l0aW9uYWxcbiAqIGFyZ3VtZW50LCByZXNwZWN0aXZlbHkuIEluIGNhc2VzIHdoZXJlIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIGlzIG5vdCBhdmFpbGFibGUsIHdhbGsgd2lsbFxuICogZGVmYXVsdCB0byB1c2luZyBhIHNpbXBsZSBmb3IuLmluIGxvb3AuXG4gKlxuICogb2JqIC0gVGhlIG9iamVjdCB0byB3YWxrIHRoZSBwcm90b3R5cGUgY2hhaW4gZm9yLlxuICogaXRlcmF0b3IgLSBUaGUgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIG9uIGVhY2ggcGFzcyBvZiB0aGUgd2Fsay5cbiAqIGNvbnRleHQgLSAoT3B0aW9uYWwpIFdoZW4gZ2l2ZW4sIHRoZSBpdGVyYXRvciB3aWxsIGJlIGNhbGxlZCB3aXRoIHRoaXMgb2JqZWN0IGFzIHRoZSByZWNlaXZlci5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB3YWxrKG9iaiwgaXRlcmF0b3IsIGNvbnRleHQpIHtcbiAgICByZXR1cm4gd2Fsa0ludGVybmFsKG9iaiwgaXRlcmF0b3IsIGNvbnRleHQsIG9iaiwge30pO1xufTtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBQcm9wZXJ0eURlc2NyaXB0b3JcbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2RlZmluZVByb3BlcnR5I2Rlc2NyaXB0aW9uXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGNvbmZpZ3VyYWJsZSBkZWZhdWx0cyB0byBmYWxzZVxuICogQHByb3BlcnR5IHtib29sZWFufSBlbnVtZXJhYmxlICAgZGVmYXVsdHMgdG8gZmFsc2VcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gd3JpdGFibGUgICAgIGRlZmF1bHRzIHRvIGZhbHNlXG4gKiBAcHJvcGVydHkgeyp9IHZhbHVlIGRlZmF1bHRzIHRvIHVuZGVmaW5lZFxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gZ2V0IGRlZmF1bHRzIHRvIHVuZGVmaW5lZFxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gc2V0IGRlZmF1bHRzIHRvIHVuZGVmaW5lZFxuICovXG5cbi8qXG4gKiBUaGUgZm9sbG93aW5nIHR5cGUgZGVmIGlzIHN0cmljdGx5IHNwZWFraW5nIGlsbGVnYWwgaW4gSlNEb2MsIGJ1dCB0aGUgZXhwcmVzc2lvbiBmb3JtcyBhXG4gKiBsZWdhbCBUeXBlc2NyaXB0IHVuaW9uIHR5cGUgYW5kIGlzIHVuZGVyc3Rvb2QgYnkgVmlzdWFsIFN0dWRpbyBhbmQgdGhlIEludGVsbGlKXG4gKiBmYW1pbHkgb2YgZWRpdG9ycy4gVGhlIFwiVFNcIiBmbGF2b3Igb2YgSlNEb2MgaXMgYmVjb21pbmcgdGhlIGRlLWZhY3RvIHN0YW5kYXJkIHRoZXNlXG4gKiBkYXlzIGZvciB0aGF0IHJlYXNvbiAoYW5kIHRoZSBmYWN0IHRoYXQgSlNEb2MgaXMgZXNzZW50aWFsbHkgdW5tYWludGFpbmVkKVxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge3tpc093bjogYm9vbGVhbn0gJiBQcm9wZXJ0eURlc2NyaXB0b3J9IFNpbm9uUHJvcGVydHlEZXNjcmlwdG9yXG4gKiBhIHNsaWdodGx5IGVucmljaGVkIHByb3BlcnR5IGRlc2NyaXB0b3JcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gaXNPd24gdHJ1ZSBpZiB0aGUgZGVzY3JpcHRvciBpcyBvd25lZCBieSB0aGlzIG9iamVjdCwgZmFsc2UgaWYgaXQgY29tZXMgZnJvbSB0aGUgcHJvdG90eXBlXG4gKi9cblxuLyoqXG4gKiBSZXR1cm5zIGEgc2xpZ2h0bHkgbW9kaWZpZWQgcHJvcGVydHkgZGVzY3JpcHRvciB0aGF0IG9uZSBjYW4gdGVsbCBpcyBmcm9tIHRoZSBvYmplY3Qgb3IgdGhlIHByb3RvdHlwZVxuICpcbiAqIEBwYXJhbSB7Kn0gb2JqZWN0XG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHlcbiAqIEByZXR1cm5zIHtTaW5vblByb3BlcnR5RGVzY3JpcHRvcn1cbiAqL1xuZnVuY3Rpb24gZ2V0UHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpIHtcbiAgICBsZXQgcHJvdG8gPSBvYmplY3Q7XG4gICAgbGV0IGRlc2NyaXB0b3I7XG4gICAgY29uc3QgaXNPd24gPSBCb29sZWFuKFxuICAgICAgICBvYmplY3QgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KSxcbiAgICApO1xuXG4gICAgd2hpbGUgKFxuICAgICAgICBwcm90byAmJlxuICAgICAgICAhKGRlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHByb3RvLCBwcm9wZXJ0eSkpXG4gICAgKSB7XG4gICAgICAgIHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHByb3RvKTtcbiAgICB9XG5cbiAgICBpZiAoZGVzY3JpcHRvcikge1xuICAgICAgICBkZXNjcmlwdG9yLmlzT3duID0gaXNPd247XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlc2NyaXB0b3I7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0UHJvcGVydHlEZXNjcmlwdG9yO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5jb25zdCB3YWxrID0gcmVxdWlyZShcIi4vdXRpbC9jb3JlL3dhbGtcIik7XG5jb25zdCBnZXRQcm9wZXJ0eURlc2NyaXB0b3IgPSByZXF1aXJlKFwiLi91dGlsL2NvcmUvZ2V0LXByb3BlcnR5LWRlc2NyaXB0b3JcIik7XG5jb25zdCBoYXNPd25Qcm9wZXJ0eSA9XG4gICAgcmVxdWlyZShcIkBzaW5vbmpzL2NvbW1vbnNcIikucHJvdG90eXBlcy5vYmplY3QuaGFzT3duUHJvcGVydHk7XG5jb25zdCBwdXNoID0gcmVxdWlyZShcIkBzaW5vbmpzL2NvbW1vbnNcIikucHJvdG90eXBlcy5hcnJheS5wdXNoO1xuXG5mdW5jdGlvbiBjb2xsZWN0TWV0aG9kKG1ldGhvZHMsIG9iamVjdCwgcHJvcCwgcHJvcE93bmVyKSB7XG4gICAgaWYgKFxuICAgICAgICB0eXBlb2YgZ2V0UHJvcGVydHlEZXNjcmlwdG9yKHByb3BPd25lciwgcHJvcCkudmFsdWUgPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgICBoYXNPd25Qcm9wZXJ0eShvYmplY3QsIHByb3ApXG4gICAgKSB7XG4gICAgICAgIHB1c2gobWV0aG9kcywgb2JqZWN0W3Byb3BdKTtcbiAgICB9XG59XG5cbi8vIFRoaXMgZnVuY3Rpb24gcmV0dXJucyBhbiBhcnJheSBvZiBhbGwgdGhlIG93biBtZXRob2RzIG9uIHRoZSBwYXNzZWQgb2JqZWN0XG5mdW5jdGlvbiBjb2xsZWN0T3duTWV0aG9kcyhvYmplY3QpIHtcbiAgICBjb25zdCBtZXRob2RzID0gW107XG5cbiAgICB3YWxrKG9iamVjdCwgY29sbGVjdE1ldGhvZC5iaW5kKG51bGwsIG1ldGhvZHMsIG9iamVjdCkpO1xuXG4gICAgcmV0dXJuIG1ldGhvZHM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29sbGVjdE93bk1ldGhvZHM7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmNvbnN0IGdldFByb3BlcnR5RGVzY3JpcHRvciA9IHJlcXVpcmUoXCIuL2dldC1wcm9wZXJ0eS1kZXNjcmlwdG9yXCIpO1xuXG5mdW5jdGlvbiBpc1Byb3BlcnR5Q29uZmlndXJhYmxlKG9iaiwgcHJvcE5hbWUpIHtcbiAgICBjb25zdCBwcm9wZXJ0eURlc2NyaXB0b3IgPSBnZXRQcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBwcm9wTmFtZSk7XG5cbiAgICByZXR1cm4gcHJvcGVydHlEZXNjcmlwdG9yID8gcHJvcGVydHlEZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA6IHRydWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNQcm9wZXJ0eUNvbmZpZ3VyYWJsZTtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBDb21wYXJlcyBhIGB2YWx1ZWAgdG8gYE5hTmBcbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBBIHZhbHVlIHRvIGV4YW1pbmVcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCB3aGVuIGB2YWx1ZWAgaXMgYE5hTmBcbiAqL1xuZnVuY3Rpb24gaXNOYU4odmFsdWUpIHtcbiAgICAvLyBVbmxpa2UgZ2xvYmFsIGBpc05hTmAsIHRoaXMgZnVuY3Rpb24gYXZvaWRzIHR5cGUgY29lcmNpb25cbiAgICAvLyBgdHlwZW9mYCBjaGVjayBhdm9pZHMgSUUgaG9zdCBvYmplY3QgaXNzdWVzLCBoYXQgdGlwIHRvXG4gICAgLy8gbG9kYXNoXG5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIiAmJiB2YWx1ZSAhPT0gdmFsdWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNOYU47XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogUmV0dXJucyBgdHJ1ZWAgd2hlbiBgdmFsdWVgIGlzIGAtMGBcbiAqXG4gKiBAYWxpYXMgbW9kdWxlOnNhbXNhbS5pc05lZ1plcm9cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgQSB2YWx1ZSB0byBleGFtaW5lXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgd2hlbiBgdmFsdWVgIGlzIGAtMGBcbiAqL1xuZnVuY3Rpb24gaXNOZWdaZXJvKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA9PT0gLUluZmluaXR5O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzTmVnWmVybztcbiIsICJcInVzZSBzdHJpY3RcIjtcblxudmFyIGlzTmFOID0gcmVxdWlyZShcIi4vaXMtbmFuXCIpO1xudmFyIGlzTmVnWmVybyA9IHJlcXVpcmUoXCIuL2lzLW5lZy16ZXJvXCIpO1xuXG4vKipcbiAqIFN0cmljdCBlcXVhbGl0eSBjaGVjayBhY2NvcmRpbmcgdG8gRWNtYVNjcmlwdCBIYXJtb255J3MgYGVnYWxgLlxuICpcbiAqICoqRnJvbSB0aGUgSGFybW9ueSB3aWtpOioqXG4gKiA+IEFuIGBlZ2FsYCBmdW5jdGlvbiBzaW1wbHkgbWFrZXMgYXZhaWxhYmxlIHRoZSBpbnRlcm5hbCBgU2FtZVZhbHVlYCBmdW5jdGlvblxuICogPiBmcm9tIHNlY3Rpb24gOS4xMiBvZiB0aGUgRVM1IHNwZWMuIElmIHR3byB2YWx1ZXMgYXJlIGVnYWwsIHRoZW4gdGhleSBhcmUgbm90XG4gKiA+IG9ic2VydmFibHkgZGlzdGluZ3Vpc2hhYmxlLlxuICpcbiAqIGBpZGVudGljYWxgIHJldHVybnMgYHRydWVgIHdoZW4gYD09PWAgaXMgYHRydWVgLCBleGNlcHQgZm9yIGAtMGAgYW5kXG4gKiBgKzBgLCB3aGVyZSBpdCByZXR1cm5zIGBmYWxzZWAuIEFkZGl0aW9uYWxseSwgaXQgcmV0dXJucyBgdHJ1ZWAgd2hlblxuICogYE5hTmAgaXMgY29tcGFyZWQgdG8gaXRzZWxmLlxuICpcbiAqIEBhbGlhcyBtb2R1bGU6c2Ftc2FtLmlkZW50aWNhbFxuICogQHBhcmFtIHsqfSBvYmoxIFRoZSBmaXJzdCB2YWx1ZSB0byBjb21wYXJlXG4gKiBAcGFyYW0geyp9IG9iajIgVGhlIHNlY29uZCB2YWx1ZSB0byBjb21wYXJlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgd2hlbiB0aGUgb2JqZWN0cyBhcmUgKmVnYWwqLCBgZmFsc2VgIG90aGVyd2lzZVxuICovXG5mdW5jdGlvbiBpZGVudGljYWwob2JqMSwgb2JqMikge1xuICAgIGlmIChvYmoxID09PSBvYmoyIHx8IChpc05hTihvYmoxKSAmJiBpc05hTihvYmoyKSkpIHtcbiAgICAgICAgcmV0dXJuIG9iajEgIT09IDAgfHwgaXNOZWdaZXJvKG9iajEpID09PSBpc05lZ1plcm8ob2JqMik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlkZW50aWNhbDtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxudmFyIHRvU3RyaW5nID0gcmVxdWlyZShcIkBzaW5vbmpzL2NvbW1vbnNcIikucHJvdG90eXBlcy5vYmplY3QudG9TdHJpbmc7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgaW50ZXJuYWwgYENsYXNzYCBieSBjYWxsaW5nIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYFxuICogd2l0aCB0aGUgcHJvdmlkZWQgdmFsdWUgYXMgYHRoaXNgLiBSZXR1cm4gdmFsdWUgaXMgYSBgU3RyaW5nYCwgbmFtaW5nIHRoZVxuICogaW50ZXJuYWwgY2xhc3MsIGUuZy4gXCJBcnJheVwiXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSAgeyp9IHZhbHVlIC0gQW55IHZhbHVlXG4gKiBAcmV0dXJucyB7c3RyaW5nfSAtIEEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBgQ2xhc3NgIG9mIGB2YWx1ZWBcbiAqL1xuZnVuY3Rpb24gZ2V0Q2xhc3ModmFsdWUpIHtcbiAgICByZXR1cm4gdG9TdHJpbmcodmFsdWUpLnNwbGl0KC9bIFxcXV0vKVsxXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRDbGFzcztcbiIsICJcInVzZSBzdHJpY3RcIjtcblxudmFyIGdldENsYXNzID0gcmVxdWlyZShcIi4vZ2V0LWNsYXNzXCIpO1xuXG4vKipcbiAqIFJldHVybnMgYHRydWVgIHdoZW4gYG9iamVjdGAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LCBgZmFsc2VgIG90aGVyd2lzZVxuICpcbiAqIEBhbGlhcyBtb2R1bGU6c2Ftc2FtLmlzQXJndW1lbnRzXG4gKiBAcGFyYW0gIHsqfSAgb2JqZWN0IC0gVGhlIG9iamVjdCB0byBleGFtaW5lXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIHdoZW4gYG9iamVjdGAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIGlzQXJndW1lbnRzKG9iamVjdCkge1xuICAgIHJldHVybiBnZXRDbGFzcyhvYmplY3QpID09PSBcIkFyZ3VtZW50c1wiO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQXJndW1lbnRzO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG52YXIgZGl2ID0gdHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiICYmIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG5cbi8qKlxuICogUmV0dXJucyBgdHJ1ZWAgd2hlbiBgb2JqZWN0YCBpcyBhIERPTSBlbGVtZW50IG5vZGUuXG4gKlxuICogVW5saWtlIFVuZGVyc2NvcmUuanMvbG9kYXNoLCB0aGlzIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIGBmYWxzZWAgaWYgYG9iamVjdGBcbiAqIGlzIGFuICplbGVtZW50LWxpa2UqIG9iamVjdCwgaS5lLiBhIHJlZ3VsYXIgb2JqZWN0IHdpdGggYSBgbm9kZVR5cGVgXG4gKiBwcm9wZXJ0eSB0aGF0IGhvbGRzIHRoZSB2YWx1ZSBgMWAuXG4gKlxuICogQGFsaWFzIG1vZHVsZTpzYW1zYW0uaXNFbGVtZW50XG4gKiBAcGFyYW0ge29iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gZXhhbWluZVxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGZvciBET00gZWxlbWVudCBub2Rlc1xuICovXG5mdW5jdGlvbiBpc0VsZW1lbnQob2JqZWN0KSB7XG4gICAgaWYgKCFvYmplY3QgfHwgb2JqZWN0Lm5vZGVUeXBlICE9PSAxIHx8ICFkaXYpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBvYmplY3QuYXBwZW5kQ2hpbGQoZGl2KTtcbiAgICAgICAgb2JqZWN0LnJlbW92ZUNoaWxkKGRpdik7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzRWxlbWVudDtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBSZXR1cm5zIGB0cnVlYCB3aGVuIHRoZSBhcmd1bWVudCBpcyBhbiBpbnN0YW5jZSBvZiBTZXQsIGBmYWxzZWAgb3RoZXJ3aXNlXG4gKlxuICogQGFsaWFzIG1vZHVsZTpzYW1zYW0uaXNTZXRcbiAqIEBwYXJhbSAgeyp9ICB2YWwgLSBBIHZhbHVlIHRvIGV4YW1pbmVcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCB3aGVuIHRoZSBhcmd1bWVudCBpcyBhbiBpbnN0YW5jZSBvZiBTZXQsIGBmYWxzZWAgb3RoZXJ3aXNlXG4gKi9cbmZ1bmN0aW9uIGlzU2V0KHZhbCkge1xuICAgIHJldHVybiAodHlwZW9mIFNldCAhPT0gXCJ1bmRlZmluZWRcIiAmJiB2YWwgaW5zdGFuY2VvZiBTZXQpIHx8IGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzU2V0O1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIFJldHVybnMgYHRydWVgIHdoZW4gYHZhbHVlYCBpcyBhIE1hcFxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgQSB2YWx1ZSB0byBleGFtaW5lXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIHdoZW4gYHZhbHVlYCBpcyBhbiBpbnN0YW5jZSBvZiBgTWFwYCwgYGZhbHNlYCBvdGhlcndpc2VcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGlzTWFwKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBNYXAgIT09IFwidW5kZWZpbmVkXCIgJiYgdmFsdWUgaW5zdGFuY2VvZiBNYXA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNNYXA7XG4iLCAiKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKSA6XG4gICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKGZhY3RvcnkpIDpcbiAgICAoZ2xvYmFsID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsVGhpcyA6IGdsb2JhbCB8fCBzZWxmLCBnbG9iYWwudHlwZURldGVjdCA9IGZhY3RvcnkoKSk7XG59KSh0aGlzLCAoZnVuY3Rpb24gKCkgeyAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgcHJvbWlzZUV4aXN0cyA9IHR5cGVvZiBQcm9taXNlID09PSAnZnVuY3Rpb24nO1xuICAgIHZhciBnbG9iYWxPYmplY3QgPSAoZnVuY3Rpb24gKE9iaikge1xuICAgICAgICBpZiAodHlwZW9mIGdsb2JhbFRoaXMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2xvYmFsVGhpcztcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoT2JqLCAndHlwZURldGVjdEdsb2JhbE9iamVjdCcsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBnbG9iYWwgPSB0eXBlRGV0ZWN0R2xvYmFsT2JqZWN0O1xuICAgICAgICBkZWxldGUgT2JqLnR5cGVEZXRlY3RHbG9iYWxPYmplY3Q7XG4gICAgICAgIHJldHVybiBnbG9iYWw7XG4gICAgfSkoT2JqZWN0LnByb3RvdHlwZSk7XG4gICAgdmFyIHN5bWJvbEV4aXN0cyA9IHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnO1xuICAgIHZhciBtYXBFeGlzdHMgPSB0eXBlb2YgTWFwICE9PSAndW5kZWZpbmVkJztcbiAgICB2YXIgc2V0RXhpc3RzID0gdHlwZW9mIFNldCAhPT0gJ3VuZGVmaW5lZCc7XG4gICAgdmFyIHdlYWtNYXBFeGlzdHMgPSB0eXBlb2YgV2Vha01hcCAhPT0gJ3VuZGVmaW5lZCc7XG4gICAgdmFyIHdlYWtTZXRFeGlzdHMgPSB0eXBlb2YgV2Vha1NldCAhPT0gJ3VuZGVmaW5lZCc7XG4gICAgdmFyIGRhdGFWaWV3RXhpc3RzID0gdHlwZW9mIERhdGFWaWV3ICE9PSAndW5kZWZpbmVkJztcbiAgICB2YXIgc3ltYm9sSXRlcmF0b3JFeGlzdHMgPSBzeW1ib2xFeGlzdHMgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciAhPT0gJ3VuZGVmaW5lZCc7XG4gICAgdmFyIHN5bWJvbFRvU3RyaW5nVGFnRXhpc3RzID0gc3ltYm9sRXhpc3RzICYmIHR5cGVvZiBTeW1ib2wudG9TdHJpbmdUYWcgIT09ICd1bmRlZmluZWQnO1xuICAgIHZhciBzZXRFbnRyaWVzRXhpc3RzID0gc2V0RXhpc3RzICYmIHR5cGVvZiBTZXQucHJvdG90eXBlLmVudHJpZXMgPT09ICdmdW5jdGlvbic7XG4gICAgdmFyIG1hcEVudHJpZXNFeGlzdHMgPSBtYXBFeGlzdHMgJiYgdHlwZW9mIE1hcC5wcm90b3R5cGUuZW50cmllcyA9PT0gJ2Z1bmN0aW9uJztcbiAgICB2YXIgc2V0SXRlcmF0b3JQcm90b3R5cGUgPSBzZXRFbnRyaWVzRXhpc3RzICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihuZXcgU2V0KCkuZW50cmllcygpKTtcbiAgICB2YXIgbWFwSXRlcmF0b3JQcm90b3R5cGUgPSBtYXBFbnRyaWVzRXhpc3RzICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihuZXcgTWFwKCkuZW50cmllcygpKTtcbiAgICB2YXIgYXJyYXlJdGVyYXRvckV4aXN0cyA9IHN5bWJvbEl0ZXJhdG9yRXhpc3RzICYmIHR5cGVvZiBBcnJheS5wcm90b3R5cGVbU3ltYm9sLml0ZXJhdG9yXSA9PT0gJ2Z1bmN0aW9uJztcbiAgICB2YXIgYXJyYXlJdGVyYXRvclByb3RvdHlwZSA9IGFycmF5SXRlcmF0b3JFeGlzdHMgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKFtdW1N5bWJvbC5pdGVyYXRvcl0oKSk7XG4gICAgdmFyIHN0cmluZ0l0ZXJhdG9yRXhpc3RzID0gc3ltYm9sSXRlcmF0b3JFeGlzdHMgJiYgdHlwZW9mIFN0cmluZy5wcm90b3R5cGVbU3ltYm9sLml0ZXJhdG9yXSA9PT0gJ2Z1bmN0aW9uJztcbiAgICB2YXIgc3RyaW5nSXRlcmF0b3JQcm90b3R5cGUgPSBzdHJpbmdJdGVyYXRvckV4aXN0cyAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoJydbU3ltYm9sLml0ZXJhdG9yXSgpKTtcbiAgICB2YXIgdG9TdHJpbmdMZWZ0U2xpY2VMZW5ndGggPSA4O1xuICAgIHZhciB0b1N0cmluZ1JpZ2h0U2xpY2VMZW5ndGggPSAtMTtcbiAgICBmdW5jdGlvbiB0eXBlRGV0ZWN0KG9iaikge1xuICAgICAgICB2YXIgdHlwZW9mT2JqID0gdHlwZW9mIG9iajtcbiAgICAgICAgaWYgKHR5cGVvZk9iaiAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2ZPYmo7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iaiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuICdudWxsJztcbiAgICAgICAgfVxuICAgICAgICBpZiAob2JqID09PSBnbG9iYWxPYmplY3QpIHtcbiAgICAgICAgICAgIHJldHVybiAnZ2xvYmFsJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmopICYmXG4gICAgICAgICAgICAoc3ltYm9sVG9TdHJpbmdUYWdFeGlzdHMgPT09IGZhbHNlIHx8ICEoU3ltYm9sLnRvU3RyaW5nVGFnIGluIG9iaikpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ0FycmF5JztcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcgJiYgd2luZG93ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdy5sb2NhdGlvbiA9PT0gJ29iamVjdCcgJiYgb2JqID09PSB3aW5kb3cubG9jYXRpb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ0xvY2F0aW9uJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93LmRvY3VtZW50ID09PSAnb2JqZWN0JyAmJiBvYmogPT09IHdpbmRvdy5kb2N1bWVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnRG9jdW1lbnQnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cubmF2aWdhdG9yID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93Lm5hdmlnYXRvci5taW1lVHlwZXMgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICAgICAgICAgIG9iaiA9PT0gd2luZG93Lm5hdmlnYXRvci5taW1lVHlwZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdNaW1lVHlwZUFycmF5JztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cubmF2aWdhdG9yLnBsdWdpbnMgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICAgICAgICAgIG9iaiA9PT0gd2luZG93Lm5hdmlnYXRvci5wbHVnaW5zKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnUGx1Z2luQXJyYXknO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgodHlwZW9mIHdpbmRvdy5IVE1MRWxlbWVudCA9PT0gJ2Z1bmN0aW9uJyB8fFxuICAgICAgICAgICAgICAgIHR5cGVvZiB3aW5kb3cuSFRNTEVsZW1lbnQgPT09ICdvYmplY3QnKSAmJlxuICAgICAgICAgICAgICAgIG9iaiBpbnN0YW5jZW9mIHdpbmRvdy5IVE1MRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIGlmIChvYmoudGFnTmFtZSA9PT0gJ0JMT0NLUVVPVEUnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnSFRNTFF1b3RlRWxlbWVudCc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChvYmoudGFnTmFtZSA9PT0gJ1REJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ0hUTUxUYWJsZURhdGFDZWxsRWxlbWVudCc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChvYmoudGFnTmFtZSA9PT0gJ1RIJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ0hUTUxUYWJsZUhlYWRlckNlbGxFbGVtZW50JztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0cmluZ1RhZyA9IChzeW1ib2xUb1N0cmluZ1RhZ0V4aXN0cyAmJiBvYmpbU3ltYm9sLnRvU3RyaW5nVGFnXSk7XG4gICAgICAgIGlmICh0eXBlb2Ygc3RyaW5nVGFnID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIHN0cmluZ1RhZztcbiAgICAgICAgfVxuICAgICAgICB2YXIgb2JqUHJvdG90eXBlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iaik7XG4gICAgICAgIGlmIChvYmpQcm90b3R5cGUgPT09IFJlZ0V4cC5wcm90b3R5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiAnUmVnRXhwJztcbiAgICAgICAgfVxuICAgICAgICBpZiAob2JqUHJvdG90eXBlID09PSBEYXRlLnByb3RvdHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuICdEYXRlJztcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvbWlzZUV4aXN0cyAmJiBvYmpQcm90b3R5cGUgPT09IFByb21pc2UucHJvdG90eXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gJ1Byb21pc2UnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZXRFeGlzdHMgJiYgb2JqUHJvdG90eXBlID09PSBTZXQucHJvdG90eXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gJ1NldCc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hcEV4aXN0cyAmJiBvYmpQcm90b3R5cGUgPT09IE1hcC5wcm90b3R5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiAnTWFwJztcbiAgICAgICAgfVxuICAgICAgICBpZiAod2Vha1NldEV4aXN0cyAmJiBvYmpQcm90b3R5cGUgPT09IFdlYWtTZXQucHJvdG90eXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gJ1dlYWtTZXQnO1xuICAgICAgICB9XG4gICAgICAgIGlmICh3ZWFrTWFwRXhpc3RzICYmIG9ialByb3RvdHlwZSA9PT0gV2Vha01hcC5wcm90b3R5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiAnV2Vha01hcCc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGFWaWV3RXhpc3RzICYmIG9ialByb3RvdHlwZSA9PT0gRGF0YVZpZXcucHJvdG90eXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gJ0RhdGFWaWV3JztcbiAgICAgICAgfVxuICAgICAgICBpZiAobWFwRXhpc3RzICYmIG9ialByb3RvdHlwZSA9PT0gbWFwSXRlcmF0b3JQcm90b3R5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiAnTWFwIEl0ZXJhdG9yJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2V0RXhpc3RzICYmIG9ialByb3RvdHlwZSA9PT0gc2V0SXRlcmF0b3JQcm90b3R5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiAnU2V0IEl0ZXJhdG9yJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXJyYXlJdGVyYXRvckV4aXN0cyAmJiBvYmpQcm90b3R5cGUgPT09IGFycmF5SXRlcmF0b3JQcm90b3R5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiAnQXJyYXkgSXRlcmF0b3InO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdHJpbmdJdGVyYXRvckV4aXN0cyAmJiBvYmpQcm90b3R5cGUgPT09IHN0cmluZ0l0ZXJhdG9yUHJvdG90eXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gJ1N0cmluZyBJdGVyYXRvcic7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9ialByb3RvdHlwZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuICdPYmplY3QnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBPYmplY3RcbiAgICAgICAgICAgIC5wcm90b3R5cGVcbiAgICAgICAgICAgIC50b1N0cmluZ1xuICAgICAgICAgICAgLmNhbGwob2JqKVxuICAgICAgICAgICAgLnNsaWNlKHRvU3RyaW5nTGVmdFNsaWNlTGVuZ3RoLCB0b1N0cmluZ1JpZ2h0U2xpY2VMZW5ndGgpO1xuICAgIH1cblxuICAgIHJldHVybiB0eXBlRGV0ZWN0O1xuXG59KSk7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBBUlJBWV9UWVBFUyA9IFtcbiAgICBBcnJheSxcbiAgICBJbnQ4QXJyYXksXG4gICAgVWludDhBcnJheSxcbiAgICBVaW50OENsYW1wZWRBcnJheSxcbiAgICBJbnQxNkFycmF5LFxuICAgIFVpbnQxNkFycmF5LFxuICAgIEludDMyQXJyYXksXG4gICAgVWludDMyQXJyYXksXG4gICAgRmxvYXQzMkFycmF5LFxuICAgIEZsb2F0NjRBcnJheSxcbl07XG5cbm1vZHVsZS5leHBvcnRzID0gQVJSQVlfVFlQRVM7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBmdW5jdGlvbk5hbWUgPSByZXF1aXJlKFwiQHNpbm9uanMvY29tbW9uc1wiKS5mdW5jdGlvbk5hbWU7XG52YXIgaW5kZXhPZiA9IHJlcXVpcmUoXCJAc2lub25qcy9jb21tb25zXCIpLnByb3RvdHlwZXMuYXJyYXkuaW5kZXhPZjtcbnZhciBtYXAgPSByZXF1aXJlKFwiQHNpbm9uanMvY29tbW9uc1wiKS5wcm90b3R5cGVzLmFycmF5Lm1hcDtcbnZhciBBUlJBWV9UWVBFUyA9IHJlcXVpcmUoXCIuL2FycmF5LXR5cGVzXCIpO1xudmFyIHR5cGUgPSByZXF1aXJlKFwidHlwZS1kZXRlY3RcIik7XG5cbi8qKlxuICogUmV0dXJucyBgdHJ1ZWAgd2hlbiBgb2JqZWN0YCBpcyBhbiBhcnJheSB0eXBlLCBgZmFsc2VgIG90aGVyd2lzZVxuICpcbiAqIEBwYXJhbSAgeyp9ICBvYmplY3QgLSBUaGUgb2JqZWN0IHRvIGV4YW1pbmVcbiAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgd2hlbiBgb2JqZWN0YCBpcyBhbiBhcnJheSB0eXBlXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBpc0FycmF5VHlwZShvYmplY3QpIHtcbiAgICByZXR1cm4gaW5kZXhPZihtYXAoQVJSQVlfVFlQRVMsIGZ1bmN0aW9uTmFtZSksIHR5cGUob2JqZWN0KSkgIT09IC0xO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQXJyYXlUeXBlO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIFJldHVybnMgYHRydWVgIHdoZW4gYHZhbHVlYCBpcyBhbiBpbnN0YW5jZSBvZiBEYXRlXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSAge0RhdGV9ICB2YWx1ZSBUaGUgdmFsdWUgdG8gZXhhbWluZVxuICogQHJldHVybnMge2Jvb2xlYW59ICAgICBgdHJ1ZWAgd2hlbiBgdmFsdWVgIGlzIGFuIGluc3RhbmNlIG9mIERhdGVcbiAqL1xuZnVuY3Rpb24gaXNEYXRlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgRGF0ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0RhdGU7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogUmV0dXJucyBgdHJ1ZWAgd2hlbiB0aGUgYXJndW1lbnQgaXMgYW4gaXRlcmFibGUsIGBmYWxzZWAgb3RoZXJ3aXNlXG4gKlxuICogQGFsaWFzIG1vZHVsZTpzYW1zYW0uaXNJdGVyYWJsZVxuICogQHBhcmFtICB7Kn0gIHZhbCAtIEEgdmFsdWUgdG8gZXhhbWluZVxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIHdoZW4gdGhlIGFyZ3VtZW50IGlzIGFuIGl0ZXJhYmxlLCBgZmFsc2VgIG90aGVyd2lzZVxuICovXG5mdW5jdGlvbiBpc0l0ZXJhYmxlKHZhbCkge1xuICAgIC8vIGNoZWNrcyBmb3IgbnVsbCBhbmQgdW5kZWZpbmVkXG4gICAgaWYgKHR5cGVvZiB2YWwgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHlwZW9mIHZhbFtTeW1ib2wuaXRlcmF0b3JdID09PSBcImZ1bmN0aW9uXCI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNJdGVyYWJsZTtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBSZXR1cm5zIGB0cnVlYCB3aGVuIHRoZSB2YWx1ZSBpcyBhIHJlZ3VsYXIgT2JqZWN0IGFuZCBub3QgYSBzcGVjaWFsaXplZCBPYmplY3RcbiAqXG4gKiBUaGlzIGhlbHBzIHNwZWVkIHVwIGRlZXBFcXVhbCBjeWNsaWMgY2hlY2tzXG4gKlxuICogVGhlIHByZW1pc2UgaXMgdGhhdCBvbmx5IE9iamVjdHMgYXJlIHN0b3JlZCBpbiB0aGUgdmlzaXRlZCBhcnJheS5cbiAqIFNvIGlmIHRoaXMgZnVuY3Rpb24gcmV0dXJucyBmYWxzZSwgd2UgZG9uJ3QgaGF2ZSB0byBkbyB0aGVcbiAqIGV4cGVuc2l2ZSBvcGVyYXRpb24gb2Ygc2VhcmNoaW5nIGZvciB0aGUgdmFsdWUgaW4gdGhlIHRoZSBhcnJheSBvZiBhbHJlYWR5XG4gKiB2aXNpdGVkIG9iamVjdHNcbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtICB7b2JqZWN0fSAgIHZhbHVlIFRoZSBvYmplY3QgdG8gZXhhbWluZVxuICogQHJldHVybnMge2Jvb2xlYW59ICAgICAgIGB0cnVlYCB3aGVuIHRoZSBvYmplY3QgaXMgYSBub24tc3BlY2lhbGlzZWQgb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gICAgcmV0dXJuIChcbiAgICAgICAgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgIHZhbHVlICE9PSBudWxsICYmXG4gICAgICAgIC8vIG5vbmUgb2YgdGhlc2UgYXJlIGNvbGxlY3Rpb24gb2JqZWN0cywgc28gd2UgY2FuIHJldHVybiBmYWxzZVxuICAgICAgICAhKHZhbHVlIGluc3RhbmNlb2YgQm9vbGVhbikgJiZcbiAgICAgICAgISh2YWx1ZSBpbnN0YW5jZW9mIERhdGUpICYmXG4gICAgICAgICEodmFsdWUgaW5zdGFuY2VvZiBFcnJvcikgJiZcbiAgICAgICAgISh2YWx1ZSBpbnN0YW5jZW9mIE51bWJlcikgJiZcbiAgICAgICAgISh2YWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCkgJiZcbiAgICAgICAgISh2YWx1ZSBpbnN0YW5jZW9mIFN0cmluZylcbiAgICApO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzT2JqZWN0O1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG52YXIgZm9yRWFjaCA9IHJlcXVpcmUoXCJAc2lub25qcy9jb21tb25zXCIpLnByb3RvdHlwZXMuc2V0LmZvckVhY2g7XG5cbi8qKlxuICogUmV0dXJucyBgdHJ1ZWAgd2hlbiBgczFgIGlzIGEgc3Vic2V0IG9mIGBzMmAsIGBmYWxzZWAgb3RoZXJ3aXNlXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSAge0FycmF5fFNldH0gIHMxICAgICAgVGhlIHRhcmdldCB2YWx1ZVxuICogQHBhcmFtICB7QXJyYXl8U2V0fSAgczIgICAgICBUaGUgY29udGFpbmluZyB2YWx1ZVxuICogQHBhcmFtICB7RnVuY3Rpb259ICBjb21wYXJlIEEgY29tcGFyaXNvbiBmdW5jdGlvbiwgc2hvdWxkIHJldHVybiBgdHJ1ZWAgd2hlblxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlcyBhcmUgY29uc2lkZXJlZCBlcXVhbFxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIHdoZW4gYHMxYCBpcyBhIHN1YnNldCBvZiBgczJgLCBgZmFsc2VgYCBvdGhlcndpc2VcbiAqL1xuZnVuY3Rpb24gaXNTdWJzZXQoczEsIHMyLCBjb21wYXJlKSB7XG4gICAgdmFyIGFsbENvbnRhaW5lZCA9IHRydWU7XG4gICAgZm9yRWFjaChzMSwgZnVuY3Rpb24gKHYxKSB7XG4gICAgICAgIHZhciBpbmNsdWRlcyA9IGZhbHNlO1xuICAgICAgICBmb3JFYWNoKHMyLCBmdW5jdGlvbiAodjIpIHtcbiAgICAgICAgICAgIGlmIChjb21wYXJlKHYyLCB2MSkpIHtcbiAgICAgICAgICAgICAgICBpbmNsdWRlcyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBhbGxDb250YWluZWQgPSBhbGxDb250YWluZWQgJiYgaW5jbHVkZXM7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gYWxsQ29udGFpbmVkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzU3Vic2V0O1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG52YXIgdmFsdWVUb1N0cmluZyA9IHJlcXVpcmUoXCJAc2lub25qcy9jb21tb25zXCIpLnZhbHVlVG9TdHJpbmc7XG52YXIgY2xhc3NOYW1lID0gcmVxdWlyZShcIkBzaW5vbmpzL2NvbW1vbnNcIikuY2xhc3NOYW1lO1xudmFyIHR5cGVPZiA9IHJlcXVpcmUoXCJAc2lub25qcy9jb21tb25zXCIpLnR5cGVPZjtcbnZhciBhcnJheVByb3RvID0gcmVxdWlyZShcIkBzaW5vbmpzL2NvbW1vbnNcIikucHJvdG90eXBlcy5hcnJheTtcbnZhciBvYmplY3RQcm90byA9IHJlcXVpcmUoXCJAc2lub25qcy9jb21tb25zXCIpLnByb3RvdHlwZXMub2JqZWN0O1xudmFyIG1hcEZvckVhY2ggPSByZXF1aXJlKFwiQHNpbm9uanMvY29tbW9uc1wiKS5wcm90b3R5cGVzLm1hcC5mb3JFYWNoO1xuXG52YXIgZ2V0Q2xhc3MgPSByZXF1aXJlKFwiLi9nZXQtY2xhc3NcIik7XG52YXIgaWRlbnRpY2FsID0gcmVxdWlyZShcIi4vaWRlbnRpY2FsXCIpO1xudmFyIGlzQXJndW1lbnRzID0gcmVxdWlyZShcIi4vaXMtYXJndW1lbnRzXCIpO1xudmFyIGlzQXJyYXlUeXBlID0gcmVxdWlyZShcIi4vaXMtYXJyYXktdHlwZVwiKTtcbnZhciBpc0RhdGUgPSByZXF1aXJlKFwiLi9pcy1kYXRlXCIpO1xudmFyIGlzRWxlbWVudCA9IHJlcXVpcmUoXCIuL2lzLWVsZW1lbnRcIik7XG52YXIgaXNJdGVyYWJsZSA9IHJlcXVpcmUoXCIuL2lzLWl0ZXJhYmxlXCIpO1xudmFyIGlzTWFwID0gcmVxdWlyZShcIi4vaXMtbWFwXCIpO1xudmFyIGlzTmFOID0gcmVxdWlyZShcIi4vaXMtbmFuXCIpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZShcIi4vaXMtb2JqZWN0XCIpO1xudmFyIGlzU2V0ID0gcmVxdWlyZShcIi4vaXMtc2V0XCIpO1xudmFyIGlzU3Vic2V0ID0gcmVxdWlyZShcIi4vaXMtc3Vic2V0XCIpO1xuXG52YXIgY29uY2F0ID0gYXJyYXlQcm90by5jb25jYXQ7XG52YXIgZXZlcnkgPSBhcnJheVByb3RvLmV2ZXJ5O1xudmFyIHB1c2ggPSBhcnJheVByb3RvLnB1c2g7XG5cbnZhciBnZXRUaW1lID0gRGF0ZS5wcm90b3R5cGUuZ2V0VGltZTtcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xudmFyIGluZGV4T2YgPSBhcnJheVByb3RvLmluZGV4T2Y7XG52YXIga2V5cyA9IE9iamVjdC5rZXlzO1xudmFyIGdldE93blByb3BlcnR5U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG5cbi8qKlxuICogRGVlcCBlcXVhbCBjb21wYXJpc29uLiBUd28gdmFsdWVzIGFyZSBcImRlZXAgZXF1YWxcIiB3aGVuOlxuICpcbiAqICAgLSBUaGV5IGFyZSBlcXVhbCwgYWNjb3JkaW5nIHRvIHNhbXNhbS5pZGVudGljYWxcbiAqICAgLSBUaGV5IGFyZSBib3RoIGRhdGUgb2JqZWN0cyByZXByZXNlbnRpbmcgdGhlIHNhbWUgdGltZVxuICogICAtIFRoZXkgYXJlIGJvdGggYXJyYXlzIGNvbnRhaW5pbmcgZWxlbWVudHMgdGhhdCBhcmUgYWxsIGRlZXBFcXVhbFxuICogICAtIFRoZXkgYXJlIG9iamVjdHMgd2l0aCB0aGUgc2FtZSBzZXQgb2YgcHJvcGVydGllcywgYW5kIGVhY2ggcHJvcGVydHlcbiAqICAgICBpbiBgYGFjdHVhbGBgIGlzIGRlZXBFcXVhbCB0byB0aGUgY29ycmVzcG9uZGluZyBwcm9wZXJ0eSBpbiBgYGV4cGVjdGF0aW9uYGBcbiAqXG4gKiBTdXBwb3J0cyBjeWNsaWMgb2JqZWN0cy5cbiAqXG4gKiBAYWxpYXMgbW9kdWxlOnNhbXNhbS5kZWVwRXF1YWxcbiAqIEBwYXJhbSB7Kn0gYWN0dWFsIFRoZSBvYmplY3QgdG8gZXhhbWluZVxuICogQHBhcmFtIHsqfSBleHBlY3RhdGlvbiBUaGUgb2JqZWN0IGFjdHVhbCBpcyBleHBlY3RlZCB0byBiZSBlcXVhbCB0b1xuICogQHBhcmFtIHtvYmplY3R9IG1hdGNoIEEgdmFsdWUgdG8gbWF0Y2ggb25cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIHRydWUgd2hlbiBhY3R1YWwgYW5kIGV4cGVjdGF0aW9uIGFyZSBjb25zaWRlcmVkIGVxdWFsXG4gKi9cbmZ1bmN0aW9uIGRlZXBFcXVhbEN5Y2xpYyhhY3R1YWwsIGV4cGVjdGF0aW9uLCBtYXRjaCkge1xuICAgIC8vIHVzZWQgZm9yIGN5Y2xpYyBjb21wYXJpc29uXG4gICAgLy8gY29udGFpbiBhbHJlYWR5IHZpc2l0ZWQgb2JqZWN0c1xuICAgIHZhciBhY3R1YWxPYmplY3RzID0gW107XG4gICAgdmFyIGV4cGVjdGF0aW9uT2JqZWN0cyA9IFtdO1xuICAgIC8vIGNvbnRhaW4gcGF0aGVzIChwb3NpdGlvbiBpbiB0aGUgb2JqZWN0IHN0cnVjdHVyZSlcbiAgICAvLyBvZiB0aGUgYWxyZWFkeSB2aXNpdGVkIG9iamVjdHNcbiAgICAvLyBpbmRleGVzIHNhbWUgYXMgaW4gb2JqZWN0cyBhcnJheXNcbiAgICB2YXIgYWN0dWFsUGF0aHMgPSBbXTtcbiAgICB2YXIgZXhwZWN0YXRpb25QYXRocyA9IFtdO1xuICAgIC8vIGNvbnRhaW5zIGNvbWJpbmF0aW9ucyBvZiBhbHJlYWR5IGNvbXBhcmVkIG9iamVjdHNcbiAgICAvLyBpbiB0aGUgbWFubmVyOiB7IFwiJDFbJ3JlZiddJDJbJ3JlZiddXCI6IHRydWUgfVxuICAgIHZhciBjb21wYXJlZCA9IHt9O1xuXG4gICAgLy8gZG9lcyB0aGUgcmVjdXJzaW9uIGZvciB0aGUgZGVlcCBlcXVhbCBjaGVja1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG4gICAgcmV0dXJuIChmdW5jdGlvbiBkZWVwRXF1YWwoXG4gICAgICAgIGFjdHVhbE9iaixcbiAgICAgICAgZXhwZWN0YXRpb25PYmosXG4gICAgICAgIGFjdHVhbFBhdGgsXG4gICAgICAgIGV4cGVjdGF0aW9uUGF0aCxcbiAgICApIHtcbiAgICAgICAgLy8gSWYgYm90aCBhcmUgbWF0Y2hlcnMgdGhleSBtdXN0IGJlIHRoZSBzYW1lIGluc3RhbmNlIGluIG9yZGVyIHRvIGJlXG4gICAgICAgIC8vIGNvbnNpZGVyZWQgZXF1YWwgSWYgd2UgZGlkbid0IGRvIHRoYXQgd2Ugd291bGQgZW5kIHVwIHJ1bm5pbmcgb25lXG4gICAgICAgIC8vIG1hdGNoZXIgYWdhaW5zdCB0aGUgb3RoZXJcbiAgICAgICAgaWYgKG1hdGNoICYmIG1hdGNoLmlzTWF0Y2hlcihleHBlY3RhdGlvbk9iaikpIHtcbiAgICAgICAgICAgIGlmIChtYXRjaC5pc01hdGNoZXIoYWN0dWFsT2JqKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhY3R1YWxPYmogPT09IGV4cGVjdGF0aW9uT2JqO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGV4cGVjdGF0aW9uT2JqLnRlc3QoYWN0dWFsT2JqKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBhY3R1YWxUeXBlID0gdHlwZW9mIGFjdHVhbE9iajtcbiAgICAgICAgdmFyIGV4cGVjdGF0aW9uVHlwZSA9IHR5cGVvZiBleHBlY3RhdGlvbk9iajtcblxuICAgICAgICBpZiAoXG4gICAgICAgICAgICBhY3R1YWxPYmogPT09IGV4cGVjdGF0aW9uT2JqIHx8XG4gICAgICAgICAgICBpc05hTihhY3R1YWxPYmopIHx8XG4gICAgICAgICAgICBpc05hTihleHBlY3RhdGlvbk9iaikgfHxcbiAgICAgICAgICAgIGFjdHVhbE9iaiA9PT0gbnVsbCB8fFxuICAgICAgICAgICAgZXhwZWN0YXRpb25PYmogPT09IG51bGwgfHxcbiAgICAgICAgICAgIGFjdHVhbE9iaiA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICBleHBlY3RhdGlvbk9iaiA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICBhY3R1YWxUeXBlICE9PSBcIm9iamVjdFwiIHx8XG4gICAgICAgICAgICBleHBlY3RhdGlvblR5cGUgIT09IFwib2JqZWN0XCJcbiAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gaWRlbnRpY2FsKGFjdHVhbE9iaiwgZXhwZWN0YXRpb25PYmopO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRWxlbWVudHMgYXJlIG9ubHkgZXF1YWwgaWYgaWRlbnRpY2FsKGV4cGVjdGVkLCBhY3R1YWwpXG4gICAgICAgIGlmIChpc0VsZW1lbnQoYWN0dWFsT2JqKSB8fCBpc0VsZW1lbnQoZXhwZWN0YXRpb25PYmopKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaXNBY3R1YWxEYXRlID0gaXNEYXRlKGFjdHVhbE9iaik7XG4gICAgICAgIHZhciBpc0V4cGVjdGF0aW9uRGF0ZSA9IGlzRGF0ZShleHBlY3RhdGlvbk9iaik7XG4gICAgICAgIGlmIChpc0FjdHVhbERhdGUgfHwgaXNFeHBlY3RhdGlvbkRhdGUpIHtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAhaXNBY3R1YWxEYXRlIHx8XG4gICAgICAgICAgICAgICAgIWlzRXhwZWN0YXRpb25EYXRlIHx8XG4gICAgICAgICAgICAgICAgZ2V0VGltZS5jYWxsKGFjdHVhbE9iaikgIT09IGdldFRpbWUuY2FsbChleHBlY3RhdGlvbk9iailcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhY3R1YWxPYmogaW5zdGFuY2VvZiBSZWdFeHAgJiYgZXhwZWN0YXRpb25PYmogaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZVRvU3RyaW5nKGFjdHVhbE9iaikgIT09IHZhbHVlVG9TdHJpbmcoZXhwZWN0YXRpb25PYmopKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGFjdHVhbE9iaiBpbnN0YW5jZW9mIFByb21pc2UgJiYgZXhwZWN0YXRpb25PYmogaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICByZXR1cm4gYWN0dWFsT2JqID09PSBleHBlY3RhdGlvbk9iajtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhY3R1YWxPYmogaW5zdGFuY2VvZiBFcnJvciAmJiBleHBlY3RhdGlvbk9iaiBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gYWN0dWFsT2JqID09PSBleHBlY3RhdGlvbk9iajtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBhY3R1YWxDbGFzcyA9IGdldENsYXNzKGFjdHVhbE9iaik7XG4gICAgICAgIHZhciBleHBlY3RhdGlvbkNsYXNzID0gZ2V0Q2xhc3MoZXhwZWN0YXRpb25PYmopO1xuICAgICAgICB2YXIgYWN0dWFsS2V5cyA9IGtleXMoYWN0dWFsT2JqKTtcbiAgICAgICAgdmFyIGV4cGVjdGF0aW9uS2V5cyA9IGtleXMoZXhwZWN0YXRpb25PYmopO1xuICAgICAgICB2YXIgYWN0dWFsTmFtZSA9IGNsYXNzTmFtZShhY3R1YWxPYmopO1xuICAgICAgICB2YXIgZXhwZWN0YXRpb25OYW1lID0gY2xhc3NOYW1lKGV4cGVjdGF0aW9uT2JqKTtcbiAgICAgICAgdmFyIGV4cGVjdGF0aW9uU3ltYm9scyA9XG4gICAgICAgICAgICB0eXBlT2YoZ2V0T3duUHJvcGVydHlTeW1ib2xzKSA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgICAgICAgICAgPyBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZXhwZWN0YXRpb25PYmopXG4gICAgICAgICAgICAgICAgOiAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogY2Fubm90IGNvbGxlY3QgY292ZXJhZ2UgZm9yIGVuZ2luZSB0aGF0IGRvZXNuJ3Qgc3VwcG9ydCBTeW1ib2wgKi9cbiAgICAgICAgICAgICAgICAgIFtdO1xuICAgICAgICB2YXIgZXhwZWN0YXRpb25LZXlzQW5kU3ltYm9scyA9IGNvbmNhdChcbiAgICAgICAgICAgIGV4cGVjdGF0aW9uS2V5cyxcbiAgICAgICAgICAgIGV4cGVjdGF0aW9uU3ltYm9scyxcbiAgICAgICAgKTtcblxuICAgICAgICBpZiAoaXNBcmd1bWVudHMoYWN0dWFsT2JqKSB8fCBpc0FyZ3VtZW50cyhleHBlY3RhdGlvbk9iaikpIHtcbiAgICAgICAgICAgIGlmIChhY3R1YWxPYmoubGVuZ3RoICE9PSBleHBlY3RhdGlvbk9iai5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgYWN0dWFsVHlwZSAhPT0gZXhwZWN0YXRpb25UeXBlIHx8XG4gICAgICAgICAgICAgICAgYWN0dWFsQ2xhc3MgIT09IGV4cGVjdGF0aW9uQ2xhc3MgfHxcbiAgICAgICAgICAgICAgICBhY3R1YWxLZXlzLmxlbmd0aCAhPT0gZXhwZWN0YXRpb25LZXlzLmxlbmd0aCB8fFxuICAgICAgICAgICAgICAgIChhY3R1YWxOYW1lICYmXG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdGF0aW9uTmFtZSAmJlxuICAgICAgICAgICAgICAgICAgICBhY3R1YWxOYW1lICE9PSBleHBlY3RhdGlvbk5hbWUpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNTZXQoYWN0dWFsT2JqKSB8fCBpc1NldChleHBlY3RhdGlvbk9iaikpIHtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAhaXNTZXQoYWN0dWFsT2JqKSB8fFxuICAgICAgICAgICAgICAgICFpc1NldChleHBlY3RhdGlvbk9iaikgfHxcbiAgICAgICAgICAgICAgICBhY3R1YWxPYmouc2l6ZSAhPT0gZXhwZWN0YXRpb25PYmouc2l6ZVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gaXNTdWJzZXQoYWN0dWFsT2JqLCBleHBlY3RhdGlvbk9iaiwgZGVlcEVxdWFsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc01hcChhY3R1YWxPYmopIHx8IGlzTWFwKGV4cGVjdGF0aW9uT2JqKSkge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICFpc01hcChhY3R1YWxPYmopIHx8XG4gICAgICAgICAgICAgICAgIWlzTWFwKGV4cGVjdGF0aW9uT2JqKSB8fFxuICAgICAgICAgICAgICAgIGFjdHVhbE9iai5zaXplICE9PSBleHBlY3RhdGlvbk9iai5zaXplXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBtYXBzRGVlcGx5RXF1YWwgPSB0cnVlO1xuICAgICAgICAgICAgbWFwRm9yRWFjaChhY3R1YWxPYmosIGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgICAgICAgICAgICAgbWFwc0RlZXBseUVxdWFsID1cbiAgICAgICAgICAgICAgICAgICAgbWFwc0RlZXBseUVxdWFsICYmXG4gICAgICAgICAgICAgICAgICAgIGRlZXBFcXVhbEN5Y2xpYyh2YWx1ZSwgZXhwZWN0YXRpb25PYmouZ2V0KGtleSkpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiBtYXBzRGVlcGx5RXF1YWw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBqUXVlcnkgb2JqZWN0cyBoYXZlIGl0ZXJhdGlvbiBwcm90b2NvbHNcbiAgICAgICAgLy8gc2VlOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9JdGVyYXRpb25fcHJvdG9jb2xzXG4gICAgICAgIC8vIEJ1dCwgdGhleSBkb24ndCB3b3JrIHdlbGwgd2l0aCB0aGUgaW1wbGVtZW50YXRpb24gY29uY2VybmluZyBpdGVyYWJsZXMgYmVsb3csXG4gICAgICAgIC8vIHNvIHdlIHdpbGwgZGV0ZWN0IHRoZW0gYW5kIHVzZSBqUXVlcnkncyBvd24gZXF1YWxpdHkgZnVuY3Rpb25cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgLS0gdGhpcyBjYW4gb25seSBiZSB0ZXN0ZWQgaW4gdGhlIGB0ZXN0LWhlYWRsZXNzYCBzY3JpcHQgKi9cbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgYWN0dWFsT2JqLmNvbnN0cnVjdG9yICYmXG4gICAgICAgICAgICBhY3R1YWxPYmouY29uc3RydWN0b3IubmFtZSA9PT0gXCJqUXVlcnlcIiAmJlxuICAgICAgICAgICAgdHlwZW9mIGFjdHVhbE9iai5pcyA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuIGFjdHVhbE9iai5pcyhleHBlY3RhdGlvbk9iaik7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaXNBY3R1YWxOb25BcnJheUl0ZXJhYmxlID1cbiAgICAgICAgICAgIGlzSXRlcmFibGUoYWN0dWFsT2JqKSAmJlxuICAgICAgICAgICAgIWlzQXJyYXlUeXBlKGFjdHVhbE9iaikgJiZcbiAgICAgICAgICAgICFpc0FyZ3VtZW50cyhhY3R1YWxPYmopO1xuICAgICAgICB2YXIgaXNFeHBlY3RhdGlvbk5vbkFycmF5SXRlcmFibGUgPVxuICAgICAgICAgICAgaXNJdGVyYWJsZShleHBlY3RhdGlvbk9iaikgJiZcbiAgICAgICAgICAgICFpc0FycmF5VHlwZShleHBlY3RhdGlvbk9iaikgJiZcbiAgICAgICAgICAgICFpc0FyZ3VtZW50cyhleHBlY3RhdGlvbk9iaik7XG4gICAgICAgIGlmIChpc0FjdHVhbE5vbkFycmF5SXRlcmFibGUgfHwgaXNFeHBlY3RhdGlvbk5vbkFycmF5SXRlcmFibGUpIHtcbiAgICAgICAgICAgIHZhciBhY3R1YWxBcnJheSA9IEFycmF5LmZyb20oYWN0dWFsT2JqKTtcbiAgICAgICAgICAgIHZhciBleHBlY3RhdGlvbkFycmF5ID0gQXJyYXkuZnJvbShleHBlY3RhdGlvbk9iaik7XG4gICAgICAgICAgICBpZiAoYWN0dWFsQXJyYXkubGVuZ3RoICE9PSBleHBlY3RhdGlvbkFycmF5Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGFycmF5RGVlcGx5RXF1YWxzID0gdHJ1ZTtcbiAgICAgICAgICAgIGV2ZXJ5KGFjdHVhbEFycmF5LCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgYXJyYXlEZWVwbHlFcXVhbHMgPVxuICAgICAgICAgICAgICAgICAgICBhcnJheURlZXBseUVxdWFscyAmJlxuICAgICAgICAgICAgICAgICAgICBkZWVwRXF1YWxDeWNsaWMoYWN0dWFsQXJyYXlba2V5XSwgZXhwZWN0YXRpb25BcnJheVtrZXldKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gYXJyYXlEZWVwbHlFcXVhbHM7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZXZlcnkoZXhwZWN0YXRpb25LZXlzQW5kU3ltYm9scywgZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wZXJ0eShhY3R1YWxPYmosIGtleSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBhY3R1YWxWYWx1ZSA9IGFjdHVhbE9ialtrZXldO1xuICAgICAgICAgICAgdmFyIGV4cGVjdGF0aW9uVmFsdWUgPSBleHBlY3RhdGlvbk9ialtrZXldO1xuICAgICAgICAgICAgdmFyIGFjdHVhbE9iamVjdCA9IGlzT2JqZWN0KGFjdHVhbFZhbHVlKTtcbiAgICAgICAgICAgIHZhciBleHBlY3RhdGlvbk9iamVjdCA9IGlzT2JqZWN0KGV4cGVjdGF0aW9uVmFsdWUpO1xuICAgICAgICAgICAgLy8gZGV0ZXJtaW5lcywgaWYgdGhlIG9iamVjdHMgd2VyZSBhbHJlYWR5IHZpc2l0ZWRcbiAgICAgICAgICAgIC8vIChpdCdzIGZhc3RlciB0byBjaGVjayBmb3IgaXNPYmplY3QgZmlyc3QsIHRoYW4gdG9cbiAgICAgICAgICAgIC8vIGdldCAtMSBmcm9tIGdldEluZGV4IGZvciBub24gb2JqZWN0cylcbiAgICAgICAgICAgIHZhciBhY3R1YWxJbmRleCA9IGFjdHVhbE9iamVjdFxuICAgICAgICAgICAgICAgID8gaW5kZXhPZihhY3R1YWxPYmplY3RzLCBhY3R1YWxWYWx1ZSlcbiAgICAgICAgICAgICAgICA6IC0xO1xuICAgICAgICAgICAgdmFyIGV4cGVjdGF0aW9uSW5kZXggPSBleHBlY3RhdGlvbk9iamVjdFxuICAgICAgICAgICAgICAgID8gaW5kZXhPZihleHBlY3RhdGlvbk9iamVjdHMsIGV4cGVjdGF0aW9uVmFsdWUpXG4gICAgICAgICAgICAgICAgOiAtMTtcbiAgICAgICAgICAgIC8vIGRldGVybWluZXMgdGhlIG5ldyBwYXRocyBvZiB0aGUgb2JqZWN0c1xuICAgICAgICAgICAgLy8gLSBmb3Igbm9uIGN5Y2xpYyBvYmplY3RzIHRoZSBjdXJyZW50IHBhdGggd2lsbCBiZSBleHRlbmRlZFxuICAgICAgICAgICAgLy8gICBieSBjdXJyZW50IHByb3BlcnR5IG5hbWVcbiAgICAgICAgICAgIC8vIC0gZm9yIGN5Y2xpYyBvYmplY3RzIHRoZSBzdG9yZWQgcGF0aCBpcyB0YWtlblxuICAgICAgICAgICAgdmFyIG5ld0FjdHVhbFBhdGggPVxuICAgICAgICAgICAgICAgIGFjdHVhbEluZGV4ICE9PSAtMVxuICAgICAgICAgICAgICAgICAgICA/IGFjdHVhbFBhdGhzW2FjdHVhbEluZGV4XVxuICAgICAgICAgICAgICAgICAgICA6IGAke2FjdHVhbFBhdGh9WyR7SlNPTi5zdHJpbmdpZnkoa2V5KX1dYDtcbiAgICAgICAgICAgIHZhciBuZXdFeHBlY3RhdGlvblBhdGggPVxuICAgICAgICAgICAgICAgIGV4cGVjdGF0aW9uSW5kZXggIT09IC0xXG4gICAgICAgICAgICAgICAgICAgID8gZXhwZWN0YXRpb25QYXRoc1tleHBlY3RhdGlvbkluZGV4XVxuICAgICAgICAgICAgICAgICAgICA6IGAke2V4cGVjdGF0aW9uUGF0aH1bJHtKU09OLnN0cmluZ2lmeShrZXkpfV1gO1xuICAgICAgICAgICAgdmFyIGNvbWJpbmVkUGF0aCA9IG5ld0FjdHVhbFBhdGggKyBuZXdFeHBlY3RhdGlvblBhdGg7XG5cbiAgICAgICAgICAgIC8vIHN0b3AgcmVjdXJzaW9uIGlmIGN1cnJlbnQgb2JqZWN0cyBhcmUgYWxyZWFkeSBjb21wYXJlZFxuICAgICAgICAgICAgaWYgKGNvbXBhcmVkW2NvbWJpbmVkUGF0aF0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gcmVtZW1iZXIgdGhlIGN1cnJlbnQgb2JqZWN0cyBhbmQgdGhlaXIgcGF0aHNcbiAgICAgICAgICAgIGlmIChhY3R1YWxJbmRleCA9PT0gLTEgJiYgYWN0dWFsT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgcHVzaChhY3R1YWxPYmplY3RzLCBhY3R1YWxWYWx1ZSk7XG4gICAgICAgICAgICAgICAgcHVzaChhY3R1YWxQYXRocywgbmV3QWN0dWFsUGF0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXhwZWN0YXRpb25JbmRleCA9PT0gLTEgJiYgZXhwZWN0YXRpb25PYmplY3QpIHtcbiAgICAgICAgICAgICAgICBwdXNoKGV4cGVjdGF0aW9uT2JqZWN0cywgZXhwZWN0YXRpb25WYWx1ZSk7XG4gICAgICAgICAgICAgICAgcHVzaChleHBlY3RhdGlvblBhdGhzLCBuZXdFeHBlY3RhdGlvblBhdGgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyByZW1lbWJlciB0aGF0IHRoZSBjdXJyZW50IG9iamVjdHMgYXJlIGFscmVhZHkgY29tcGFyZWRcbiAgICAgICAgICAgIGlmIChhY3R1YWxPYmplY3QgJiYgZXhwZWN0YXRpb25PYmplY3QpIHtcbiAgICAgICAgICAgICAgICBjb21wYXJlZFtjb21iaW5lZFBhdGhdID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRW5kIG9mIGN5Y2xpYyBsb2dpY1xuXG4gICAgICAgICAgICAvLyBuZWl0aGVyIGFjdHVhbFZhbHVlIG5vciBleHBlY3RhdGlvblZhbHVlIGlzIGEgY3ljbGVcbiAgICAgICAgICAgIC8vIGNvbnRpbnVlIHdpdGggbmV4dCBsZXZlbFxuICAgICAgICAgICAgcmV0dXJuIGRlZXBFcXVhbChcbiAgICAgICAgICAgICAgICBhY3R1YWxWYWx1ZSxcbiAgICAgICAgICAgICAgICBleHBlY3RhdGlvblZhbHVlLFxuICAgICAgICAgICAgICAgIG5ld0FjdHVhbFBhdGgsXG4gICAgICAgICAgICAgICAgbmV3RXhwZWN0YXRpb25QYXRoLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgfSkoYWN0dWFsLCBleHBlY3RhdGlvbiwgXCIkMVwiLCBcIiQyXCIpO1xufVxuXG5kZWVwRXF1YWxDeWNsaWMudXNlID0gZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGRlZXBFcXVhbChhLCBiKSB7XG4gICAgICAgIHJldHVybiBkZWVwRXF1YWxDeWNsaWMoYSwgYiwgbWF0Y2gpO1xuICAgIH07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlZXBFcXVhbEN5Y2xpYztcbiIsICJcInVzZSBzdHJpY3RcIjtcblxudmFyIHNsaWNlID0gcmVxdWlyZShcIkBzaW5vbmpzL2NvbW1vbnNcIikucHJvdG90eXBlcy5zdHJpbmcuc2xpY2U7XG52YXIgdHlwZU9mID0gcmVxdWlyZShcIkBzaW5vbmpzL2NvbW1vbnNcIikudHlwZU9mO1xudmFyIHZhbHVlVG9TdHJpbmcgPSByZXF1aXJlKFwiQHNpbm9uanMvY29tbW9uc1wiKS52YWx1ZVRvU3RyaW5nO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBzdHJpbmcgcmVwcmVzZW5hdGlvbiBvZiBhbiBpdGVyYWJsZSBvYmplY3RcbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtICAge29iamVjdH0gb2JqIFRoZSBpdGVyYWJsZSBvYmplY3QgdG8gc3RyaW5naWZ5XG4gKiBAcmV0dXJucyB7c3RyaW5nfSAgICAgQSBzdHJpbmcgcmVwcmVzZW50YXRpb25cbiAqL1xuZnVuY3Rpb24gaXRlcmFibGVUb1N0cmluZyhvYmopIHtcbiAgICBpZiAodHlwZU9mKG9iaikgPT09IFwibWFwXCIpIHtcbiAgICAgICAgcmV0dXJuIG1hcFRvU3RyaW5nKG9iaik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGdlbmVyaWNJdGVyYWJsZVRvU3RyaW5nKG9iaik7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIE1hcFxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0gICB7TWFwfSBtYXAgICAgVGhlIG1hcCB0byBzdHJpbmdpZnlcbiAqIEByZXR1cm5zIHtzdHJpbmd9ICAgICBBIHN0cmluZyByZXByZXNlbnRhdGlvblxuICovXG5mdW5jdGlvbiBtYXBUb1N0cmluZyhtYXApIHtcbiAgICB2YXIgcmVwcmVzZW50YXRpb24gPSBcIlwiO1xuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEBzaW5vbmpzL25vLXByb3RvdHlwZS1tZXRob2RzL25vLXByb3RvdHlwZS1tZXRob2RzXG4gICAgbWFwLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgcmVwcmVzZW50YXRpb24gKz0gYFske3N0cmluZ2lmeShrZXkpfSwke3N0cmluZ2lmeSh2YWx1ZSl9XSxgO1xuICAgIH0pO1xuXG4gICAgcmVwcmVzZW50YXRpb24gPSBzbGljZShyZXByZXNlbnRhdGlvbiwgMCwgLTEpO1xuICAgIHJldHVybiByZXByZXNlbnRhdGlvbjtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBzdHJpbmcgcmVwcmVzZW5hdGlvbiBmb3IgYW4gaXRlcmFibGVcbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtICAge29iamVjdH0gaXRlcmFibGUgVGhlIGl0ZXJhYmxlIHRvIHN0cmluZ2lmeVxuICogQHJldHVybnMge3N0cmluZ30gICAgICAgICAgQSBzdHJpbmcgcmVwcmVzZW50YXRpb25cbiAqL1xuZnVuY3Rpb24gZ2VuZXJpY0l0ZXJhYmxlVG9TdHJpbmcoaXRlcmFibGUpIHtcbiAgICB2YXIgcmVwcmVzZW50YXRpb24gPSBcIlwiO1xuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEBzaW5vbmpzL25vLXByb3RvdHlwZS1tZXRob2RzL25vLXByb3RvdHlwZS1tZXRob2RzXG4gICAgaXRlcmFibGUuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmVwcmVzZW50YXRpb24gKz0gYCR7c3RyaW5naWZ5KHZhbHVlKX0sYDtcbiAgICB9KTtcblxuICAgIHJlcHJlc2VudGF0aW9uID0gc2xpY2UocmVwcmVzZW50YXRpb24sIDAsIC0xKTtcbiAgICByZXR1cm4gcmVwcmVzZW50YXRpb247XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgcGFzc2VkIGBpdGVtYFxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0gIHtvYmplY3R9IGl0ZW0gVGhlIGl0ZW0gdG8gc3RyaW5naWZ5XG4gKiBAcmV0dXJucyB7c3RyaW5nfSAgICAgIEEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGBpdGVtYFxuICovXG5mdW5jdGlvbiBzdHJpbmdpZnkoaXRlbSkge1xuICAgIHJldHVybiB0eXBlb2YgaXRlbSA9PT0gXCJzdHJpbmdcIiA/IGAnJHtpdGVtfSdgIDogdmFsdWVUb1N0cmluZyhpdGVtKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpdGVyYWJsZVRvU3RyaW5nO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG52YXIgbWF0Y2hlclByb3RvdHlwZSA9IHtcbiAgICB0b1N0cmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tZXNzYWdlO1xuICAgIH0sXG59O1xuXG5tYXRjaGVyUHJvdG90eXBlLm9yID0gZnVuY3Rpb24gKHZhbHVlT3JNYXRjaGVyKSB7XG4gICAgdmFyIGNyZWF0ZU1hdGNoZXIgPSByZXF1aXJlKFwiLi4vY3JlYXRlLW1hdGNoZXJcIik7XG4gICAgdmFyIGlzTWF0Y2hlciA9IGNyZWF0ZU1hdGNoZXIuaXNNYXRjaGVyO1xuXG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJNYXRjaGVyIGV4cGVjdGVkXCIpO1xuICAgIH1cblxuICAgIHZhciBtMiA9IGlzTWF0Y2hlcih2YWx1ZU9yTWF0Y2hlcilcbiAgICAgICAgPyB2YWx1ZU9yTWF0Y2hlclxuICAgICAgICA6IGNyZWF0ZU1hdGNoZXIodmFsdWVPck1hdGNoZXIpO1xuICAgIHZhciBtMSA9IHRoaXM7XG4gICAgdmFyIG9yID0gT2JqZWN0LmNyZWF0ZShtYXRjaGVyUHJvdG90eXBlKTtcbiAgICBvci50ZXN0ID0gZnVuY3Rpb24gKGFjdHVhbCkge1xuICAgICAgICByZXR1cm4gbTEudGVzdChhY3R1YWwpIHx8IG0yLnRlc3QoYWN0dWFsKTtcbiAgICB9O1xuICAgIG9yLm1lc3NhZ2UgPSBgJHttMS5tZXNzYWdlfS5vcigke20yLm1lc3NhZ2V9KWA7XG4gICAgcmV0dXJuIG9yO1xufTtcblxubWF0Y2hlclByb3RvdHlwZS5hbmQgPSBmdW5jdGlvbiAodmFsdWVPck1hdGNoZXIpIHtcbiAgICB2YXIgY3JlYXRlTWF0Y2hlciA9IHJlcXVpcmUoXCIuLi9jcmVhdGUtbWF0Y2hlclwiKTtcbiAgICB2YXIgaXNNYXRjaGVyID0gY3JlYXRlTWF0Y2hlci5pc01hdGNoZXI7XG5cbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk1hdGNoZXIgZXhwZWN0ZWRcIik7XG4gICAgfVxuXG4gICAgdmFyIG0yID0gaXNNYXRjaGVyKHZhbHVlT3JNYXRjaGVyKVxuICAgICAgICA/IHZhbHVlT3JNYXRjaGVyXG4gICAgICAgIDogY3JlYXRlTWF0Y2hlcih2YWx1ZU9yTWF0Y2hlcik7XG4gICAgdmFyIG0xID0gdGhpcztcbiAgICB2YXIgYW5kID0gT2JqZWN0LmNyZWF0ZShtYXRjaGVyUHJvdG90eXBlKTtcbiAgICBhbmQudGVzdCA9IGZ1bmN0aW9uIChhY3R1YWwpIHtcbiAgICAgICAgcmV0dXJuIG0xLnRlc3QoYWN0dWFsKSAmJiBtMi50ZXN0KGFjdHVhbCk7XG4gICAgfTtcbiAgICBhbmQubWVzc2FnZSA9IGAke20xLm1lc3NhZ2V9LmFuZCgke20yLm1lc3NhZ2V9KWA7XG4gICAgcmV0dXJuIGFuZDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gbWF0Y2hlclByb3RvdHlwZTtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxudmFyIGlzUHJvdG90eXBlT2YgPSByZXF1aXJlKFwiQHNpbm9uanMvY29tbW9uc1wiKS5wcm90b3R5cGVzLm9iamVjdC5pc1Byb3RvdHlwZU9mO1xuXG52YXIgbWF0Y2hlclByb3RvdHlwZSA9IHJlcXVpcmUoXCIuL21hdGNoZXItcHJvdG90eXBlXCIpO1xuXG4vKipcbiAqIFJldHVybnMgYHRydWVgIHdoZW4gYG9iamVjdGAgaXMgYSBtYXRjaGVyXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gb2JqZWN0IEEgdmFsdWUgdG8gZXhhbWluZVxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIHdoZW4gYG9iamVjdGAgaXMgYSBtYXRjaGVyXG4gKi9cbmZ1bmN0aW9uIGlzTWF0Y2hlcihvYmplY3QpIHtcbiAgICByZXR1cm4gaXNQcm90b3R5cGVPZihtYXRjaGVyUHJvdG90eXBlLCBvYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzTWF0Y2hlcjtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxudmFyIGlzTWF0Y2hlciA9IHJlcXVpcmUoXCIuL2lzLW1hdGNoZXJcIik7XG5cbi8qKlxuICogVGhyb3dzIGEgVHlwZUVycm9yIHdoZW4gYHZhbHVlYCBpcyBub3QgYSBtYXRjaGVyXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGV4YW1pbmVcbiAqL1xuZnVuY3Rpb24gYXNzZXJ0TWF0Y2hlcih2YWx1ZSkge1xuICAgIGlmICghaXNNYXRjaGVyKHZhbHVlKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiTWF0Y2hlciBleHBlY3RlZFwiKTtcbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXNzZXJ0TWF0Y2hlcjtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBUaHJvd3MgYSBUeXBlRXJyb3Igd2hlbiBleHBlY3RlZCBtZXRob2QgZG9lc24ndCBleGlzdFxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIEEgdmFsdWUgdG8gZXhhbWluZVxuICogQHBhcmFtIHtzdHJpbmd9IG1ldGhvZCBUaGUgbmFtZSBvZiB0aGUgbWV0aG9kIHRvIGxvb2sgZm9yXG4gKiBAcGFyYW0ge25hbWV9IG5hbWUgQSBuYW1lIHRvIHVzZSBmb3IgdGhlIGVycm9yIG1lc3NhZ2VcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXRob2RQYXRoIFRoZSBuYW1lIG9mIHRoZSBtZXRob2QgdG8gdXNlIGZvciBlcnJvciBtZXNzYWdlc1xuICogQHRocm93cyB7VHlwZUVycm9yfSBXaGVuIHRoZSBtZXRob2QgZG9lc24ndCBleGlzdFxuICovXG5mdW5jdGlvbiBhc3NlcnRNZXRob2RFeGlzdHModmFsdWUsIG1ldGhvZCwgbmFtZSwgbWV0aG9kUGF0aCkge1xuICAgIGlmICh2YWx1ZVttZXRob2RdID09PSBudWxsIHx8IHZhbHVlW21ldGhvZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBFeHBlY3RlZCAke25hbWV9IHRvIGhhdmUgbWV0aG9kICR7bWV0aG9kUGF0aH1gKTtcbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXNzZXJ0TWV0aG9kRXhpc3RzO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG52YXIgdHlwZU9mID0gcmVxdWlyZShcIkBzaW5vbmpzL2NvbW1vbnNcIikudHlwZU9mO1xuXG4vKipcbiAqIEVuc3VyZXMgdGhhdCB2YWx1ZSBpcyBvZiB0eXBlXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgQSB2YWx1ZSB0byBleGFtaW5lXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBBIGJhc2ljIEphdmFTY3JpcHQgdHlwZSB0byBjb21wYXJlIHRvLCBlLmcuIFwib2JqZWN0XCIsIFwic3RyaW5nXCJcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIEEgc3RyaW5nIHRvIHVzZSBmb3IgdGhlIGVycm9yIG1lc3NhZ2VcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgdmFsdWUgaXMgbm90IG9mIHRoZSBleHBlY3RlZCB0eXBlXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICovXG5mdW5jdGlvbiBhc3NlcnRUeXBlKHZhbHVlLCB0eXBlLCBuYW1lKSB7XG4gICAgdmFyIGFjdHVhbCA9IHR5cGVPZih2YWx1ZSk7XG4gICAgaWYgKGFjdHVhbCAhPT0gdHlwZSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgYEV4cGVjdGVkIHR5cGUgb2YgJHtuYW1lfSB0byBiZSAke3R5cGV9LCBidXQgd2FzICR7YWN0dWFsfWAsXG4gICAgICAgICk7XG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFzc2VydFR5cGU7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciB0eXBlT2YgPSByZXF1aXJlKFwiQHNpbm9uanMvY29tbW9uc1wiKS50eXBlT2Y7XG5cbi8qKlxuICogUmV0dXJucyBgdHJ1ZWAgZm9yIGl0ZXJhYmxlc1xuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIEEgdmFsdWUgdG8gZXhhbWluZVxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIHdoZW4gYHZhbHVlYCBsb29rcyBsaWtlIGFuIGl0ZXJhYmxlXG4gKi9cbmZ1bmN0aW9uIGlzSXRlcmFibGUodmFsdWUpIHtcbiAgICByZXR1cm4gQm9vbGVhbih2YWx1ZSkgJiYgdHlwZU9mKHZhbHVlLmZvckVhY2gpID09PSBcImZ1bmN0aW9uXCI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNJdGVyYWJsZTtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxudmFyIGV2ZXJ5ID0gcmVxdWlyZShcIkBzaW5vbmpzL2NvbW1vbnNcIikucHJvdG90eXBlcy5hcnJheS5ldmVyeTtcbnZhciBjb25jYXQgPSByZXF1aXJlKFwiQHNpbm9uanMvY29tbW9uc1wiKS5wcm90b3R5cGVzLmFycmF5LmNvbmNhdDtcbnZhciB0eXBlT2YgPSByZXF1aXJlKFwiQHNpbm9uanMvY29tbW9uc1wiKS50eXBlT2Y7XG5cbnZhciBkZWVwRXF1YWxGYWN0b3J5ID0gcmVxdWlyZShcIi4uL2RlZXAtZXF1YWxcIikudXNlO1xuXG52YXIgaWRlbnRpY2FsID0gcmVxdWlyZShcIi4uL2lkZW50aWNhbFwiKTtcbnZhciBpc01hdGNoZXIgPSByZXF1aXJlKFwiLi9pcy1tYXRjaGVyXCIpO1xuXG52YXIga2V5cyA9IE9iamVjdC5rZXlzO1xudmFyIGdldE93blByb3BlcnR5U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG5cbi8qKlxuICogTWF0Y2hlcyBgYWN0dWFsYCB3aXRoIGBleHBlY3RhdGlvbmBcbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSBhY3R1YWwgQSB2YWx1ZSB0byBleGFtaW5lXG4gKiBAcGFyYW0ge29iamVjdH0gZXhwZWN0YXRpb24gQW4gb2JqZWN0IHdpdGggcHJvcGVydGllcyB0byBtYXRjaCBvblxuICogQHBhcmFtIHtvYmplY3R9IG1hdGNoZXIgQSBtYXRjaGVyIHRvIHVzZSBmb3IgY29tcGFyaXNvblxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSB3aGVuIGBhY3R1YWxgIG1hdGNoZXMgYWxsIHByb3BlcnRpZXMgaW4gYGV4cGVjdGF0aW9uYFxuICovXG5mdW5jdGlvbiBtYXRjaE9iamVjdChhY3R1YWwsIGV4cGVjdGF0aW9uLCBtYXRjaGVyKSB7XG4gICAgdmFyIGRlZXBFcXVhbCA9IGRlZXBFcXVhbEZhY3RvcnkobWF0Y2hlcik7XG4gICAgaWYgKGFjdHVhbCA9PT0gbnVsbCB8fCBhY3R1YWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGV4cGVjdGVkS2V5cyA9IGtleXMoZXhwZWN0YXRpb24pO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlOiBjYW5ub3QgY29sbGVjdCBjb3ZlcmFnZSBmb3IgZW5naW5lIHRoYXQgZG9lc24ndCBzdXBwb3J0IFN5bWJvbCAqL1xuICAgIGlmICh0eXBlT2YoZ2V0T3duUHJvcGVydHlTeW1ib2xzKSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGV4cGVjdGVkS2V5cyA9IGNvbmNhdChleHBlY3RlZEtleXMsIGdldE93blByb3BlcnR5U3ltYm9scyhleHBlY3RhdGlvbikpO1xuICAgIH1cblxuICAgIHJldHVybiBldmVyeShleHBlY3RlZEtleXMsIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdmFyIGV4cCA9IGV4cGVjdGF0aW9uW2tleV07XG4gICAgICAgIHZhciBhY3QgPSBhY3R1YWxba2V5XTtcblxuICAgICAgICBpZiAoaXNNYXRjaGVyKGV4cCkpIHtcbiAgICAgICAgICAgIGlmICghZXhwLnRlc3QoYWN0KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0eXBlT2YoZXhwKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgaWYgKGlkZW50aWNhbChleHAsIGFjdCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghbWF0Y2hPYmplY3QoYWN0LCBleHAsIG1hdGNoZXIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCFkZWVwRXF1YWwoYWN0LCBleHApKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXRjaE9iamVjdDtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxudmFyIGZ1bmN0aW9uTmFtZSA9IHJlcXVpcmUoXCJAc2lub25qcy9jb21tb25zXCIpLmZ1bmN0aW9uTmFtZTtcbnZhciBqb2luID0gcmVxdWlyZShcIkBzaW5vbmpzL2NvbW1vbnNcIikucHJvdG90eXBlcy5hcnJheS5qb2luO1xudmFyIG1hcCA9IHJlcXVpcmUoXCJAc2lub25qcy9jb21tb25zXCIpLnByb3RvdHlwZXMuYXJyYXkubWFwO1xudmFyIHN0cmluZ0luZGV4T2YgPSByZXF1aXJlKFwiQHNpbm9uanMvY29tbW9uc1wiKS5wcm90b3R5cGVzLnN0cmluZy5pbmRleE9mO1xudmFyIHZhbHVlVG9TdHJpbmcgPSByZXF1aXJlKFwiQHNpbm9uanMvY29tbW9uc1wiKS52YWx1ZVRvU3RyaW5nO1xuXG52YXIgbWF0Y2hPYmplY3QgPSByZXF1aXJlKFwiLi9tYXRjaC1vYmplY3RcIik7XG5cbnZhciBjcmVhdGVUeXBlTWFwID0gZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZnVuY3Rpb246IGZ1bmN0aW9uIChtLCBleHBlY3RhdGlvbiwgbWVzc2FnZSkge1xuICAgICAgICAgICAgbS50ZXN0ID0gZXhwZWN0YXRpb247XG4gICAgICAgICAgICBtLm1lc3NhZ2UgPSBtZXNzYWdlIHx8IGBtYXRjaCgke2Z1bmN0aW9uTmFtZShleHBlY3RhdGlvbil9KWA7XG4gICAgICAgIH0sXG4gICAgICAgIG51bWJlcjogZnVuY3Rpb24gKG0sIGV4cGVjdGF0aW9uKSB7XG4gICAgICAgICAgICBtLnRlc3QgPSBmdW5jdGlvbiAoYWN0dWFsKSB7XG4gICAgICAgICAgICAgICAgLy8gd2UgbmVlZCB0eXBlIGNvZXJjaW9uIGhlcmVcbiAgICAgICAgICAgICAgICByZXR1cm4gZXhwZWN0YXRpb24gPT0gYWN0dWFsOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgb2JqZWN0OiBmdW5jdGlvbiAobSwgZXhwZWN0YXRpb24pIHtcbiAgICAgICAgICAgIHZhciBhcnJheSA9IFtdO1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGV4cGVjdGF0aW9uLnRlc3QgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIG0udGVzdCA9IGZ1bmN0aW9uIChhY3R1YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGV4cGVjdGF0aW9uLnRlc3QoYWN0dWFsKSA9PT0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIG0ubWVzc2FnZSA9IGBtYXRjaCgke2Z1bmN0aW9uTmFtZShleHBlY3RhdGlvbi50ZXN0KX0pYDtcbiAgICAgICAgICAgICAgICByZXR1cm4gbTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYXJyYXkgPSBtYXAoT2JqZWN0LmtleXMoZXhwZWN0YXRpb24pLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGAke2tleX06ICR7dmFsdWVUb1N0cmluZyhleHBlY3RhdGlvbltrZXldKX1gO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIG0udGVzdCA9IGZ1bmN0aW9uIChhY3R1YWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWF0Y2hPYmplY3QoYWN0dWFsLCBleHBlY3RhdGlvbiwgbWF0Y2gpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIG0ubWVzc2FnZSA9IGBtYXRjaCgke2pvaW4oYXJyYXksIFwiLCBcIil9KWA7XG5cbiAgICAgICAgICAgIHJldHVybiBtO1xuICAgICAgICB9LFxuICAgICAgICByZWdleHA6IGZ1bmN0aW9uIChtLCBleHBlY3RhdGlvbikge1xuICAgICAgICAgICAgbS50ZXN0ID0gZnVuY3Rpb24gKGFjdHVhbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlb2YgYWN0dWFsID09PSBcInN0cmluZ1wiICYmIGV4cGVjdGF0aW9uLnRlc3QoYWN0dWFsKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIHN0cmluZzogZnVuY3Rpb24gKG0sIGV4cGVjdGF0aW9uKSB7XG4gICAgICAgICAgICBtLnRlc3QgPSBmdW5jdGlvbiAoYWN0dWFsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIGFjdHVhbCA9PT0gXCJzdHJpbmdcIiAmJlxuICAgICAgICAgICAgICAgICAgICBzdHJpbmdJbmRleE9mKGFjdHVhbCwgZXhwZWN0YXRpb24pICE9PSAtMVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbS5tZXNzYWdlID0gYG1hdGNoKFwiJHtleHBlY3RhdGlvbn1cIilgO1xuICAgICAgICB9LFxuICAgIH07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZVR5cGVNYXA7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBhcnJheVByb3RvID0gcmVxdWlyZShcIkBzaW5vbmpzL2NvbW1vbnNcIikucHJvdG90eXBlcy5hcnJheTtcbnZhciBkZWVwRXF1YWwgPSByZXF1aXJlKFwiLi9kZWVwLWVxdWFsXCIpLnVzZShjcmVhdGVNYXRjaGVyKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11c2UtYmVmb3JlLWRlZmluZVxudmFyIGV2ZXJ5ID0gcmVxdWlyZShcIkBzaW5vbmpzL2NvbW1vbnNcIikuZXZlcnk7XG52YXIgZnVuY3Rpb25OYW1lID0gcmVxdWlyZShcIkBzaW5vbmpzL2NvbW1vbnNcIikuZnVuY3Rpb25OYW1lO1xudmFyIGl0ZXJhYmxlVG9TdHJpbmcgPSByZXF1aXJlKFwiLi9pdGVyYWJsZS10by1zdHJpbmdcIik7XG52YXIgb2JqZWN0UHJvdG8gPSByZXF1aXJlKFwiQHNpbm9uanMvY29tbW9uc1wiKS5wcm90b3R5cGVzLm9iamVjdDtcbnZhciB0eXBlT2YgPSByZXF1aXJlKFwiQHNpbm9uanMvY29tbW9uc1wiKS50eXBlT2Y7XG52YXIgdmFsdWVUb1N0cmluZyA9IHJlcXVpcmUoXCJAc2lub25qcy9jb21tb25zXCIpLnZhbHVlVG9TdHJpbmc7XG5cbnZhciBhc3NlcnRNYXRjaGVyID0gcmVxdWlyZShcIi4vY3JlYXRlLW1hdGNoZXIvYXNzZXJ0LW1hdGNoZXJcIik7XG52YXIgYXNzZXJ0TWV0aG9kRXhpc3RzID0gcmVxdWlyZShcIi4vY3JlYXRlLW1hdGNoZXIvYXNzZXJ0LW1ldGhvZC1leGlzdHNcIik7XG52YXIgYXNzZXJ0VHlwZSA9IHJlcXVpcmUoXCIuL2NyZWF0ZS1tYXRjaGVyL2Fzc2VydC10eXBlXCIpO1xudmFyIGlzSXRlcmFibGUgPSByZXF1aXJlKFwiLi9jcmVhdGUtbWF0Y2hlci9pcy1pdGVyYWJsZVwiKTtcbnZhciBpc01hdGNoZXIgPSByZXF1aXJlKFwiLi9jcmVhdGUtbWF0Y2hlci9pcy1tYXRjaGVyXCIpO1xuXG52YXIgbWF0Y2hlclByb3RvdHlwZSA9IHJlcXVpcmUoXCIuL2NyZWF0ZS1tYXRjaGVyL21hdGNoZXItcHJvdG90eXBlXCIpO1xuXG52YXIgYXJyYXlJbmRleE9mID0gYXJyYXlQcm90by5pbmRleE9mO1xudmFyIHNvbWUgPSBhcnJheVByb3RvLnNvbWU7XG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xudmFyIG9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbnZhciBUWVBFX01BUCA9IHJlcXVpcmUoXCIuL2NyZWF0ZS1tYXRjaGVyL3R5cGUtbWFwXCIpKGNyZWF0ZU1hdGNoZXIpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVzZS1iZWZvcmUtZGVmaW5lXG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hdGNoZXIgb2JqZWN0IGZvciB0aGUgcGFzc2VkIGV4cGVjdGF0aW9uXG4gKlxuICogQGFsaWFzIG1vZHVsZTpzYW1zYW0uY3JlYXRlTWF0Y2hlclxuICogQHBhcmFtIHsqfSBleHBlY3RhdGlvbiBBbiBleHBlY3R0YXRpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIEEgbWVzc2FnZSBmb3IgdGhlIGV4cGVjdGF0aW9uXG4gKiBAcmV0dXJucyB7b2JqZWN0fSBBIG1hdGNoZXIgb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZU1hdGNoZXIoZXhwZWN0YXRpb24sIG1lc3NhZ2UpIHtcbiAgICB2YXIgbSA9IE9iamVjdC5jcmVhdGUobWF0Y2hlclByb3RvdHlwZSk7XG4gICAgdmFyIHR5cGUgPSB0eXBlT2YoZXhwZWN0YXRpb24pO1xuXG4gICAgaWYgKG1lc3NhZ2UgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgbWVzc2FnZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiTWVzc2FnZSBzaG91bGQgYmUgYSBzdHJpbmdcIik7XG4gICAgfVxuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAyKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICBgRXhwZWN0ZWQgMSBvciAyIGFyZ3VtZW50cywgcmVjZWl2ZWQgJHthcmd1bWVudHMubGVuZ3RofWAsXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGUgaW4gVFlQRV9NQVApIHtcbiAgICAgICAgVFlQRV9NQVBbdHlwZV0obSwgZXhwZWN0YXRpb24sIG1lc3NhZ2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG0udGVzdCA9IGZ1bmN0aW9uIChhY3R1YWwpIHtcbiAgICAgICAgICAgIHJldHVybiBkZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RhdGlvbik7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKCFtLm1lc3NhZ2UpIHtcbiAgICAgICAgbS5tZXNzYWdlID0gYG1hdGNoKCR7dmFsdWVUb1N0cmluZyhleHBlY3RhdGlvbil9KWA7XG4gICAgfVxuXG4gICAgLy8gZW5zdXJlIHRoYXQgbm90aGluZyBtdXRhdGVzIHRoZSBleHBvcnRlZCBtZXNzYWdlIHZhbHVlLCByZWYgaHR0cHM6Ly9naXRodWIuY29tL3Npbm9uanMvc2lub24vaXNzdWVzLzI1MDJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobSwgXCJtZXNzYWdlXCIsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICB2YWx1ZTogbS5tZXNzYWdlLFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIG07XG59XG5cbmNyZWF0ZU1hdGNoZXIuaXNNYXRjaGVyID0gaXNNYXRjaGVyO1xuXG5jcmVhdGVNYXRjaGVyLmFueSA9IGNyZWF0ZU1hdGNoZXIoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0cnVlO1xufSwgXCJhbnlcIik7XG5cbmNyZWF0ZU1hdGNoZXIuZGVmaW5lZCA9IGNyZWF0ZU1hdGNoZXIoZnVuY3Rpb24gKGFjdHVhbCkge1xuICAgIHJldHVybiBhY3R1YWwgIT09IG51bGwgJiYgYWN0dWFsICE9PSB1bmRlZmluZWQ7XG59LCBcImRlZmluZWRcIik7XG5cbmNyZWF0ZU1hdGNoZXIudHJ1dGh5ID0gY3JlYXRlTWF0Y2hlcihmdW5jdGlvbiAoYWN0dWFsKSB7XG4gICAgcmV0dXJuIEJvb2xlYW4oYWN0dWFsKTtcbn0sIFwidHJ1dGh5XCIpO1xuXG5jcmVhdGVNYXRjaGVyLmZhbHN5ID0gY3JlYXRlTWF0Y2hlcihmdW5jdGlvbiAoYWN0dWFsKSB7XG4gICAgcmV0dXJuICFhY3R1YWw7XG59LCBcImZhbHN5XCIpO1xuXG5jcmVhdGVNYXRjaGVyLnNhbWUgPSBmdW5jdGlvbiAoZXhwZWN0YXRpb24pIHtcbiAgICByZXR1cm4gY3JlYXRlTWF0Y2hlcihcbiAgICAgICAgZnVuY3Rpb24gKGFjdHVhbCkge1xuICAgICAgICAgICAgcmV0dXJuIGV4cGVjdGF0aW9uID09PSBhY3R1YWw7XG4gICAgICAgIH0sXG4gICAgICAgIGBzYW1lKCR7dmFsdWVUb1N0cmluZyhleHBlY3RhdGlvbil9KWAsXG4gICAgKTtcbn07XG5cbmNyZWF0ZU1hdGNoZXIuaW4gPSBmdW5jdGlvbiAoYXJyYXlPZkV4cGVjdGF0aW9ucykge1xuICAgIGlmICh0eXBlT2YoYXJyYXlPZkV4cGVjdGF0aW9ucykgIT09IFwiYXJyYXlcIikge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiYXJyYXkgZXhwZWN0ZWRcIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNyZWF0ZU1hdGNoZXIoXG4gICAgICAgIGZ1bmN0aW9uIChhY3R1YWwpIHtcbiAgICAgICAgICAgIHJldHVybiBzb21lKGFycmF5T2ZFeHBlY3RhdGlvbnMsIGZ1bmN0aW9uIChleHBlY3RhdGlvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBleHBlY3RhdGlvbiA9PT0gYWN0dWFsO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGBpbigke3ZhbHVlVG9TdHJpbmcoYXJyYXlPZkV4cGVjdGF0aW9ucyl9KWAsXG4gICAgKTtcbn07XG5cbmNyZWF0ZU1hdGNoZXIudHlwZU9mID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICBhc3NlcnRUeXBlKHR5cGUsIFwic3RyaW5nXCIsIFwidHlwZVwiKTtcbiAgICByZXR1cm4gY3JlYXRlTWF0Y2hlcihmdW5jdGlvbiAoYWN0dWFsKSB7XG4gICAgICAgIHJldHVybiB0eXBlT2YoYWN0dWFsKSA9PT0gdHlwZTtcbiAgICB9LCBgdHlwZU9mKFwiJHt0eXBlfVwiKWApO1xufTtcblxuY3JlYXRlTWF0Y2hlci5pbnN0YW5jZU9mID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoXG4gICAgICAgIHR5cGVvZiBTeW1ib2wgPT09IFwidW5kZWZpbmVkXCIgfHxcbiAgICAgICAgdHlwZW9mIFN5bWJvbC5oYXNJbnN0YW5jZSA9PT0gXCJ1bmRlZmluZWRcIlxuICAgICkge1xuICAgICAgICBhc3NlcnRUeXBlKHR5cGUsIFwiZnVuY3Rpb25cIiwgXCJ0eXBlXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGFzc2VydE1ldGhvZEV4aXN0cyhcbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICBTeW1ib2wuaGFzSW5zdGFuY2UsXG4gICAgICAgICAgICBcInR5cGVcIixcbiAgICAgICAgICAgIFwiW1N5bWJvbC5oYXNJbnN0YW5jZV1cIixcbiAgICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZU1hdGNoZXIoXG4gICAgICAgIGZ1bmN0aW9uIChhY3R1YWwpIHtcbiAgICAgICAgICAgIHJldHVybiBhY3R1YWwgaW5zdGFuY2VvZiB0eXBlO1xuICAgICAgICB9LFxuICAgICAgICBgaW5zdGFuY2VPZigke2Z1bmN0aW9uTmFtZSh0eXBlKSB8fCBvYmplY3RUb1N0cmluZyh0eXBlKX0pYCxcbiAgICApO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgcHJvcGVydHkgbWF0Y2hlclxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcm9wZXJ0eVRlc3QgQSBmdW5jdGlvbiB0byB0ZXN0IHRoZSBwcm9wZXJ0eSBhZ2FpbnN0IGEgdmFsdWVcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlUHJlZml4IEEgcHJlZml4IHRvIHVzZSBmb3IgbWVzc2FnZXMgZ2VuZXJhdGVkIGJ5IHRoZSBtYXRjaGVyXG4gKiBAcmV0dXJucyB7b2JqZWN0fSBBIG1hdGNoZXJcbiAqL1xuZnVuY3Rpb24gY3JlYXRlUHJvcGVydHlNYXRjaGVyKHByb3BlcnR5VGVzdCwgbWVzc2FnZVByZWZpeCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAocHJvcGVydHksIHZhbHVlKSB7XG4gICAgICAgIGFzc2VydFR5cGUocHJvcGVydHksIFwic3RyaW5nXCIsIFwicHJvcGVydHlcIik7XG4gICAgICAgIHZhciBvbmx5UHJvcGVydHkgPSBhcmd1bWVudHMubGVuZ3RoID09PSAxO1xuICAgICAgICB2YXIgbWVzc2FnZSA9IGAke21lc3NhZ2VQcmVmaXh9KFwiJHtwcm9wZXJ0eX1cImA7XG4gICAgICAgIGlmICghb25seVByb3BlcnR5KSB7XG4gICAgICAgICAgICBtZXNzYWdlICs9IGAsICR7dmFsdWVUb1N0cmluZyh2YWx1ZSl9YDtcbiAgICAgICAgfVxuICAgICAgICBtZXNzYWdlICs9IFwiKVwiO1xuICAgICAgICByZXR1cm4gY3JlYXRlTWF0Y2hlcihmdW5jdGlvbiAoYWN0dWFsKSB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgYWN0dWFsID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgICAgICBhY3R1YWwgPT09IG51bGwgfHxcbiAgICAgICAgICAgICAgICAhcHJvcGVydHlUZXN0KGFjdHVhbCwgcHJvcGVydHkpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb25seVByb3BlcnR5IHx8IGRlZXBFcXVhbChhY3R1YWxbcHJvcGVydHldLCB2YWx1ZSk7XG4gICAgICAgIH0sIG1lc3NhZ2UpO1xuICAgIH07XG59XG5cbmNyZWF0ZU1hdGNoZXIuaGFzID0gY3JlYXRlUHJvcGVydHlNYXRjaGVyKGZ1bmN0aW9uIChhY3R1YWwsIHByb3BlcnR5KSB7XG4gICAgaWYgKHR5cGVvZiBhY3R1YWwgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgcmV0dXJuIHByb3BlcnR5IGluIGFjdHVhbDtcbiAgICB9XG4gICAgcmV0dXJuIGFjdHVhbFtwcm9wZXJ0eV0gIT09IHVuZGVmaW5lZDtcbn0sIFwiaGFzXCIpO1xuXG5jcmVhdGVNYXRjaGVyLmhhc093biA9IGNyZWF0ZVByb3BlcnR5TWF0Y2hlcihmdW5jdGlvbiAoYWN0dWFsLCBwcm9wZXJ0eSkge1xuICAgIHJldHVybiBoYXNPd25Qcm9wZXJ0eShhY3R1YWwsIHByb3BlcnR5KTtcbn0sIFwiaGFzT3duXCIpO1xuXG5jcmVhdGVNYXRjaGVyLmhhc05lc3RlZCA9IGZ1bmN0aW9uIChwcm9wZXJ0eSwgdmFsdWUpIHtcbiAgICBhc3NlcnRUeXBlKHByb3BlcnR5LCBcInN0cmluZ1wiLCBcInByb3BlcnR5XCIpO1xuICAgIHZhciBvbmx5UHJvcGVydHkgPSBhcmd1bWVudHMubGVuZ3RoID09PSAxO1xuICAgIHZhciBtZXNzYWdlID0gYGhhc05lc3RlZChcIiR7cHJvcGVydHl9XCJgO1xuICAgIGlmICghb25seVByb3BlcnR5KSB7XG4gICAgICAgIG1lc3NhZ2UgKz0gYCwgJHt2YWx1ZVRvU3RyaW5nKHZhbHVlKX1gO1xuICAgIH1cbiAgICBtZXNzYWdlICs9IFwiKVwiO1xuICAgIHJldHVybiBjcmVhdGVNYXRjaGVyKGZ1bmN0aW9uIChhY3R1YWwpIHtcbiAgICAgICAgY29uc3QgcGFydHMgPSBwcm9wZXJ0eS5zcGxpdCgvKD86XFwufFxcW3xcXF0pKz8vKS5maWx0ZXIoQm9vbGVhbik7XG4gICAgICAgIGxldCBjdXJyZW50ID0gYWN0dWFsO1xuICAgICAgICBmb3IgKGNvbnN0IHBhcnQgb2YgcGFydHMpIHtcbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Py5bcGFydF07XG4gICAgICAgICAgICBpZiAoY3VycmVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvbmx5UHJvcGVydHkgfHwgZGVlcEVxdWFsKGN1cnJlbnQsIHZhbHVlKTtcbiAgICB9LCBtZXNzYWdlKTtcbn07XG5cbnZhciBqc29uUGFyc2VSZXN1bHRUeXBlcyA9IHtcbiAgICBudWxsOiB0cnVlLFxuICAgIGJvb2xlYW46IHRydWUsXG4gICAgbnVtYmVyOiB0cnVlLFxuICAgIHN0cmluZzogdHJ1ZSxcbiAgICBvYmplY3Q6IHRydWUsXG4gICAgYXJyYXk6IHRydWUsXG59O1xuY3JlYXRlTWF0Y2hlci5qc29uID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgaWYgKCFqc29uUGFyc2VSZXN1bHRUeXBlc1t0eXBlT2YodmFsdWUpXSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiVmFsdWUgY2Fubm90IGJlIHRoZSByZXN1bHQgb2YgSlNPTi5wYXJzZVwiKTtcbiAgICB9XG4gICAgdmFyIG1lc3NhZ2UgPSBganNvbigke0pTT04uc3RyaW5naWZ5KHZhbHVlLCBudWxsLCBcIiAgXCIpfSlgO1xuICAgIHJldHVybiBjcmVhdGVNYXRjaGVyKGZ1bmN0aW9uIChhY3R1YWwpIHtcbiAgICAgICAgdmFyIHBhcnNlZDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHBhcnNlZCA9IEpTT04ucGFyc2UoYWN0dWFsKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWVwRXF1YWwocGFyc2VkLCB2YWx1ZSk7XG4gICAgfSwgbWVzc2FnZSk7XG59O1xuXG5jcmVhdGVNYXRjaGVyLmV2ZXJ5ID0gZnVuY3Rpb24gKHByZWRpY2F0ZSkge1xuICAgIGFzc2VydE1hdGNoZXIocHJlZGljYXRlKTtcblxuICAgIHJldHVybiBjcmVhdGVNYXRjaGVyKGZ1bmN0aW9uIChhY3R1YWwpIHtcbiAgICAgICAgaWYgKHR5cGVPZihhY3R1YWwpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gZXZlcnkoT2JqZWN0LmtleXMoYWN0dWFsKSwgZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcmVkaWNhdGUudGVzdChhY3R1YWxba2V5XSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBpc0l0ZXJhYmxlKGFjdHVhbCkgJiZcbiAgICAgICAgICAgIGV2ZXJ5KGFjdHVhbCwgZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJlZGljYXRlLnRlc3QoZWxlbWVudCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgIH0sIGBldmVyeSgke3ByZWRpY2F0ZS5tZXNzYWdlfSlgKTtcbn07XG5cbmNyZWF0ZU1hdGNoZXIuc29tZSA9IGZ1bmN0aW9uIChwcmVkaWNhdGUpIHtcbiAgICBhc3NlcnRNYXRjaGVyKHByZWRpY2F0ZSk7XG5cbiAgICByZXR1cm4gY3JlYXRlTWF0Y2hlcihmdW5jdGlvbiAoYWN0dWFsKSB7XG4gICAgICAgIGlmICh0eXBlT2YoYWN0dWFsKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgcmV0dXJuICFldmVyeShPYmplY3Qua2V5cyhhY3R1YWwpLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICFwcmVkaWNhdGUudGVzdChhY3R1YWxba2V5XSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBpc0l0ZXJhYmxlKGFjdHVhbCkgJiZcbiAgICAgICAgICAgICFldmVyeShhY3R1YWwsIGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICFwcmVkaWNhdGUudGVzdChlbGVtZW50KTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgfSwgYHNvbWUoJHtwcmVkaWNhdGUubWVzc2FnZX0pYCk7XG59O1xuXG5jcmVhdGVNYXRjaGVyLmFycmF5ID0gY3JlYXRlTWF0Y2hlci50eXBlT2YoXCJhcnJheVwiKTtcblxuY3JlYXRlTWF0Y2hlci5hcnJheS5kZWVwRXF1YWxzID0gZnVuY3Rpb24gKGV4cGVjdGF0aW9uKSB7XG4gICAgcmV0dXJuIGNyZWF0ZU1hdGNoZXIoXG4gICAgICAgIGZ1bmN0aW9uIChhY3R1YWwpIHtcbiAgICAgICAgICAgIC8vIENvbXBhcmluZyBsZW5ndGhzIGlzIHRoZSBmYXN0ZXN0IHdheSB0byBzcG90IGEgZGlmZmVyZW5jZSBiZWZvcmUgaXRlcmF0aW5nIHRocm91Z2ggZXZlcnkgaXRlbVxuICAgICAgICAgICAgdmFyIHNhbWVMZW5ndGggPSBhY3R1YWwubGVuZ3RoID09PSBleHBlY3RhdGlvbi5sZW5ndGg7XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIHR5cGVPZihhY3R1YWwpID09PSBcImFycmF5XCIgJiZcbiAgICAgICAgICAgICAgICBzYW1lTGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgZXZlcnkoYWN0dWFsLCBmdW5jdGlvbiAoZWxlbWVudCwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGV4cGVjdGVkID0gZXhwZWN0YXRpb25baW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHlwZU9mKGV4cGVjdGVkKSA9PT0gXCJhcnJheVwiICYmXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlT2YoZWxlbWVudCkgPT09IFwiYXJyYXlcIlxuICAgICAgICAgICAgICAgICAgICAgICAgPyBjcmVhdGVNYXRjaGVyLmFycmF5LmRlZXBFcXVhbHMoZXhwZWN0ZWQpLnRlc3QoZWxlbWVudClcbiAgICAgICAgICAgICAgICAgICAgICAgIDogZGVlcEVxdWFsKGV4cGVjdGVkLCBlbGVtZW50KTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSxcbiAgICAgICAgYGRlZXBFcXVhbHMoWyR7aXRlcmFibGVUb1N0cmluZyhleHBlY3RhdGlvbil9XSlgLFxuICAgICk7XG59O1xuXG5jcmVhdGVNYXRjaGVyLmFycmF5LnN0YXJ0c1dpdGggPSBmdW5jdGlvbiAoZXhwZWN0YXRpb24pIHtcbiAgICByZXR1cm4gY3JlYXRlTWF0Y2hlcihcbiAgICAgICAgZnVuY3Rpb24gKGFjdHVhbCkge1xuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICB0eXBlT2YoYWN0dWFsKSA9PT0gXCJhcnJheVwiICYmXG4gICAgICAgICAgICAgICAgZXZlcnkoZXhwZWN0YXRpb24sIGZ1bmN0aW9uIChleHBlY3RlZEVsZW1lbnQsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhY3R1YWxbaW5kZXhdID09PSBleHBlY3RlZEVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0sXG4gICAgICAgIGBzdGFydHNXaXRoKFske2l0ZXJhYmxlVG9TdHJpbmcoZXhwZWN0YXRpb24pfV0pYCxcbiAgICApO1xufTtcblxuY3JlYXRlTWF0Y2hlci5hcnJheS5lbmRzV2l0aCA9IGZ1bmN0aW9uIChleHBlY3RhdGlvbikge1xuICAgIHJldHVybiBjcmVhdGVNYXRjaGVyKFxuICAgICAgICBmdW5jdGlvbiAoYWN0dWFsKSB7XG4gICAgICAgICAgICAvLyBUaGlzIGluZGljYXRlcyB0aGUgaW5kZXggaW4gd2hpY2ggd2Ugc2hvdWxkIHN0YXJ0IG1hdGNoaW5nXG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gYWN0dWFsLmxlbmd0aCAtIGV4cGVjdGF0aW9uLmxlbmd0aDtcblxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICB0eXBlT2YoYWN0dWFsKSA9PT0gXCJhcnJheVwiICYmXG4gICAgICAgICAgICAgICAgZXZlcnkoZXhwZWN0YXRpb24sIGZ1bmN0aW9uIChleHBlY3RlZEVsZW1lbnQsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhY3R1YWxbb2Zmc2V0ICsgaW5kZXhdID09PSBleHBlY3RlZEVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0sXG4gICAgICAgIGBlbmRzV2l0aChbJHtpdGVyYWJsZVRvU3RyaW5nKGV4cGVjdGF0aW9uKX1dKWAsXG4gICAgKTtcbn07XG5cbmNyZWF0ZU1hdGNoZXIuYXJyYXkuY29udGFpbnMgPSBmdW5jdGlvbiAoZXhwZWN0YXRpb24pIHtcbiAgICByZXR1cm4gY3JlYXRlTWF0Y2hlcihcbiAgICAgICAgZnVuY3Rpb24gKGFjdHVhbCkge1xuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICB0eXBlT2YoYWN0dWFsKSA9PT0gXCJhcnJheVwiICYmXG4gICAgICAgICAgICAgICAgZXZlcnkoZXhwZWN0YXRpb24sIGZ1bmN0aW9uIChleHBlY3RlZEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFycmF5SW5kZXhPZihhY3R1YWwsIGV4cGVjdGVkRWxlbWVudCkgIT09IC0xO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApO1xuICAgICAgICB9LFxuICAgICAgICBgY29udGFpbnMoWyR7aXRlcmFibGVUb1N0cmluZyhleHBlY3RhdGlvbil9XSlgLFxuICAgICk7XG59O1xuXG5jcmVhdGVNYXRjaGVyLm1hcCA9IGNyZWF0ZU1hdGNoZXIudHlwZU9mKFwibWFwXCIpO1xuXG5jcmVhdGVNYXRjaGVyLm1hcC5kZWVwRXF1YWxzID0gZnVuY3Rpb24gbWFwRGVlcEVxdWFscyhleHBlY3RhdGlvbikge1xuICAgIHJldHVybiBjcmVhdGVNYXRjaGVyKFxuICAgICAgICBmdW5jdGlvbiAoYWN0dWFsKSB7XG4gICAgICAgICAgICAvLyBDb21wYXJpbmcgbGVuZ3RocyBpcyB0aGUgZmFzdGVzdCB3YXkgdG8gc3BvdCBhIGRpZmZlcmVuY2UgYmVmb3JlIGl0ZXJhdGluZyB0aHJvdWdoIGV2ZXJ5IGl0ZW1cbiAgICAgICAgICAgIHZhciBzYW1lTGVuZ3RoID0gYWN0dWFsLnNpemUgPT09IGV4cGVjdGF0aW9uLnNpemU7XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIHR5cGVPZihhY3R1YWwpID09PSBcIm1hcFwiICYmXG4gICAgICAgICAgICAgICAgc2FtZUxlbmd0aCAmJlxuICAgICAgICAgICAgICAgIGV2ZXJ5KGFjdHVhbCwgZnVuY3Rpb24gKGVsZW1lbnQsIGtleSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0YXRpb24uaGFzKGtleSkgJiYgZXhwZWN0YXRpb24uZ2V0KGtleSkgPT09IGVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSxcbiAgICAgICAgYGRlZXBFcXVhbHMoTWFwWyR7aXRlcmFibGVUb1N0cmluZyhleHBlY3RhdGlvbil9XSlgLFxuICAgICk7XG59O1xuXG5jcmVhdGVNYXRjaGVyLm1hcC5jb250YWlucyA9IGZ1bmN0aW9uIG1hcENvbnRhaW5zKGV4cGVjdGF0aW9uKSB7XG4gICAgcmV0dXJuIGNyZWF0ZU1hdGNoZXIoXG4gICAgICAgIGZ1bmN0aW9uIChhY3R1YWwpIHtcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgdHlwZU9mKGFjdHVhbCkgPT09IFwibWFwXCIgJiZcbiAgICAgICAgICAgICAgICBldmVyeShleHBlY3RhdGlvbiwgZnVuY3Rpb24gKGVsZW1lbnQsIGtleSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWN0dWFsLmhhcyhrZXkpICYmIGFjdHVhbC5nZXQoa2V5KSA9PT0gZWxlbWVudDtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSxcbiAgICAgICAgYGNvbnRhaW5zKE1hcFske2l0ZXJhYmxlVG9TdHJpbmcoZXhwZWN0YXRpb24pfV0pYCxcbiAgICApO1xufTtcblxuY3JlYXRlTWF0Y2hlci5zZXQgPSBjcmVhdGVNYXRjaGVyLnR5cGVPZihcInNldFwiKTtcblxuY3JlYXRlTWF0Y2hlci5zZXQuZGVlcEVxdWFscyA9IGZ1bmN0aW9uIHNldERlZXBFcXVhbHMoZXhwZWN0YXRpb24pIHtcbiAgICByZXR1cm4gY3JlYXRlTWF0Y2hlcihcbiAgICAgICAgZnVuY3Rpb24gKGFjdHVhbCkge1xuICAgICAgICAgICAgLy8gQ29tcGFyaW5nIGxlbmd0aHMgaXMgdGhlIGZhc3Rlc3Qgd2F5IHRvIHNwb3QgYSBkaWZmZXJlbmNlIGJlZm9yZSBpdGVyYXRpbmcgdGhyb3VnaCBldmVyeSBpdGVtXG4gICAgICAgICAgICB2YXIgc2FtZUxlbmd0aCA9IGFjdHVhbC5zaXplID09PSBleHBlY3RhdGlvbi5zaXplO1xuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICB0eXBlT2YoYWN0dWFsKSA9PT0gXCJzZXRcIiAmJlxuICAgICAgICAgICAgICAgIHNhbWVMZW5ndGggJiZcbiAgICAgICAgICAgICAgICBldmVyeShhY3R1YWwsIGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBleHBlY3RhdGlvbi5oYXMoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0sXG4gICAgICAgIGBkZWVwRXF1YWxzKFNldFske2l0ZXJhYmxlVG9TdHJpbmcoZXhwZWN0YXRpb24pfV0pYCxcbiAgICApO1xufTtcblxuY3JlYXRlTWF0Y2hlci5zZXQuY29udGFpbnMgPSBmdW5jdGlvbiBzZXRDb250YWlucyhleHBlY3RhdGlvbikge1xuICAgIHJldHVybiBjcmVhdGVNYXRjaGVyKFxuICAgICAgICBmdW5jdGlvbiAoYWN0dWFsKSB7XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIHR5cGVPZihhY3R1YWwpID09PSBcInNldFwiICYmXG4gICAgICAgICAgICAgICAgZXZlcnkoZXhwZWN0YXRpb24sIGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhY3R1YWwuaGFzKGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApO1xuICAgICAgICB9LFxuICAgICAgICBgY29udGFpbnMoU2V0WyR7aXRlcmFibGVUb1N0cmluZyhleHBlY3RhdGlvbil9XSlgLFxuICAgICk7XG59O1xuXG5jcmVhdGVNYXRjaGVyLmJvb2wgPSBjcmVhdGVNYXRjaGVyLnR5cGVPZihcImJvb2xlYW5cIik7XG5jcmVhdGVNYXRjaGVyLm51bWJlciA9IGNyZWF0ZU1hdGNoZXIudHlwZU9mKFwibnVtYmVyXCIpO1xuY3JlYXRlTWF0Y2hlci5zdHJpbmcgPSBjcmVhdGVNYXRjaGVyLnR5cGVPZihcInN0cmluZ1wiKTtcbmNyZWF0ZU1hdGNoZXIub2JqZWN0ID0gY3JlYXRlTWF0Y2hlci50eXBlT2YoXCJvYmplY3RcIik7XG5jcmVhdGVNYXRjaGVyLmZ1bmMgPSBjcmVhdGVNYXRjaGVyLnR5cGVPZihcImZ1bmN0aW9uXCIpO1xuY3JlYXRlTWF0Y2hlci5yZWdleHAgPSBjcmVhdGVNYXRjaGVyLnR5cGVPZihcInJlZ2V4cFwiKTtcbmNyZWF0ZU1hdGNoZXIuZGF0ZSA9IGNyZWF0ZU1hdGNoZXIudHlwZU9mKFwiZGF0ZVwiKTtcbmNyZWF0ZU1hdGNoZXIuc3ltYm9sID0gY3JlYXRlTWF0Y2hlci50eXBlT2YoXCJzeW1ib2xcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlTWF0Y2hlcjtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxudmFyIHZhbHVlVG9TdHJpbmcgPSByZXF1aXJlKFwiQHNpbm9uanMvY29tbW9uc1wiKS52YWx1ZVRvU3RyaW5nO1xudmFyIGluZGV4T2YgPSByZXF1aXJlKFwiQHNpbm9uanMvY29tbW9uc1wiKS5wcm90b3R5cGVzLnN0cmluZy5pbmRleE9mO1xudmFyIGZvckVhY2ggPSByZXF1aXJlKFwiQHNpbm9uanMvY29tbW9uc1wiKS5wcm90b3R5cGVzLmFycmF5LmZvckVhY2g7XG52YXIgdHlwZSA9IHJlcXVpcmUoXCJ0eXBlLWRldGVjdFwiKTtcblxudmFyIGVuZ2luZUNhbkNvbXBhcmVNYXBzID0gdHlwZW9mIEFycmF5LmZyb20gPT09IFwiZnVuY3Rpb25cIjtcbnZhciBkZWVwRXF1YWwgPSByZXF1aXJlKFwiLi9kZWVwLWVxdWFsXCIpLnVzZShtYXRjaCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdXNlLWJlZm9yZS1kZWZpbmVcbnZhciBpc0FycmF5VHlwZSA9IHJlcXVpcmUoXCIuL2lzLWFycmF5LXR5cGVcIik7XG52YXIgaXNTdWJzZXQgPSByZXF1aXJlKFwiLi9pcy1zdWJzZXRcIik7XG52YXIgY3JlYXRlTWF0Y2hlciA9IHJlcXVpcmUoXCIuL2NyZWF0ZS1tYXRjaGVyXCIpO1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSB3aGVuIGBhcnJheWAgY29udGFpbnMgYWxsIG9mIGBzdWJzZXRgIGFzIGRlZmluZWQgYnkgdGhlIGBjb21wYXJlYFxuICogYXJndW1lbnRcbiAqXG4gKiBAcGFyYW0gIHtBcnJheX0gYXJyYXkgICBBbiBhcnJheSB0byBzZWFyY2ggZm9yIGEgc3Vic2V0XG4gKiBAcGFyYW0gIHtBcnJheX0gc3Vic2V0ICBUaGUgc3Vic2V0IHRvIGZpbmQgaW4gdGhlIGFycmF5XG4gKiBAcGFyYW0gIHtGdW5jdGlvbn0gY29tcGFyZSBBIGNvbXBhcmlzb24gZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtib29sZWFufSAgICAgICAgIFtkZXNjcmlwdGlvbl1cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGFycmF5Q29udGFpbnMoYXJyYXksIHN1YnNldCwgY29tcGFyZSkge1xuICAgIGlmIChzdWJzZXQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICB2YXIgaSwgbCwgaiwgaztcbiAgICBmb3IgKGkgPSAwLCBsID0gYXJyYXkubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICAgIGlmIChjb21wYXJlKGFycmF5W2ldLCBzdWJzZXRbMF0pKSB7XG4gICAgICAgICAgICBmb3IgKGogPSAwLCBrID0gc3Vic2V0Lmxlbmd0aDsgaiA8IGs7ICsraikge1xuICAgICAgICAgICAgICAgIGlmIChpICsgaiA+PSBsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFjb21wYXJlKGFycmF5W2kgKyBqXSwgc3Vic2V0W2pdKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKiBlc2xpbnQtZGlzYWJsZSBjb21wbGV4aXR5ICovXG4vKipcbiAqIE1hdGNoZXMgYW4gb2JqZWN0IHdpdGggYSBtYXRjaGVyIChvciB2YWx1ZSlcbiAqXG4gKiBAYWxpYXMgbW9kdWxlOnNhbXNhbS5tYXRjaFxuICogQHBhcmFtIHtvYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IGNhbmRpZGF0ZSB0byBtYXRjaFxuICogQHBhcmFtIHtvYmplY3R9IG1hdGNoZXJPclZhbHVlIEEgbWF0Y2hlciBvciB2YWx1ZSB0byBtYXRjaCBhZ2FpbnN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSB3aGVuIGBvYmplY3RgIG1hdGNoZXMgYG1hdGNoZXJPclZhbHVlYFxuICovXG5mdW5jdGlvbiBtYXRjaChvYmplY3QsIG1hdGNoZXJPclZhbHVlKSB7XG4gICAgaWYgKG1hdGNoZXJPclZhbHVlICYmIHR5cGVvZiBtYXRjaGVyT3JWYWx1ZS50ZXN0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIG1hdGNoZXJPclZhbHVlLnRlc3Qob2JqZWN0KTtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKHR5cGUobWF0Y2hlck9yVmFsdWUpKSB7XG4gICAgICAgIGNhc2UgXCJiaWdpbnRcIjpcbiAgICAgICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgICBjYXNlIFwic3ltYm9sXCI6XG4gICAgICAgICAgICByZXR1cm4gbWF0Y2hlck9yVmFsdWUgPT09IG9iamVjdDtcbiAgICAgICAgY2FzZSBcImZ1bmN0aW9uXCI6XG4gICAgICAgICAgICByZXR1cm4gbWF0Y2hlck9yVmFsdWUob2JqZWN0KSA9PT0gdHJ1ZTtcbiAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgICAgdmFyIG5vdE51bGwgPSB0eXBlb2Ygb2JqZWN0ID09PSBcInN0cmluZ1wiIHx8IEJvb2xlYW4ob2JqZWN0KTtcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgbm90TnVsbCAmJlxuICAgICAgICAgICAgICAgIGluZGV4T2YoXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlVG9TdHJpbmcob2JqZWN0KS50b0xvd2VyQ2FzZSgpLFxuICAgICAgICAgICAgICAgICAgICBtYXRjaGVyT3JWYWx1ZS50b0xvd2VyQ2FzZSgpLFxuICAgICAgICAgICAgICAgICkgPj0gMFxuICAgICAgICAgICAgKTtcbiAgICAgICAgY2FzZSBcIm51bGxcIjpcbiAgICAgICAgICAgIHJldHVybiBvYmplY3QgPT09IG51bGw7XG4gICAgICAgIGNhc2UgXCJ1bmRlZmluZWRcIjpcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSBcInVuZGVmaW5lZFwiO1xuICAgICAgICBjYXNlIFwiRGF0ZVwiOlxuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICAgIGlmICh0eXBlKG9iamVjdCkgPT09IFwiRGF0ZVwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iamVjdC5nZXRUaW1lKCkgPT09IG1hdGNoZXJPclZhbHVlLmdldFRpbWUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiB0aGlzIGlzIGJhc2ljYWxseSB0aGUgcmVzdCBvZiB0aGUgZnVuY3Rpb24sIHdoaWNoIGlzIGNvdmVyZWQgKi9cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiQXJyYXlcIjpcbiAgICAgICAgY2FzZSBcIkludDhBcnJheVwiOlxuICAgICAgICBjYXNlIFwiVWludDhBcnJheVwiOlxuICAgICAgICBjYXNlIFwiVWludDhDbGFtcGVkQXJyYXlcIjpcbiAgICAgICAgY2FzZSBcIkludDE2QXJyYXlcIjpcbiAgICAgICAgY2FzZSBcIlVpbnQxNkFycmF5XCI6XG4gICAgICAgIGNhc2UgXCJJbnQzMkFycmF5XCI6XG4gICAgICAgIGNhc2UgXCJVaW50MzJBcnJheVwiOlxuICAgICAgICBjYXNlIFwiRmxvYXQzMkFycmF5XCI6XG4gICAgICAgIGNhc2UgXCJGbG9hdDY0QXJyYXlcIjpcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgaXNBcnJheVR5cGUobWF0Y2hlck9yVmFsdWUpICYmXG4gICAgICAgICAgICAgICAgYXJyYXlDb250YWlucyhvYmplY3QsIG1hdGNoZXJPclZhbHVlLCBtYXRjaClcbiAgICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgXCJNYXBcIjpcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiB0aGlzIGlzIGNvdmVyZWQgYnkgYSB0ZXN0LCB0aGF0IGlzIG9ubHkgcnVuIGluIElFLCBidXQgd2UgY29sbGVjdCBjb3ZlcmFnZSBpbmZvcm1hdGlvbiBpbiBub2RlKi9cbiAgICAgICAgICAgIGlmICghZW5naW5lQ2FuQ29tcGFyZU1hcHMpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIFwiVGhlIEphdmFTY3JpcHQgZW5naW5lIGRvZXMgbm90IHN1cHBvcnQgQXJyYXkuZnJvbSBhbmQgY2Fubm90IHJlbGlhYmx5IGRvIHZhbHVlIGNvbXBhcmlzb24gb2YgTWFwIGluc3RhbmNlc1wiLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgdHlwZShvYmplY3QpID09PSBcIk1hcFwiICYmXG4gICAgICAgICAgICAgICAgYXJyYXlDb250YWlucyhcbiAgICAgICAgICAgICAgICAgICAgQXJyYXkuZnJvbShvYmplY3QpLFxuICAgICAgICAgICAgICAgICAgICBBcnJheS5mcm9tKG1hdGNoZXJPclZhbHVlKSxcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2gsXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHN3aXRjaCAodHlwZShvYmplY3QpKSB7XG4gICAgICAgIGNhc2UgXCJudWxsXCI6XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGNhc2UgXCJTZXRcIjpcbiAgICAgICAgICAgIHJldHVybiBpc1N1YnNldChtYXRjaGVyT3JWYWx1ZSwgb2JqZWN0LCBtYXRjaCk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmIChtYXRjaGVyT3JWYWx1ZSAmJiB0eXBlb2YgbWF0Y2hlck9yVmFsdWUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgaWYgKG1hdGNoZXJPclZhbHVlID09PSBvYmplY3QpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0ICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHByb3A7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBndWFyZC1mb3ItaW5cbiAgICAgICAgZm9yIChwcm9wIGluIG1hdGNoZXJPclZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBvYmplY3RbcHJvcF07XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09PSBcInVuZGVmaW5lZFwiICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIG9iamVjdC5nZXRBdHRyaWJ1dGUgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBvYmplY3QuZ2V0QXR0cmlidXRlKHByb3ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIG1hdGNoZXJPclZhbHVlW3Byb3BdID09PSBudWxsIHx8XG4gICAgICAgICAgICAgICAgdHlwZW9mIG1hdGNoZXJPclZhbHVlW3Byb3BdID09PSBcInVuZGVmaW5lZFwiXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09IG1hdGNoZXJPclZhbHVlW3Byb3BdKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gXCJ1bmRlZmluZWRcIiB8fFxuICAgICAgICAgICAgICAgICFkZWVwRXF1YWwodmFsdWUsIG1hdGNoZXJPclZhbHVlW3Byb3BdKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTWF0Y2hlciB3YXMgYW4gdW5rbm93biBvciB1bnN1cHBvcnRlZCB0eXBlXCIpO1xufVxuLyogZXNsaW50LWVuYWJsZSBjb21wbGV4aXR5ICovXG5cbmZvckVhY2goT2JqZWN0LmtleXMoY3JlYXRlTWF0Y2hlciksIGZ1bmN0aW9uIChrZXkpIHtcbiAgICBtYXRjaFtrZXldID0gY3JlYXRlTWF0Y2hlcltrZXldO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gbWF0Y2g7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogQG1vZHVsZSBzYW1zYW1cbiAqL1xudmFyIGlkZW50aWNhbCA9IHJlcXVpcmUoXCIuL2lkZW50aWNhbFwiKTtcbnZhciBpc0FyZ3VtZW50cyA9IHJlcXVpcmUoXCIuL2lzLWFyZ3VtZW50c1wiKTtcbnZhciBpc0VsZW1lbnQgPSByZXF1aXJlKFwiLi9pcy1lbGVtZW50XCIpO1xudmFyIGlzTmVnWmVybyA9IHJlcXVpcmUoXCIuL2lzLW5lZy16ZXJvXCIpO1xudmFyIGlzU2V0ID0gcmVxdWlyZShcIi4vaXMtc2V0XCIpO1xudmFyIGlzTWFwID0gcmVxdWlyZShcIi4vaXMtbWFwXCIpO1xudmFyIG1hdGNoID0gcmVxdWlyZShcIi4vbWF0Y2hcIik7XG52YXIgZGVlcEVxdWFsQ3ljbGljID0gcmVxdWlyZShcIi4vZGVlcC1lcXVhbFwiKS51c2UobWF0Y2gpO1xudmFyIGNyZWF0ZU1hdGNoZXIgPSByZXF1aXJlKFwiLi9jcmVhdGUtbWF0Y2hlclwiKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgY3JlYXRlTWF0Y2hlcjogY3JlYXRlTWF0Y2hlcixcbiAgICBkZWVwRXF1YWw6IGRlZXBFcXVhbEN5Y2xpYyxcbiAgICBpZGVudGljYWw6IGlkZW50aWNhbCxcbiAgICBpc0FyZ3VtZW50czogaXNBcmd1bWVudHMsXG4gICAgaXNFbGVtZW50OiBpc0VsZW1lbnQsXG4gICAgaXNNYXA6IGlzTWFwLFxuICAgIGlzTmVnWmVybzogaXNOZWdaZXJvLFxuICAgIGlzU2V0OiBpc1NldCxcbiAgICBtYXRjaDogbWF0Y2gsXG59O1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5jb25zdCBhcnJheSA9IFtudWxsLCBcIm9uY2VcIiwgXCJ0d2ljZVwiLCBcInRocmljZVwiXTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB0aW1lc0luV29yZHMoY291bnQpIHtcbiAgICByZXR1cm4gYXJyYXlbY291bnRdIHx8IGAke2NvdW50IHx8IDB9IHRpbWVzYDtcbn07XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG4vKiBlc2xpbnQgY29tcGxleGl0eTogWzIsIDE4XSwgbWF4LXN0YXRlbWVudHM6IFsyLCAzM10gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaGFzU3ltYm9scygpIHtcblx0aWYgKHR5cGVvZiBTeW1ib2wgIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgIT09ICdmdW5jdGlvbicpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdGlmICh0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSAnc3ltYm9sJykgeyByZXR1cm4gdHJ1ZTsgfVxuXG5cdHZhciBvYmogPSB7fTtcblx0dmFyIHN5bSA9IFN5bWJvbCgndGVzdCcpO1xuXHR2YXIgc3ltT2JqID0gT2JqZWN0KHN5bSk7XG5cdGlmICh0eXBlb2Ygc3ltID09PSAnc3RyaW5nJykgeyByZXR1cm4gZmFsc2U7IH1cblxuXHRpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHN5bSkgIT09ICdbb2JqZWN0IFN5bWJvbF0nKSB7IHJldHVybiBmYWxzZTsgfVxuXHRpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHN5bU9iaikgIT09ICdbb2JqZWN0IFN5bWJvbF0nKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdC8vIHRlbXAgZGlzYWJsZWQgcGVyIGh0dHBzOi8vZ2l0aHViLmNvbS9samhhcmIvb2JqZWN0LmFzc2lnbi9pc3N1ZXMvMTdcblx0Ly8gaWYgKHN5bSBpbnN0YW5jZW9mIFN5bWJvbCkgeyByZXR1cm4gZmFsc2U7IH1cblx0Ly8gdGVtcCBkaXNhYmxlZCBwZXIgaHR0cHM6Ly9naXRodWIuY29tL1dlYlJlZmxlY3Rpb24vZ2V0LW93bi1wcm9wZXJ0eS1zeW1ib2xzL2lzc3Vlcy80XG5cdC8vIGlmICghKHN5bU9iaiBpbnN0YW5jZW9mIFN5bWJvbCkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0Ly8gaWYgKHR5cGVvZiBTeW1ib2wucHJvdG90eXBlLnRvU3RyaW5nICE9PSAnZnVuY3Rpb24nKSB7IHJldHVybiBmYWxzZTsgfVxuXHQvLyBpZiAoU3RyaW5nKHN5bSkgIT09IFN5bWJvbC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChzeW0pKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdHZhciBzeW1WYWwgPSA0Mjtcblx0b2JqW3N5bV0gPSBzeW1WYWw7XG5cdGZvciAoc3ltIGluIG9iaikgeyByZXR1cm4gZmFsc2U7IH0gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheCwgbm8tdW5yZWFjaGFibGUtbG9vcFxuXHRpZiAodHlwZW9mIE9iamVjdC5rZXlzID09PSAnZnVuY3Rpb24nICYmIE9iamVjdC5rZXlzKG9iaikubGVuZ3RoICE9PSAwKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdGlmICh0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgPT09ICdmdW5jdGlvbicgJiYgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob2JqKS5sZW5ndGggIT09IDApIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0dmFyIHN5bXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iaik7XG5cdGlmIChzeW1zLmxlbmd0aCAhPT0gMSB8fCBzeW1zWzBdICE9PSBzeW0pIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0aWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwob2JqLCBzeW0pKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdGlmICh0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdHZhciBkZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIHN5bSk7XG5cdFx0aWYgKGRlc2NyaXB0b3IudmFsdWUgIT09IHN5bVZhbCB8fCBkZXNjcmlwdG9yLmVudW1lcmFibGUgIT09IHRydWUpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdH1cblxuXHRyZXR1cm4gdHJ1ZTtcbn07XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaGFzU3ltYm9scyA9IHJlcXVpcmUoJ2hhcy1zeW1ib2xzL3NoYW1zJyk7XG5cbi8qKiBAdHlwZSB7aW1wb3J0KCcuJyl9ICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGhhc1RvU3RyaW5nVGFnU2hhbXMoKSB7XG5cdHJldHVybiBoYXNTeW1ib2xzKCkgJiYgISFTeW1ib2wudG9TdHJpbmdUYWc7XG59O1xuIiwgIid1c2Ugc3RyaWN0JztcblxuLyoqIEB0eXBlIHtpbXBvcnQoJy4nKX0gKi9cbm1vZHVsZS5leHBvcnRzID0gRXJyb3I7XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG4vKiogQHR5cGUge2ltcG9ydCgnLi9ldmFsJyl9ICovXG5tb2R1bGUuZXhwb3J0cyA9IEV2YWxFcnJvcjtcbiIsICIndXNlIHN0cmljdCc7XG5cbi8qKiBAdHlwZSB7aW1wb3J0KCcuL3JhbmdlJyl9ICovXG5tb2R1bGUuZXhwb3J0cyA9IFJhbmdlRXJyb3I7XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG4vKiogQHR5cGUge2ltcG9ydCgnLi9yZWYnKX0gKi9cbm1vZHVsZS5leHBvcnRzID0gUmVmZXJlbmNlRXJyb3I7XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG4vKiogQHR5cGUge2ltcG9ydCgnLi9zeW50YXgnKX0gKi9cbm1vZHVsZS5leHBvcnRzID0gU3ludGF4RXJyb3I7XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG4vKiogQHR5cGUge2ltcG9ydCgnLi90eXBlJyl9ICovXG5tb2R1bGUuZXhwb3J0cyA9IFR5cGVFcnJvcjtcbiIsICIndXNlIHN0cmljdCc7XG5cbi8qKiBAdHlwZSB7aW1wb3J0KCcuL3VyaScpfSAqL1xubW9kdWxlLmV4cG9ydHMgPSBVUklFcnJvcjtcbiIsICIndXNlIHN0cmljdCc7XG5cbnZhciBvcmlnU3ltYm9sID0gdHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sO1xudmFyIGhhc1N5bWJvbFNoYW0gPSByZXF1aXJlKCcuL3NoYW1zJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaGFzTmF0aXZlU3ltYm9scygpIHtcblx0aWYgKHR5cGVvZiBvcmlnU3ltYm9sICE9PSAnZnVuY3Rpb24nKSB7IHJldHVybiBmYWxzZTsgfVxuXHRpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ2Z1bmN0aW9uJykgeyByZXR1cm4gZmFsc2U7IH1cblx0aWYgKHR5cGVvZiBvcmlnU3ltYm9sKCdmb28nKSAhPT0gJ3N5bWJvbCcpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdGlmICh0eXBlb2YgU3ltYm9sKCdiYXInKSAhPT0gJ3N5bWJvbCcpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0cmV0dXJuIGhhc1N5bWJvbFNoYW0oKTtcbn07XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdGVzdCA9IHtcblx0X19wcm90b19fOiBudWxsLFxuXHRmb286IHt9XG59O1xuXG52YXIgJE9iamVjdCA9IE9iamVjdDtcblxuLyoqIEB0eXBlIHtpbXBvcnQoJy4nKX0gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaGFzUHJvdG8oKSB7XG5cdC8vIEB0cy1leHBlY3QtZXJyb3I6IFRTIGVycm9ycyBvbiBhbiBpbmhlcml0ZWQgcHJvcGVydHkgZm9yIHNvbWUgcmVhc29uXG5cdHJldHVybiB7IF9fcHJvdG9fXzogdGVzdCB9LmZvbyA9PT0gdGVzdC5mb29cblx0XHQmJiAhKHRlc3QgaW5zdGFuY2VvZiAkT2JqZWN0KTtcbn07XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG4vKiBlc2xpbnQgbm8taW52YWxpZC10aGlzOiAxICovXG5cbnZhciBFUlJPUl9NRVNTQUdFID0gJ0Z1bmN0aW9uLnByb3RvdHlwZS5iaW5kIGNhbGxlZCBvbiBpbmNvbXBhdGlibGUgJztcbnZhciB0b1N0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgbWF4ID0gTWF0aC5tYXg7XG52YXIgZnVuY1R5cGUgPSAnW29iamVjdCBGdW5jdGlvbl0nO1xuXG52YXIgY29uY2F0dHkgPSBmdW5jdGlvbiBjb25jYXR0eShhLCBiKSB7XG4gICAgdmFyIGFyciA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGFycltpXSA9IGFbaV07XG4gICAgfVxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgYi5sZW5ndGg7IGogKz0gMSkge1xuICAgICAgICBhcnJbaiArIGEubGVuZ3RoXSA9IGJbal07XG4gICAgfVxuXG4gICAgcmV0dXJuIGFycjtcbn07XG5cbnZhciBzbGljeSA9IGZ1bmN0aW9uIHNsaWN5KGFyckxpa2UsIG9mZnNldCkge1xuICAgIHZhciBhcnIgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gb2Zmc2V0IHx8IDAsIGogPSAwOyBpIDwgYXJyTGlrZS5sZW5ndGg7IGkgKz0gMSwgaiArPSAxKSB7XG4gICAgICAgIGFycltqXSA9IGFyckxpa2VbaV07XG4gICAgfVxuICAgIHJldHVybiBhcnI7XG59O1xuXG52YXIgam9pbnkgPSBmdW5jdGlvbiAoYXJyLCBqb2luZXIpIHtcbiAgICB2YXIgc3RyID0gJyc7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgc3RyICs9IGFycltpXTtcbiAgICAgICAgaWYgKGkgKyAxIDwgYXJyLmxlbmd0aCkge1xuICAgICAgICAgICAgc3RyICs9IGpvaW5lcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3RyO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBiaW5kKHRoYXQpIHtcbiAgICB2YXIgdGFyZ2V0ID0gdGhpcztcbiAgICBpZiAodHlwZW9mIHRhcmdldCAhPT0gJ2Z1bmN0aW9uJyB8fCB0b1N0ci5hcHBseSh0YXJnZXQpICE9PSBmdW5jVHlwZSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEVSUk9SX01FU1NBR0UgKyB0YXJnZXQpO1xuICAgIH1cbiAgICB2YXIgYXJncyA9IHNsaWN5KGFyZ3VtZW50cywgMSk7XG5cbiAgICB2YXIgYm91bmQ7XG4gICAgdmFyIGJpbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBib3VuZCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRhcmdldC5hcHBseShcbiAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgIGNvbmNhdHR5KGFyZ3MsIGFyZ3VtZW50cylcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAoT2JqZWN0KHJlc3VsdCkgPT09IHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFyZ2V0LmFwcGx5KFxuICAgICAgICAgICAgdGhhdCxcbiAgICAgICAgICAgIGNvbmNhdHR5KGFyZ3MsIGFyZ3VtZW50cylcbiAgICAgICAgKTtcblxuICAgIH07XG5cbiAgICB2YXIgYm91bmRMZW5ndGggPSBtYXgoMCwgdGFyZ2V0Lmxlbmd0aCAtIGFyZ3MubGVuZ3RoKTtcbiAgICB2YXIgYm91bmRBcmdzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBib3VuZExlbmd0aDsgaSsrKSB7XG4gICAgICAgIGJvdW5kQXJnc1tpXSA9ICckJyArIGk7XG4gICAgfVxuXG4gICAgYm91bmQgPSBGdW5jdGlvbignYmluZGVyJywgJ3JldHVybiBmdW5jdGlvbiAoJyArIGpvaW55KGJvdW5kQXJncywgJywnKSArICcpeyByZXR1cm4gYmluZGVyLmFwcGx5KHRoaXMsYXJndW1lbnRzKTsgfScpKGJpbmRlcik7XG5cbiAgICBpZiAodGFyZ2V0LnByb3RvdHlwZSkge1xuICAgICAgICB2YXIgRW1wdHkgPSBmdW5jdGlvbiBFbXB0eSgpIHt9O1xuICAgICAgICBFbXB0eS5wcm90b3R5cGUgPSB0YXJnZXQucHJvdG90eXBlO1xuICAgICAgICBib3VuZC5wcm90b3R5cGUgPSBuZXcgRW1wdHkoKTtcbiAgICAgICAgRW1wdHkucHJvdG90eXBlID0gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gYm91bmQ7XG59O1xuIiwgIid1c2Ugc3RyaWN0JztcblxudmFyIGltcGxlbWVudGF0aW9uID0gcmVxdWlyZSgnLi9pbXBsZW1lbnRhdGlvbicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kIHx8IGltcGxlbWVudGF0aW9uO1xuIiwgIid1c2Ugc3RyaWN0JztcblxudmFyIGNhbGwgPSBGdW5jdGlvbi5wcm90b3R5cGUuY2FsbDtcbnZhciAkaGFzT3duID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBiaW5kID0gcmVxdWlyZSgnZnVuY3Rpb24tYmluZCcpO1xuXG4vKiogQHR5cGUge2ltcG9ydCgnLicpfSAqL1xubW9kdWxlLmV4cG9ydHMgPSBiaW5kLmNhbGwoY2FsbCwgJGhhc093bik7XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdW5kZWZpbmVkO1xuXG52YXIgJEVycm9yID0gcmVxdWlyZSgnZXMtZXJyb3JzJyk7XG52YXIgJEV2YWxFcnJvciA9IHJlcXVpcmUoJ2VzLWVycm9ycy9ldmFsJyk7XG52YXIgJFJhbmdlRXJyb3IgPSByZXF1aXJlKCdlcy1lcnJvcnMvcmFuZ2UnKTtcbnZhciAkUmVmZXJlbmNlRXJyb3IgPSByZXF1aXJlKCdlcy1lcnJvcnMvcmVmJyk7XG52YXIgJFN5bnRheEVycm9yID0gcmVxdWlyZSgnZXMtZXJyb3JzL3N5bnRheCcpO1xudmFyICRUeXBlRXJyb3IgPSByZXF1aXJlKCdlcy1lcnJvcnMvdHlwZScpO1xudmFyICRVUklFcnJvciA9IHJlcXVpcmUoJ2VzLWVycm9ycy91cmknKTtcblxudmFyICRGdW5jdGlvbiA9IEZ1bmN0aW9uO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29uc2lzdGVudC1yZXR1cm5cbnZhciBnZXRFdmFsbGVkQ29uc3RydWN0b3IgPSBmdW5jdGlvbiAoZXhwcmVzc2lvblN5bnRheCkge1xuXHR0cnkge1xuXHRcdHJldHVybiAkRnVuY3Rpb24oJ1widXNlIHN0cmljdFwiOyByZXR1cm4gKCcgKyBleHByZXNzaW9uU3ludGF4ICsgJykuY29uc3RydWN0b3I7JykoKTtcblx0fSBjYXRjaCAoZSkge31cbn07XG5cbnZhciAkZ09QRCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG5pZiAoJGdPUEQpIHtcblx0dHJ5IHtcblx0XHQkZ09QRCh7fSwgJycpO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0JGdPUEQgPSBudWxsOyAvLyB0aGlzIGlzIElFIDgsIHdoaWNoIGhhcyBhIGJyb2tlbiBnT1BEXG5cdH1cbn1cblxudmFyIHRocm93VHlwZUVycm9yID0gZnVuY3Rpb24gKCkge1xuXHR0aHJvdyBuZXcgJFR5cGVFcnJvcigpO1xufTtcbnZhciBUaHJvd1R5cGVFcnJvciA9ICRnT1BEXG5cdD8gKGZ1bmN0aW9uICgpIHtcblx0XHR0cnkge1xuXHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC1leHByZXNzaW9ucywgbm8tY2FsbGVyLCBuby1yZXN0cmljdGVkLXByb3BlcnRpZXNcblx0XHRcdGFyZ3VtZW50cy5jYWxsZWU7IC8vIElFIDggZG9lcyBub3QgdGhyb3cgaGVyZVxuXHRcdFx0cmV0dXJuIHRocm93VHlwZUVycm9yO1xuXHRcdH0gY2F0Y2ggKGNhbGxlZVRocm93cykge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0Ly8gSUUgOCB0aHJvd3Mgb24gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihhcmd1bWVudHMsICcnKVxuXHRcdFx0XHRyZXR1cm4gJGdPUEQoYXJndW1lbnRzLCAnY2FsbGVlJykuZ2V0O1xuXHRcdFx0fSBjYXRjaCAoZ09QRHRocm93cykge1xuXHRcdFx0XHRyZXR1cm4gdGhyb3dUeXBlRXJyb3I7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KCkpXG5cdDogdGhyb3dUeXBlRXJyb3I7XG5cbnZhciBoYXNTeW1ib2xzID0gcmVxdWlyZSgnaGFzLXN5bWJvbHMnKSgpO1xudmFyIGhhc1Byb3RvID0gcmVxdWlyZSgnaGFzLXByb3RvJykoKTtcblxudmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mIHx8IChcblx0aGFzUHJvdG9cblx0XHQ/IGZ1bmN0aW9uICh4KSB7IHJldHVybiB4Ll9fcHJvdG9fXzsgfSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXByb3RvXG5cdFx0OiBudWxsXG4pO1xuXG52YXIgbmVlZHNFdmFsID0ge307XG5cbnZhciBUeXBlZEFycmF5ID0gdHlwZW9mIFVpbnQ4QXJyYXkgPT09ICd1bmRlZmluZWQnIHx8ICFnZXRQcm90byA/IHVuZGVmaW5lZCA6IGdldFByb3RvKFVpbnQ4QXJyYXkpO1xuXG52YXIgSU5UUklOU0lDUyA9IHtcblx0X19wcm90b19fOiBudWxsLFxuXHQnJUFnZ3JlZ2F0ZUVycm9yJSc6IHR5cGVvZiBBZ2dyZWdhdGVFcnJvciA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBBZ2dyZWdhdGVFcnJvcixcblx0JyVBcnJheSUnOiBBcnJheSxcblx0JyVBcnJheUJ1ZmZlciUnOiB0eXBlb2YgQXJyYXlCdWZmZXIgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogQXJyYXlCdWZmZXIsXG5cdCclQXJyYXlJdGVyYXRvclByb3RvdHlwZSUnOiBoYXNTeW1ib2xzICYmIGdldFByb3RvID8gZ2V0UHJvdG8oW11bU3ltYm9sLml0ZXJhdG9yXSgpKSA6IHVuZGVmaW5lZCxcblx0JyVBc3luY0Zyb21TeW5jSXRlcmF0b3JQcm90b3R5cGUlJzogdW5kZWZpbmVkLFxuXHQnJUFzeW5jRnVuY3Rpb24lJzogbmVlZHNFdmFsLFxuXHQnJUFzeW5jR2VuZXJhdG9yJSc6IG5lZWRzRXZhbCxcblx0JyVBc3luY0dlbmVyYXRvckZ1bmN0aW9uJSc6IG5lZWRzRXZhbCxcblx0JyVBc3luY0l0ZXJhdG9yUHJvdG90eXBlJSc6IG5lZWRzRXZhbCxcblx0JyVBdG9taWNzJSc6IHR5cGVvZiBBdG9taWNzID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEF0b21pY3MsXG5cdCclQmlnSW50JSc6IHR5cGVvZiBCaWdJbnQgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogQmlnSW50LFxuXHQnJUJpZ0ludDY0QXJyYXklJzogdHlwZW9mIEJpZ0ludDY0QXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogQmlnSW50NjRBcnJheSxcblx0JyVCaWdVaW50NjRBcnJheSUnOiB0eXBlb2YgQmlnVWludDY0QXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogQmlnVWludDY0QXJyYXksXG5cdCclQm9vbGVhbiUnOiBCb29sZWFuLFxuXHQnJURhdGFWaWV3JSc6IHR5cGVvZiBEYXRhVmlldyA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBEYXRhVmlldyxcblx0JyVEYXRlJSc6IERhdGUsXG5cdCclZGVjb2RlVVJJJSc6IGRlY29kZVVSSSxcblx0JyVkZWNvZGVVUklDb21wb25lbnQlJzogZGVjb2RlVVJJQ29tcG9uZW50LFxuXHQnJWVuY29kZVVSSSUnOiBlbmNvZGVVUkksXG5cdCclZW5jb2RlVVJJQ29tcG9uZW50JSc6IGVuY29kZVVSSUNvbXBvbmVudCxcblx0JyVFcnJvciUnOiAkRXJyb3IsXG5cdCclZXZhbCUnOiBldmFsLCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWV2YWxcblx0JyVFdmFsRXJyb3IlJzogJEV2YWxFcnJvcixcblx0JyVGbG9hdDMyQXJyYXklJzogdHlwZW9mIEZsb2F0MzJBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBGbG9hdDMyQXJyYXksXG5cdCclRmxvYXQ2NEFycmF5JSc6IHR5cGVvZiBGbG9hdDY0QXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogRmxvYXQ2NEFycmF5LFxuXHQnJUZpbmFsaXphdGlvblJlZ2lzdHJ5JSc6IHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBGaW5hbGl6YXRpb25SZWdpc3RyeSxcblx0JyVGdW5jdGlvbiUnOiAkRnVuY3Rpb24sXG5cdCclR2VuZXJhdG9yRnVuY3Rpb24lJzogbmVlZHNFdmFsLFxuXHQnJUludDhBcnJheSUnOiB0eXBlb2YgSW50OEFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEludDhBcnJheSxcblx0JyVJbnQxNkFycmF5JSc6IHR5cGVvZiBJbnQxNkFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEludDE2QXJyYXksXG5cdCclSW50MzJBcnJheSUnOiB0eXBlb2YgSW50MzJBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBJbnQzMkFycmF5LFxuXHQnJWlzRmluaXRlJSc6IGlzRmluaXRlLFxuXHQnJWlzTmFOJSc6IGlzTmFOLFxuXHQnJUl0ZXJhdG9yUHJvdG90eXBlJSc6IGhhc1N5bWJvbHMgJiYgZ2V0UHJvdG8gPyBnZXRQcm90byhnZXRQcm90byhbXVtTeW1ib2wuaXRlcmF0b3JdKCkpKSA6IHVuZGVmaW5lZCxcblx0JyVKU09OJSc6IHR5cGVvZiBKU09OID09PSAnb2JqZWN0JyA/IEpTT04gOiB1bmRlZmluZWQsXG5cdCclTWFwJSc6IHR5cGVvZiBNYXAgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogTWFwLFxuXHQnJU1hcEl0ZXJhdG9yUHJvdG90eXBlJSc6IHR5cGVvZiBNYXAgPT09ICd1bmRlZmluZWQnIHx8ICFoYXNTeW1ib2xzIHx8ICFnZXRQcm90byA/IHVuZGVmaW5lZCA6IGdldFByb3RvKG5ldyBNYXAoKVtTeW1ib2wuaXRlcmF0b3JdKCkpLFxuXHQnJU1hdGglJzogTWF0aCxcblx0JyVOdW1iZXIlJzogTnVtYmVyLFxuXHQnJU9iamVjdCUnOiBPYmplY3QsXG5cdCclcGFyc2VGbG9hdCUnOiBwYXJzZUZsb2F0LFxuXHQnJXBhcnNlSW50JSc6IHBhcnNlSW50LFxuXHQnJVByb21pc2UlJzogdHlwZW9mIFByb21pc2UgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogUHJvbWlzZSxcblx0JyVQcm94eSUnOiB0eXBlb2YgUHJveHkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogUHJveHksXG5cdCclUmFuZ2VFcnJvciUnOiAkUmFuZ2VFcnJvcixcblx0JyVSZWZlcmVuY2VFcnJvciUnOiAkUmVmZXJlbmNlRXJyb3IsXG5cdCclUmVmbGVjdCUnOiB0eXBlb2YgUmVmbGVjdCA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBSZWZsZWN0LFxuXHQnJVJlZ0V4cCUnOiBSZWdFeHAsXG5cdCclU2V0JSc6IHR5cGVvZiBTZXQgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogU2V0LFxuXHQnJVNldEl0ZXJhdG9yUHJvdG90eXBlJSc6IHR5cGVvZiBTZXQgPT09ICd1bmRlZmluZWQnIHx8ICFoYXNTeW1ib2xzIHx8ICFnZXRQcm90byA/IHVuZGVmaW5lZCA6IGdldFByb3RvKG5ldyBTZXQoKVtTeW1ib2wuaXRlcmF0b3JdKCkpLFxuXHQnJVNoYXJlZEFycmF5QnVmZmVyJSc6IHR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlciA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBTaGFyZWRBcnJheUJ1ZmZlcixcblx0JyVTdHJpbmclJzogU3RyaW5nLFxuXHQnJVN0cmluZ0l0ZXJhdG9yUHJvdG90eXBlJSc6IGhhc1N5bWJvbHMgJiYgZ2V0UHJvdG8gPyBnZXRQcm90bygnJ1tTeW1ib2wuaXRlcmF0b3JdKCkpIDogdW5kZWZpbmVkLFxuXHQnJVN5bWJvbCUnOiBoYXNTeW1ib2xzID8gU3ltYm9sIDogdW5kZWZpbmVkLFxuXHQnJVN5bnRheEVycm9yJSc6ICRTeW50YXhFcnJvcixcblx0JyVUaHJvd1R5cGVFcnJvciUnOiBUaHJvd1R5cGVFcnJvcixcblx0JyVUeXBlZEFycmF5JSc6IFR5cGVkQXJyYXksXG5cdCclVHlwZUVycm9yJSc6ICRUeXBlRXJyb3IsXG5cdCclVWludDhBcnJheSUnOiB0eXBlb2YgVWludDhBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBVaW50OEFycmF5LFxuXHQnJVVpbnQ4Q2xhbXBlZEFycmF5JSc6IHR5cGVvZiBVaW50OENsYW1wZWRBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBVaW50OENsYW1wZWRBcnJheSxcblx0JyVVaW50MTZBcnJheSUnOiB0eXBlb2YgVWludDE2QXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogVWludDE2QXJyYXksXG5cdCclVWludDMyQXJyYXklJzogdHlwZW9mIFVpbnQzMkFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFVpbnQzMkFycmF5LFxuXHQnJVVSSUVycm9yJSc6ICRVUklFcnJvcixcblx0JyVXZWFrTWFwJSc6IHR5cGVvZiBXZWFrTWFwID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFdlYWtNYXAsXG5cdCclV2Vha1JlZiUnOiB0eXBlb2YgV2Vha1JlZiA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBXZWFrUmVmLFxuXHQnJVdlYWtTZXQlJzogdHlwZW9mIFdlYWtTZXQgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogV2Vha1NldFxufTtcblxuaWYgKGdldFByb3RvKSB7XG5cdHRyeSB7XG5cdFx0bnVsbC5lcnJvcjsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtZXhwcmVzc2lvbnNcblx0fSBjYXRjaCAoZSkge1xuXHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLXNoYWRvd3JlYWxtL3B1bGwvMzg0I2lzc3VlY29tbWVudC0xMzY0MjY0MjI5XG5cdFx0dmFyIGVycm9yUHJvdG8gPSBnZXRQcm90byhnZXRQcm90byhlKSk7XG5cdFx0SU5UUklOU0lDU1snJUVycm9yLnByb3RvdHlwZSUnXSA9IGVycm9yUHJvdG87XG5cdH1cbn1cblxudmFyIGRvRXZhbCA9IGZ1bmN0aW9uIGRvRXZhbChuYW1lKSB7XG5cdHZhciB2YWx1ZTtcblx0aWYgKG5hbWUgPT09ICclQXN5bmNGdW5jdGlvbiUnKSB7XG5cdFx0dmFsdWUgPSBnZXRFdmFsbGVkQ29uc3RydWN0b3IoJ2FzeW5jIGZ1bmN0aW9uICgpIHt9Jyk7XG5cdH0gZWxzZSBpZiAobmFtZSA9PT0gJyVHZW5lcmF0b3JGdW5jdGlvbiUnKSB7XG5cdFx0dmFsdWUgPSBnZXRFdmFsbGVkQ29uc3RydWN0b3IoJ2Z1bmN0aW9uKiAoKSB7fScpO1xuXHR9IGVsc2UgaWYgKG5hbWUgPT09ICclQXN5bmNHZW5lcmF0b3JGdW5jdGlvbiUnKSB7XG5cdFx0dmFsdWUgPSBnZXRFdmFsbGVkQ29uc3RydWN0b3IoJ2FzeW5jIGZ1bmN0aW9uKiAoKSB7fScpO1xuXHR9IGVsc2UgaWYgKG5hbWUgPT09ICclQXN5bmNHZW5lcmF0b3IlJykge1xuXHRcdHZhciBmbiA9IGRvRXZhbCgnJUFzeW5jR2VuZXJhdG9yRnVuY3Rpb24lJyk7XG5cdFx0aWYgKGZuKSB7XG5cdFx0XHR2YWx1ZSA9IGZuLnByb3RvdHlwZTtcblx0XHR9XG5cdH0gZWxzZSBpZiAobmFtZSA9PT0gJyVBc3luY0l0ZXJhdG9yUHJvdG90eXBlJScpIHtcblx0XHR2YXIgZ2VuID0gZG9FdmFsKCclQXN5bmNHZW5lcmF0b3IlJyk7XG5cdFx0aWYgKGdlbiAmJiBnZXRQcm90bykge1xuXHRcdFx0dmFsdWUgPSBnZXRQcm90byhnZW4ucHJvdG90eXBlKTtcblx0XHR9XG5cdH1cblxuXHRJTlRSSU5TSUNTW25hbWVdID0gdmFsdWU7XG5cblx0cmV0dXJuIHZhbHVlO1xufTtcblxudmFyIExFR0FDWV9BTElBU0VTID0ge1xuXHRfX3Byb3RvX186IG51bGwsXG5cdCclQXJyYXlCdWZmZXJQcm90b3R5cGUlJzogWydBcnJheUJ1ZmZlcicsICdwcm90b3R5cGUnXSxcblx0JyVBcnJheVByb3RvdHlwZSUnOiBbJ0FycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJUFycmF5UHJvdG9fZW50cmllcyUnOiBbJ0FycmF5JywgJ3Byb3RvdHlwZScsICdlbnRyaWVzJ10sXG5cdCclQXJyYXlQcm90b19mb3JFYWNoJSc6IFsnQXJyYXknLCAncHJvdG90eXBlJywgJ2ZvckVhY2gnXSxcblx0JyVBcnJheVByb3RvX2tleXMlJzogWydBcnJheScsICdwcm90b3R5cGUnLCAna2V5cyddLFxuXHQnJUFycmF5UHJvdG9fdmFsdWVzJSc6IFsnQXJyYXknLCAncHJvdG90eXBlJywgJ3ZhbHVlcyddLFxuXHQnJUFzeW5jRnVuY3Rpb25Qcm90b3R5cGUlJzogWydBc3luY0Z1bmN0aW9uJywgJ3Byb3RvdHlwZSddLFxuXHQnJUFzeW5jR2VuZXJhdG9yJSc6IFsnQXN5bmNHZW5lcmF0b3JGdW5jdGlvbicsICdwcm90b3R5cGUnXSxcblx0JyVBc3luY0dlbmVyYXRvclByb3RvdHlwZSUnOiBbJ0FzeW5jR2VuZXJhdG9yRnVuY3Rpb24nLCAncHJvdG90eXBlJywgJ3Byb3RvdHlwZSddLFxuXHQnJUJvb2xlYW5Qcm90b3R5cGUlJzogWydCb29sZWFuJywgJ3Byb3RvdHlwZSddLFxuXHQnJURhdGFWaWV3UHJvdG90eXBlJSc6IFsnRGF0YVZpZXcnLCAncHJvdG90eXBlJ10sXG5cdCclRGF0ZVByb3RvdHlwZSUnOiBbJ0RhdGUnLCAncHJvdG90eXBlJ10sXG5cdCclRXJyb3JQcm90b3R5cGUlJzogWydFcnJvcicsICdwcm90b3R5cGUnXSxcblx0JyVFdmFsRXJyb3JQcm90b3R5cGUlJzogWydFdmFsRXJyb3InLCAncHJvdG90eXBlJ10sXG5cdCclRmxvYXQzMkFycmF5UHJvdG90eXBlJSc6IFsnRmxvYXQzMkFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJUZsb2F0NjRBcnJheVByb3RvdHlwZSUnOiBbJ0Zsb2F0NjRBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVGdW5jdGlvblByb3RvdHlwZSUnOiBbJ0Z1bmN0aW9uJywgJ3Byb3RvdHlwZSddLFxuXHQnJUdlbmVyYXRvciUnOiBbJ0dlbmVyYXRvckZ1bmN0aW9uJywgJ3Byb3RvdHlwZSddLFxuXHQnJUdlbmVyYXRvclByb3RvdHlwZSUnOiBbJ0dlbmVyYXRvckZ1bmN0aW9uJywgJ3Byb3RvdHlwZScsICdwcm90b3R5cGUnXSxcblx0JyVJbnQ4QXJyYXlQcm90b3R5cGUlJzogWydJbnQ4QXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclSW50MTZBcnJheVByb3RvdHlwZSUnOiBbJ0ludDE2QXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclSW50MzJBcnJheVByb3RvdHlwZSUnOiBbJ0ludDMyQXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclSlNPTlBhcnNlJSc6IFsnSlNPTicsICdwYXJzZSddLFxuXHQnJUpTT05TdHJpbmdpZnklJzogWydKU09OJywgJ3N0cmluZ2lmeSddLFxuXHQnJU1hcFByb3RvdHlwZSUnOiBbJ01hcCcsICdwcm90b3R5cGUnXSxcblx0JyVOdW1iZXJQcm90b3R5cGUlJzogWydOdW1iZXInLCAncHJvdG90eXBlJ10sXG5cdCclT2JqZWN0UHJvdG90eXBlJSc6IFsnT2JqZWN0JywgJ3Byb3RvdHlwZSddLFxuXHQnJU9ialByb3RvX3RvU3RyaW5nJSc6IFsnT2JqZWN0JywgJ3Byb3RvdHlwZScsICd0b1N0cmluZyddLFxuXHQnJU9ialByb3RvX3ZhbHVlT2YlJzogWydPYmplY3QnLCAncHJvdG90eXBlJywgJ3ZhbHVlT2YnXSxcblx0JyVQcm9taXNlUHJvdG90eXBlJSc6IFsnUHJvbWlzZScsICdwcm90b3R5cGUnXSxcblx0JyVQcm9taXNlUHJvdG9fdGhlbiUnOiBbJ1Byb21pc2UnLCAncHJvdG90eXBlJywgJ3RoZW4nXSxcblx0JyVQcm9taXNlX2FsbCUnOiBbJ1Byb21pc2UnLCAnYWxsJ10sXG5cdCclUHJvbWlzZV9yZWplY3QlJzogWydQcm9taXNlJywgJ3JlamVjdCddLFxuXHQnJVByb21pc2VfcmVzb2x2ZSUnOiBbJ1Byb21pc2UnLCAncmVzb2x2ZSddLFxuXHQnJVJhbmdlRXJyb3JQcm90b3R5cGUlJzogWydSYW5nZUVycm9yJywgJ3Byb3RvdHlwZSddLFxuXHQnJVJlZmVyZW5jZUVycm9yUHJvdG90eXBlJSc6IFsnUmVmZXJlbmNlRXJyb3InLCAncHJvdG90eXBlJ10sXG5cdCclUmVnRXhwUHJvdG90eXBlJSc6IFsnUmVnRXhwJywgJ3Byb3RvdHlwZSddLFxuXHQnJVNldFByb3RvdHlwZSUnOiBbJ1NldCcsICdwcm90b3R5cGUnXSxcblx0JyVTaGFyZWRBcnJheUJ1ZmZlclByb3RvdHlwZSUnOiBbJ1NoYXJlZEFycmF5QnVmZmVyJywgJ3Byb3RvdHlwZSddLFxuXHQnJVN0cmluZ1Byb3RvdHlwZSUnOiBbJ1N0cmluZycsICdwcm90b3R5cGUnXSxcblx0JyVTeW1ib2xQcm90b3R5cGUlJzogWydTeW1ib2wnLCAncHJvdG90eXBlJ10sXG5cdCclU3ludGF4RXJyb3JQcm90b3R5cGUlJzogWydTeW50YXhFcnJvcicsICdwcm90b3R5cGUnXSxcblx0JyVUeXBlZEFycmF5UHJvdG90eXBlJSc6IFsnVHlwZWRBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVUeXBlRXJyb3JQcm90b3R5cGUlJzogWydUeXBlRXJyb3InLCAncHJvdG90eXBlJ10sXG5cdCclVWludDhBcnJheVByb3RvdHlwZSUnOiBbJ1VpbnQ4QXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclVWludDhDbGFtcGVkQXJyYXlQcm90b3R5cGUlJzogWydVaW50OENsYW1wZWRBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVVaW50MTZBcnJheVByb3RvdHlwZSUnOiBbJ1VpbnQxNkFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJVVpbnQzMkFycmF5UHJvdG90eXBlJSc6IFsnVWludDMyQXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclVVJJRXJyb3JQcm90b3R5cGUlJzogWydVUklFcnJvcicsICdwcm90b3R5cGUnXSxcblx0JyVXZWFrTWFwUHJvdG90eXBlJSc6IFsnV2Vha01hcCcsICdwcm90b3R5cGUnXSxcblx0JyVXZWFrU2V0UHJvdG90eXBlJSc6IFsnV2Vha1NldCcsICdwcm90b3R5cGUnXVxufTtcblxudmFyIGJpbmQgPSByZXF1aXJlKCdmdW5jdGlvbi1iaW5kJyk7XG52YXIgaGFzT3duID0gcmVxdWlyZSgnaGFzb3duJyk7XG52YXIgJGNvbmNhdCA9IGJpbmQuY2FsbChGdW5jdGlvbi5jYWxsLCBBcnJheS5wcm90b3R5cGUuY29uY2F0KTtcbnZhciAkc3BsaWNlQXBwbHkgPSBiaW5kLmNhbGwoRnVuY3Rpb24uYXBwbHksIEFycmF5LnByb3RvdHlwZS5zcGxpY2UpO1xudmFyICRyZXBsYWNlID0gYmluZC5jYWxsKEZ1bmN0aW9uLmNhbGwsIFN0cmluZy5wcm90b3R5cGUucmVwbGFjZSk7XG52YXIgJHN0clNsaWNlID0gYmluZC5jYWxsKEZ1bmN0aW9uLmNhbGwsIFN0cmluZy5wcm90b3R5cGUuc2xpY2UpO1xudmFyICRleGVjID0gYmluZC5jYWxsKEZ1bmN0aW9uLmNhbGwsIFJlZ0V4cC5wcm90b3R5cGUuZXhlYyk7XG5cbi8qIGFkYXB0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vbG9kYXNoL2xvZGFzaC9ibG9iLzQuMTcuMTUvZGlzdC9sb2Rhc2guanMjTDY3MzUtTDY3NDQgKi9cbnZhciByZVByb3BOYW1lID0gL1teJS5bXFxdXSt8XFxbKD86KC0/XFxkKyg/OlxcLlxcZCspPyl8KFtcIiddKSgoPzooPyFcXDIpW15cXFxcXXxcXFxcLikqPylcXDIpXFxdfCg/PSg/OlxcLnxcXFtcXF0pKD86XFwufFxcW1xcXXwlJCkpL2c7XG52YXIgcmVFc2NhcGVDaGFyID0gL1xcXFwoXFxcXCk/L2c7IC8qKiBVc2VkIHRvIG1hdGNoIGJhY2tzbGFzaGVzIGluIHByb3BlcnR5IHBhdGhzLiAqL1xudmFyIHN0cmluZ1RvUGF0aCA9IGZ1bmN0aW9uIHN0cmluZ1RvUGF0aChzdHJpbmcpIHtcblx0dmFyIGZpcnN0ID0gJHN0clNsaWNlKHN0cmluZywgMCwgMSk7XG5cdHZhciBsYXN0ID0gJHN0clNsaWNlKHN0cmluZywgLTEpO1xuXHRpZiAoZmlyc3QgPT09ICclJyAmJiBsYXN0ICE9PSAnJScpIHtcblx0XHR0aHJvdyBuZXcgJFN5bnRheEVycm9yKCdpbnZhbGlkIGludHJpbnNpYyBzeW50YXgsIGV4cGVjdGVkIGNsb3NpbmcgYCVgJyk7XG5cdH0gZWxzZSBpZiAobGFzdCA9PT0gJyUnICYmIGZpcnN0ICE9PSAnJScpIHtcblx0XHR0aHJvdyBuZXcgJFN5bnRheEVycm9yKCdpbnZhbGlkIGludHJpbnNpYyBzeW50YXgsIGV4cGVjdGVkIG9wZW5pbmcgYCVgJyk7XG5cdH1cblx0dmFyIHJlc3VsdCA9IFtdO1xuXHQkcmVwbGFjZShzdHJpbmcsIHJlUHJvcE5hbWUsIGZ1bmN0aW9uIChtYXRjaCwgbnVtYmVyLCBxdW90ZSwgc3ViU3RyaW5nKSB7XG5cdFx0cmVzdWx0W3Jlc3VsdC5sZW5ndGhdID0gcXVvdGUgPyAkcmVwbGFjZShzdWJTdHJpbmcsIHJlRXNjYXBlQ2hhciwgJyQxJykgOiBudW1iZXIgfHwgbWF0Y2g7XG5cdH0pO1xuXHRyZXR1cm4gcmVzdWx0O1xufTtcbi8qIGVuZCBhZGFwdGF0aW9uICovXG5cbnZhciBnZXRCYXNlSW50cmluc2ljID0gZnVuY3Rpb24gZ2V0QmFzZUludHJpbnNpYyhuYW1lLCBhbGxvd01pc3NpbmcpIHtcblx0dmFyIGludHJpbnNpY05hbWUgPSBuYW1lO1xuXHR2YXIgYWxpYXM7XG5cdGlmIChoYXNPd24oTEVHQUNZX0FMSUFTRVMsIGludHJpbnNpY05hbWUpKSB7XG5cdFx0YWxpYXMgPSBMRUdBQ1lfQUxJQVNFU1tpbnRyaW5zaWNOYW1lXTtcblx0XHRpbnRyaW5zaWNOYW1lID0gJyUnICsgYWxpYXNbMF0gKyAnJSc7XG5cdH1cblxuXHRpZiAoaGFzT3duKElOVFJJTlNJQ1MsIGludHJpbnNpY05hbWUpKSB7XG5cdFx0dmFyIHZhbHVlID0gSU5UUklOU0lDU1tpbnRyaW5zaWNOYW1lXTtcblx0XHRpZiAodmFsdWUgPT09IG5lZWRzRXZhbCkge1xuXHRcdFx0dmFsdWUgPSBkb0V2YWwoaW50cmluc2ljTmFtZSk7XG5cdFx0fVxuXHRcdGlmICh0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnICYmICFhbGxvd01pc3NpbmcpIHtcblx0XHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdpbnRyaW5zaWMgJyArIG5hbWUgKyAnIGV4aXN0cywgYnV0IGlzIG5vdCBhdmFpbGFibGUuIFBsZWFzZSBmaWxlIGFuIGlzc3VlIScpO1xuXHRcdH1cblxuXHRcdHJldHVybiB7XG5cdFx0XHRhbGlhczogYWxpYXMsXG5cdFx0XHRuYW1lOiBpbnRyaW5zaWNOYW1lLFxuXHRcdFx0dmFsdWU6IHZhbHVlXG5cdFx0fTtcblx0fVxuXG5cdHRocm93IG5ldyAkU3ludGF4RXJyb3IoJ2ludHJpbnNpYyAnICsgbmFtZSArICcgZG9lcyBub3QgZXhpc3QhJyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIEdldEludHJpbnNpYyhuYW1lLCBhbGxvd01pc3NpbmcpIHtcblx0aWYgKHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJyB8fCBuYW1lLmxlbmd0aCA9PT0gMCkge1xuXHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdpbnRyaW5zaWMgbmFtZSBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZycpO1xuXHR9XG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSAmJiB0eXBlb2YgYWxsb3dNaXNzaW5nICE9PSAnYm9vbGVhbicpIHtcblx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignXCJhbGxvd01pc3NpbmdcIiBhcmd1bWVudCBtdXN0IGJlIGEgYm9vbGVhbicpO1xuXHR9XG5cblx0aWYgKCRleGVjKC9eJT9bXiVdKiU/JC8sIG5hbWUpID09PSBudWxsKSB7XG5cdFx0dGhyb3cgbmV3ICRTeW50YXhFcnJvcignYCVgIG1heSBub3QgYmUgcHJlc2VudCBhbnl3aGVyZSBidXQgYXQgdGhlIGJlZ2lubmluZyBhbmQgZW5kIG9mIHRoZSBpbnRyaW5zaWMgbmFtZScpO1xuXHR9XG5cdHZhciBwYXJ0cyA9IHN0cmluZ1RvUGF0aChuYW1lKTtcblx0dmFyIGludHJpbnNpY0Jhc2VOYW1lID0gcGFydHMubGVuZ3RoID4gMCA/IHBhcnRzWzBdIDogJyc7XG5cblx0dmFyIGludHJpbnNpYyA9IGdldEJhc2VJbnRyaW5zaWMoJyUnICsgaW50cmluc2ljQmFzZU5hbWUgKyAnJScsIGFsbG93TWlzc2luZyk7XG5cdHZhciBpbnRyaW5zaWNSZWFsTmFtZSA9IGludHJpbnNpYy5uYW1lO1xuXHR2YXIgdmFsdWUgPSBpbnRyaW5zaWMudmFsdWU7XG5cdHZhciBza2lwRnVydGhlckNhY2hpbmcgPSBmYWxzZTtcblxuXHR2YXIgYWxpYXMgPSBpbnRyaW5zaWMuYWxpYXM7XG5cdGlmIChhbGlhcykge1xuXHRcdGludHJpbnNpY0Jhc2VOYW1lID0gYWxpYXNbMF07XG5cdFx0JHNwbGljZUFwcGx5KHBhcnRzLCAkY29uY2F0KFswLCAxXSwgYWxpYXMpKTtcblx0fVxuXG5cdGZvciAodmFyIGkgPSAxLCBpc093biA9IHRydWU7IGkgPCBwYXJ0cy5sZW5ndGg7IGkgKz0gMSkge1xuXHRcdHZhciBwYXJ0ID0gcGFydHNbaV07XG5cdFx0dmFyIGZpcnN0ID0gJHN0clNsaWNlKHBhcnQsIDAsIDEpO1xuXHRcdHZhciBsYXN0ID0gJHN0clNsaWNlKHBhcnQsIC0xKTtcblx0XHRpZiAoXG5cdFx0XHQoXG5cdFx0XHRcdChmaXJzdCA9PT0gJ1wiJyB8fCBmaXJzdCA9PT0gXCInXCIgfHwgZmlyc3QgPT09ICdgJylcblx0XHRcdFx0fHwgKGxhc3QgPT09ICdcIicgfHwgbGFzdCA9PT0gXCInXCIgfHwgbGFzdCA9PT0gJ2AnKVxuXHRcdFx0KVxuXHRcdFx0JiYgZmlyc3QgIT09IGxhc3Rcblx0XHQpIHtcblx0XHRcdHRocm93IG5ldyAkU3ludGF4RXJyb3IoJ3Byb3BlcnR5IG5hbWVzIHdpdGggcXVvdGVzIG11c3QgaGF2ZSBtYXRjaGluZyBxdW90ZXMnKTtcblx0XHR9XG5cdFx0aWYgKHBhcnQgPT09ICdjb25zdHJ1Y3RvcicgfHwgIWlzT3duKSB7XG5cdFx0XHRza2lwRnVydGhlckNhY2hpbmcgPSB0cnVlO1xuXHRcdH1cblxuXHRcdGludHJpbnNpY0Jhc2VOYW1lICs9ICcuJyArIHBhcnQ7XG5cdFx0aW50cmluc2ljUmVhbE5hbWUgPSAnJScgKyBpbnRyaW5zaWNCYXNlTmFtZSArICclJztcblxuXHRcdGlmIChoYXNPd24oSU5UUklOU0lDUywgaW50cmluc2ljUmVhbE5hbWUpKSB7XG5cdFx0XHR2YWx1ZSA9IElOVFJJTlNJQ1NbaW50cmluc2ljUmVhbE5hbWVdO1xuXHRcdH0gZWxzZSBpZiAodmFsdWUgIT0gbnVsbCkge1xuXHRcdFx0aWYgKCEocGFydCBpbiB2YWx1ZSkpIHtcblx0XHRcdFx0aWYgKCFhbGxvd01pc3NpbmcpIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignYmFzZSBpbnRyaW5zaWMgZm9yICcgKyBuYW1lICsgJyBleGlzdHMsIGJ1dCB0aGUgcHJvcGVydHkgaXMgbm90IGF2YWlsYWJsZS4nKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdm9pZCB1bmRlZmluZWQ7XG5cdFx0XHR9XG5cdFx0XHRpZiAoJGdPUEQgJiYgKGkgKyAxKSA+PSBwYXJ0cy5sZW5ndGgpIHtcblx0XHRcdFx0dmFyIGRlc2MgPSAkZ09QRCh2YWx1ZSwgcGFydCk7XG5cdFx0XHRcdGlzT3duID0gISFkZXNjO1xuXG5cdFx0XHRcdC8vIEJ5IGNvbnZlbnRpb24sIHdoZW4gYSBkYXRhIHByb3BlcnR5IGlzIGNvbnZlcnRlZCB0byBhbiBhY2Nlc3NvclxuXHRcdFx0XHQvLyBwcm9wZXJ0eSB0byBlbXVsYXRlIGEgZGF0YSBwcm9wZXJ0eSB0aGF0IGRvZXMgbm90IHN1ZmZlciBmcm9tXG5cdFx0XHRcdC8vIHRoZSBvdmVycmlkZSBtaXN0YWtlLCB0aGF0IGFjY2Vzc29yJ3MgZ2V0dGVyIGlzIG1hcmtlZCB3aXRoXG5cdFx0XHRcdC8vIGFuIGBvcmlnaW5hbFZhbHVlYCBwcm9wZXJ0eS4gSGVyZSwgd2hlbiB3ZSBkZXRlY3QgdGhpcywgd2Vcblx0XHRcdFx0Ly8gdXBob2xkIHRoZSBpbGx1c2lvbiBieSBwcmV0ZW5kaW5nIHRvIHNlZSB0aGF0IG9yaWdpbmFsIGRhdGFcblx0XHRcdFx0Ly8gcHJvcGVydHksIGkuZS4sIHJldHVybmluZyB0aGUgdmFsdWUgcmF0aGVyIHRoYW4gdGhlIGdldHRlclxuXHRcdFx0XHQvLyBpdHNlbGYuXG5cdFx0XHRcdGlmIChpc093biAmJiAnZ2V0JyBpbiBkZXNjICYmICEoJ29yaWdpbmFsVmFsdWUnIGluIGRlc2MuZ2V0KSkge1xuXHRcdFx0XHRcdHZhbHVlID0gZGVzYy5nZXQ7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dmFsdWUgPSB2YWx1ZVtwYXJ0XTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aXNPd24gPSBoYXNPd24odmFsdWUsIHBhcnQpO1xuXHRcdFx0XHR2YWx1ZSA9IHZhbHVlW3BhcnRdO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoaXNPd24gJiYgIXNraXBGdXJ0aGVyQ2FjaGluZykge1xuXHRcdFx0XHRJTlRSSU5TSUNTW2ludHJpbnNpY1JlYWxOYW1lXSA9IHZhbHVlO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRyZXR1cm4gdmFsdWU7XG59O1xuIiwgIid1c2Ugc3RyaWN0JztcblxudmFyIEdldEludHJpbnNpYyA9IHJlcXVpcmUoJ2dldC1pbnRyaW5zaWMnKTtcblxuLyoqIEB0eXBlIHtpbXBvcnQoJy4nKX0gKi9cbnZhciAkZGVmaW5lUHJvcGVydHkgPSBHZXRJbnRyaW5zaWMoJyVPYmplY3QuZGVmaW5lUHJvcGVydHklJywgdHJ1ZSkgfHwgZmFsc2U7XG5pZiAoJGRlZmluZVByb3BlcnR5KSB7XG5cdHRyeSB7XG5cdFx0JGRlZmluZVByb3BlcnR5KHt9LCAnYScsIHsgdmFsdWU6IDEgfSk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHQvLyBJRSA4IGhhcyBhIGJyb2tlbiBkZWZpbmVQcm9wZXJ0eVxuXHRcdCRkZWZpbmVQcm9wZXJ0eSA9IGZhbHNlO1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gJGRlZmluZVByb3BlcnR5O1xuIiwgIid1c2Ugc3RyaWN0JztcblxudmFyIEdldEludHJpbnNpYyA9IHJlcXVpcmUoJ2dldC1pbnRyaW5zaWMnKTtcblxudmFyICRnT1BEID0gR2V0SW50cmluc2ljKCclT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciUnLCB0cnVlKTtcblxuaWYgKCRnT1BEKSB7XG5cdHRyeSB7XG5cdFx0JGdPUEQoW10sICdsZW5ndGgnKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdC8vIElFIDggaGFzIGEgYnJva2VuIGdPUERcblx0XHQkZ09QRCA9IG51bGw7XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSAkZ09QRDtcbiIsICIndXNlIHN0cmljdCc7XG5cbnZhciAkZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCdlcy1kZWZpbmUtcHJvcGVydHknKTtcblxudmFyICRTeW50YXhFcnJvciA9IHJlcXVpcmUoJ2VzLWVycm9ycy9zeW50YXgnKTtcbnZhciAkVHlwZUVycm9yID0gcmVxdWlyZSgnZXMtZXJyb3JzL3R5cGUnKTtcblxudmFyIGdvcGQgPSByZXF1aXJlKCdnb3BkJyk7XG5cbi8qKiBAdHlwZSB7aW1wb3J0KCcuJyl9ICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGRlZmluZURhdGFQcm9wZXJ0eShcblx0b2JqLFxuXHRwcm9wZXJ0eSxcblx0dmFsdWVcbikge1xuXHRpZiAoIW9iaiB8fCAodHlwZW9mIG9iaiAhPT0gJ29iamVjdCcgJiYgdHlwZW9mIG9iaiAhPT0gJ2Z1bmN0aW9uJykpIHtcblx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignYG9iamAgbXVzdCBiZSBhbiBvYmplY3Qgb3IgYSBmdW5jdGlvbmAnKTtcblx0fVxuXHRpZiAodHlwZW9mIHByb3BlcnR5ICE9PSAnc3RyaW5nJyAmJiB0eXBlb2YgcHJvcGVydHkgIT09ICdzeW1ib2wnKSB7XG5cdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ2Bwcm9wZXJ0eWAgbXVzdCBiZSBhIHN0cmluZyBvciBhIHN5bWJvbGAnKTtcblx0fVxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgdHlwZW9mIGFyZ3VtZW50c1szXSAhPT0gJ2Jvb2xlYW4nICYmIGFyZ3VtZW50c1szXSAhPT0gbnVsbCkge1xuXHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdgbm9uRW51bWVyYWJsZWAsIGlmIHByb3ZpZGVkLCBtdXN0IGJlIGEgYm9vbGVhbiBvciBudWxsJyk7XG5cdH1cblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIHR5cGVvZiBhcmd1bWVudHNbNF0gIT09ICdib29sZWFuJyAmJiBhcmd1bWVudHNbNF0gIT09IG51bGwpIHtcblx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignYG5vbldyaXRhYmxlYCwgaWYgcHJvdmlkZWQsIG11c3QgYmUgYSBib29sZWFuIG9yIG51bGwnKTtcblx0fVxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDUgJiYgdHlwZW9mIGFyZ3VtZW50c1s1XSAhPT0gJ2Jvb2xlYW4nICYmIGFyZ3VtZW50c1s1XSAhPT0gbnVsbCkge1xuXHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdgbm9uQ29uZmlndXJhYmxlYCwgaWYgcHJvdmlkZWQsIG11c3QgYmUgYSBib29sZWFuIG9yIG51bGwnKTtcblx0fVxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDYgJiYgdHlwZW9mIGFyZ3VtZW50c1s2XSAhPT0gJ2Jvb2xlYW4nKSB7XG5cdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ2Bsb29zZWAsIGlmIHByb3ZpZGVkLCBtdXN0IGJlIGEgYm9vbGVhbicpO1xuXHR9XG5cblx0dmFyIG5vbkVudW1lcmFibGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMyA/IGFyZ3VtZW50c1szXSA6IG51bGw7XG5cdHZhciBub25Xcml0YWJsZSA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ID8gYXJndW1lbnRzWzRdIDogbnVsbDtcblx0dmFyIG5vbkNvbmZpZ3VyYWJsZSA9IGFyZ3VtZW50cy5sZW5ndGggPiA1ID8gYXJndW1lbnRzWzVdIDogbnVsbDtcblx0dmFyIGxvb3NlID0gYXJndW1lbnRzLmxlbmd0aCA+IDYgPyBhcmd1bWVudHNbNl0gOiBmYWxzZTtcblxuXHQvKiBAdHlwZSB7ZmFsc2UgfCBUeXBlZFByb3BlcnR5RGVzY3JpcHRvcjx1bmtub3duPn0gKi9cblx0dmFyIGRlc2MgPSAhIWdvcGQgJiYgZ29wZChvYmosIHByb3BlcnR5KTtcblxuXHRpZiAoJGRlZmluZVByb3BlcnR5KSB7XG5cdFx0JGRlZmluZVByb3BlcnR5KG9iaiwgcHJvcGVydHksIHtcblx0XHRcdGNvbmZpZ3VyYWJsZTogbm9uQ29uZmlndXJhYmxlID09PSBudWxsICYmIGRlc2MgPyBkZXNjLmNvbmZpZ3VyYWJsZSA6ICFub25Db25maWd1cmFibGUsXG5cdFx0XHRlbnVtZXJhYmxlOiBub25FbnVtZXJhYmxlID09PSBudWxsICYmIGRlc2MgPyBkZXNjLmVudW1lcmFibGUgOiAhbm9uRW51bWVyYWJsZSxcblx0XHRcdHZhbHVlOiB2YWx1ZSxcblx0XHRcdHdyaXRhYmxlOiBub25Xcml0YWJsZSA9PT0gbnVsbCAmJiBkZXNjID8gZGVzYy53cml0YWJsZSA6ICFub25Xcml0YWJsZVxuXHRcdH0pO1xuXHR9IGVsc2UgaWYgKGxvb3NlIHx8ICghbm9uRW51bWVyYWJsZSAmJiAhbm9uV3JpdGFibGUgJiYgIW5vbkNvbmZpZ3VyYWJsZSkpIHtcblx0XHQvLyBtdXN0IGZhbGwgYmFjayB0byBbW1NldF1dLCBhbmQgd2FzIG5vdCBleHBsaWNpdGx5IGFza2VkIHRvIG1ha2Ugbm9uLWVudW1lcmFibGUsIG5vbi13cml0YWJsZSwgb3Igbm9uLWNvbmZpZ3VyYWJsZVxuXHRcdG9ialtwcm9wZXJ0eV0gPSB2YWx1ZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyAkU3ludGF4RXJyb3IoJ1RoaXMgZW52aXJvbm1lbnQgZG9lcyBub3Qgc3VwcG9ydCBkZWZpbmluZyBhIHByb3BlcnR5IGFzIG5vbi1jb25maWd1cmFibGUsIG5vbi13cml0YWJsZSwgb3Igbm9uLWVudW1lcmFibGUuJyk7XG5cdH1cbn07XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG52YXIgJGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnZXMtZGVmaW5lLXByb3BlcnR5Jyk7XG5cbnZhciBoYXNQcm9wZXJ0eURlc2NyaXB0b3JzID0gZnVuY3Rpb24gaGFzUHJvcGVydHlEZXNjcmlwdG9ycygpIHtcblx0cmV0dXJuICEhJGRlZmluZVByb3BlcnR5O1xufTtcblxuaGFzUHJvcGVydHlEZXNjcmlwdG9ycy5oYXNBcnJheUxlbmd0aERlZmluZUJ1ZyA9IGZ1bmN0aW9uIGhhc0FycmF5TGVuZ3RoRGVmaW5lQnVnKCkge1xuXHQvLyBub2RlIHYwLjYgaGFzIGEgYnVnIHdoZXJlIGFycmF5IGxlbmd0aHMgY2FuIGJlIFNldCBidXQgbm90IERlZmluZWRcblx0aWYgKCEkZGVmaW5lUHJvcGVydHkpIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXHR0cnkge1xuXHRcdHJldHVybiAkZGVmaW5lUHJvcGVydHkoW10sICdsZW5ndGgnLCB7IHZhbHVlOiAxIH0pLmxlbmd0aCAhPT0gMTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdC8vIEluIEZpcmVmb3ggNC0yMiwgZGVmaW5pbmcgbGVuZ3RoIG9uIGFuIGFycmF5IHRocm93cyBhbiBleGNlcHRpb24uXG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzUHJvcGVydHlEZXNjcmlwdG9ycztcbiIsICIndXNlIHN0cmljdCc7XG5cbnZhciBHZXRJbnRyaW5zaWMgPSByZXF1aXJlKCdnZXQtaW50cmluc2ljJyk7XG52YXIgZGVmaW5lID0gcmVxdWlyZSgnZGVmaW5lLWRhdGEtcHJvcGVydHknKTtcbnZhciBoYXNEZXNjcmlwdG9ycyA9IHJlcXVpcmUoJ2hhcy1wcm9wZXJ0eS1kZXNjcmlwdG9ycycpKCk7XG52YXIgZ09QRCA9IHJlcXVpcmUoJ2dvcGQnKTtcblxudmFyICRUeXBlRXJyb3IgPSByZXF1aXJlKCdlcy1lcnJvcnMvdHlwZScpO1xudmFyICRmbG9vciA9IEdldEludHJpbnNpYygnJU1hdGguZmxvb3IlJyk7XG5cbi8qKiBAdHlwZSB7aW1wb3J0KCcuJyl9ICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNldEZ1bmN0aW9uTGVuZ3RoKGZuLCBsZW5ndGgpIHtcblx0aWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuXHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdgZm5gIGlzIG5vdCBhIGZ1bmN0aW9uJyk7XG5cdH1cblx0aWYgKHR5cGVvZiBsZW5ndGggIT09ICdudW1iZXInIHx8IGxlbmd0aCA8IDAgfHwgbGVuZ3RoID4gMHhGRkZGRkZGRiB8fCAkZmxvb3IobGVuZ3RoKSAhPT0gbGVuZ3RoKSB7XG5cdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ2BsZW5ndGhgIG11c3QgYmUgYSBwb3NpdGl2ZSAzMi1iaXQgaW50ZWdlcicpO1xuXHR9XG5cblx0dmFyIGxvb3NlID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgISFhcmd1bWVudHNbMl07XG5cblx0dmFyIGZ1bmN0aW9uTGVuZ3RoSXNDb25maWd1cmFibGUgPSB0cnVlO1xuXHR2YXIgZnVuY3Rpb25MZW5ndGhJc1dyaXRhYmxlID0gdHJ1ZTtcblx0aWYgKCdsZW5ndGgnIGluIGZuICYmIGdPUEQpIHtcblx0XHR2YXIgZGVzYyA9IGdPUEQoZm4sICdsZW5ndGgnKTtcblx0XHRpZiAoZGVzYyAmJiAhZGVzYy5jb25maWd1cmFibGUpIHtcblx0XHRcdGZ1bmN0aW9uTGVuZ3RoSXNDb25maWd1cmFibGUgPSBmYWxzZTtcblx0XHR9XG5cdFx0aWYgKGRlc2MgJiYgIWRlc2Mud3JpdGFibGUpIHtcblx0XHRcdGZ1bmN0aW9uTGVuZ3RoSXNXcml0YWJsZSA9IGZhbHNlO1xuXHRcdH1cblx0fVxuXG5cdGlmIChmdW5jdGlvbkxlbmd0aElzQ29uZmlndXJhYmxlIHx8IGZ1bmN0aW9uTGVuZ3RoSXNXcml0YWJsZSB8fCAhbG9vc2UpIHtcblx0XHRpZiAoaGFzRGVzY3JpcHRvcnMpIHtcblx0XHRcdGRlZmluZSgvKiogQHR5cGUge1BhcmFtZXRlcnM8ZGVmaW5lPlswXX0gKi8gKGZuKSwgJ2xlbmd0aCcsIGxlbmd0aCwgdHJ1ZSwgdHJ1ZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGRlZmluZSgvKiogQHR5cGUge1BhcmFtZXRlcnM8ZGVmaW5lPlswXX0gKi8gKGZuKSwgJ2xlbmd0aCcsIGxlbmd0aCk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBmbjtcbn07XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYmluZCA9IHJlcXVpcmUoJ2Z1bmN0aW9uLWJpbmQnKTtcbnZhciBHZXRJbnRyaW5zaWMgPSByZXF1aXJlKCdnZXQtaW50cmluc2ljJyk7XG52YXIgc2V0RnVuY3Rpb25MZW5ndGggPSByZXF1aXJlKCdzZXQtZnVuY3Rpb24tbGVuZ3RoJyk7XG5cbnZhciAkVHlwZUVycm9yID0gcmVxdWlyZSgnZXMtZXJyb3JzL3R5cGUnKTtcbnZhciAkYXBwbHkgPSBHZXRJbnRyaW5zaWMoJyVGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHklJyk7XG52YXIgJGNhbGwgPSBHZXRJbnRyaW5zaWMoJyVGdW5jdGlvbi5wcm90b3R5cGUuY2FsbCUnKTtcbnZhciAkcmVmbGVjdEFwcGx5ID0gR2V0SW50cmluc2ljKCclUmVmbGVjdC5hcHBseSUnLCB0cnVlKSB8fCBiaW5kLmNhbGwoJGNhbGwsICRhcHBseSk7XG5cbnZhciAkZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCdlcy1kZWZpbmUtcHJvcGVydHknKTtcbnZhciAkbWF4ID0gR2V0SW50cmluc2ljKCclTWF0aC5tYXglJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY2FsbEJpbmQob3JpZ2luYWxGdW5jdGlvbikge1xuXHRpZiAodHlwZW9mIG9yaWdpbmFsRnVuY3Rpb24gIT09ICdmdW5jdGlvbicpIHtcblx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignYSBmdW5jdGlvbiBpcyByZXF1aXJlZCcpO1xuXHR9XG5cdHZhciBmdW5jID0gJHJlZmxlY3RBcHBseShiaW5kLCAkY2FsbCwgYXJndW1lbnRzKTtcblx0cmV0dXJuIHNldEZ1bmN0aW9uTGVuZ3RoKFxuXHRcdGZ1bmMsXG5cdFx0MSArICRtYXgoMCwgb3JpZ2luYWxGdW5jdGlvbi5sZW5ndGggLSAoYXJndW1lbnRzLmxlbmd0aCAtIDEpKSxcblx0XHR0cnVlXG5cdCk7XG59O1xuXG52YXIgYXBwbHlCaW5kID0gZnVuY3Rpb24gYXBwbHlCaW5kKCkge1xuXHRyZXR1cm4gJHJlZmxlY3RBcHBseShiaW5kLCAkYXBwbHksIGFyZ3VtZW50cyk7XG59O1xuXG5pZiAoJGRlZmluZVByb3BlcnR5KSB7XG5cdCRkZWZpbmVQcm9wZXJ0eShtb2R1bGUuZXhwb3J0cywgJ2FwcGx5JywgeyB2YWx1ZTogYXBwbHlCaW5kIH0pO1xufSBlbHNlIHtcblx0bW9kdWxlLmV4cG9ydHMuYXBwbHkgPSBhcHBseUJpbmQ7XG59XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG52YXIgR2V0SW50cmluc2ljID0gcmVxdWlyZSgnZ2V0LWludHJpbnNpYycpO1xuXG52YXIgY2FsbEJpbmQgPSByZXF1aXJlKCcuLycpO1xuXG52YXIgJGluZGV4T2YgPSBjYWxsQmluZChHZXRJbnRyaW5zaWMoJ1N0cmluZy5wcm90b3R5cGUuaW5kZXhPZicpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjYWxsQm91bmRJbnRyaW5zaWMobmFtZSwgYWxsb3dNaXNzaW5nKSB7XG5cdHZhciBpbnRyaW5zaWMgPSBHZXRJbnRyaW5zaWMobmFtZSwgISFhbGxvd01pc3NpbmcpO1xuXHRpZiAodHlwZW9mIGludHJpbnNpYyA9PT0gJ2Z1bmN0aW9uJyAmJiAkaW5kZXhPZihuYW1lLCAnLnByb3RvdHlwZS4nKSA+IC0xKSB7XG5cdFx0cmV0dXJuIGNhbGxCaW5kKGludHJpbnNpYyk7XG5cdH1cblx0cmV0dXJuIGludHJpbnNpYztcbn07XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaGFzVG9TdHJpbmdUYWcgPSByZXF1aXJlKCdoYXMtdG9zdHJpbmd0YWcvc2hhbXMnKSgpO1xudmFyIGNhbGxCb3VuZCA9IHJlcXVpcmUoJ2NhbGwtYmluZC9jYWxsQm91bmQnKTtcblxudmFyICR0b1N0cmluZyA9IGNhbGxCb3VuZCgnT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZycpO1xuXG52YXIgaXNTdGFuZGFyZEFyZ3VtZW50cyA9IGZ1bmN0aW9uIGlzQXJndW1lbnRzKHZhbHVlKSB7XG5cdGlmIChoYXNUb1N0cmluZ1RhZyAmJiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIFN5bWJvbC50b1N0cmluZ1RhZyBpbiB2YWx1ZSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXHRyZXR1cm4gJHRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG59O1xuXG52YXIgaXNMZWdhY3lBcmd1bWVudHMgPSBmdW5jdGlvbiBpc0FyZ3VtZW50cyh2YWx1ZSkge1xuXHRpZiAoaXNTdGFuZGFyZEFyZ3VtZW50cyh2YWx1ZSkpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXHRyZXR1cm4gdmFsdWUgIT09IG51bGwgJiZcblx0XHR0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmXG5cdFx0dHlwZW9mIHZhbHVlLmxlbmd0aCA9PT0gJ251bWJlcicgJiZcblx0XHR2YWx1ZS5sZW5ndGggPj0gMCAmJlxuXHRcdCR0b1N0cmluZyh2YWx1ZSkgIT09ICdbb2JqZWN0IEFycmF5XScgJiZcblx0XHQkdG9TdHJpbmcodmFsdWUuY2FsbGVlKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbn07XG5cbnZhciBzdXBwb3J0c1N0YW5kYXJkQXJndW1lbnRzID0gKGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuIGlzU3RhbmRhcmRBcmd1bWVudHMoYXJndW1lbnRzKTtcbn0oKSk7XG5cbmlzU3RhbmRhcmRBcmd1bWVudHMuaXNMZWdhY3lBcmd1bWVudHMgPSBpc0xlZ2FjeUFyZ3VtZW50czsgLy8gZm9yIHRlc3RzXG5cbm1vZHVsZS5leHBvcnRzID0gc3VwcG9ydHNTdGFuZGFyZEFyZ3VtZW50cyA/IGlzU3RhbmRhcmRBcmd1bWVudHMgOiBpc0xlZ2FjeUFyZ3VtZW50cztcbiIsICIndXNlIHN0cmljdCc7XG5cbnZhciB0b1N0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgZm5Ub1N0ciA9IEZ1bmN0aW9uLnByb3RvdHlwZS50b1N0cmluZztcbnZhciBpc0ZuUmVnZXggPSAvXlxccyooPzpmdW5jdGlvbik/XFwqLztcbnZhciBoYXNUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJ2hhcy10b3N0cmluZ3RhZy9zaGFtcycpKCk7XG52YXIgZ2V0UHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG52YXIgZ2V0R2VuZXJhdG9yRnVuYyA9IGZ1bmN0aW9uICgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjb25zaXN0ZW50LXJldHVyblxuXHRpZiAoIWhhc1RvU3RyaW5nVGFnKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cdHRyeSB7XG5cdFx0cmV0dXJuIEZ1bmN0aW9uKCdyZXR1cm4gZnVuY3Rpb24qKCkge30nKSgpO1xuXHR9IGNhdGNoIChlKSB7XG5cdH1cbn07XG52YXIgR2VuZXJhdG9yRnVuY3Rpb247XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNHZW5lcmF0b3JGdW5jdGlvbihmbikge1xuXHRpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cdGlmIChpc0ZuUmVnZXgudGVzdChmblRvU3RyLmNhbGwoZm4pKSkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cdGlmICghaGFzVG9TdHJpbmdUYWcpIHtcblx0XHR2YXIgc3RyID0gdG9TdHIuY2FsbChmbik7XG5cdFx0cmV0dXJuIHN0ciA9PT0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJztcblx0fVxuXHRpZiAoIWdldFByb3RvKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cdGlmICh0eXBlb2YgR2VuZXJhdG9yRnVuY3Rpb24gPT09ICd1bmRlZmluZWQnKSB7XG5cdFx0dmFyIGdlbmVyYXRvckZ1bmMgPSBnZXRHZW5lcmF0b3JGdW5jKCk7XG5cdFx0R2VuZXJhdG9yRnVuY3Rpb24gPSBnZW5lcmF0b3JGdW5jID8gZ2V0UHJvdG8oZ2VuZXJhdG9yRnVuYykgOiBmYWxzZTtcblx0fVxuXHRyZXR1cm4gZ2V0UHJvdG8oZm4pID09PSBHZW5lcmF0b3JGdW5jdGlvbjtcbn07XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZm5Ub1N0ciA9IEZ1bmN0aW9uLnByb3RvdHlwZS50b1N0cmluZztcbnZhciByZWZsZWN0QXBwbHkgPSB0eXBlb2YgUmVmbGVjdCA9PT0gJ29iamVjdCcgJiYgUmVmbGVjdCAhPT0gbnVsbCAmJiBSZWZsZWN0LmFwcGx5O1xudmFyIGJhZEFycmF5TGlrZTtcbnZhciBpc0NhbGxhYmxlTWFya2VyO1xuaWYgKHR5cGVvZiByZWZsZWN0QXBwbHkgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSA9PT0gJ2Z1bmN0aW9uJykge1xuXHR0cnkge1xuXHRcdGJhZEFycmF5TGlrZSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ2xlbmd0aCcsIHtcblx0XHRcdGdldDogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHR0aHJvdyBpc0NhbGxhYmxlTWFya2VyO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdGlzQ2FsbGFibGVNYXJrZXIgPSB7fTtcblx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdGhyb3ctbGl0ZXJhbFxuXHRcdHJlZmxlY3RBcHBseShmdW5jdGlvbiAoKSB7IHRocm93IDQyOyB9LCBudWxsLCBiYWRBcnJheUxpa2UpO1xuXHR9IGNhdGNoIChfKSB7XG5cdFx0aWYgKF8gIT09IGlzQ2FsbGFibGVNYXJrZXIpIHtcblx0XHRcdHJlZmxlY3RBcHBseSA9IG51bGw7XG5cdFx0fVxuXHR9XG59IGVsc2Uge1xuXHRyZWZsZWN0QXBwbHkgPSBudWxsO1xufVxuXG52YXIgY29uc3RydWN0b3JSZWdleCA9IC9eXFxzKmNsYXNzXFxiLztcbnZhciBpc0VTNkNsYXNzRm4gPSBmdW5jdGlvbiBpc0VTNkNsYXNzRnVuY3Rpb24odmFsdWUpIHtcblx0dHJ5IHtcblx0XHR2YXIgZm5TdHIgPSBmblRvU3RyLmNhbGwodmFsdWUpO1xuXHRcdHJldHVybiBjb25zdHJ1Y3RvclJlZ2V4LnRlc3QoZm5TdHIpO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0cmV0dXJuIGZhbHNlOyAvLyBub3QgYSBmdW5jdGlvblxuXHR9XG59O1xuXG52YXIgdHJ5RnVuY3Rpb25PYmplY3QgPSBmdW5jdGlvbiB0cnlGdW5jdGlvblRvU3RyKHZhbHVlKSB7XG5cdHRyeSB7XG5cdFx0aWYgKGlzRVM2Q2xhc3NGbih2YWx1ZSkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0Zm5Ub1N0ci5jYWxsKHZhbHVlKTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufTtcbnZhciB0b1N0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgb2JqZWN0Q2xhc3MgPSAnW29iamVjdCBPYmplY3RdJztcbnZhciBmbkNsYXNzID0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbnZhciBnZW5DbGFzcyA9ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXSc7XG52YXIgZGRhQ2xhc3MgPSAnW29iamVjdCBIVE1MQWxsQ29sbGVjdGlvbl0nOyAvLyBJRSAxMVxudmFyIGRkYUNsYXNzMiA9ICdbb2JqZWN0IEhUTUwgZG9jdW1lbnQuYWxsIGNsYXNzXSc7XG52YXIgZGRhQ2xhc3MzID0gJ1tvYmplY3QgSFRNTENvbGxlY3Rpb25dJzsgLy8gSUUgOS0xMFxudmFyIGhhc1RvU3RyaW5nVGFnID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiAhIVN5bWJvbC50b1N0cmluZ1RhZzsgLy8gYmV0dGVyOiB1c2UgYGhhcy10b3N0cmluZ3RhZ2BcblxudmFyIGlzSUU2OCA9ICEoMCBpbiBbLF0pOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNwYXJzZS1hcnJheXMsIGNvbW1hLXNwYWNpbmdcblxudmFyIGlzRERBID0gZnVuY3Rpb24gaXNEb2N1bWVudERvdEFsbCgpIHsgcmV0dXJuIGZhbHNlOyB9O1xuaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gJ29iamVjdCcpIHtcblx0Ly8gRmlyZWZveCAzIGNhbm9uaWNhbGl6ZXMgRERBIHRvIHVuZGVmaW5lZCB3aGVuIGl0J3Mgbm90IGFjY2Vzc2VkIGRpcmVjdGx5XG5cdHZhciBhbGwgPSBkb2N1bWVudC5hbGw7XG5cdGlmICh0b1N0ci5jYWxsKGFsbCkgPT09IHRvU3RyLmNhbGwoZG9jdW1lbnQuYWxsKSkge1xuXHRcdGlzRERBID0gZnVuY3Rpb24gaXNEb2N1bWVudERvdEFsbCh2YWx1ZSkge1xuXHRcdFx0LyogZ2xvYmFscyBkb2N1bWVudDogZmFsc2UgKi9cblx0XHRcdC8vIGluIElFIDYtOCwgdHlwZW9mIGRvY3VtZW50LmFsbCBpcyBcIm9iamVjdFwiIGFuZCBpdCdzIHRydXRoeVxuXHRcdFx0aWYgKChpc0lFNjggfHwgIXZhbHVlKSAmJiAodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJyB8fCB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSkge1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdHZhciBzdHIgPSB0b1N0ci5jYWxsKHZhbHVlKTtcblx0XHRcdFx0XHRyZXR1cm4gKFxuXHRcdFx0XHRcdFx0c3RyID09PSBkZGFDbGFzc1xuXHRcdFx0XHRcdFx0fHwgc3RyID09PSBkZGFDbGFzczJcblx0XHRcdFx0XHRcdHx8IHN0ciA9PT0gZGRhQ2xhc3MzIC8vIG9wZXJhIDEyLjE2XG5cdFx0XHRcdFx0XHR8fCBzdHIgPT09IG9iamVjdENsYXNzIC8vIElFIDYtOFxuXHRcdFx0XHRcdCkgJiYgdmFsdWUoJycpID09IG51bGw7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXG5cdFx0XHRcdH0gY2F0Y2ggKGUpIHsgLyoqLyB9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fTtcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlZmxlY3RBcHBseVxuXHQ/IGZ1bmN0aW9uIGlzQ2FsbGFibGUodmFsdWUpIHtcblx0XHRpZiAoaXNEREEodmFsdWUpKSB7IHJldHVybiB0cnVlOyB9XG5cdFx0aWYgKCF2YWx1ZSkgeyByZXR1cm4gZmFsc2U7IH1cblx0XHRpZiAodHlwZW9mIHZhbHVlICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0dHJ5IHtcblx0XHRcdHJlZmxlY3RBcHBseSh2YWx1ZSwgbnVsbCwgYmFkQXJyYXlMaWtlKTtcblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRpZiAoZSAhPT0gaXNDYWxsYWJsZU1hcmtlcikgeyByZXR1cm4gZmFsc2U7IH1cblx0XHR9XG5cdFx0cmV0dXJuICFpc0VTNkNsYXNzRm4odmFsdWUpICYmIHRyeUZ1bmN0aW9uT2JqZWN0KHZhbHVlKTtcblx0fVxuXHQ6IGZ1bmN0aW9uIGlzQ2FsbGFibGUodmFsdWUpIHtcblx0XHRpZiAoaXNEREEodmFsdWUpKSB7IHJldHVybiB0cnVlOyB9XG5cdFx0aWYgKCF2YWx1ZSkgeyByZXR1cm4gZmFsc2U7IH1cblx0XHRpZiAodHlwZW9mIHZhbHVlICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0aWYgKGhhc1RvU3RyaW5nVGFnKSB7IHJldHVybiB0cnlGdW5jdGlvbk9iamVjdCh2YWx1ZSk7IH1cblx0XHRpZiAoaXNFUzZDbGFzc0ZuKHZhbHVlKSkgeyByZXR1cm4gZmFsc2U7IH1cblx0XHR2YXIgc3RyQ2xhc3MgPSB0b1N0ci5jYWxsKHZhbHVlKTtcblx0XHRpZiAoc3RyQ2xhc3MgIT09IGZuQ2xhc3MgJiYgc3RyQ2xhc3MgIT09IGdlbkNsYXNzICYmICEoL15cXFtvYmplY3QgSFRNTC8pLnRlc3Qoc3RyQ2xhc3MpKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdHJldHVybiB0cnlGdW5jdGlvbk9iamVjdCh2YWx1ZSk7XG5cdH07XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNDYWxsYWJsZSA9IHJlcXVpcmUoJ2lzLWNhbGxhYmxlJyk7XG5cbnZhciB0b1N0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG52YXIgZm9yRWFjaEFycmF5ID0gZnVuY3Rpb24gZm9yRWFjaEFycmF5KGFycmF5LCBpdGVyYXRvciwgcmVjZWl2ZXIpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYXJyYXkubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoYXJyYXksIGkpKSB7XG4gICAgICAgICAgICBpZiAocmVjZWl2ZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGl0ZXJhdG9yKGFycmF5W2ldLCBpLCBhcnJheSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGl0ZXJhdG9yLmNhbGwocmVjZWl2ZXIsIGFycmF5W2ldLCBpLCBhcnJheSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG52YXIgZm9yRWFjaFN0cmluZyA9IGZ1bmN0aW9uIGZvckVhY2hTdHJpbmcoc3RyaW5nLCBpdGVyYXRvciwgcmVjZWl2ZXIpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gc3RyaW5nLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIC8vIG5vIHN1Y2ggdGhpbmcgYXMgYSBzcGFyc2Ugc3RyaW5nLlxuICAgICAgICBpZiAocmVjZWl2ZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgaXRlcmF0b3Ioc3RyaW5nLmNoYXJBdChpKSwgaSwgc3RyaW5nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yLmNhbGwocmVjZWl2ZXIsIHN0cmluZy5jaGFyQXQoaSksIGksIHN0cmluZyk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG52YXIgZm9yRWFjaE9iamVjdCA9IGZ1bmN0aW9uIGZvckVhY2hPYmplY3Qob2JqZWN0LCBpdGVyYXRvciwgcmVjZWl2ZXIpIHtcbiAgICBmb3IgKHZhciBrIGluIG9iamVjdCkge1xuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGspKSB7XG4gICAgICAgICAgICBpZiAocmVjZWl2ZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGl0ZXJhdG9yKG9iamVjdFtrXSwgaywgb2JqZWN0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaXRlcmF0b3IuY2FsbChyZWNlaXZlciwgb2JqZWN0W2tdLCBrLCBvYmplY3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxudmFyIGZvckVhY2ggPSBmdW5jdGlvbiBmb3JFYWNoKGxpc3QsIGl0ZXJhdG9yLCB0aGlzQXJnKSB7XG4gICAgaWYgKCFpc0NhbGxhYmxlKGl0ZXJhdG9yKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpdGVyYXRvciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICB9XG5cbiAgICB2YXIgcmVjZWl2ZXI7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gMykge1xuICAgICAgICByZWNlaXZlciA9IHRoaXNBcmc7XG4gICAgfVxuXG4gICAgaWYgKHRvU3RyLmNhbGwobGlzdCkgPT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICAgICAgZm9yRWFjaEFycmF5KGxpc3QsIGl0ZXJhdG9yLCByZWNlaXZlcik7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbGlzdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgZm9yRWFjaFN0cmluZyhsaXN0LCBpdGVyYXRvciwgcmVjZWl2ZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvckVhY2hPYmplY3QobGlzdCwgaXRlcmF0b3IsIHJlY2VpdmVyKTtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZvckVhY2g7XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG4vKiogQHR5cGUge2ltcG9ydCgnLicpfSAqL1xubW9kdWxlLmV4cG9ydHMgPSBbXG5cdCdGbG9hdDMyQXJyYXknLFxuXHQnRmxvYXQ2NEFycmF5Jyxcblx0J0ludDhBcnJheScsXG5cdCdJbnQxNkFycmF5Jyxcblx0J0ludDMyQXJyYXknLFxuXHQnVWludDhBcnJheScsXG5cdCdVaW50OENsYW1wZWRBcnJheScsXG5cdCdVaW50MTZBcnJheScsXG5cdCdVaW50MzJBcnJheScsXG5cdCdCaWdJbnQ2NEFycmF5Jyxcblx0J0JpZ1VpbnQ2NEFycmF5J1xuXTtcbiIsICIndXNlIHN0cmljdCc7XG5cbnZhciBwb3NzaWJsZU5hbWVzID0gcmVxdWlyZSgncG9zc2libGUtdHlwZWQtYXJyYXktbmFtZXMnKTtcblxudmFyIGcgPSB0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiBnbG9iYWxUaGlzO1xuXG4vKiogQHR5cGUge2ltcG9ydCgnLicpfSAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBhdmFpbGFibGVUeXBlZEFycmF5cygpIHtcblx0dmFyIC8qKiBAdHlwZSB7UmV0dXJuVHlwZTx0eXBlb2YgYXZhaWxhYmxlVHlwZWRBcnJheXM+fSAqLyBvdXQgPSBbXTtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBwb3NzaWJsZU5hbWVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0aWYgKHR5cGVvZiBnW3Bvc3NpYmxlTmFtZXNbaV1dID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdFx0XHRvdXRbb3V0Lmxlbmd0aF0gPSBwb3NzaWJsZU5hbWVzW2ldO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gb3V0O1xufTtcbiIsICIndXNlIHN0cmljdCc7XG5cbnZhciBmb3JFYWNoID0gcmVxdWlyZSgnZm9yLWVhY2gnKTtcbnZhciBhdmFpbGFibGVUeXBlZEFycmF5cyA9IHJlcXVpcmUoJ2F2YWlsYWJsZS10eXBlZC1hcnJheXMnKTtcbnZhciBjYWxsQmluZCA9IHJlcXVpcmUoJ2NhbGwtYmluZCcpO1xudmFyIGNhbGxCb3VuZCA9IHJlcXVpcmUoJ2NhbGwtYmluZC9jYWxsQm91bmQnKTtcbnZhciBnT1BEID0gcmVxdWlyZSgnZ29wZCcpO1xuXG4vKiogQHR5cGUgeyhPOiBvYmplY3QpID0+IHN0cmluZ30gKi9cbnZhciAkdG9TdHJpbmcgPSBjYWxsQm91bmQoJ09iamVjdC5wcm90b3R5cGUudG9TdHJpbmcnKTtcbnZhciBoYXNUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJ2hhcy10b3N0cmluZ3RhZy9zaGFtcycpKCk7XG5cbnZhciBnID0gdHlwZW9mIGdsb2JhbFRoaXMgPT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogZ2xvYmFsVGhpcztcbnZhciB0eXBlZEFycmF5cyA9IGF2YWlsYWJsZVR5cGVkQXJyYXlzKCk7XG5cbnZhciAkc2xpY2UgPSBjYWxsQm91bmQoJ1N0cmluZy5wcm90b3R5cGUuc2xpY2UnKTtcbnZhciBnZXRQcm90b3R5cGVPZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjsgLy8gcmVxdWlyZSgnZ2V0cHJvdG90eXBlb2YnKTtcblxuLyoqIEB0eXBlIHs8VCA9IHVua25vd24+KGFycmF5OiByZWFkb25seSBUW10sIHZhbHVlOiB1bmtub3duKSA9PiBudW1iZXJ9ICovXG52YXIgJGluZGV4T2YgPSBjYWxsQm91bmQoJ0FycmF5LnByb3RvdHlwZS5pbmRleE9mJywgdHJ1ZSkgfHwgZnVuY3Rpb24gaW5kZXhPZihhcnJheSwgdmFsdWUpIHtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkgKz0gMSkge1xuXHRcdGlmIChhcnJheVtpXSA9PT0gdmFsdWUpIHtcblx0XHRcdHJldHVybiBpO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gLTE7XG59O1xuXG4vKiogQHR5cGVkZWYgeyhyZWNlaXZlcjogaW1wb3J0KCcuJykuVHlwZWRBcnJheSkgPT4gc3RyaW5nIHwgdHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwgfCB0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGx9IEdldHRlciAqL1xuLyoqIEB0eXBlIHt7IFtrIGluIGBcXCQke2ltcG9ydCgnLicpLlR5cGVkQXJyYXlOYW1lfWBdPzogR2V0dGVyIH0gJiB7IF9fcHJvdG9fXzogbnVsbCB9fSAqL1xudmFyIGNhY2hlID0geyBfX3Byb3RvX186IG51bGwgfTtcbmlmIChoYXNUb1N0cmluZ1RhZyAmJiBnT1BEICYmIGdldFByb3RvdHlwZU9mKSB7XG5cdGZvckVhY2godHlwZWRBcnJheXMsIGZ1bmN0aW9uICh0eXBlZEFycmF5KSB7XG5cdFx0dmFyIGFyciA9IG5ldyBnW3R5cGVkQXJyYXldKCk7XG5cdFx0aWYgKFN5bWJvbC50b1N0cmluZ1RhZyBpbiBhcnIpIHtcblx0XHRcdHZhciBwcm90byA9IGdldFByb3RvdHlwZU9mKGFycik7XG5cdFx0XHQvLyBAdHMtZXhwZWN0LWVycm9yIFRTIHdvbid0IG5hcnJvdyBpbnNpZGUgYSBjbG9zdXJlXG5cdFx0XHR2YXIgZGVzY3JpcHRvciA9IGdPUEQocHJvdG8sIFN5bWJvbC50b1N0cmluZ1RhZyk7XG5cdFx0XHRpZiAoIWRlc2NyaXB0b3IpIHtcblx0XHRcdFx0dmFyIHN1cGVyUHJvdG8gPSBnZXRQcm90b3R5cGVPZihwcm90byk7XG5cdFx0XHRcdC8vIEB0cy1leHBlY3QtZXJyb3IgVFMgd29uJ3QgbmFycm93IGluc2lkZSBhIGNsb3N1cmVcblx0XHRcdFx0ZGVzY3JpcHRvciA9IGdPUEQoc3VwZXJQcm90bywgU3ltYm9sLnRvU3RyaW5nVGFnKTtcblx0XHRcdH1cblx0XHRcdC8vIEB0cy1leHBlY3QtZXJyb3IgVE9ETzogZml4XG5cdFx0XHRjYWNoZVsnJCcgKyB0eXBlZEFycmF5XSA9IGNhbGxCaW5kKGRlc2NyaXB0b3IuZ2V0KTtcblx0XHR9XG5cdH0pO1xufSBlbHNlIHtcblx0Zm9yRWFjaCh0eXBlZEFycmF5cywgZnVuY3Rpb24gKHR5cGVkQXJyYXkpIHtcblx0XHR2YXIgYXJyID0gbmV3IGdbdHlwZWRBcnJheV0oKTtcblx0XHR2YXIgZm4gPSBhcnIuc2xpY2UgfHwgYXJyLnNldDtcblx0XHRpZiAoZm4pIHtcblx0XHRcdC8vIEB0cy1leHBlY3QtZXJyb3IgVE9ETzogZml4XG5cdFx0XHRjYWNoZVsnJCcgKyB0eXBlZEFycmF5XSA9IGNhbGxCaW5kKGZuKTtcblx0XHR9XG5cdH0pO1xufVxuXG4vKiogQHR5cGUgeyh2YWx1ZTogb2JqZWN0KSA9PiBmYWxzZSB8IGltcG9ydCgnLicpLlR5cGVkQXJyYXlOYW1lfSAqL1xudmFyIHRyeVR5cGVkQXJyYXlzID0gZnVuY3Rpb24gdHJ5QWxsVHlwZWRBcnJheXModmFsdWUpIHtcblx0LyoqIEB0eXBlIHtSZXR1cm5UeXBlPHR5cGVvZiB0cnlBbGxUeXBlZEFycmF5cz59ICovIHZhciBmb3VuZCA9IGZhbHNlO1xuXHRmb3JFYWNoKFxuXHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1leHRyYS1wYXJlbnNcblx0XHQvKiogQHR5cGUge1JlY29yZDxgXFwkJHtUeXBlZEFycmF5TmFtZX1gLCBHZXR0ZXI+fSAqLyAvKiogQHR5cGUge2FueX0gKi8gKGNhY2hlKSxcblx0XHQvKiogQHR5cGUgeyhnZXR0ZXI6IEdldHRlciwgbmFtZTogYFxcJCR7aW1wb3J0KCcuJykuVHlwZWRBcnJheU5hbWV9YCkgPT4gdm9pZH0gKi9cblx0XHRmdW5jdGlvbiAoZ2V0dGVyLCB0eXBlZEFycmF5KSB7XG5cdFx0XHRpZiAoIWZvdW5kKSB7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdC8vIEB0cy1leHBlY3QtZXJyb3IgVE9ETzogZml4XG5cdFx0XHRcdFx0aWYgKCckJyArIGdldHRlcih2YWx1ZSkgPT09IHR5cGVkQXJyYXkpIHtcblx0XHRcdFx0XHRcdGZvdW5kID0gJHNsaWNlKHR5cGVkQXJyYXksIDEpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBjYXRjaCAoZSkgeyAvKiovIH1cblx0XHRcdH1cblx0XHR9XG5cdCk7XG5cdHJldHVybiBmb3VuZDtcbn07XG5cbi8qKiBAdHlwZSB7KHZhbHVlOiBvYmplY3QpID0+IGZhbHNlIHwgaW1wb3J0KCcuJykuVHlwZWRBcnJheU5hbWV9ICovXG52YXIgdHJ5U2xpY2VzID0gZnVuY3Rpb24gdHJ5QWxsU2xpY2VzKHZhbHVlKSB7XG5cdC8qKiBAdHlwZSB7UmV0dXJuVHlwZTx0eXBlb2YgdHJ5QWxsU2xpY2VzPn0gKi8gdmFyIGZvdW5kID0gZmFsc2U7XG5cdGZvckVhY2goXG5cdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWV4dHJhLXBhcmVuc1xuXHRcdC8qKiBAdHlwZSB7UmVjb3JkPGBcXCQke1R5cGVkQXJyYXlOYW1lfWAsIEdldHRlcj59ICovIC8qKiBAdHlwZSB7YW55fSAqLyAoY2FjaGUpLFxuXHRcdC8qKiBAdHlwZSB7KGdldHRlcjogdHlwZW9mIGNhY2hlLCBuYW1lOiBgXFwkJHtpbXBvcnQoJy4nKS5UeXBlZEFycmF5TmFtZX1gKSA9PiB2b2lkfSAqLyBmdW5jdGlvbiAoZ2V0dGVyLCBuYW1lKSB7XG5cdFx0XHRpZiAoIWZvdW5kKSB7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0Ly8gQHRzLWV4cGVjdC1lcnJvciBUT0RPOiBmaXhcblx0XHRcdFx0XHRnZXR0ZXIodmFsdWUpO1xuXHRcdFx0XHRcdGZvdW5kID0gJHNsaWNlKG5hbWUsIDEpO1xuXHRcdFx0XHR9IGNhdGNoIChlKSB7IC8qKi8gfVxuXHRcdFx0fVxuXHRcdH1cblx0KTtcblx0cmV0dXJuIGZvdW5kO1xufTtcblxuLyoqIEB0eXBlIHtpbXBvcnQoJy4nKX0gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSB7XG5cdGlmICghdmFsdWUgfHwgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JykgeyByZXR1cm4gZmFsc2U7IH1cblx0aWYgKCFoYXNUb1N0cmluZ1RhZykge1xuXHRcdC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuXHRcdHZhciB0YWcgPSAkc2xpY2UoJHRvU3RyaW5nKHZhbHVlKSwgOCwgLTEpO1xuXHRcdGlmICgkaW5kZXhPZih0eXBlZEFycmF5cywgdGFnKSA+IC0xKSB7XG5cdFx0XHRyZXR1cm4gdGFnO1xuXHRcdH1cblx0XHRpZiAodGFnICE9PSAnT2JqZWN0Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHQvLyBub2RlIDwgMC42IGhpdHMgaGVyZSBvbiByZWFsIFR5cGVkIEFycmF5c1xuXHRcdHJldHVybiB0cnlTbGljZXModmFsdWUpO1xuXHR9XG5cdGlmICghZ09QRCkgeyByZXR1cm4gbnVsbDsgfSAvLyB1bmtub3duIGVuZ2luZVxuXHRyZXR1cm4gdHJ5VHlwZWRBcnJheXModmFsdWUpO1xufTtcbiIsICIndXNlIHN0cmljdCc7XG5cbnZhciB3aGljaFR5cGVkQXJyYXkgPSByZXF1aXJlKCd3aGljaC10eXBlZC1hcnJheScpO1xuXG4vKiogQHR5cGUge2ltcG9ydCgnLicpfSAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc1R5cGVkQXJyYXkodmFsdWUpIHtcblx0cmV0dXJuICEhd2hpY2hUeXBlZEFycmF5KHZhbHVlKTtcbn07XG4iLCAiLy8gQ3VycmVudGx5IGluIHN5bmMgd2l0aCBOb2RlLmpzIGxpYi9pbnRlcm5hbC91dGlsL3R5cGVzLmpzXG4vLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvY29tbWl0LzExMmNjN2MyNzU1MTI1NGFhMmIxNzA5OGZiNzc0ODY3ZjA1ZWQwZDlcblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNBcmd1bWVudHNPYmplY3QgPSByZXF1aXJlKCdpcy1hcmd1bWVudHMnKTtcbnZhciBpc0dlbmVyYXRvckZ1bmN0aW9uID0gcmVxdWlyZSgnaXMtZ2VuZXJhdG9yLWZ1bmN0aW9uJyk7XG52YXIgd2hpY2hUeXBlZEFycmF5ID0gcmVxdWlyZSgnd2hpY2gtdHlwZWQtYXJyYXknKTtcbnZhciBpc1R5cGVkQXJyYXkgPSByZXF1aXJlKCdpcy10eXBlZC1hcnJheScpO1xuXG5mdW5jdGlvbiB1bmN1cnJ5VGhpcyhmKSB7XG4gIHJldHVybiBmLmNhbGwuYmluZChmKTtcbn1cblxudmFyIEJpZ0ludFN1cHBvcnRlZCA9IHR5cGVvZiBCaWdJbnQgIT09ICd1bmRlZmluZWQnO1xudmFyIFN5bWJvbFN1cHBvcnRlZCA9IHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnO1xuXG52YXIgT2JqZWN0VG9TdHJpbmcgPSB1bmN1cnJ5VGhpcyhPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nKTtcblxudmFyIG51bWJlclZhbHVlID0gdW5jdXJyeVRoaXMoTnVtYmVyLnByb3RvdHlwZS52YWx1ZU9mKTtcbnZhciBzdHJpbmdWYWx1ZSA9IHVuY3VycnlUaGlzKFN0cmluZy5wcm90b3R5cGUudmFsdWVPZik7XG52YXIgYm9vbGVhblZhbHVlID0gdW5jdXJyeVRoaXMoQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZik7XG5cbmlmIChCaWdJbnRTdXBwb3J0ZWQpIHtcbiAgdmFyIGJpZ0ludFZhbHVlID0gdW5jdXJyeVRoaXMoQmlnSW50LnByb3RvdHlwZS52YWx1ZU9mKTtcbn1cblxuaWYgKFN5bWJvbFN1cHBvcnRlZCkge1xuICB2YXIgc3ltYm9sVmFsdWUgPSB1bmN1cnJ5VGhpcyhTeW1ib2wucHJvdG90eXBlLnZhbHVlT2YpO1xufVxuXG5mdW5jdGlvbiBjaGVja0JveGVkUHJpbWl0aXZlKHZhbHVlLCBwcm90b3R5cGVWYWx1ZU9mKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHRyeSB7XG4gICAgcHJvdG90eXBlVmFsdWVPZih2YWx1ZSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2goZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5leHBvcnRzLmlzQXJndW1lbnRzT2JqZWN0ID0gaXNBcmd1bWVudHNPYmplY3Q7XG5leHBvcnRzLmlzR2VuZXJhdG9yRnVuY3Rpb24gPSBpc0dlbmVyYXRvckZ1bmN0aW9uO1xuZXhwb3J0cy5pc1R5cGVkQXJyYXkgPSBpc1R5cGVkQXJyYXk7XG5cbi8vIFRha2VuIGZyb20gaGVyZSBhbmQgbW9kaWZpZWQgZm9yIGJldHRlciBicm93c2VyIHN1cHBvcnRcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9zaW5kcmVzb3JodXMvcC1pcy1wcm9taXNlL2Jsb2IvY2RhMzVhNTEzYmRhMDNmOTc3YWQ1Y2RlM2EwNzlkMjM3ZTgyZDdlZi9pbmRleC5qc1xuZnVuY3Rpb24gaXNQcm9taXNlKGlucHV0KSB7XG5cdHJldHVybiAoXG5cdFx0KFxuXHRcdFx0dHlwZW9mIFByb21pc2UgIT09ICd1bmRlZmluZWQnICYmXG5cdFx0XHRpbnB1dCBpbnN0YW5jZW9mIFByb21pc2Vcblx0XHQpIHx8XG5cdFx0KFxuXHRcdFx0aW5wdXQgIT09IG51bGwgJiZcblx0XHRcdHR5cGVvZiBpbnB1dCA9PT0gJ29iamVjdCcgJiZcblx0XHRcdHR5cGVvZiBpbnB1dC50aGVuID09PSAnZnVuY3Rpb24nICYmXG5cdFx0XHR0eXBlb2YgaW5wdXQuY2F0Y2ggPT09ICdmdW5jdGlvbidcblx0XHQpXG5cdCk7XG59XG5leHBvcnRzLmlzUHJvbWlzZSA9IGlzUHJvbWlzZTtcblxuZnVuY3Rpb24gaXNBcnJheUJ1ZmZlclZpZXcodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgQXJyYXlCdWZmZXIuaXNWaWV3KSB7XG4gICAgcmV0dXJuIEFycmF5QnVmZmVyLmlzVmlldyh2YWx1ZSk7XG4gIH1cblxuICByZXR1cm4gKFxuICAgIGlzVHlwZWRBcnJheSh2YWx1ZSkgfHxcbiAgICBpc0RhdGFWaWV3KHZhbHVlKVxuICApO1xufVxuZXhwb3J0cy5pc0FycmF5QnVmZmVyVmlldyA9IGlzQXJyYXlCdWZmZXJWaWV3O1xuXG5cbmZ1bmN0aW9uIGlzVWludDhBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSA9PT0gJ1VpbnQ4QXJyYXknO1xufVxuZXhwb3J0cy5pc1VpbnQ4QXJyYXkgPSBpc1VpbnQ4QXJyYXk7XG5cbmZ1bmN0aW9uIGlzVWludDhDbGFtcGVkQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkgPT09ICdVaW50OENsYW1wZWRBcnJheSc7XG59XG5leHBvcnRzLmlzVWludDhDbGFtcGVkQXJyYXkgPSBpc1VpbnQ4Q2xhbXBlZEFycmF5O1xuXG5mdW5jdGlvbiBpc1VpbnQxNkFycmF5KHZhbHVlKSB7XG4gIHJldHVybiB3aGljaFR5cGVkQXJyYXkodmFsdWUpID09PSAnVWludDE2QXJyYXknO1xufVxuZXhwb3J0cy5pc1VpbnQxNkFycmF5ID0gaXNVaW50MTZBcnJheTtcblxuZnVuY3Rpb24gaXNVaW50MzJBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSA9PT0gJ1VpbnQzMkFycmF5Jztcbn1cbmV4cG9ydHMuaXNVaW50MzJBcnJheSA9IGlzVWludDMyQXJyYXk7XG5cbmZ1bmN0aW9uIGlzSW50OEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiB3aGljaFR5cGVkQXJyYXkodmFsdWUpID09PSAnSW50OEFycmF5Jztcbn1cbmV4cG9ydHMuaXNJbnQ4QXJyYXkgPSBpc0ludDhBcnJheTtcblxuZnVuY3Rpb24gaXNJbnQxNkFycmF5KHZhbHVlKSB7XG4gIHJldHVybiB3aGljaFR5cGVkQXJyYXkodmFsdWUpID09PSAnSW50MTZBcnJheSc7XG59XG5leHBvcnRzLmlzSW50MTZBcnJheSA9IGlzSW50MTZBcnJheTtcblxuZnVuY3Rpb24gaXNJbnQzMkFycmF5KHZhbHVlKSB7XG4gIHJldHVybiB3aGljaFR5cGVkQXJyYXkodmFsdWUpID09PSAnSW50MzJBcnJheSc7XG59XG5leHBvcnRzLmlzSW50MzJBcnJheSA9IGlzSW50MzJBcnJheTtcblxuZnVuY3Rpb24gaXNGbG9hdDMyQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkgPT09ICdGbG9hdDMyQXJyYXknO1xufVxuZXhwb3J0cy5pc0Zsb2F0MzJBcnJheSA9IGlzRmxvYXQzMkFycmF5O1xuXG5mdW5jdGlvbiBpc0Zsb2F0NjRBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSA9PT0gJ0Zsb2F0NjRBcnJheSc7XG59XG5leHBvcnRzLmlzRmxvYXQ2NEFycmF5ID0gaXNGbG9hdDY0QXJyYXk7XG5cbmZ1bmN0aW9uIGlzQmlnSW50NjRBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSA9PT0gJ0JpZ0ludDY0QXJyYXknO1xufVxuZXhwb3J0cy5pc0JpZ0ludDY0QXJyYXkgPSBpc0JpZ0ludDY0QXJyYXk7XG5cbmZ1bmN0aW9uIGlzQmlnVWludDY0QXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkgPT09ICdCaWdVaW50NjRBcnJheSc7XG59XG5leHBvcnRzLmlzQmlnVWludDY0QXJyYXkgPSBpc0JpZ1VpbnQ2NEFycmF5O1xuXG5mdW5jdGlvbiBpc01hcFRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3RUb1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IE1hcF0nO1xufVxuaXNNYXBUb1N0cmluZy53b3JraW5nID0gKFxuICB0eXBlb2YgTWFwICE9PSAndW5kZWZpbmVkJyAmJlxuICBpc01hcFRvU3RyaW5nKG5ldyBNYXAoKSlcbik7XG5cbmZ1bmN0aW9uIGlzTWFwKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgTWFwID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBpc01hcFRvU3RyaW5nLndvcmtpbmdcbiAgICA/IGlzTWFwVG9TdHJpbmcodmFsdWUpXG4gICAgOiB2YWx1ZSBpbnN0YW5jZW9mIE1hcDtcbn1cbmV4cG9ydHMuaXNNYXAgPSBpc01hcDtcblxuZnVuY3Rpb24gaXNTZXRUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBTZXRdJztcbn1cbmlzU2V0VG9TdHJpbmcud29ya2luZyA9IChcbiAgdHlwZW9mIFNldCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgaXNTZXRUb1N0cmluZyhuZXcgU2V0KCkpXG4pO1xuZnVuY3Rpb24gaXNTZXQodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiBTZXQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGlzU2V0VG9TdHJpbmcud29ya2luZ1xuICAgID8gaXNTZXRUb1N0cmluZyh2YWx1ZSlcbiAgICA6IHZhbHVlIGluc3RhbmNlb2YgU2V0O1xufVxuZXhwb3J0cy5pc1NldCA9IGlzU2V0O1xuXG5mdW5jdGlvbiBpc1dlYWtNYXBUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBXZWFrTWFwXSc7XG59XG5pc1dlYWtNYXBUb1N0cmluZy53b3JraW5nID0gKFxuICB0eXBlb2YgV2Vha01hcCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgaXNXZWFrTWFwVG9TdHJpbmcobmV3IFdlYWtNYXAoKSlcbik7XG5mdW5jdGlvbiBpc1dlYWtNYXAodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiBXZWFrTWFwID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBpc1dlYWtNYXBUb1N0cmluZy53b3JraW5nXG4gICAgPyBpc1dlYWtNYXBUb1N0cmluZyh2YWx1ZSlcbiAgICA6IHZhbHVlIGluc3RhbmNlb2YgV2Vha01hcDtcbn1cbmV4cG9ydHMuaXNXZWFrTWFwID0gaXNXZWFrTWFwO1xuXG5mdW5jdGlvbiBpc1dlYWtTZXRUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBXZWFrU2V0XSc7XG59XG5pc1dlYWtTZXRUb1N0cmluZy53b3JraW5nID0gKFxuICB0eXBlb2YgV2Vha1NldCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgaXNXZWFrU2V0VG9TdHJpbmcobmV3IFdlYWtTZXQoKSlcbik7XG5mdW5jdGlvbiBpc1dlYWtTZXQodmFsdWUpIHtcbiAgcmV0dXJuIGlzV2Vha1NldFRvU3RyaW5nKHZhbHVlKTtcbn1cbmV4cG9ydHMuaXNXZWFrU2V0ID0gaXNXZWFrU2V0O1xuXG5mdW5jdGlvbiBpc0FycmF5QnVmZmVyVG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJztcbn1cbmlzQXJyYXlCdWZmZXJUb1N0cmluZy53b3JraW5nID0gKFxuICB0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmXG4gIGlzQXJyYXlCdWZmZXJUb1N0cmluZyhuZXcgQXJyYXlCdWZmZXIoKSlcbik7XG5mdW5jdGlvbiBpc0FycmF5QnVmZmVyKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGlzQXJyYXlCdWZmZXJUb1N0cmluZy53b3JraW5nXG4gICAgPyBpc0FycmF5QnVmZmVyVG9TdHJpbmcodmFsdWUpXG4gICAgOiB2YWx1ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyO1xufVxuZXhwb3J0cy5pc0FycmF5QnVmZmVyID0gaXNBcnJheUJ1ZmZlcjtcblxuZnVuY3Rpb24gaXNEYXRhVmlld1RvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3RUb1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IERhdGFWaWV3XSc7XG59XG5pc0RhdGFWaWV3VG9TdHJpbmcud29ya2luZyA9IChcbiAgdHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJlxuICB0eXBlb2YgRGF0YVZpZXcgIT09ICd1bmRlZmluZWQnICYmXG4gIGlzRGF0YVZpZXdUb1N0cmluZyhuZXcgRGF0YVZpZXcobmV3IEFycmF5QnVmZmVyKDEpLCAwLCAxKSlcbik7XG5mdW5jdGlvbiBpc0RhdGFWaWV3KHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgRGF0YVZpZXcgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGlzRGF0YVZpZXdUb1N0cmluZy53b3JraW5nXG4gICAgPyBpc0RhdGFWaWV3VG9TdHJpbmcodmFsdWUpXG4gICAgOiB2YWx1ZSBpbnN0YW5jZW9mIERhdGFWaWV3O1xufVxuZXhwb3J0cy5pc0RhdGFWaWV3ID0gaXNEYXRhVmlldztcblxuLy8gU3RvcmUgYSBjb3B5IG9mIFNoYXJlZEFycmF5QnVmZmVyIGluIGNhc2UgaXQncyBkZWxldGVkIGVsc2V3aGVyZVxudmFyIFNoYXJlZEFycmF5QnVmZmVyQ29weSA9IHR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgPyBTaGFyZWRBcnJheUJ1ZmZlciA6IHVuZGVmaW5lZDtcbmZ1bmN0aW9uIGlzU2hhcmVkQXJyYXlCdWZmZXJUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBTaGFyZWRBcnJheUJ1ZmZlcl0nO1xufVxuZnVuY3Rpb24gaXNTaGFyZWRBcnJheUJ1ZmZlcih2YWx1ZSkge1xuICBpZiAodHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyQ29weSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAodHlwZW9mIGlzU2hhcmVkQXJyYXlCdWZmZXJUb1N0cmluZy53b3JraW5nID09PSAndW5kZWZpbmVkJykge1xuICAgIGlzU2hhcmVkQXJyYXlCdWZmZXJUb1N0cmluZy53b3JraW5nID0gaXNTaGFyZWRBcnJheUJ1ZmZlclRvU3RyaW5nKG5ldyBTaGFyZWRBcnJheUJ1ZmZlckNvcHkoKSk7XG4gIH1cblxuICByZXR1cm4gaXNTaGFyZWRBcnJheUJ1ZmZlclRvU3RyaW5nLndvcmtpbmdcbiAgICA/IGlzU2hhcmVkQXJyYXlCdWZmZXJUb1N0cmluZyh2YWx1ZSlcbiAgICA6IHZhbHVlIGluc3RhbmNlb2YgU2hhcmVkQXJyYXlCdWZmZXJDb3B5O1xufVxuZXhwb3J0cy5pc1NoYXJlZEFycmF5QnVmZmVyID0gaXNTaGFyZWRBcnJheUJ1ZmZlcjtcblxuZnVuY3Rpb24gaXNBc3luY0Z1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3RUb1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IEFzeW5jRnVuY3Rpb25dJztcbn1cbmV4cG9ydHMuaXNBc3luY0Z1bmN0aW9uID0gaXNBc3luY0Z1bmN0aW9uO1xuXG5mdW5jdGlvbiBpc01hcEl0ZXJhdG9yKHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3RUb1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IE1hcCBJdGVyYXRvcl0nO1xufVxuZXhwb3J0cy5pc01hcEl0ZXJhdG9yID0gaXNNYXBJdGVyYXRvcjtcblxuZnVuY3Rpb24gaXNTZXRJdGVyYXRvcih2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBTZXQgSXRlcmF0b3JdJztcbn1cbmV4cG9ydHMuaXNTZXRJdGVyYXRvciA9IGlzU2V0SXRlcmF0b3I7XG5cbmZ1bmN0aW9uIGlzR2VuZXJhdG9yT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3RUb1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IEdlbmVyYXRvcl0nO1xufVxuZXhwb3J0cy5pc0dlbmVyYXRvck9iamVjdCA9IGlzR2VuZXJhdG9yT2JqZWN0O1xuXG5mdW5jdGlvbiBpc1dlYkFzc2VtYmx5Q29tcGlsZWRNb2R1bGUodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgV2ViQXNzZW1ibHkuTW9kdWxlXSc7XG59XG5leHBvcnRzLmlzV2ViQXNzZW1ibHlDb21waWxlZE1vZHVsZSA9IGlzV2ViQXNzZW1ibHlDb21waWxlZE1vZHVsZTtcblxuZnVuY3Rpb24gaXNOdW1iZXJPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIGNoZWNrQm94ZWRQcmltaXRpdmUodmFsdWUsIG51bWJlclZhbHVlKTtcbn1cbmV4cG9ydHMuaXNOdW1iZXJPYmplY3QgPSBpc051bWJlck9iamVjdDtcblxuZnVuY3Rpb24gaXNTdHJpbmdPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIGNoZWNrQm94ZWRQcmltaXRpdmUodmFsdWUsIHN0cmluZ1ZhbHVlKTtcbn1cbmV4cG9ydHMuaXNTdHJpbmdPYmplY3QgPSBpc1N0cmluZ09iamVjdDtcblxuZnVuY3Rpb24gaXNCb29sZWFuT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBjaGVja0JveGVkUHJpbWl0aXZlKHZhbHVlLCBib29sZWFuVmFsdWUpO1xufVxuZXhwb3J0cy5pc0Jvb2xlYW5PYmplY3QgPSBpc0Jvb2xlYW5PYmplY3Q7XG5cbmZ1bmN0aW9uIGlzQmlnSW50T2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBCaWdJbnRTdXBwb3J0ZWQgJiYgY2hlY2tCb3hlZFByaW1pdGl2ZSh2YWx1ZSwgYmlnSW50VmFsdWUpO1xufVxuZXhwb3J0cy5pc0JpZ0ludE9iamVjdCA9IGlzQmlnSW50T2JqZWN0O1xuXG5mdW5jdGlvbiBpc1N5bWJvbE9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gU3ltYm9sU3VwcG9ydGVkICYmIGNoZWNrQm94ZWRQcmltaXRpdmUodmFsdWUsIHN5bWJvbFZhbHVlKTtcbn1cbmV4cG9ydHMuaXNTeW1ib2xPYmplY3QgPSBpc1N5bWJvbE9iamVjdDtcblxuZnVuY3Rpb24gaXNCb3hlZFByaW1pdGl2ZSh2YWx1ZSkge1xuICByZXR1cm4gKFxuICAgIGlzTnVtYmVyT2JqZWN0KHZhbHVlKSB8fFxuICAgIGlzU3RyaW5nT2JqZWN0KHZhbHVlKSB8fFxuICAgIGlzQm9vbGVhbk9iamVjdCh2YWx1ZSkgfHxcbiAgICBpc0JpZ0ludE9iamVjdCh2YWx1ZSkgfHxcbiAgICBpc1N5bWJvbE9iamVjdCh2YWx1ZSlcbiAgKTtcbn1cbmV4cG9ydHMuaXNCb3hlZFByaW1pdGl2ZSA9IGlzQm94ZWRQcmltaXRpdmU7XG5cbmZ1bmN0aW9uIGlzQW55QXJyYXlCdWZmZXIodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJyAmJiAoXG4gICAgaXNBcnJheUJ1ZmZlcih2YWx1ZSkgfHxcbiAgICBpc1NoYXJlZEFycmF5QnVmZmVyKHZhbHVlKVxuICApO1xufVxuZXhwb3J0cy5pc0FueUFycmF5QnVmZmVyID0gaXNBbnlBcnJheUJ1ZmZlcjtcblxuWydpc1Byb3h5JywgJ2lzRXh0ZXJuYWwnLCAnaXNNb2R1bGVOYW1lc3BhY2VPYmplY3QnXS5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbWV0aG9kLCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKG1ldGhvZCArICcgaXMgbm90IHN1cHBvcnRlZCBpbiB1c2VybGFuZCcpO1xuICAgIH1cbiAgfSk7XG59KTtcbiIsICJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQnVmZmVyKGFyZykge1xuICByZXR1cm4gYXJnICYmIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnXG4gICAgJiYgdHlwZW9mIGFyZy5jb3B5ID09PSAnZnVuY3Rpb24nXG4gICAgJiYgdHlwZW9mIGFyZy5maWxsID09PSAnZnVuY3Rpb24nXG4gICAgJiYgdHlwZW9mIGFyZy5yZWFkVUludDggPT09ICdmdW5jdGlvbic7XG59IiwgImlmICh0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAvLyBpbXBsZW1lbnRhdGlvbiBmcm9tIHN0YW5kYXJkIG5vZGUuanMgJ3V0aWwnIG1vZHVsZVxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGlmIChzdXBlckN0b3IpIHtcbiAgICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICAgIHZhbHVlOiBjdG9yLFxuICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfTtcbn0gZWxzZSB7XG4gIC8vIG9sZCBzY2hvb2wgc2hpbSBmb3Igb2xkIGJyb3dzZXJzXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgaWYgKHN1cGVyQ3Rvcikge1xuICAgICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICAgIHZhciBUZW1wQ3RvciA9IGZ1bmN0aW9uICgpIHt9XG4gICAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlXG4gICAgICBjdG9yLnByb3RvdHlwZSA9IG5ldyBUZW1wQ3RvcigpXG4gICAgICBjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGN0b3JcbiAgICB9XG4gIH1cbn1cbiIsICIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyB8fFxuICBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKG9iaikge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgICB2YXIgZGVzY3JpcHRvcnMgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGRlc2NyaXB0b3JzW2tleXNbaV1dID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleXNbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gZGVzY3JpcHRvcnM7XG4gIH07XG5cbnZhciBmb3JtYXRSZWdFeHAgPSAvJVtzZGolXS9nO1xuZXhwb3J0cy5mb3JtYXQgPSBmdW5jdGlvbihmKSB7XG4gIGlmICghaXNTdHJpbmcoZikpIHtcbiAgICB2YXIgb2JqZWN0cyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBvYmplY3RzLnB1c2goaW5zcGVjdChhcmd1bWVudHNbaV0pKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdHMuam9pbignICcpO1xuICB9XG5cbiAgdmFyIGkgPSAxO1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgdmFyIGxlbiA9IGFyZ3MubGVuZ3RoO1xuICB2YXIgc3RyID0gU3RyaW5nKGYpLnJlcGxhY2UoZm9ybWF0UmVnRXhwLCBmdW5jdGlvbih4KSB7XG4gICAgaWYgKHggPT09ICclJScpIHJldHVybiAnJSc7XG4gICAgaWYgKGkgPj0gbGVuKSByZXR1cm4geDtcbiAgICBzd2l0Y2ggKHgpIHtcbiAgICAgIGNhc2UgJyVzJzogcmV0dXJuIFN0cmluZyhhcmdzW2krK10pO1xuICAgICAgY2FzZSAnJWQnOiByZXR1cm4gTnVtYmVyKGFyZ3NbaSsrXSk7XG4gICAgICBjYXNlICclaic6XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGFyZ3NbaSsrXSk7XG4gICAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgICByZXR1cm4gJ1tDaXJjdWxhcl0nO1xuICAgICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4geDtcbiAgICB9XG4gIH0pO1xuICBmb3IgKHZhciB4ID0gYXJnc1tpXTsgaSA8IGxlbjsgeCA9IGFyZ3NbKytpXSkge1xuICAgIGlmIChpc051bGwoeCkgfHwgIWlzT2JqZWN0KHgpKSB7XG4gICAgICBzdHIgKz0gJyAnICsgeDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyICs9ICcgJyArIGluc3BlY3QoeCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdHI7XG59O1xuXG5cbi8vIE1hcmsgdGhhdCBhIG1ldGhvZCBzaG91bGQgbm90IGJlIHVzZWQuXG4vLyBSZXR1cm5zIGEgbW9kaWZpZWQgZnVuY3Rpb24gd2hpY2ggd2FybnMgb25jZSBieSBkZWZhdWx0LlxuLy8gSWYgLS1uby1kZXByZWNhdGlvbiBpcyBzZXQsIHRoZW4gaXQgaXMgYSBuby1vcC5cbmV4cG9ydHMuZGVwcmVjYXRlID0gZnVuY3Rpb24oZm4sIG1zZykge1xuICBpZiAodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHByb2Nlc3Mubm9EZXByZWNhdGlvbiA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiBmbjtcbiAgfVxuXG4gIC8vIEFsbG93IGZvciBkZXByZWNhdGluZyB0aGluZ3MgaW4gdGhlIHByb2Nlc3Mgb2Ygc3RhcnRpbmcgdXAuXG4gIGlmICh0eXBlb2YgcHJvY2VzcyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZXhwb3J0cy5kZXByZWNhdGUoZm4sIG1zZykuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9XG5cbiAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBkZXByZWNhdGVkKCkge1xuICAgIGlmICghd2FybmVkKSB7XG4gICAgICBpZiAocHJvY2Vzcy50aHJvd0RlcHJlY2F0aW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLnRyYWNlRGVwcmVjYXRpb24pIHtcbiAgICAgICAgY29uc29sZS50cmFjZShtc2cpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihtc2cpO1xuICAgICAgfVxuICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICByZXR1cm4gZGVwcmVjYXRlZDtcbn07XG5cblxudmFyIGRlYnVncyA9IHt9O1xudmFyIGRlYnVnRW52UmVnZXggPSAvXiQvO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9ERUJVRykge1xuICB2YXIgZGVidWdFbnYgPSBwcm9jZXNzLmVudi5OT0RFX0RFQlVHO1xuICBkZWJ1Z0VudiA9IGRlYnVnRW52LnJlcGxhY2UoL1t8XFxcXHt9KClbXFxdXiQrPy5dL2csICdcXFxcJCYnKVxuICAgIC5yZXBsYWNlKC9cXCovZywgJy4qJylcbiAgICAucmVwbGFjZSgvLC9nLCAnJHxeJylcbiAgICAudG9VcHBlckNhc2UoKTtcbiAgZGVidWdFbnZSZWdleCA9IG5ldyBSZWdFeHAoJ14nICsgZGVidWdFbnYgKyAnJCcsICdpJyk7XG59XG5leHBvcnRzLmRlYnVnbG9nID0gZnVuY3Rpb24oc2V0KSB7XG4gIHNldCA9IHNldC50b1VwcGVyQ2FzZSgpO1xuICBpZiAoIWRlYnVnc1tzZXRdKSB7XG4gICAgaWYgKGRlYnVnRW52UmVnZXgudGVzdChzZXQpKSB7XG4gICAgICB2YXIgcGlkID0gcHJvY2Vzcy5waWQ7XG4gICAgICBkZWJ1Z3Nbc2V0XSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbXNnID0gZXhwb3J0cy5mb3JtYXQuYXBwbHkoZXhwb3J0cywgYXJndW1lbnRzKTtcbiAgICAgICAgY29uc29sZS5lcnJvcignJXMgJWQ6ICVzJywgc2V0LCBwaWQsIG1zZyk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWJ1Z3Nbc2V0XSA9IGZ1bmN0aW9uKCkge307XG4gICAgfVxuICB9XG4gIHJldHVybiBkZWJ1Z3Nbc2V0XTtcbn07XG5cblxuLyoqXG4gKiBFY2hvcyB0aGUgdmFsdWUgb2YgYSB2YWx1ZS4gVHJ5cyB0byBwcmludCB0aGUgdmFsdWUgb3V0XG4gKiBpbiB0aGUgYmVzdCB3YXkgcG9zc2libGUgZ2l2ZW4gdGhlIGRpZmZlcmVudCB0eXBlcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gcHJpbnQgb3V0LlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMgT3B0aW9uYWwgb3B0aW9ucyBvYmplY3QgdGhhdCBhbHRlcnMgdGhlIG91dHB1dC5cbiAqL1xuLyogbGVnYWN5OiBvYmosIHNob3dIaWRkZW4sIGRlcHRoLCBjb2xvcnMqL1xuZnVuY3Rpb24gaW5zcGVjdChvYmosIG9wdHMpIHtcbiAgLy8gZGVmYXVsdCBvcHRpb25zXG4gIHZhciBjdHggPSB7XG4gICAgc2VlbjogW10sXG4gICAgc3R5bGl6ZTogc3R5bGl6ZU5vQ29sb3JcbiAgfTtcbiAgLy8gbGVnYWN5Li4uXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDMpIGN0eC5kZXB0aCA9IGFyZ3VtZW50c1syXTtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gNCkgY3R4LmNvbG9ycyA9IGFyZ3VtZW50c1szXTtcbiAgaWYgKGlzQm9vbGVhbihvcHRzKSkge1xuICAgIC8vIGxlZ2FjeS4uLlxuICAgIGN0eC5zaG93SGlkZGVuID0gb3B0cztcbiAgfSBlbHNlIGlmIChvcHRzKSB7XG4gICAgLy8gZ290IGFuIFwib3B0aW9uc1wiIG9iamVjdFxuICAgIGV4cG9ydHMuX2V4dGVuZChjdHgsIG9wdHMpO1xuICB9XG4gIC8vIHNldCBkZWZhdWx0IG9wdGlvbnNcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5zaG93SGlkZGVuKSkgY3R4LnNob3dIaWRkZW4gPSBmYWxzZTtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5kZXB0aCkpIGN0eC5kZXB0aCA9IDI7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguY29sb3JzKSkgY3R4LmNvbG9ycyA9IGZhbHNlO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmN1c3RvbUluc3BlY3QpKSBjdHguY3VzdG9tSW5zcGVjdCA9IHRydWU7XG4gIGlmIChjdHguY29sb3JzKSBjdHguc3R5bGl6ZSA9IHN0eWxpemVXaXRoQ29sb3I7XG4gIHJldHVybiBmb3JtYXRWYWx1ZShjdHgsIG9iaiwgY3R4LmRlcHRoKTtcbn1cbmV4cG9ydHMuaW5zcGVjdCA9IGluc3BlY3Q7XG5cblxuLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9BTlNJX2VzY2FwZV9jb2RlI2dyYXBoaWNzXG5pbnNwZWN0LmNvbG9ycyA9IHtcbiAgJ2JvbGQnIDogWzEsIDIyXSxcbiAgJ2l0YWxpYycgOiBbMywgMjNdLFxuICAndW5kZXJsaW5lJyA6IFs0LCAyNF0sXG4gICdpbnZlcnNlJyA6IFs3LCAyN10sXG4gICd3aGl0ZScgOiBbMzcsIDM5XSxcbiAgJ2dyZXknIDogWzkwLCAzOV0sXG4gICdibGFjaycgOiBbMzAsIDM5XSxcbiAgJ2JsdWUnIDogWzM0LCAzOV0sXG4gICdjeWFuJyA6IFszNiwgMzldLFxuICAnZ3JlZW4nIDogWzMyLCAzOV0sXG4gICdtYWdlbnRhJyA6IFszNSwgMzldLFxuICAncmVkJyA6IFszMSwgMzldLFxuICAneWVsbG93JyA6IFszMywgMzldXG59O1xuXG4vLyBEb24ndCB1c2UgJ2JsdWUnIG5vdCB2aXNpYmxlIG9uIGNtZC5leGVcbmluc3BlY3Quc3R5bGVzID0ge1xuICAnc3BlY2lhbCc6ICdjeWFuJyxcbiAgJ251bWJlcic6ICd5ZWxsb3cnLFxuICAnYm9vbGVhbic6ICd5ZWxsb3cnLFxuICAndW5kZWZpbmVkJzogJ2dyZXknLFxuICAnbnVsbCc6ICdib2xkJyxcbiAgJ3N0cmluZyc6ICdncmVlbicsXG4gICdkYXRlJzogJ21hZ2VudGEnLFxuICAvLyBcIm5hbWVcIjogaW50ZW50aW9uYWxseSBub3Qgc3R5bGluZ1xuICAncmVnZXhwJzogJ3JlZCdcbn07XG5cblxuZnVuY3Rpb24gc3R5bGl6ZVdpdGhDb2xvcihzdHIsIHN0eWxlVHlwZSkge1xuICB2YXIgc3R5bGUgPSBpbnNwZWN0LnN0eWxlc1tzdHlsZVR5cGVdO1xuXG4gIGlmIChzdHlsZSkge1xuICAgIHJldHVybiAnXFx1MDAxYlsnICsgaW5zcGVjdC5jb2xvcnNbc3R5bGVdWzBdICsgJ20nICsgc3RyICtcbiAgICAgICAgICAgJ1xcdTAwMWJbJyArIGluc3BlY3QuY29sb3JzW3N0eWxlXVsxXSArICdtJztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG59XG5cblxuZnVuY3Rpb24gc3R5bGl6ZU5vQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHtcbiAgcmV0dXJuIHN0cjtcbn1cblxuXG5mdW5jdGlvbiBhcnJheVRvSGFzaChhcnJheSkge1xuICB2YXIgaGFzaCA9IHt9O1xuXG4gIGFycmF5LmZvckVhY2goZnVuY3Rpb24odmFsLCBpZHgpIHtcbiAgICBoYXNoW3ZhbF0gPSB0cnVlO1xuICB9KTtcblxuICByZXR1cm4gaGFzaDtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRWYWx1ZShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMpIHtcbiAgLy8gUHJvdmlkZSBhIGhvb2sgZm9yIHVzZXItc3BlY2lmaWVkIGluc3BlY3QgZnVuY3Rpb25zLlxuICAvLyBDaGVjayB0aGF0IHZhbHVlIGlzIGFuIG9iamVjdCB3aXRoIGFuIGluc3BlY3QgZnVuY3Rpb24gb24gaXRcbiAgaWYgKGN0eC5jdXN0b21JbnNwZWN0ICYmXG4gICAgICB2YWx1ZSAmJlxuICAgICAgaXNGdW5jdGlvbih2YWx1ZS5pbnNwZWN0KSAmJlxuICAgICAgLy8gRmlsdGVyIG91dCB0aGUgdXRpbCBtb2R1bGUsIGl0J3MgaW5zcGVjdCBmdW5jdGlvbiBpcyBzcGVjaWFsXG4gICAgICB2YWx1ZS5pbnNwZWN0ICE9PSBleHBvcnRzLmluc3BlY3QgJiZcbiAgICAgIC8vIEFsc28gZmlsdGVyIG91dCBhbnkgcHJvdG90eXBlIG9iamVjdHMgdXNpbmcgdGhlIGNpcmN1bGFyIGNoZWNrLlxuICAgICAgISh2YWx1ZS5jb25zdHJ1Y3RvciAmJiB2YWx1ZS5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgPT09IHZhbHVlKSkge1xuICAgIHZhciByZXQgPSB2YWx1ZS5pbnNwZWN0KHJlY3Vyc2VUaW1lcywgY3R4KTtcbiAgICBpZiAoIWlzU3RyaW5nKHJldCkpIHtcbiAgICAgIHJldCA9IGZvcm1hdFZhbHVlKGN0eCwgcmV0LCByZWN1cnNlVGltZXMpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgLy8gUHJpbWl0aXZlIHR5cGVzIGNhbm5vdCBoYXZlIHByb3BlcnRpZXNcbiAgdmFyIHByaW1pdGl2ZSA9IGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKTtcbiAgaWYgKHByaW1pdGl2ZSkge1xuICAgIHJldHVybiBwcmltaXRpdmU7XG4gIH1cblxuICAvLyBMb29rIHVwIHRoZSBrZXlzIG9mIHRoZSBvYmplY3QuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXModmFsdWUpO1xuICB2YXIgdmlzaWJsZUtleXMgPSBhcnJheVRvSGFzaChrZXlzKTtcblxuICBpZiAoY3R4LnNob3dIaWRkZW4pIHtcbiAgICBrZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModmFsdWUpO1xuICB9XG5cbiAgLy8gSUUgZG9lc24ndCBtYWtlIGVycm9yIGZpZWxkcyBub24tZW51bWVyYWJsZVxuICAvLyBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvaWUvZHd3NTJzYnQodj12cy45NCkuYXNweFxuICBpZiAoaXNFcnJvcih2YWx1ZSlcbiAgICAgICYmIChrZXlzLmluZGV4T2YoJ21lc3NhZ2UnKSA+PSAwIHx8IGtleXMuaW5kZXhPZignZGVzY3JpcHRpb24nKSA+PSAwKSkge1xuICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gIH1cblxuICAvLyBTb21lIHR5cGUgb2Ygb2JqZWN0IHdpdGhvdXQgcHJvcGVydGllcyBjYW4gYmUgc2hvcnRjdXR0ZWQuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgdmFyIG5hbWUgPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW0Z1bmN0aW9uJyArIG5hbWUgKyAnXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7XG4gICAgfVxuICAgIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdkYXRlJyk7XG4gICAgfVxuICAgIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICB2YXIgYmFzZSA9ICcnLCBhcnJheSA9IGZhbHNlLCBicmFjZXMgPSBbJ3snLCAnfSddO1xuXG4gIC8vIE1ha2UgQXJyYXkgc2F5IHRoYXQgdGhleSBhcmUgQXJyYXlcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgYXJyYXkgPSB0cnVlO1xuICAgIGJyYWNlcyA9IFsnWycsICddJ107XG4gIH1cblxuICAvLyBNYWtlIGZ1bmN0aW9ucyBzYXkgdGhhdCB0aGV5IGFyZSBmdW5jdGlvbnNcbiAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgdmFyIG4gPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcbiAgICBiYXNlID0gJyBbRnVuY3Rpb24nICsgbiArICddJztcbiAgfVxuXG4gIC8vIE1ha2UgUmVnRXhwcyBzYXkgdGhhdCB0aGV5IGFyZSBSZWdFeHBzXG4gIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZGF0ZXMgd2l0aCBwcm9wZXJ0aWVzIGZpcnN0IHNheSB0aGUgZGF0ZVxuICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBEYXRlLnByb3RvdHlwZS50b1VUQ1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZXJyb3Igd2l0aCBtZXNzYWdlIGZpcnN0IHNheSB0aGUgZXJyb3JcbiAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgfVxuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCAmJiAoIWFycmF5IHx8IHZhbHVlLmxlbmd0aCA9PSAwKSkge1xuICAgIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgYnJhY2VzWzFdO1xuICB9XG5cbiAgaWYgKHJlY3Vyc2VUaW1lcyA8IDApIHtcbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tPYmplY3RdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cblxuICBjdHguc2Vlbi5wdXNoKHZhbHVlKTtcblxuICB2YXIgb3V0cHV0O1xuICBpZiAoYXJyYXkpIHtcbiAgICBvdXRwdXQgPSBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKTtcbiAgfSBlbHNlIHtcbiAgICBvdXRwdXQgPSBrZXlzLm1hcChmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KTtcbiAgICB9KTtcbiAgfVxuXG4gIGN0eC5zZWVuLnBvcCgpO1xuXG4gIHJldHVybiByZWR1Y2VUb1NpbmdsZVN0cmluZyhvdXRwdXQsIGJhc2UsIGJyYWNlcyk7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpIHtcbiAgaWYgKGlzVW5kZWZpbmVkKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ3VuZGVmaW5lZCcsICd1bmRlZmluZWQnKTtcbiAgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xuICAgIHZhciBzaW1wbGUgPSAnXFwnJyArIEpTT04uc3RyaW5naWZ5KHZhbHVlKS5yZXBsYWNlKC9eXCJ8XCIkL2csICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKSArICdcXCcnO1xuICAgIHJldHVybiBjdHguc3R5bGl6ZShzaW1wbGUsICdzdHJpbmcnKTtcbiAgfVxuICBpZiAoaXNOdW1iZXIodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnbnVtYmVyJyk7XG4gIGlmIChpc0Jvb2xlYW4odmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnYm9vbGVhbicpO1xuICAvLyBGb3Igc29tZSByZWFzb24gdHlwZW9mIG51bGwgaXMgXCJvYmplY3RcIiwgc28gc3BlY2lhbCBjYXNlIGhlcmUuXG4gIGlmIChpc051bGwodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnbnVsbCcsICdudWxsJyk7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0RXJyb3IodmFsdWUpIHtcbiAgcmV0dXJuICdbJyArIEVycm9yLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSArICddJztcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKSB7XG4gIHZhciBvdXRwdXQgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkodmFsdWUsIFN0cmluZyhpKSkpIHtcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXG4gICAgICAgICAgU3RyaW5nKGkpLCB0cnVlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dHB1dC5wdXNoKCcnKTtcbiAgICB9XG4gIH1cbiAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgIGlmICgha2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cyxcbiAgICAgICAgICBrZXksIHRydWUpKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gb3V0cHV0O1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpIHtcbiAgdmFyIG5hbWUsIHN0ciwgZGVzYztcbiAgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodmFsdWUsIGtleSkgfHwgeyB2YWx1ZTogdmFsdWVba2V5XSB9O1xuICBpZiAoZGVzYy5nZXQpIHtcbiAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyL1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbU2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG4gIGlmICghaGFzT3duUHJvcGVydHkodmlzaWJsZUtleXMsIGtleSkpIHtcbiAgICBuYW1lID0gJ1snICsga2V5ICsgJ10nO1xuICB9XG4gIGlmICghc3RyKSB7XG4gICAgaWYgKGN0eC5zZWVuLmluZGV4T2YoZGVzYy52YWx1ZSkgPCAwKSB7XG4gICAgICBpZiAoaXNOdWxsKHJlY3Vyc2VUaW1lcykpIHtcbiAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCBkZXNjLnZhbHVlLCBudWxsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgcmVjdXJzZVRpbWVzIC0gMSk7XG4gICAgICB9XG4gICAgICBpZiAoc3RyLmluZGV4T2YoJ1xcbicpID4gLTEpIHtcbiAgICAgICAgaWYgKGFycmF5KSB7XG4gICAgICAgICAgc3RyID0gc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICcgICcgKyBsaW5lO1xuICAgICAgICAgIH0pLmpvaW4oJ1xcbicpLnNsaWNlKDIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0ciA9ICdcXG4nICsgc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICcgICAnICsgbGluZTtcbiAgICAgICAgICB9KS5qb2luKCdcXG4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0NpcmN1bGFyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG4gIGlmIChpc1VuZGVmaW5lZChuYW1lKSkge1xuICAgIGlmIChhcnJheSAmJiBrZXkubWF0Y2goL15cXGQrJC8pKSB7XG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgICBuYW1lID0gSlNPTi5zdHJpbmdpZnkoJycgKyBrZXkpO1xuICAgIGlmIChuYW1lLm1hdGNoKC9eXCIoW2EtekEtWl9dW2EtekEtWl8wLTldKilcIiQvKSkge1xuICAgICAgbmFtZSA9IG5hbWUuc2xpY2UoMSwgLTEpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICduYW1lJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpXG4gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8oXlwifFwiJCkvZywgXCInXCIpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICdzdHJpbmcnKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmFtZSArICc6ICcgKyBzdHI7XG59XG5cblxuZnVuY3Rpb24gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpIHtcbiAgdmFyIG51bUxpbmVzRXN0ID0gMDtcbiAgdmFyIGxlbmd0aCA9IG91dHB1dC5yZWR1Y2UoZnVuY3Rpb24ocHJldiwgY3VyKSB7XG4gICAgbnVtTGluZXNFc3QrKztcbiAgICBpZiAoY3VyLmluZGV4T2YoJ1xcbicpID49IDApIG51bUxpbmVzRXN0Kys7XG4gICAgcmV0dXJuIHByZXYgKyBjdXIucmVwbGFjZSgvXFx1MDAxYlxcW1xcZFxcZD9tL2csICcnKS5sZW5ndGggKyAxO1xuICB9LCAwKTtcblxuICBpZiAobGVuZ3RoID4gNjApIHtcbiAgICByZXR1cm4gYnJhY2VzWzBdICtcbiAgICAgICAgICAgKGJhc2UgPT09ICcnID8gJycgOiBiYXNlICsgJ1xcbiAnKSArXG4gICAgICAgICAgICcgJyArXG4gICAgICAgICAgIG91dHB1dC5qb2luKCcsXFxuICAnKSArXG4gICAgICAgICAgICcgJyArXG4gICAgICAgICAgIGJyYWNlc1sxXTtcbiAgfVxuXG4gIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgJyAnICsgb3V0cHV0LmpvaW4oJywgJykgKyAnICcgKyBicmFjZXNbMV07XG59XG5cblxuLy8gTk9URTogVGhlc2UgdHlwZSBjaGVja2luZyBmdW5jdGlvbnMgaW50ZW50aW9uYWxseSBkb24ndCB1c2UgYGluc3RhbmNlb2ZgXG4vLyBiZWNhdXNlIGl0IGlzIGZyYWdpbGUgYW5kIGNhbiBiZSBlYXNpbHkgZmFrZWQgd2l0aCBgT2JqZWN0LmNyZWF0ZSgpYC5cbmV4cG9ydHMudHlwZXMgPSByZXF1aXJlKCcuL3N1cHBvcnQvdHlwZXMnKTtcblxuZnVuY3Rpb24gaXNBcnJheShhcikge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShhcik7XG59XG5leHBvcnRzLmlzQXJyYXkgPSBpc0FycmF5O1xuXG5mdW5jdGlvbiBpc0Jvb2xlYW4oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnYm9vbGVhbic7XG59XG5leHBvcnRzLmlzQm9vbGVhbiA9IGlzQm9vbGVhbjtcblxuZnVuY3Rpb24gaXNOdWxsKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGwgPSBpc051bGw7XG5cbmZ1bmN0aW9uIGlzTnVsbE9yVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbE9yVW5kZWZpbmVkID0gaXNOdWxsT3JVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG59XG5leHBvcnRzLmlzTnVtYmVyID0gaXNOdW1iZXI7XG5cbmZ1bmN0aW9uIGlzU3RyaW5nKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N0cmluZyc7XG59XG5leHBvcnRzLmlzU3RyaW5nID0gaXNTdHJpbmc7XG5cbmZ1bmN0aW9uIGlzU3ltYm9sKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCc7XG59XG5leHBvcnRzLmlzU3ltYm9sID0gaXNTeW1ib2w7XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG59XG5leHBvcnRzLmlzVW5kZWZpbmVkID0gaXNVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzUmVnRXhwKHJlKSB7XG4gIHJldHVybiBpc09iamVjdChyZSkgJiYgb2JqZWN0VG9TdHJpbmcocmUpID09PSAnW29iamVjdCBSZWdFeHBdJztcbn1cbmV4cG9ydHMuaXNSZWdFeHAgPSBpc1JlZ0V4cDtcbmV4cG9ydHMudHlwZXMuaXNSZWdFeHAgPSBpc1JlZ0V4cDtcblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzRGF0ZShkKSB7XG4gIHJldHVybiBpc09iamVjdChkKSAmJiBvYmplY3RUb1N0cmluZyhkKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuZXhwb3J0cy5pc0RhdGUgPSBpc0RhdGU7XG5leHBvcnRzLnR5cGVzLmlzRGF0ZSA9IGlzRGF0ZTtcblxuZnVuY3Rpb24gaXNFcnJvcihlKSB7XG4gIHJldHVybiBpc09iamVjdChlKSAmJlxuICAgICAgKG9iamVjdFRvU3RyaW5nKGUpID09PSAnW29iamVjdCBFcnJvcl0nIHx8IGUgaW5zdGFuY2VvZiBFcnJvcik7XG59XG5leHBvcnRzLmlzRXJyb3IgPSBpc0Vycm9yO1xuZXhwb3J0cy50eXBlcy5pc05hdGl2ZUVycm9yID0gaXNFcnJvcjtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5leHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZShhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbCB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnbnVtYmVyJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnIHx8ICAvLyBFUzYgc3ltYm9sXG4gICAgICAgICB0eXBlb2YgYXJnID09PSAndW5kZWZpbmVkJztcbn1cbmV4cG9ydHMuaXNQcmltaXRpdmUgPSBpc1ByaW1pdGl2ZTtcblxuZXhwb3J0cy5pc0J1ZmZlciA9IHJlcXVpcmUoJy4vc3VwcG9ydC9pc0J1ZmZlcicpO1xuXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyhvKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobyk7XG59XG5cblxuZnVuY3Rpb24gcGFkKG4pIHtcbiAgcmV0dXJuIG4gPCAxMCA/ICcwJyArIG4udG9TdHJpbmcoMTApIDogbi50b1N0cmluZygxMCk7XG59XG5cblxudmFyIG1vbnRocyA9IFsnSmFuJywgJ0ZlYicsICdNYXInLCAnQXByJywgJ01heScsICdKdW4nLCAnSnVsJywgJ0F1ZycsICdTZXAnLFxuICAgICAgICAgICAgICAnT2N0JywgJ05vdicsICdEZWMnXTtcblxuLy8gMjYgRmViIDE2OjE5OjM0XG5mdW5jdGlvbiB0aW1lc3RhbXAoKSB7XG4gIHZhciBkID0gbmV3IERhdGUoKTtcbiAgdmFyIHRpbWUgPSBbcGFkKGQuZ2V0SG91cnMoKSksXG4gICAgICAgICAgICAgIHBhZChkLmdldE1pbnV0ZXMoKSksXG4gICAgICAgICAgICAgIHBhZChkLmdldFNlY29uZHMoKSldLmpvaW4oJzonKTtcbiAgcmV0dXJuIFtkLmdldERhdGUoKSwgbW9udGhzW2QuZ2V0TW9udGgoKV0sIHRpbWVdLmpvaW4oJyAnKTtcbn1cblxuXG4vLyBsb2cgaXMganVzdCBhIHRoaW4gd3JhcHBlciB0byBjb25zb2xlLmxvZyB0aGF0IHByZXBlbmRzIGEgdGltZXN0YW1wXG5leHBvcnRzLmxvZyA9IGZ1bmN0aW9uKCkge1xuICBjb25zb2xlLmxvZygnJXMgLSAlcycsIHRpbWVzdGFtcCgpLCBleHBvcnRzLmZvcm1hdC5hcHBseShleHBvcnRzLCBhcmd1bWVudHMpKTtcbn07XG5cblxuLyoqXG4gKiBJbmhlcml0IHRoZSBwcm90b3R5cGUgbWV0aG9kcyBmcm9tIG9uZSBjb25zdHJ1Y3RvciBpbnRvIGFub3RoZXIuXG4gKlxuICogVGhlIEZ1bmN0aW9uLnByb3RvdHlwZS5pbmhlcml0cyBmcm9tIGxhbmcuanMgcmV3cml0dGVuIGFzIGEgc3RhbmRhbG9uZVxuICogZnVuY3Rpb24gKG5vdCBvbiBGdW5jdGlvbi5wcm90b3R5cGUpLiBOT1RFOiBJZiB0aGlzIGZpbGUgaXMgdG8gYmUgbG9hZGVkXG4gKiBkdXJpbmcgYm9vdHN0cmFwcGluZyB0aGlzIGZ1bmN0aW9uIG5lZWRzIHRvIGJlIHJld3JpdHRlbiB1c2luZyBzb21lIG5hdGl2ZVxuICogZnVuY3Rpb25zIGFzIHByb3RvdHlwZSBzZXR1cCB1c2luZyBub3JtYWwgSmF2YVNjcmlwdCBkb2VzIG5vdCB3b3JrIGFzXG4gKiBleHBlY3RlZCBkdXJpbmcgYm9vdHN0cmFwcGluZyAoc2VlIG1pcnJvci5qcyBpbiByMTE0OTAzKS5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjdG9yIENvbnN0cnVjdG9yIGZ1bmN0aW9uIHdoaWNoIG5lZWRzIHRvIGluaGVyaXQgdGhlXG4gKiAgICAgcHJvdG90eXBlLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gc3VwZXJDdG9yIENvbnN0cnVjdG9yIGZ1bmN0aW9uIHRvIGluaGVyaXQgcHJvdG90eXBlIGZyb20uXG4gKi9cbmV4cG9ydHMuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuXG5leHBvcnRzLl9leHRlbmQgPSBmdW5jdGlvbihvcmlnaW4sIGFkZCkge1xuICAvLyBEb24ndCBkbyBhbnl0aGluZyBpZiBhZGQgaXNuJ3QgYW4gb2JqZWN0XG4gIGlmICghYWRkIHx8ICFpc09iamVjdChhZGQpKSByZXR1cm4gb3JpZ2luO1xuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoYWRkKTtcbiAgdmFyIGkgPSBrZXlzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIG9yaWdpbltrZXlzW2ldXSA9IGFkZFtrZXlzW2ldXTtcbiAgfVxuICByZXR1cm4gb3JpZ2luO1xufTtcblxuZnVuY3Rpb24gaGFzT3duUHJvcGVydHkob2JqLCBwcm9wKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcbn1cblxudmFyIGtDdXN0b21Qcm9taXNpZmllZFN5bWJvbCA9IHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnID8gU3ltYm9sKCd1dGlsLnByb21pc2lmeS5jdXN0b20nKSA6IHVuZGVmaW5lZDtcblxuZXhwb3J0cy5wcm9taXNpZnkgPSBmdW5jdGlvbiBwcm9taXNpZnkob3JpZ2luYWwpIHtcbiAgaWYgKHR5cGVvZiBvcmlnaW5hbCAhPT0gJ2Z1bmN0aW9uJylcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJvcmlnaW5hbFwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbicpO1xuXG4gIGlmIChrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2wgJiYgb3JpZ2luYWxba0N1c3RvbVByb21pc2lmaWVkU3ltYm9sXSkge1xuICAgIHZhciBmbiA9IG9yaWdpbmFsW2tDdXN0b21Qcm9taXNpZmllZFN5bWJvbF07XG4gICAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwidXRpbC5wcm9taXNpZnkuY3VzdG9tXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uJyk7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmbiwga0N1c3RvbVByb21pc2lmaWVkU3ltYm9sLCB7XG4gICAgICB2YWx1ZTogZm4sIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogZmFsc2UsIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBmbjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZuKCkge1xuICAgIHZhciBwcm9taXNlUmVzb2x2ZSwgcHJvbWlzZVJlamVjdDtcbiAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHByb21pc2VSZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgIHByb21pc2VSZWplY3QgPSByZWplY3Q7XG4gICAgfSk7XG5cbiAgICB2YXIgYXJncyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcmdzLnB1c2goYXJndW1lbnRzW2ldKTtcbiAgICB9XG4gICAgYXJncy5wdXNoKGZ1bmN0aW9uIChlcnIsIHZhbHVlKSB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHByb21pc2VSZWplY3QoZXJyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb21pc2VSZXNvbHZlKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRyeSB7XG4gICAgICBvcmlnaW5hbC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHByb21pc2VSZWplY3QoZXJyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxuXG4gIE9iamVjdC5zZXRQcm90b3R5cGVPZihmbiwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG9yaWdpbmFsKSk7XG5cbiAgaWYgKGtDdXN0b21Qcm9taXNpZmllZFN5bWJvbCkgT2JqZWN0LmRlZmluZVByb3BlcnR5KGZuLCBrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2wsIHtcbiAgICB2YWx1ZTogZm4sIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogZmFsc2UsIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFxuICAgIGZuLFxuICAgIGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMob3JpZ2luYWwpXG4gICk7XG59XG5cbmV4cG9ydHMucHJvbWlzaWZ5LmN1c3RvbSA9IGtDdXN0b21Qcm9taXNpZmllZFN5bWJvbFxuXG5mdW5jdGlvbiBjYWxsYmFja2lmeU9uUmVqZWN0ZWQocmVhc29uLCBjYikge1xuICAvLyBgIXJlYXNvbmAgZ3VhcmQgaW5zcGlyZWQgYnkgYmx1ZWJpcmQgKFJlZjogaHR0cHM6Ly9nb28uZ2wvdDVJUzZNKS5cbiAgLy8gQmVjYXVzZSBgbnVsbGAgaXMgYSBzcGVjaWFsIGVycm9yIHZhbHVlIGluIGNhbGxiYWNrcyB3aGljaCBtZWFucyBcIm5vIGVycm9yXG4gIC8vIG9jY3VycmVkXCIsIHdlIGVycm9yLXdyYXAgc28gdGhlIGNhbGxiYWNrIGNvbnN1bWVyIGNhbiBkaXN0aW5ndWlzaCBiZXR3ZWVuXG4gIC8vIFwidGhlIHByb21pc2UgcmVqZWN0ZWQgd2l0aCBudWxsXCIgb3IgXCJ0aGUgcHJvbWlzZSBmdWxmaWxsZWQgd2l0aCB1bmRlZmluZWRcIi5cbiAgaWYgKCFyZWFzb24pIHtcbiAgICB2YXIgbmV3UmVhc29uID0gbmV3IEVycm9yKCdQcm9taXNlIHdhcyByZWplY3RlZCB3aXRoIGEgZmFsc3kgdmFsdWUnKTtcbiAgICBuZXdSZWFzb24ucmVhc29uID0gcmVhc29uO1xuICAgIHJlYXNvbiA9IG5ld1JlYXNvbjtcbiAgfVxuICByZXR1cm4gY2IocmVhc29uKTtcbn1cblxuZnVuY3Rpb24gY2FsbGJhY2tpZnkob3JpZ2luYWwpIHtcbiAgaWYgKHR5cGVvZiBvcmlnaW5hbCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcIm9yaWdpbmFsXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uJyk7XG4gIH1cblxuICAvLyBXZSBETyBOT1QgcmV0dXJuIHRoZSBwcm9taXNlIGFzIGl0IGdpdmVzIHRoZSB1c2VyIGEgZmFsc2Ugc2Vuc2UgdGhhdFxuICAvLyB0aGUgcHJvbWlzZSBpcyBhY3R1YWxseSBzb21laG93IHJlbGF0ZWQgdG8gdGhlIGNhbGxiYWNrJ3MgZXhlY3V0aW9uXG4gIC8vIGFuZCB0aGF0IHRoZSBjYWxsYmFjayB0aHJvd2luZyB3aWxsIHJlamVjdCB0aGUgcHJvbWlzZS5cbiAgZnVuY3Rpb24gY2FsbGJhY2tpZmllZCgpIHtcbiAgICB2YXIgYXJncyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcmdzLnB1c2goYXJndW1lbnRzW2ldKTtcbiAgICB9XG5cbiAgICB2YXIgbWF5YmVDYiA9IGFyZ3MucG9wKCk7XG4gICAgaWYgKHR5cGVvZiBtYXliZUNiICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgbGFzdCBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24nKTtcbiAgICB9XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBjYiA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIG1heWJlQ2IuYXBwbHkoc2VsZiwgYXJndW1lbnRzKTtcbiAgICB9O1xuICAgIC8vIEluIHRydWUgbm9kZSBzdHlsZSB3ZSBwcm9jZXNzIHRoZSBjYWxsYmFjayBvbiBgbmV4dFRpY2tgIHdpdGggYWxsIHRoZVxuICAgIC8vIGltcGxpY2F0aW9ucyAoc3RhY2ssIGB1bmNhdWdodEV4Y2VwdGlvbmAsIGBhc3luY19ob29rc2ApXG4gICAgb3JpZ2luYWwuYXBwbHkodGhpcywgYXJncylcbiAgICAgIC50aGVuKGZ1bmN0aW9uKHJldCkgeyBwcm9jZXNzLm5leHRUaWNrKGNiLmJpbmQobnVsbCwgbnVsbCwgcmV0KSkgfSxcbiAgICAgICAgICAgIGZ1bmN0aW9uKHJlaikgeyBwcm9jZXNzLm5leHRUaWNrKGNhbGxiYWNraWZ5T25SZWplY3RlZC5iaW5kKG51bGwsIHJlaiwgY2IpKSB9KTtcbiAgfVxuXG4gIE9iamVjdC5zZXRQcm90b3R5cGVPZihjYWxsYmFja2lmaWVkLCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob3JpZ2luYWwpKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY2FsbGJhY2tpZmllZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhvcmlnaW5hbCkpO1xuICByZXR1cm4gY2FsbGJhY2tpZmllZDtcbn1cbmV4cG9ydHMuY2FsbGJhY2tpZnkgPSBjYWxsYmFja2lmeTtcbiIsICJcInVzZSBzdHJpY3RcIjtcbi8qKiBAbW9kdWxlICovXG5cbmNvbnN0IGFycmF5UHJvdG8gPSByZXF1aXJlKFwiQHNpbm9uanMvY29tbW9uc1wiKS5wcm90b3R5cGVzLmFycmF5O1xuY29uc3QgY2FsbGVkSW5PcmRlciA9IHJlcXVpcmUoXCJAc2lub25qcy9jb21tb25zXCIpLmNhbGxlZEluT3JkZXI7XG5jb25zdCBjcmVhdGVNYXRjaGVyID0gcmVxdWlyZShcIkBzaW5vbmpzL3NhbXNhbVwiKS5jcmVhdGVNYXRjaGVyO1xuY29uc3Qgb3JkZXJCeUZpcnN0Q2FsbCA9IHJlcXVpcmUoXCJAc2lub25qcy9jb21tb25zXCIpLm9yZGVyQnlGaXJzdENhbGw7XG5jb25zdCB0aW1lc0luV29yZHMgPSByZXF1aXJlKFwiLi91dGlsL2NvcmUvdGltZXMtaW4td29yZHNcIik7XG5jb25zdCBpbnNwZWN0ID0gcmVxdWlyZShcInV0aWxcIikuaW5zcGVjdDtcbmNvbnN0IHN0cmluZ1NsaWNlID0gcmVxdWlyZShcIkBzaW5vbmpzL2NvbW1vbnNcIikucHJvdG90eXBlcy5zdHJpbmcuc2xpY2U7XG5jb25zdCBnbG9iYWxPYmplY3QgPSByZXF1aXJlKFwiQHNpbm9uanMvY29tbW9uc1wiKS5nbG9iYWw7XG5cbmNvbnN0IGFycmF5U2xpY2UgPSBhcnJheVByb3RvLnNsaWNlO1xuY29uc3QgY29uY2F0ID0gYXJyYXlQcm90by5jb25jYXQ7XG5jb25zdCBmb3JFYWNoID0gYXJyYXlQcm90by5mb3JFYWNoO1xuY29uc3Qgam9pbiA9IGFycmF5UHJvdG8uam9pbjtcbmNvbnN0IHNwbGljZSA9IGFycmF5UHJvdG8uc3BsaWNlO1xuXG5mdW5jdGlvbiBhcHBseURlZmF1bHRzKG9iaiwgZGVmYXVsdHMpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhkZWZhdWx0cykpIHtcbiAgICAgICAgY29uc3QgdmFsID0gb2JqW2tleV07XG4gICAgICAgIGlmICh2YWwgPT09IG51bGwgfHwgdHlwZW9mIHZhbCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgb2JqW2tleV0gPSBkZWZhdWx0c1trZXldO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIEB0eXBlZGVmIHtvYmplY3R9IENyZWF0ZUFzc2VydE9wdGlvbnNcbiAqIEBnbG9iYWxcbiAqXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtzaG91bGRMaW1pdEFzc2VydGlvbkxvZ3NdIGRlZmF1bHQgaXMgZmFsc2VcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSAgW2Fzc2VydGlvbkxvZ0xpbWl0XSBkZWZhdWx0IGlzIDEwS1xuICovXG5cbi8qKlxuICogQ3JlYXRlIGFuIGFzc2VydGlvbiBvYmplY3QgdGhhdCBleHBvc2VzIHNldmVyYWwgbWV0aG9kcyB0byBpbnZva2VcbiAqXG4gKiBAcGFyYW0ge0NyZWF0ZUFzc2VydE9wdGlvbnN9ICBbb3B0c10gb3B0aW9ucyBiYWdcbiAqIEByZXR1cm5zIHtvYmplY3R9IG9iamVjdCB3aXRoIG11bHRpcGxlIGFzc2VydGlvbiBtZXRob2RzXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUFzc2VydE9iamVjdChvcHRzKSB7XG4gICAgY29uc3QgY2xlYW5lZEFzc2VydE9wdGlvbnMgPSBvcHRzIHx8IHt9O1xuICAgIGFwcGx5RGVmYXVsdHMoY2xlYW5lZEFzc2VydE9wdGlvbnMsIHtcbiAgICAgICAgc2hvdWxkTGltaXRBc3NlcnRpb25Mb2dzOiBmYWxzZSxcbiAgICAgICAgYXNzZXJ0aW9uTG9nTGltaXQ6IDFlNCxcbiAgICB9KTtcblxuICAgIGNvbnN0IGFzc2VydCA9IHtcbiAgICAgICAgZmFpbDogZnVuY3Rpb24gZmFpbChtZXNzYWdlKSB7XG4gICAgICAgICAgICBsZXQgbXNnID0gbWVzc2FnZTtcbiAgICAgICAgICAgIGlmIChjbGVhbmVkQXNzZXJ0T3B0aW9ucy5zaG91bGRMaW1pdEFzc2VydGlvbkxvZ3MpIHtcbiAgICAgICAgICAgICAgICBtc2cgPSBtZXNzYWdlLnN1YnN0cmluZyhcbiAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgY2xlYW5lZEFzc2VydE9wdGlvbnMuYXNzZXJ0aW9uTG9nTGltaXQsXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKG1zZyk7XG4gICAgICAgICAgICBlcnJvci5uYW1lID0gXCJBc3NlcnRFcnJvclwiO1xuXG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfSxcblxuICAgICAgICBwYXNzOiBmdW5jdGlvbiBwYXNzKCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNhbGxPcmRlcjogZnVuY3Rpb24gYXNzZXJ0Q2FsbE9yZGVyKCkge1xuICAgICAgICAgICAgdmVyaWZ5SXNTdHViLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICBsZXQgZXhwZWN0ZWQgPSBcIlwiO1xuICAgICAgICAgICAgbGV0IGFjdHVhbCA9IFwiXCI7XG5cbiAgICAgICAgICAgIGlmICghY2FsbGVkSW5PcmRlcihhcmd1bWVudHMpKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWQgPSBqb2luKGFyZ3VtZW50cywgXCIsIFwiKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2FsbHMgPSBhcnJheVNsaWNlKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBpID0gY2FsbHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjYWxsc1stLWldLmNhbGxlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwbGljZShjYWxscywgaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYWN0dWFsID0gam9pbihvcmRlckJ5Rmlyc3RDYWxsKGNhbGxzKSwgXCIsIFwiKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoaXMgZmFpbHMsIHdlJ2xsIGp1c3QgZmFsbCBiYWNrIHRvIHRoZSBibGFuayBzdHJpbmdcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmYWlsQXNzZXJ0aW9uKFxuICAgICAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgICAgICBgZXhwZWN0ZWQgJHtleHBlY3RlZH0gdG8gYmUgY2FsbGVkIGluIG9yZGVyIGJ1dCB3ZXJlIGNhbGxlZCBhcyAke2FjdHVhbH1gLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFzc2VydC5wYXNzKFwiY2FsbE9yZGVyXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGNhbGxDb3VudDogZnVuY3Rpb24gYXNzZXJ0Q2FsbENvdW50KG1ldGhvZCwgY291bnQpIHtcbiAgICAgICAgICAgIHZlcmlmeUlzU3R1YihtZXRob2QpO1xuXG4gICAgICAgICAgICBsZXQgbXNnO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb3VudCAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIG1zZyA9XG4gICAgICAgICAgICAgICAgICAgIGBleHBlY3RlZCAke2luc3BlY3QoY291bnQpfSB0byBiZSBhIG51bWJlciBgICtcbiAgICAgICAgICAgICAgICAgICAgYGJ1dCB3YXMgb2YgdHlwZSAke3R5cGVvZiBjb3VudH1gO1xuICAgICAgICAgICAgICAgIGZhaWxBc3NlcnRpb24odGhpcywgbXNnKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobWV0aG9kLmNhbGxDb3VudCAhPT0gY291bnQpIHtcbiAgICAgICAgICAgICAgICBtc2cgPVxuICAgICAgICAgICAgICAgICAgICBgZXhwZWN0ZWQgJW4gdG8gYmUgY2FsbGVkICR7dGltZXNJbldvcmRzKGNvdW50KX0gYCArXG4gICAgICAgICAgICAgICAgICAgIGBidXQgd2FzIGNhbGxlZCAlYyVDYDtcbiAgICAgICAgICAgICAgICBmYWlsQXNzZXJ0aW9uKHRoaXMsIG1ldGhvZC5wcmludGYobXNnKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFzc2VydC5wYXNzKFwiY2FsbENvdW50XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGV4cG9zZTogZnVuY3Rpb24gZXhwb3NlKHRhcmdldCwgb3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwidGFyZ2V0IGlzIG51bGwgb3IgdW5kZWZpbmVkXCIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBvID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgICAgIGNvbnN0IHByZWZpeCA9XG4gICAgICAgICAgICAgICAgKHR5cGVvZiBvLnByZWZpeCA9PT0gXCJ1bmRlZmluZWRcIiAmJiBcImFzc2VydFwiKSB8fCBvLnByZWZpeDtcbiAgICAgICAgICAgIGNvbnN0IGluY2x1ZGVGYWlsID1cbiAgICAgICAgICAgICAgICB0eXBlb2Ygby5pbmNsdWRlRmFpbCA9PT0gXCJ1bmRlZmluZWRcIiB8fCBCb29sZWFuKG8uaW5jbHVkZUZhaWwpO1xuICAgICAgICAgICAgY29uc3QgaW5zdGFuY2UgPSB0aGlzO1xuXG4gICAgICAgICAgICBmb3JFYWNoKE9iamVjdC5rZXlzKGluc3RhbmNlKSwgZnVuY3Rpb24gKG1ldGhvZCkge1xuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kICE9PSBcImV4cG9zZVwiICYmXG4gICAgICAgICAgICAgICAgICAgIChpbmNsdWRlRmFpbCB8fCAhL14oZmFpbCkvLnRlc3QobWV0aG9kKSlcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W2V4cG9zZWROYW1lKHByZWZpeCwgbWV0aG9kKV0gPSBpbnN0YW5jZVttZXRob2RdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgICB9LFxuXG4gICAgICAgIG1hdGNoOiBmdW5jdGlvbiBtYXRjaChhY3R1YWwsIGV4cGVjdGF0aW9uKSB7XG4gICAgICAgICAgICBjb25zdCBtYXRjaGVyID0gY3JlYXRlTWF0Y2hlcihleHBlY3RhdGlvbik7XG4gICAgICAgICAgICBpZiAobWF0Y2hlci50ZXN0KGFjdHVhbCkpIHtcbiAgICAgICAgICAgICAgICBhc3NlcnQucGFzcyhcIm1hdGNoXCIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmb3JtYXR0ZWQgPSBbXG4gICAgICAgICAgICAgICAgICAgIFwiZXhwZWN0ZWQgdmFsdWUgdG8gbWF0Y2hcIixcbiAgICAgICAgICAgICAgICAgICAgYCAgICBleHBlY3RlZCA9ICR7aW5zcGVjdChleHBlY3RhdGlvbil9YCxcbiAgICAgICAgICAgICAgICAgICAgYCAgICBhY3R1YWwgPSAke2luc3BlY3QoYWN0dWFsKX1gLFxuICAgICAgICAgICAgICAgIF07XG5cbiAgICAgICAgICAgICAgICBmYWlsQXNzZXJ0aW9uKHRoaXMsIGpvaW4oZm9ybWF0dGVkLCBcIlxcblwiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHZlcmlmeUlzU3R1YigpIHtcbiAgICAgICAgY29uc3QgYXJncyA9IGFycmF5U2xpY2UoYXJndW1lbnRzKTtcblxuICAgICAgICBmb3JFYWNoKGFyZ3MsIGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgICAgICAgICAgIGlmICghbWV0aG9kKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0LmZhaWwoXCJmYWtlIGlzIG5vdCBhIHNweVwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG1ldGhvZC5wcm94eSAmJiBtZXRob2QucHJveHkuaXNTaW5vblByb3h5KSB7XG4gICAgICAgICAgICAgICAgdmVyaWZ5SXNTdHViKG1ldGhvZC5wcm94eSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbWV0aG9kICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmZhaWwoYCR7bWV0aG9kfSBpcyBub3QgYSBmdW5jdGlvbmApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbWV0aG9kLmdldENhbGwgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZmFpbChgJHttZXRob2R9IGlzIG5vdCBzdHViYmVkYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2ZXJpZnlJc1ZhbGlkQXNzZXJ0aW9uKGFzc2VydGlvbk1ldGhvZCwgYXNzZXJ0aW9uQXJncykge1xuICAgICAgICBzd2l0Y2ggKGFzc2VydGlvbk1ldGhvZCkge1xuICAgICAgICAgICAgY2FzZSBcIm5vdENhbGxlZFwiOlxuICAgICAgICAgICAgY2FzZSBcImNhbGxlZFwiOlxuICAgICAgICAgICAgY2FzZSBcImNhbGxlZE9uY2VcIjpcbiAgICAgICAgICAgIGNhc2UgXCJjYWxsZWRUd2ljZVwiOlxuICAgICAgICAgICAgY2FzZSBcImNhbGxlZFRocmljZVwiOlxuICAgICAgICAgICAgICAgIGlmIChhc3NlcnRpb25BcmdzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZmFpbChcbiAgICAgICAgICAgICAgICAgICAgICAgIGAke2Fzc2VydGlvbk1ldGhvZH0gdGFrZXMgMSBhcmd1bWVudCBidXQgd2FzIGNhbGxlZCB3aXRoICR7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0aW9uQXJncy5sZW5ndGggKyAxXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGFyZ3VtZW50c2AsXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZhaWxBc3NlcnRpb24ob2JqZWN0LCBtc2cpIHtcbiAgICAgICAgY29uc3Qgb2JqID0gb2JqZWN0IHx8IGdsb2JhbE9iamVjdDtcbiAgICAgICAgY29uc3QgZmFpbE1ldGhvZCA9IG9iai5mYWlsIHx8IGFzc2VydC5mYWlsO1xuICAgICAgICBmYWlsTWV0aG9kLmNhbGwob2JqLCBtc2cpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1pcnJvclByb3BBc0Fzc2VydGlvbihuYW1lLCBtZXRob2QsIG1lc3NhZ2UpIHtcbiAgICAgICAgbGV0IG1zZyA9IG1lc3NhZ2U7XG4gICAgICAgIGxldCBtZXRoID0gbWV0aG9kO1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgbXNnID0gbWV0aG9kO1xuICAgICAgICAgICAgbWV0aCA9IG5hbWU7XG4gICAgICAgIH1cblxuICAgICAgICBhc3NlcnRbbmFtZV0gPSBmdW5jdGlvbiAoZmFrZSkge1xuICAgICAgICAgICAgdmVyaWZ5SXNTdHViKGZha2UpO1xuXG4gICAgICAgICAgICBjb25zdCBhcmdzID0gYXJyYXlTbGljZShhcmd1bWVudHMsIDEpO1xuICAgICAgICAgICAgbGV0IGZhaWxlZCA9IGZhbHNlO1xuXG4gICAgICAgICAgICB2ZXJpZnlJc1ZhbGlkQXNzZXJ0aW9uKG5hbWUsIGFyZ3MpO1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIG1ldGggPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIGZhaWxlZCA9ICFtZXRoKGZha2UpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmYWlsZWQgPVxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgZmFrZVttZXRoXSA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgICAgICAgICAgICAgICAgICA/ICFmYWtlW21ldGhdLmFwcGx5KGZha2UsIGFyZ3MpXG4gICAgICAgICAgICAgICAgICAgICAgICA6ICFmYWtlW21ldGhdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZmFpbGVkKSB7XG4gICAgICAgICAgICAgICAgZmFpbEFzc2VydGlvbihcbiAgICAgICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgKGZha2UucHJpbnRmIHx8IGZha2UucHJveHkucHJpbnRmKS5hcHBseShcbiAgICAgICAgICAgICAgICAgICAgICAgIGZha2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25jYXQoW21zZ10sIGFyZ3MpLFxuICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFzc2VydC5wYXNzKG5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGV4cG9zZWROYW1lKHByZWZpeCwgcHJvcCkge1xuICAgICAgICByZXR1cm4gIXByZWZpeCB8fCAvXmZhaWwvLnRlc3QocHJvcClcbiAgICAgICAgICAgID8gcHJvcFxuICAgICAgICAgICAgOiBwcmVmaXggK1xuICAgICAgICAgICAgICAgICAgc3RyaW5nU2xpY2UocHJvcCwgMCwgMSkudG9VcHBlckNhc2UoKSArXG4gICAgICAgICAgICAgICAgICBzdHJpbmdTbGljZShwcm9wLCAxKTtcbiAgICB9XG5cbiAgICBtaXJyb3JQcm9wQXNBc3NlcnRpb24oXG4gICAgICAgIFwiY2FsbGVkXCIsXG4gICAgICAgIFwiZXhwZWN0ZWQgJW4gdG8gaGF2ZSBiZWVuIGNhbGxlZCBhdCBsZWFzdCBvbmNlIGJ1dCB3YXMgbmV2ZXIgY2FsbGVkXCIsXG4gICAgKTtcbiAgICBtaXJyb3JQcm9wQXNBc3NlcnRpb24oXG4gICAgICAgIFwibm90Q2FsbGVkXCIsXG4gICAgICAgIGZ1bmN0aW9uIChzcHkpIHtcbiAgICAgICAgICAgIHJldHVybiAhc3B5LmNhbGxlZDtcbiAgICAgICAgfSxcbiAgICAgICAgXCJleHBlY3RlZCAlbiB0byBub3QgaGF2ZSBiZWVuIGNhbGxlZCBidXQgd2FzIGNhbGxlZCAlYyVDXCIsXG4gICAgKTtcbiAgICBtaXJyb3JQcm9wQXNBc3NlcnRpb24oXG4gICAgICAgIFwiY2FsbGVkT25jZVwiLFxuICAgICAgICBcImV4cGVjdGVkICVuIHRvIGJlIGNhbGxlZCBvbmNlIGJ1dCB3YXMgY2FsbGVkICVjJUNcIixcbiAgICApO1xuICAgIG1pcnJvclByb3BBc0Fzc2VydGlvbihcbiAgICAgICAgXCJjYWxsZWRUd2ljZVwiLFxuICAgICAgICBcImV4cGVjdGVkICVuIHRvIGJlIGNhbGxlZCB0d2ljZSBidXQgd2FzIGNhbGxlZCAlYyVDXCIsXG4gICAgKTtcbiAgICBtaXJyb3JQcm9wQXNBc3NlcnRpb24oXG4gICAgICAgIFwiY2FsbGVkVGhyaWNlXCIsXG4gICAgICAgIFwiZXhwZWN0ZWQgJW4gdG8gYmUgY2FsbGVkIHRocmljZSBidXQgd2FzIGNhbGxlZCAlYyVDXCIsXG4gICAgKTtcbiAgICBtaXJyb3JQcm9wQXNBc3NlcnRpb24oXG4gICAgICAgIFwiY2FsbGVkT25cIixcbiAgICAgICAgXCJleHBlY3RlZCAlbiB0byBiZSBjYWxsZWQgd2l0aCAlMSBhcyB0aGlzIGJ1dCB3YXMgY2FsbGVkIHdpdGggJXRcIixcbiAgICApO1xuICAgIG1pcnJvclByb3BBc0Fzc2VydGlvbihcbiAgICAgICAgXCJhbHdheXNDYWxsZWRPblwiLFxuICAgICAgICBcImV4cGVjdGVkICVuIHRvIGFsd2F5cyBiZSBjYWxsZWQgd2l0aCAlMSBhcyB0aGlzIGJ1dCB3YXMgY2FsbGVkIHdpdGggJXRcIixcbiAgICApO1xuICAgIG1pcnJvclByb3BBc0Fzc2VydGlvbihcImNhbGxlZFdpdGhOZXdcIiwgXCJleHBlY3RlZCAlbiB0byBiZSBjYWxsZWQgd2l0aCBuZXdcIik7XG4gICAgbWlycm9yUHJvcEFzQXNzZXJ0aW9uKFxuICAgICAgICBcImFsd2F5c0NhbGxlZFdpdGhOZXdcIixcbiAgICAgICAgXCJleHBlY3RlZCAlbiB0byBhbHdheXMgYmUgY2FsbGVkIHdpdGggbmV3XCIsXG4gICAgKTtcbiAgICBtaXJyb3JQcm9wQXNBc3NlcnRpb24oXG4gICAgICAgIFwiY2FsbGVkV2l0aFwiLFxuICAgICAgICBcImV4cGVjdGVkICVuIHRvIGJlIGNhbGxlZCB3aXRoIGFyZ3VtZW50cyAlRFwiLFxuICAgICk7XG4gICAgbWlycm9yUHJvcEFzQXNzZXJ0aW9uKFxuICAgICAgICBcImNhbGxlZFdpdGhNYXRjaFwiLFxuICAgICAgICBcImV4cGVjdGVkICVuIHRvIGJlIGNhbGxlZCB3aXRoIG1hdGNoICVEXCIsXG4gICAgKTtcbiAgICBtaXJyb3JQcm9wQXNBc3NlcnRpb24oXG4gICAgICAgIFwiYWx3YXlzQ2FsbGVkV2l0aFwiLFxuICAgICAgICBcImV4cGVjdGVkICVuIHRvIGFsd2F5cyBiZSBjYWxsZWQgd2l0aCBhcmd1bWVudHMgJURcIixcbiAgICApO1xuICAgIG1pcnJvclByb3BBc0Fzc2VydGlvbihcbiAgICAgICAgXCJhbHdheXNDYWxsZWRXaXRoTWF0Y2hcIixcbiAgICAgICAgXCJleHBlY3RlZCAlbiB0byBhbHdheXMgYmUgY2FsbGVkIHdpdGggbWF0Y2ggJURcIixcbiAgICApO1xuICAgIG1pcnJvclByb3BBc0Fzc2VydGlvbihcbiAgICAgICAgXCJjYWxsZWRXaXRoRXhhY3RseVwiLFxuICAgICAgICBcImV4cGVjdGVkICVuIHRvIGJlIGNhbGxlZCB3aXRoIGV4YWN0IGFyZ3VtZW50cyAlRFwiLFxuICAgICk7XG4gICAgbWlycm9yUHJvcEFzQXNzZXJ0aW9uKFxuICAgICAgICBcImNhbGxlZE9uY2VXaXRoXCIsXG4gICAgICAgIFwiZXhwZWN0ZWQgJW4gdG8gYmUgY2FsbGVkIG9uY2UgYW5kIHdpdGggYXJndW1lbnRzICVEXCIsXG4gICAgKTtcbiAgICBtaXJyb3JQcm9wQXNBc3NlcnRpb24oXG4gICAgICAgIFwiY2FsbGVkT25jZVdpdGhFeGFjdGx5XCIsXG4gICAgICAgIFwiZXhwZWN0ZWQgJW4gdG8gYmUgY2FsbGVkIG9uY2UgYW5kIHdpdGggZXhhY3QgYXJndW1lbnRzICVEXCIsXG4gICAgKTtcbiAgICBtaXJyb3JQcm9wQXNBc3NlcnRpb24oXG4gICAgICAgIFwiY2FsbGVkT25jZVdpdGhNYXRjaFwiLFxuICAgICAgICBcImV4cGVjdGVkICVuIHRvIGJlIGNhbGxlZCBvbmNlIGFuZCB3aXRoIG1hdGNoICVEXCIsXG4gICAgKTtcbiAgICBtaXJyb3JQcm9wQXNBc3NlcnRpb24oXG4gICAgICAgIFwiYWx3YXlzQ2FsbGVkV2l0aEV4YWN0bHlcIixcbiAgICAgICAgXCJleHBlY3RlZCAlbiB0byBhbHdheXMgYmUgY2FsbGVkIHdpdGggZXhhY3QgYXJndW1lbnRzICVEXCIsXG4gICAgKTtcbiAgICBtaXJyb3JQcm9wQXNBc3NlcnRpb24oXG4gICAgICAgIFwibmV2ZXJDYWxsZWRXaXRoXCIsXG4gICAgICAgIFwiZXhwZWN0ZWQgJW4gdG8gbmV2ZXIgYmUgY2FsbGVkIHdpdGggYXJndW1lbnRzICUqJUNcIixcbiAgICApO1xuICAgIG1pcnJvclByb3BBc0Fzc2VydGlvbihcbiAgICAgICAgXCJuZXZlckNhbGxlZFdpdGhNYXRjaFwiLFxuICAgICAgICBcImV4cGVjdGVkICVuIHRvIG5ldmVyIGJlIGNhbGxlZCB3aXRoIG1hdGNoICUqJUNcIixcbiAgICApO1xuICAgIG1pcnJvclByb3BBc0Fzc2VydGlvbihcInRocmV3XCIsIFwiJW4gZGlkIG5vdCB0aHJvdyBleGNlcHRpb24lQ1wiKTtcbiAgICBtaXJyb3JQcm9wQXNBc3NlcnRpb24oXCJhbHdheXNUaHJld1wiLCBcIiVuIGRpZCBub3QgYWx3YXlzIHRocm93IGV4Y2VwdGlvbiVDXCIpO1xuXG4gICAgcmV0dXJuIGFzc2VydDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVBc3NlcnRPYmplY3QoKTtcbm1vZHVsZS5leHBvcnRzLmNyZWF0ZUFzc2VydE9iamVjdCA9IGNyZWF0ZUFzc2VydE9iamVjdDtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuY29uc3QgZ2xvYmFsT2JqZWN0ID0gcmVxdWlyZShcIkBzaW5vbmpzL2NvbW1vbnNcIikuZ2xvYmFsO1xubGV0IHRpbWVyc01vZHVsZSwgdGltZXJzUHJvbWlzZXNNb2R1bGU7XG5pZiAodHlwZW9mIHJlcXVpcmUgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgdGltZXJzTW9kdWxlID0gcmVxdWlyZShcInRpbWVyc1wiKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIGlnbm9yZWRcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgdGltZXJzUHJvbWlzZXNNb2R1bGUgPSByZXF1aXJlKFwidGltZXJzL3Byb21pc2VzXCIpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gaWdub3JlZFxuICAgIH1cbn1cblxuLyoqXG4gKiBAdHlwZWRlZiB7XCJuZXh0QXN5bmNcIiB8IFwibWFudWFsXCIgfCBcImludGVydmFsXCJ9IFRpY2tNb2RlXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBOZXh0QXN5bmNUaWNrTW9kZVxuICogQHByb3BlcnR5IHtcIm5leHRBc3luY1wifSBtb2RlXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBNYW51YWxUaWNrTW9kZVxuICogQHByb3BlcnR5IHtcIm1hbnVhbFwifSBtb2RlXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBJbnRlcnZhbFRpY2tNb2RlXG4gKiBAcHJvcGVydHkge1wiaW50ZXJ2YWxcIn0gbW9kZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtkZWx0YV1cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtJbnRlcnZhbFRpY2tNb2RlIHwgTmV4dEFzeW5jVGlja01vZGUgfCBNYW51YWxUaWNrTW9kZX0gVGltZXJUaWNrTW9kZVxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge29iamVjdH0gSWRsZURlYWRsaW5lXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGRpZFRpbWVvdXQgLSB3aGV0aGVyIG9yIG5vdCB0aGUgY2FsbGJhY2sgd2FzIGNhbGxlZCBiZWZvcmUgcmVhY2hpbmcgdGhlIG9wdGlvbmFsIHRpbWVvdXRcbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb24oKTpudW1iZXJ9IHRpbWVSZW1haW5pbmcgLSBhIGZsb2F0aW5nLXBvaW50IHZhbHVlIHByb3ZpZGluZyBhbiBlc3RpbWF0ZSBvZiB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyByZW1haW5pbmcgaW4gdGhlIGN1cnJlbnQgaWRsZSBwZXJpb2RcbiAqL1xuXG4vKipcbiAqIFF1ZXVlcyBhIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBkdXJpbmcgYSBicm93c2VyJ3MgaWRsZSBwZXJpb2RzXG4gKiBAY2FsbGJhY2sgUmVxdWVzdElkbGVDYWxsYmFja1xuICogQHBhcmFtIHtmdW5jdGlvbihJZGxlRGVhZGxpbmUpfSBjYWxsYmFja1xuICogQHBhcmFtIHt7dGltZW91dDogbnVtYmVyfX0gb3B0aW9ucyAtIGFuIG9wdGlvbnMgb2JqZWN0XG4gKiBAcmV0dXJucyB7bnVtYmVyfSB0aGUgaWRcbiAqL1xuXG4vKipcbiAqIEBjYWxsYmFjayBOZXh0VGlja1xuICogQHBhcmFtIHtWb2lkVmFyQXJnc0Z1bmN9IGNhbGxiYWNrIC0gdGhlIGNhbGxiYWNrIHRvIHJ1blxuICogQHBhcmFtIHsuLi4qfSBhcmdzIC0gb3B0aW9uYWwgYXJndW1lbnRzIHRvIGNhbGwgdGhlIGNhbGxiYWNrIHdpdGhcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5cbi8qKlxuICogQGNhbGxiYWNrIFNldEltbWVkaWF0ZVxuICogQHBhcmFtIHtWb2lkVmFyQXJnc0Z1bmN9IGNhbGxiYWNrIC0gdGhlIGNhbGxiYWNrIHRvIHJ1blxuICogQHBhcmFtIHsuLi4qfSBhcmdzIC0gb3B0aW9uYWwgYXJndW1lbnRzIHRvIGNhbGwgdGhlIGNhbGxiYWNrIHdpdGhcbiAqIEByZXR1cm5zIHtOb2RlSW1tZWRpYXRlfVxuICovXG5cbi8qKlxuICogQGNhbGxiYWNrIFZvaWRWYXJBcmdzRnVuY1xuICogQHBhcmFtIHsuLi4qfSBjYWxsYmFjayAtIHRoZSBjYWxsYmFjayB0byBydW5cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5cbi8qKlxuICogQHR5cGVkZWYgUmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9uKG51bWJlcik6dm9pZH0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gKiBAcmV0dXJucyB7bnVtYmVyfSAtIHRoZSBpZFxuICovXG5cbi8qKlxuICogQHR5cGVkZWYgUGVyZm9ybWFuY2VcbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb24oKTogbnVtYmVyfSBub3dcbiAqL1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBqc2RvYy9yZXF1aXJlLXByb3BlcnR5LWRlc2NyaXB0aW9uICovXG4vKipcbiAqIEB0eXBlZGVmIHtvYmplY3R9IENsb2NrXG4gKiBAcHJvcGVydHkge251bWJlcn0gbm93IC0gdGhlIGN1cnJlbnQgdGltZVxuICogQHByb3BlcnR5IHtEYXRlfSBEYXRlIC0gdGhlIERhdGUgY29uc3RydWN0b3JcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBsb29wTGltaXQgLSB0aGUgbWF4aW11bSBudW1iZXIgb2YgdGltZXJzIGJlZm9yZSBhc3N1bWluZyBhbiBpbmZpbml0ZSBsb29wXG4gKiBAcHJvcGVydHkge1JlcXVlc3RJZGxlQ2FsbGJhY2t9IHJlcXVlc3RJZGxlQ2FsbGJhY2tcbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb24obnVtYmVyKTp2b2lkfSBjYW5jZWxJZGxlQ2FsbGJhY2tcbiAqIEBwcm9wZXJ0eSB7c2V0VGltZW91dH0gc2V0VGltZW91dFxuICogQHByb3BlcnR5IHtjbGVhclRpbWVvdXR9IGNsZWFyVGltZW91dFxuICogQHByb3BlcnR5IHtOZXh0VGlja30gbmV4dFRpY2tcbiAqIEBwcm9wZXJ0eSB7cXVldWVNaWNyb3Rhc2t9IHF1ZXVlTWljcm90YXNrXG4gKiBAcHJvcGVydHkge3NldEludGVydmFsfSBzZXRJbnRlcnZhbFxuICogQHByb3BlcnR5IHtjbGVhckludGVydmFsfSBjbGVhckludGVydmFsXG4gKiBAcHJvcGVydHkge1NldEltbWVkaWF0ZX0gc2V0SW1tZWRpYXRlXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9uKE5vZGVJbW1lZGlhdGUpOnZvaWR9IGNsZWFySW1tZWRpYXRlXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9uKCk6bnVtYmVyfSBjb3VudFRpbWVyc1xuICogQHByb3BlcnR5IHtSZXF1ZXN0QW5pbWF0aW9uRnJhbWV9IHJlcXVlc3RBbmltYXRpb25GcmFtZVxuICogQHByb3BlcnR5IHtmdW5jdGlvbihudW1iZXIpOnZvaWR9IGNhbmNlbEFuaW1hdGlvbkZyYW1lXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9uKCk6dm9pZH0gcnVuTWljcm90YXNrc1xuICogQHByb3BlcnR5IHtmdW5jdGlvbihzdHJpbmcgfCBudW1iZXIpOiBudW1iZXJ9IHRpY2tcbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb24oc3RyaW5nIHwgbnVtYmVyKTogUHJvbWlzZTxudW1iZXI+fSB0aWNrQXN5bmNcbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb24oKTogbnVtYmVyfSBuZXh0XG4gKiBAcHJvcGVydHkge2Z1bmN0aW9uKCk6IFByb21pc2U8bnVtYmVyPn0gbmV4dEFzeW5jXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9uKCk6IG51bWJlcn0gcnVuQWxsXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9uKCk6IG51bWJlcn0gcnVuVG9GcmFtZVxuICogQHByb3BlcnR5IHtmdW5jdGlvbigpOiBQcm9taXNlPG51bWJlcj59IHJ1bkFsbEFzeW5jXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9uKCk6IG51bWJlcn0gcnVuVG9MYXN0XG4gKiBAcHJvcGVydHkge2Z1bmN0aW9uKCk6IFByb21pc2U8bnVtYmVyPn0gcnVuVG9MYXN0QXN5bmNcbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb24oKTogdm9pZH0gcmVzZXRcbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb24obnVtYmVyIHwgRGF0ZSk6IHZvaWR9IHNldFN5c3RlbVRpbWVcbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb24obnVtYmVyKTogdm9pZH0ganVtcFxuICogQHByb3BlcnR5IHtQZXJmb3JtYW5jZX0gcGVyZm9ybWFuY2VcbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb24obnVtYmVyW10pOiBudW1iZXJbXX0gaHJ0aW1lIC0gcHJvY2Vzcy5ocnRpbWUgKGxlZ2FjeSlcbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb24oKTogdm9pZH0gdW5pbnN0YWxsIFVuaW5zdGFsbCB0aGUgY2xvY2suXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9uW119IG1ldGhvZHMgLSB0aGUgbWV0aG9kcyB0aGF0IGFyZSBmYWtlZFxuICogQHByb3BlcnR5IHtib29sZWFufSBbc2hvdWxkQ2xlYXJOYXRpdmVUaW1lcnNdIGluaGVyaXRlZCBmcm9tIGNvbmZpZ1xuICogQHByb3BlcnR5IHt7bWV0aG9kTmFtZTpzdHJpbmcsIG9yaWdpbmFsOmFueX1bXSB8IHVuZGVmaW5lZH0gdGltZXJzTW9kdWxlTWV0aG9kc1xuICogQHByb3BlcnR5IHt7bWV0aG9kTmFtZTpzdHJpbmcsIG9yaWdpbmFsOmFueX1bXSB8IHVuZGVmaW5lZH0gdGltZXJzUHJvbWlzZXNNb2R1bGVNZXRob2RzXG4gKiBAcHJvcGVydHkge01hcDxmdW5jdGlvbigpOiB2b2lkLCBBYm9ydFNpZ25hbD59IGFib3J0TGlzdGVuZXJNYXBcbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb24oVGltZXJUaWNrTW9kZSk6IHZvaWR9IHNldFRpY2tNb2RlXG4gKi9cbi8qIGVzbGludC1lbmFibGUganNkb2MvcmVxdWlyZS1wcm9wZXJ0eS1kZXNjcmlwdGlvbiAqL1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciB0aGUgYGluc3RhbGxgIG1ldGhvZC5cbiAqIEB0eXBlZGVmIHtvYmplY3R9IENvbmZpZ1xuICogQHByb3BlcnR5IHtudW1iZXJ8RGF0ZX0gW25vd10gYSBudW1iZXIgKGluIG1pbGxpc2Vjb25kcykgb3IgYSBEYXRlIG9iamVjdCAoZGVmYXVsdCBlcG9jaClcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nW119IFt0b0Zha2VdIG5hbWVzIG9mIHRoZSBtZXRob2RzIHRoYXQgc2hvdWxkIGJlIGZha2VkLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtsb29wTGltaXRdIHRoZSBtYXhpbXVtIG51bWJlciBvZiB0aW1lcnMgdGhhdCB3aWxsIGJlIHJ1biB3aGVuIGNhbGxpbmcgcnVuQWxsKClcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3Nob3VsZEFkdmFuY2VUaW1lXSB0ZWxscyBGYWtlVGltZXJzIHRvIGluY3JlbWVudCBtb2NrZWQgdGltZSBhdXRvbWF0aWNhbGx5IChkZWZhdWx0IGZhbHNlKVxuICogQHByb3BlcnR5IHtudW1iZXJ9IFthZHZhbmNlVGltZURlbHRhXSBpbmNyZW1lbnQgbW9ja2VkIHRpbWUgZXZlcnkgPDxhZHZhbmNlVGltZURlbHRhPj4gbXMgKGRlZmF1bHQ6IDIwbXMpXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtzaG91bGRDbGVhck5hdGl2ZVRpbWVyc10gZm9yd2FyZHMgY2xlYXIgdGltZXIgY2FsbHMgdG8gbmF0aXZlIGZ1bmN0aW9ucyBpZiB0aGV5IGFyZSBub3QgZmFrZXMgKGRlZmF1bHQ6IGZhbHNlKVxuICogQHByb3BlcnR5IHtib29sZWFufSBbaWdub3JlTWlzc2luZ1RpbWVyc10gZGVmYXVsdCBpcyBmYWxzZSwgbWVhbmluZyBhc2tpbmcgdG8gZmFrZSB0aW1lcnMgdGhhdCBhcmUgbm90IHByZXNlbnQgd2lsbCB0aHJvdyBhbiBlcnJvclxuICovXG5cbi8qIGVzbGludC1kaXNhYmxlIGpzZG9jL3JlcXVpcmUtcHJvcGVydHktZGVzY3JpcHRpb24gKi9cbi8qKlxuICogVGhlIGludGVybmFsIHN0cnVjdHVyZSB0byBkZXNjcmliZSBhIHNjaGVkdWxlZCBmYWtlIHRpbWVyXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBUaW1lclxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gZnVuY1xuICogQHByb3BlcnR5IHsqW119IGFyZ3NcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkZWxheVxuICogQHByb3BlcnR5IHtudW1iZXJ9IGNhbGxBdFxuICogQHByb3BlcnR5IHtudW1iZXJ9IGNyZWF0ZWRBdFxuICogQHByb3BlcnR5IHtib29sZWFufSBpbW1lZGlhdGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBpZFxuICogQHByb3BlcnR5IHtFcnJvcn0gW2Vycm9yXVxuICovXG5cbi8qKlxuICogQSBOb2RlIHRpbWVyXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBOb2RlSW1tZWRpYXRlXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9uKCk6IGJvb2xlYW59IGhhc1JlZlxuICogQHByb3BlcnR5IHtmdW5jdGlvbigpOiBOb2RlSW1tZWRpYXRlfSByZWZcbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb24oKTogTm9kZUltbWVkaWF0ZX0gdW5yZWZcbiAqL1xuLyogZXNsaW50LWVuYWJsZSBqc2RvYy9yZXF1aXJlLXByb3BlcnR5LWRlc2NyaXB0aW9uICovXG5cbi8qIGVzbGludC1kaXNhYmxlIGNvbXBsZXhpdHkgKi9cblxuLyoqXG4gKiBNb2NrcyBhdmFpbGFibGUgZmVhdHVyZXMgaW4gdGhlIHNwZWNpZmllZCBnbG9iYWwgbmFtZXNwYWNlLlxuICogQHBhcmFtIHsqfSBfZ2xvYmFsIE5hbWVzcGFjZSB0byBtb2NrIChlLmcuIGB3aW5kb3dgKVxuICogQHJldHVybnMge0Zha2VUaW1lcnN9XG4gKi9cbmZ1bmN0aW9uIHdpdGhHbG9iYWwoX2dsb2JhbCkge1xuICAgIGNvbnN0IG1heFRpbWVvdXQgPSBNYXRoLnBvdygyLCAzMSkgLSAxOyAvL3NlZSBodHRwczovL2hleWNhbS5naXRodWIuaW8vd2ViaWRsLyNhYnN0cmFjdC1vcGRlZi1jb252ZXJ0dG9pbnRcbiAgICBjb25zdCBpZENvdW50ZXJTdGFydCA9IDFlMTI7IC8vIGFyYml0cmFyaWx5IGxhcmdlIG51bWJlciB0byBhdm9pZCBjb2xsaXNpb25zIHdpdGggbmF0aXZlIHRpbWVyIElEc1xuICAgIGNvbnN0IE5PT1AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfTtcbiAgICBjb25zdCBOT09QX0FSUkFZID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfTtcbiAgICBjb25zdCBpc1ByZXNlbnQgPSB7fTtcbiAgICBsZXQgdGltZW91dFJlc3VsdCxcbiAgICAgICAgYWRkVGltZXJSZXR1cm5zT2JqZWN0ID0gZmFsc2U7XG5cbiAgICBpZiAoX2dsb2JhbC5zZXRUaW1lb3V0KSB7XG4gICAgICAgIGlzUHJlc2VudC5zZXRUaW1lb3V0ID0gdHJ1ZTtcbiAgICAgICAgdGltZW91dFJlc3VsdCA9IF9nbG9iYWwuc2V0VGltZW91dChOT09QLCAwKTtcbiAgICAgICAgYWRkVGltZXJSZXR1cm5zT2JqZWN0ID0gdHlwZW9mIHRpbWVvdXRSZXN1bHQgPT09IFwib2JqZWN0XCI7XG4gICAgfVxuICAgIGlzUHJlc2VudC5jbGVhclRpbWVvdXQgPSBCb29sZWFuKF9nbG9iYWwuY2xlYXJUaW1lb3V0KTtcbiAgICBpc1ByZXNlbnQuc2V0SW50ZXJ2YWwgPSBCb29sZWFuKF9nbG9iYWwuc2V0SW50ZXJ2YWwpO1xuICAgIGlzUHJlc2VudC5jbGVhckludGVydmFsID0gQm9vbGVhbihfZ2xvYmFsLmNsZWFySW50ZXJ2YWwpO1xuICAgIGlzUHJlc2VudC5ocnRpbWUgPVxuICAgICAgICBfZ2xvYmFsLnByb2Nlc3MgJiYgdHlwZW9mIF9nbG9iYWwucHJvY2Vzcy5ocnRpbWUgPT09IFwiZnVuY3Rpb25cIjtcbiAgICBpc1ByZXNlbnQuaHJ0aW1lQmlnaW50ID1cbiAgICAgICAgaXNQcmVzZW50LmhydGltZSAmJiB0eXBlb2YgX2dsb2JhbC5wcm9jZXNzLmhydGltZS5iaWdpbnQgPT09IFwiZnVuY3Rpb25cIjtcbiAgICBpc1ByZXNlbnQubmV4dFRpY2sgPVxuICAgICAgICBfZ2xvYmFsLnByb2Nlc3MgJiYgdHlwZW9mIF9nbG9iYWwucHJvY2Vzcy5uZXh0VGljayA9PT0gXCJmdW5jdGlvblwiO1xuICAgIGNvbnN0IHV0aWxQcm9taXNpZnkgPSBfZ2xvYmFsLnByb2Nlc3MgJiYgcmVxdWlyZShcInV0aWxcIikucHJvbWlzaWZ5O1xuICAgIGlzUHJlc2VudC5wZXJmb3JtYW5jZSA9XG4gICAgICAgIF9nbG9iYWwucGVyZm9ybWFuY2UgJiYgdHlwZW9mIF9nbG9iYWwucGVyZm9ybWFuY2Uubm93ID09PSBcImZ1bmN0aW9uXCI7XG4gICAgY29uc3QgaGFzUGVyZm9ybWFuY2VQcm90b3R5cGUgPVxuICAgICAgICBfZ2xvYmFsLlBlcmZvcm1hbmNlICYmXG4gICAgICAgICh0eXBlb2YgX2dsb2JhbC5QZXJmb3JtYW5jZSkubWF0Y2goL14oZnVuY3Rpb258b2JqZWN0KSQvKTtcbiAgICBjb25zdCBoYXNQZXJmb3JtYW5jZUNvbnN0cnVjdG9yUHJvdG90eXBlID1cbiAgICAgICAgX2dsb2JhbC5wZXJmb3JtYW5jZSAmJlxuICAgICAgICBfZ2xvYmFsLnBlcmZvcm1hbmNlLmNvbnN0cnVjdG9yICYmXG4gICAgICAgIF9nbG9iYWwucGVyZm9ybWFuY2UuY29uc3RydWN0b3IucHJvdG90eXBlO1xuICAgIGlzUHJlc2VudC5xdWV1ZU1pY3JvdGFzayA9IF9nbG9iYWwuaGFzT3duUHJvcGVydHkoXCJxdWV1ZU1pY3JvdGFza1wiKTtcbiAgICBpc1ByZXNlbnQucmVxdWVzdEFuaW1hdGlvbkZyYW1lID1cbiAgICAgICAgX2dsb2JhbC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgJiZcbiAgICAgICAgdHlwZW9mIF9nbG9iYWwucmVxdWVzdEFuaW1hdGlvbkZyYW1lID09PSBcImZ1bmN0aW9uXCI7XG4gICAgaXNQcmVzZW50LmNhbmNlbEFuaW1hdGlvbkZyYW1lID1cbiAgICAgICAgX2dsb2JhbC5jYW5jZWxBbmltYXRpb25GcmFtZSAmJlxuICAgICAgICB0eXBlb2YgX2dsb2JhbC5jYW5jZWxBbmltYXRpb25GcmFtZSA9PT0gXCJmdW5jdGlvblwiO1xuICAgIGlzUHJlc2VudC5yZXF1ZXN0SWRsZUNhbGxiYWNrID1cbiAgICAgICAgX2dsb2JhbC5yZXF1ZXN0SWRsZUNhbGxiYWNrICYmXG4gICAgICAgIHR5cGVvZiBfZ2xvYmFsLnJlcXVlc3RJZGxlQ2FsbGJhY2sgPT09IFwiZnVuY3Rpb25cIjtcbiAgICBpc1ByZXNlbnQuY2FuY2VsSWRsZUNhbGxiYWNrUHJlc2VudCA9XG4gICAgICAgIF9nbG9iYWwuY2FuY2VsSWRsZUNhbGxiYWNrICYmXG4gICAgICAgIHR5cGVvZiBfZ2xvYmFsLmNhbmNlbElkbGVDYWxsYmFjayA9PT0gXCJmdW5jdGlvblwiO1xuICAgIGlzUHJlc2VudC5zZXRJbW1lZGlhdGUgPVxuICAgICAgICBfZ2xvYmFsLnNldEltbWVkaWF0ZSAmJiB0eXBlb2YgX2dsb2JhbC5zZXRJbW1lZGlhdGUgPT09IFwiZnVuY3Rpb25cIjtcbiAgICBpc1ByZXNlbnQuY2xlYXJJbW1lZGlhdGUgPVxuICAgICAgICBfZ2xvYmFsLmNsZWFySW1tZWRpYXRlICYmIHR5cGVvZiBfZ2xvYmFsLmNsZWFySW1tZWRpYXRlID09PSBcImZ1bmN0aW9uXCI7XG4gICAgaXNQcmVzZW50LkludGwgPSBfZ2xvYmFsLkludGwgJiYgdHlwZW9mIF9nbG9iYWwuSW50bCA9PT0gXCJvYmplY3RcIjtcblxuICAgIGlmIChfZ2xvYmFsLmNsZWFyVGltZW91dCkge1xuICAgICAgICBfZ2xvYmFsLmNsZWFyVGltZW91dCh0aW1lb3V0UmVzdWx0KTtcbiAgICB9XG5cbiAgICBjb25zdCBOYXRpdmVEYXRlID0gX2dsb2JhbC5EYXRlO1xuICAgIGNvbnN0IE5hdGl2ZUludGwgPSBpc1ByZXNlbnQuSW50bFxuICAgICAgICA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFxuICAgICAgICAgICAgICBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgICAgICAgICAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhfZ2xvYmFsLkludGwpLFxuICAgICAgICAgIClcbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgbGV0IHVuaXF1ZVRpbWVySWQgPSBpZENvdW50ZXJTdGFydDtcblxuICAgIGlmIChOYXRpdmVEYXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgXCJUaGUgZ2xvYmFsIHNjb3BlIGRvZXNuJ3QgaGF2ZSBhIGBEYXRlYCBvYmplY3RcIiArXG4gICAgICAgICAgICAgICAgXCIgKHNlZSBodHRwczovL2dpdGh1Yi5jb20vc2lub25qcy9zaW5vbi9pc3N1ZXMvMTg1MiNpc3N1ZWNvbW1lbnQtNDE5NjIyNzgwKVwiLFxuICAgICAgICApO1xuICAgIH1cbiAgICBpc1ByZXNlbnQuRGF0ZSA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgUGVyZm9ybWFuY2VFbnRyeSBvYmplY3QgZW5jYXBzdWxhdGVzIGEgc2luZ2xlIHBlcmZvcm1hbmNlIG1ldHJpY1xuICAgICAqIHRoYXQgaXMgcGFydCBvZiB0aGUgYnJvd3NlcidzIHBlcmZvcm1hbmNlIHRpbWVsaW5lLlxuICAgICAqXG4gICAgICogVGhpcyBpcyBhbiBvYmplY3QgcmV0dXJuZWQgYnkgdGhlIGBtYXJrYCBhbmQgYG1lYXN1cmVgIG1ldGhvZHMgb24gdGhlIFBlcmZvcm1hbmNlIHByb3RvdHlwZVxuICAgICAqL1xuICAgIGNsYXNzIEZha2VQZXJmb3JtYW5jZUVudHJ5IHtcbiAgICAgICAgY29uc3RydWN0b3IobmFtZSwgZW50cnlUeXBlLCBzdGFydFRpbWUsIGR1cmF0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICAgICAgdGhpcy5lbnRyeVR5cGUgPSBlbnRyeVR5cGU7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0VGltZSA9IHN0YXJ0VGltZTtcbiAgICAgICAgICAgIHRoaXMuZHVyYXRpb24gPSBkdXJhdGlvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRvSlNPTigpIHtcbiAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh7IC4uLnRoaXMgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbnVtXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNOdW1iZXJGaW5pdGUobnVtKSB7XG4gICAgICAgIGlmIChOdW1iZXIuaXNGaW5pdGUpIHtcbiAgICAgICAgICAgIHJldHVybiBOdW1iZXIuaXNGaW5pdGUobnVtKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpc0Zpbml0ZShudW0pO1xuICAgIH1cblxuICAgIGxldCBpc05lYXJJbmZpbml0ZUxpbWl0ID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0Nsb2NrfSBjbG9ja1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2hlY2tJc05lYXJJbmZpbml0ZUxpbWl0KGNsb2NrLCBpKSB7XG4gICAgICAgIGlmIChjbG9jay5sb29wTGltaXQgJiYgaSA9PT0gY2xvY2subG9vcExpbWl0IC0gMSkge1xuICAgICAgICAgICAgaXNOZWFySW5maW5pdGVMaW1pdCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlc2V0SXNOZWFySW5maW5pdGVMaW1pdCgpIHtcbiAgICAgICAgaXNOZWFySW5maW5pdGVMaW1pdCA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhcnNlIHN0cmluZ3MgbGlrZSBcIjAxOjEwOjAwXCIgKG1lYW5pbmcgMSBob3VyLCAxMCBtaW51dGVzLCAwIHNlY29uZHMpIGludG9cbiAgICAgKiBudW1iZXIgb2YgbWlsbGlzZWNvbmRzLiBUaGlzIGlzIHVzZWQgdG8gc3VwcG9ydCBodW1hbi1yZWFkYWJsZSBzdHJpbmdzIHBhc3NlZFxuICAgICAqIHRvIGNsb2NrLnRpY2soKVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBhcnNlVGltZShzdHIpIHtcbiAgICAgICAgaWYgKCFzdHIpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgc3RyaW5ncyA9IHN0ci5zcGxpdChcIjpcIik7XG4gICAgICAgIGNvbnN0IGwgPSBzdHJpbmdzLmxlbmd0aDtcbiAgICAgICAgbGV0IGkgPSBsO1xuICAgICAgICBsZXQgbXMgPSAwO1xuICAgICAgICBsZXQgcGFyc2VkO1xuXG4gICAgICAgIGlmIChsID4gMyB8fCAhL14oXFxkXFxkOil7MCwyfVxcZFxcZD8kLy50ZXN0KHN0cikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICBcInRpY2sgb25seSB1bmRlcnN0YW5kcyBudW1iZXJzLCAnbTpzJyBhbmQgJ2g6bTpzJy4gRWFjaCBwYXJ0IG11c3QgYmUgdHdvIGRpZ2l0c1wiLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgIHBhcnNlZCA9IHBhcnNlSW50KHN0cmluZ3NbaV0sIDEwKTtcblxuICAgICAgICAgICAgaWYgKHBhcnNlZCA+PSA2MCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCB0aW1lICR7c3RyfWApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtcyArPSBwYXJzZWQgKiBNYXRoLnBvdyg2MCwgbCAtIGkgLSAxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtcyAqIDEwMDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBkZWNpbWFsIHBhcnQgb2YgdGhlIG1pbGxpc2Vjb25kIHZhbHVlIGFzIG5hbm9zZWNvbmRzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1zRmxvYXQgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHNcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBhbiBpbnRlZ2VyIG51bWJlciBvZiBuYW5vc2Vjb25kcyBpbiB0aGUgcmFuZ2UgWzAsMWU2KVxuICAgICAqXG4gICAgICogRXhhbXBsZTogbmFub1JlbWFpbmVyKDEyMy40NTY3ODkpIC0+IDQ1Njc4OVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG5hbm9SZW1haW5kZXIobXNGbG9hdCkge1xuICAgICAgICBjb25zdCBtb2R1bG8gPSAxZTY7XG4gICAgICAgIGNvbnN0IHJlbWFpbmRlciA9IChtc0Zsb2F0ICogMWU2KSAlIG1vZHVsbztcbiAgICAgICAgY29uc3QgcG9zaXRpdmVSZW1haW5kZXIgPVxuICAgICAgICAgICAgcmVtYWluZGVyIDwgMCA/IHJlbWFpbmRlciArIG1vZHVsbyA6IHJlbWFpbmRlcjtcblxuICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihwb3NpdGl2ZVJlbWFpbmRlcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlZCB0byBncm9rIHRoZSBgbm93YCBwYXJhbWV0ZXIgdG8gY3JlYXRlQ2xvY2suXG4gICAgICogQHBhcmFtIHtEYXRlfG51bWJlcn0gZXBvY2ggdGhlIHN5c3RlbSB0aW1lXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRFcG9jaChlcG9jaCkge1xuICAgICAgICBpZiAoIWVwb2NoKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGVwb2NoLmdldFRpbWUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgcmV0dXJuIGVwb2NoLmdldFRpbWUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGVwb2NoID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICByZXR1cm4gZXBvY2g7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIm5vdyBzaG91bGQgYmUgbWlsbGlzZWNvbmRzIHNpbmNlIFVOSVggZXBvY2hcIik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGZyb21cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdG9cbiAgICAgKiBAcGFyYW0ge1RpbWVyfSB0aW1lclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluUmFuZ2UoZnJvbSwgdG8sIHRpbWVyKSB7XG4gICAgICAgIHJldHVybiB0aW1lciAmJiB0aW1lci5jYWxsQXQgPj0gZnJvbSAmJiB0aW1lci5jYWxsQXQgPD0gdG87XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtDbG9ja30gY2xvY2tcbiAgICAgKiBAcGFyYW0ge1RpbWVyfSBqb2JcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRJbmZpbml0ZUxvb3BFcnJvcihjbG9jaywgam9iKSB7XG4gICAgICAgIGNvbnN0IGluZmluaXRlTG9vcEVycm9yID0gbmV3IEVycm9yKFxuICAgICAgICAgICAgYEFib3J0aW5nIGFmdGVyIHJ1bm5pbmcgJHtjbG9jay5sb29wTGltaXR9IHRpbWVycywgYXNzdW1pbmcgYW4gaW5maW5pdGUgbG9vcCFgLFxuICAgICAgICApO1xuXG4gICAgICAgIGlmICgham9iLmVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5maW5pdGVMb29wRXJyb3I7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBwYXR0ZXJuIG5ldmVyIG1hdGNoZWQgaW4gTm9kZVxuICAgICAgICBjb25zdCBjb21wdXRlZFRhcmdldFBhdHRlcm4gPSAvdGFyZ2V0XFwuKls8fCh8W10uKj9bPnxcXF18KV1cXHMqLztcbiAgICAgICAgbGV0IGNsb2NrTWV0aG9kUGF0dGVybiA9IG5ldyBSZWdFeHAoXG4gICAgICAgICAgICBTdHJpbmcoT2JqZWN0LmtleXMoY2xvY2spLmpvaW4oXCJ8XCIpKSxcbiAgICAgICAgKTtcblxuICAgICAgICBpZiAoYWRkVGltZXJSZXR1cm5zT2JqZWN0KSB7XG4gICAgICAgICAgICAvLyBub2RlLmpzIGVudmlyb25tZW50XG4gICAgICAgICAgICBjbG9ja01ldGhvZFBhdHRlcm4gPSBuZXcgUmVnRXhwKFxuICAgICAgICAgICAgICAgIGBcXFxccythdCAoT2JqZWN0XFxcXC4pPyg/OiR7T2JqZWN0LmtleXMoY2xvY2spLmpvaW4oXCJ8XCIpfSlcXFxccytgLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBtYXRjaGVkTGluZUluZGV4ID0gLTE7XG4gICAgICAgIGpvYi5lcnJvci5zdGFjay5zcGxpdChcIlxcblwiKS5zb21lKGZ1bmN0aW9uIChsaW5lLCBpKSB7XG4gICAgICAgICAgICAvLyBJZiB3ZSd2ZSBtYXRjaGVkIGEgY29tcHV0ZWQgdGFyZ2V0IGxpbmUgKGUuZy4gc2V0VGltZW91dCkgdGhlbiB3ZVxuICAgICAgICAgICAgLy8gZG9uJ3QgbmVlZCB0byBsb29rIGFueSBmdXJ0aGVyLiBSZXR1cm4gdHJ1ZSB0byBzdG9wIGl0ZXJhdGluZy5cbiAgICAgICAgICAgIGNvbnN0IG1hdGNoZWRDb21wdXRlZFRhcmdldCA9IGxpbmUubWF0Y2goY29tcHV0ZWRUYXJnZXRQYXR0ZXJuKTtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgaWYgKG1hdGNoZWRDb21wdXRlZFRhcmdldCkge1xuICAgICAgICAgICAgICAgIG1hdGNoZWRMaW5lSW5kZXggPSBpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJZiB3ZSd2ZSBtYXRjaGVkIGEgY2xvY2sgbWV0aG9kIGxpbmUsIHRoZW4gdGhlcmUgbWF5IHN0aWxsIGJlXG4gICAgICAgICAgICAvLyBvdGhlcnMgZnVydGhlciBkb3duIHRoZSB0cmFjZS4gUmV0dXJuIGZhbHNlIHRvIGtlZXAgaXRlcmF0aW5nLlxuICAgICAgICAgICAgY29uc3QgbWF0Y2hlZENsb2NrTWV0aG9kID0gbGluZS5tYXRjaChjbG9ja01ldGhvZFBhdHRlcm4pO1xuICAgICAgICAgICAgaWYgKG1hdGNoZWRDbG9ja01ldGhvZCkge1xuICAgICAgICAgICAgICAgIG1hdGNoZWRMaW5lSW5kZXggPSBpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSWYgd2UgaGF2ZW4ndCBtYXRjaGVkIGFueXRoaW5nIG9uIHRoaXMgbGluZSwgYnV0IHdlIG1hdGNoZWRcbiAgICAgICAgICAgIC8vIHByZXZpb3VzbHkgYW5kIHNldCB0aGUgbWF0Y2hlZCBsaW5lIGluZGV4LCB0aGVuIHdlIGNhbiBzdG9wLlxuICAgICAgICAgICAgLy8gSWYgd2UgaGF2ZW4ndCBtYXRjaGVkIHByZXZpb3VzbHksIHRoZW4gd2Ugc2hvdWxkIGtlZXAgaXRlcmF0aW5nLlxuICAgICAgICAgICAgcmV0dXJuIG1hdGNoZWRMaW5lSW5kZXggPj0gMDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3Qgc3RhY2sgPSBgJHtpbmZpbml0ZUxvb3BFcnJvcn1cXG4ke2pvYi50eXBlIHx8IFwiTWljcm90YXNrXCJ9IC0gJHtcbiAgICAgICAgICAgIGpvYi5mdW5jLm5hbWUgfHwgXCJhbm9ueW1vdXNcIlxuICAgICAgICB9XFxuJHtqb2IuZXJyb3Iuc3RhY2tcbiAgICAgICAgICAgIC5zcGxpdChcIlxcblwiKVxuICAgICAgICAgICAgLnNsaWNlKG1hdGNoZWRMaW5lSW5kZXggKyAxKVxuICAgICAgICAgICAgLmpvaW4oXCJcXG5cIil9YDtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGluZmluaXRlTG9vcEVycm9yLCBcInN0YWNrXCIsIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogc3RhY2ssXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gbm9vcFxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGluZmluaXRlTG9vcEVycm9yO1xuICAgIH1cblxuICAgIC8vZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGpzZG9jL3JlcXVpcmUtanNkb2NcbiAgICBmdW5jdGlvbiBjcmVhdGVEYXRlKCkge1xuICAgICAgICBjbGFzcyBDbG9ja0RhdGUgZXh0ZW5kcyBOYXRpdmVEYXRlIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHllYXJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtb250aFxuICAgICAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGRhdGVcbiAgICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBob3VyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gbWludXRlXG4gICAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gc2Vjb25kXG4gICAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gbXNcbiAgICAgICAgICAgICAqIEByZXR1cm5zIHZvaWRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICAgICAgICBjb25zdHJ1Y3Rvcih5ZWFyLCBtb250aCwgZGF0ZSwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1zKSB7XG4gICAgICAgICAgICAgICAgLy8gRGVmZW5zaXZlIGFuZCB2ZXJib3NlIHRvIGF2b2lkIHBvdGVudGlhbCBoYXJtIGluIHBhc3NpbmdcbiAgICAgICAgICAgICAgICAvLyBleHBsaWNpdCB1bmRlZmluZWQgd2hlbiB1c2VyIGRvZXMgbm90IHBhc3MgYXJndW1lbnRcbiAgICAgICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBzdXBlcihDbG9ja0RhdGUuY2xvY2subm93KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGVuc3VyZXMgaWRlbnRpdHkgY2hlY2tzIHVzaW5nIHRoZSBjb25zdHJ1Y3RvciBwcm9wIHN0aWxsIHdvcmtzXG4gICAgICAgICAgICAgICAgLy8gdGhpcyBzaG91bGQgaGF2ZSBubyBvdGhlciBmdW5jdGlvbmFsIGVmZmVjdFxuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNvbnN0cnVjdG9yXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IE5hdGl2ZURhdGUsXG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzdGF0aWMgW1N5bWJvbC5oYXNJbnN0YW5jZV0oaW5zdGFuY2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5zdGFuY2UgaW5zdGFuY2VvZiBOYXRpdmVEYXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgQ2xvY2tEYXRlLmlzRmFrZSA9IHRydWU7XG5cbiAgICAgICAgaWYgKE5hdGl2ZURhdGUubm93KSB7XG4gICAgICAgICAgICBDbG9ja0RhdGUubm93ID0gZnVuY3Rpb24gbm93KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBDbG9ja0RhdGUuY2xvY2subm93O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChOYXRpdmVEYXRlLnRvU291cmNlKSB7XG4gICAgICAgICAgICBDbG9ja0RhdGUudG9Tb3VyY2UgPSBmdW5jdGlvbiB0b1NvdXJjZSgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTmF0aXZlRGF0ZS50b1NvdXJjZSgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIENsb2NrRGF0ZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgICAgICAgcmV0dXJuIE5hdGl2ZURhdGUudG9TdHJpbmcoKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBub2luc3BlY3Rpb24gVW5uZWNlc3NhcnlMb2NhbFZhcmlhYmxlSlNcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgbm9ybWFsIENsYXNzIGNvbnN0cnVjdG9yIGNhbm5vdCBiZSBjYWxsZWQgd2l0aG91dCBgbmV3YCwgYnV0IERhdGUgY2FuLCBzbyB3ZSBuZWVkXG4gICAgICAgICAqIHRvIHdyYXAgaXQgaW4gYSBQcm94eSBpbiBvcmRlciB0byBlbnN1cmUgdGhpcyBmdW5jdGlvbmFsaXR5IG9mIERhdGUgaXMga2VwdCBpbnRhY3RcbiAgICAgICAgICogQHR5cGUge0Nsb2NrRGF0ZX1cbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IENsb2NrRGF0ZVByb3h5ID0gbmV3IFByb3h5KENsb2NrRGF0ZSwge1xuICAgICAgICAgICAgLy8gaGFuZGxlciBmb3IgW1tDYWxsXV0gaW52b2NhdGlvbnMgKGkuZS4gbm90IHVzaW5nIGBuZXdgKVxuICAgICAgICAgICAgYXBwbHkoKSB7XG4gICAgICAgICAgICAgICAgLy8gdGhlIERhdGUgY29uc3RydWN0b3IgY2FsbGVkIGFzIGEgZnVuY3Rpb24sIHJlZiBFY21hLTI2MiBFZGl0aW9uIDUuMSwgc2VjdGlvbiAxNS45LjIuXG4gICAgICAgICAgICAgICAgLy8gVGhpcyByZW1haW5zIHNvIGluIHRoZSAxMHRoIGVkaXRpb24gb2YgMjAxOSBhcyB3ZWxsLlxuICAgICAgICAgICAgICAgIGlmICh0aGlzIGluc3RhbmNlb2YgQ2xvY2tEYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgICBcIkEgUHJveHkgc2hvdWxkIG9ubHkgY2FwdHVyZSBgbmV3YCBjYWxscyB3aXRoIHRoZSBgY29uc3RydWN0YCBoYW5kbGVyLiBUaGlzIGlzIG5vdCBzdXBwb3NlZCB0byBiZSBwb3NzaWJsZSwgc28gY2hlY2sgdGhlIGxvZ2ljLlwiLFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTmF0aXZlRGF0ZShDbG9ja0RhdGUuY2xvY2subm93KS50b1N0cmluZygpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIENsb2NrRGF0ZVByb3h5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1pcnJvciBJbnRsIGJ5IGRlZmF1bHQgb24gb3VyIGZha2UgaW1wbGVtZW50YXRpb25cbiAgICAgKlxuICAgICAqIE1vc3Qgb2YgdGhlIHByb3BlcnRpZXMgYXJlIHRoZSBvcmlnaW5hbCBuYXRpdmUgb25lcyxcbiAgICAgKiBidXQgd2UgbmVlZCB0byB0YWtlIGNvbnRyb2wgb2YgdGhvc2UgdGhhdCBoYXZlIGFcbiAgICAgKiBkZXBlbmRlbmN5IG9uIHRoZSBjdXJyZW50IGNsb2NrLlxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9IHRoZSBwYXJ0bHkgZmFrZSBJbnRsIGltcGxlbWVudGF0aW9uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlSW50bCgpIHtcbiAgICAgICAgY29uc3QgQ2xvY2tJbnRsID0ge307XG4gICAgICAgIC8qXG4gICAgICAgICAqIEFsbCBwcm9wZXJ0aWVzIG9mIEludGwgYXJlIG5vbi1lbnVtZXJhYmxlLCBzbyB3ZSBuZWVkXG4gICAgICAgICAqIHRvIGRvIGEgYml0IG9mIHdvcmsgdG8gZ2V0IHRoZW0gb3V0LlxuICAgICAgICAgKi9cbiAgICAgICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoTmF0aXZlSW50bCkuZm9yRWFjaChcbiAgICAgICAgICAgIChwcm9wZXJ0eSkgPT4gKENsb2NrSW50bFtwcm9wZXJ0eV0gPSBOYXRpdmVJbnRsW3Byb3BlcnR5XSksXG4gICAgICAgICk7XG5cbiAgICAgICAgQ2xvY2tJbnRsLkRhdGVUaW1lRm9ybWF0ID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlYWxGb3JtYXR0ZXIgPSBuZXcgTmF0aXZlSW50bC5EYXRlVGltZUZvcm1hdCguLi5hcmdzKTtcbiAgICAgICAgICAgIGNvbnN0IGZvcm1hdHRlciA9IHt9O1xuXG4gICAgICAgICAgICBbXCJmb3JtYXRSYW5nZVwiLCBcImZvcm1hdFJhbmdlVG9QYXJ0c1wiLCBcInJlc29sdmVkT3B0aW9uc1wiXS5mb3JFYWNoKFxuICAgICAgICAgICAgICAgIChtZXRob2QpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZm9ybWF0dGVyW21ldGhvZF0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVhbEZvcm1hdHRlclttZXRob2RdLmJpbmQocmVhbEZvcm1hdHRlcik7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIFtcImZvcm1hdFwiLCBcImZvcm1hdFRvUGFydHNcIl0uZm9yRWFjaCgobWV0aG9kKSA9PiB7XG4gICAgICAgICAgICAgICAgZm9ybWF0dGVyW21ldGhvZF0gPSBmdW5jdGlvbiAoZGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVhbEZvcm1hdHRlclttZXRob2RdKGRhdGUgfHwgQ2xvY2tJbnRsLmNsb2NrLm5vdyk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gZm9ybWF0dGVyO1xuICAgICAgICB9O1xuXG4gICAgICAgIENsb2NrSW50bC5EYXRlVGltZUZvcm1hdC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFxuICAgICAgICAgICAgTmF0aXZlSW50bC5EYXRlVGltZUZvcm1hdC5wcm90b3R5cGUsXG4gICAgICAgICk7XG5cbiAgICAgICAgQ2xvY2tJbnRsLkRhdGVUaW1lRm9ybWF0LnN1cHBvcnRlZExvY2FsZXNPZiA9XG4gICAgICAgICAgICBOYXRpdmVJbnRsLkRhdGVUaW1lRm9ybWF0LnN1cHBvcnRlZExvY2FsZXNPZjtcblxuICAgICAgICByZXR1cm4gQ2xvY2tJbnRsO1xuICAgIH1cblxuICAgIC8vZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGpzZG9jL3JlcXVpcmUtanNkb2NcbiAgICBmdW5jdGlvbiBlbnF1ZXVlSm9iKGNsb2NrLCBqb2IpIHtcbiAgICAgICAgLy8gZW5xdWV1ZXMgYSBtaWNyb3RpY2stZGVmZXJyZWQgdGFzayAtIGVjbWEyNjIvI3NlYy1lbnF1ZXVlam9iXG4gICAgICAgIGlmICghY2xvY2suam9icykge1xuICAgICAgICAgICAgY2xvY2suam9icyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGNsb2NrLmpvYnMucHVzaChqb2IpO1xuICAgIH1cblxuICAgIC8vZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGpzZG9jL3JlcXVpcmUtanNkb2NcbiAgICBmdW5jdGlvbiBydW5Kb2JzKGNsb2NrKSB7XG4gICAgICAgIC8vIHJ1bnMgYWxsIG1pY3JvdGljay1kZWZlcnJlZCB0YXNrcyAtIGVjbWEyNjIvI3NlYy1ydW5qb2JzXG4gICAgICAgIGlmICghY2xvY2suam9icykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2xvY2suam9icy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgam9iID0gY2xvY2suam9ic1tpXTtcbiAgICAgICAgICAgIGpvYi5mdW5jLmFwcGx5KG51bGwsIGpvYi5hcmdzKTtcblxuICAgICAgICAgICAgY2hlY2tJc05lYXJJbmZpbml0ZUxpbWl0KGNsb2NrLCBpKTtcbiAgICAgICAgICAgIGlmIChjbG9jay5sb29wTGltaXQgJiYgaSA+IGNsb2NrLmxvb3BMaW1pdCkge1xuICAgICAgICAgICAgICAgIHRocm93IGdldEluZmluaXRlTG9vcEVycm9yKGNsb2NrLCBqb2IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlc2V0SXNOZWFySW5maW5pdGVMaW1pdCgpO1xuICAgICAgICBjbG9jay5qb2JzID0gW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtDbG9ja30gY2xvY2tcbiAgICAgKiBAcGFyYW0ge1RpbWVyfSB0aW1lclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IGlkIG9mIHRoZSBjcmVhdGVkIHRpbWVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gYWRkVGltZXIoY2xvY2ssIHRpbWVyKSB7XG4gICAgICAgIGlmICh0aW1lci5mdW5jID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbGxiYWNrIG11c3QgYmUgcHJvdmlkZWQgdG8gdGltZXIgY2FsbHNcIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYWRkVGltZXJSZXR1cm5zT2JqZWN0KSB7XG4gICAgICAgICAgICAvLyBOb2RlLmpzIGVudmlyb25tZW50XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRpbWVyLmZ1bmMgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIGBbRVJSX0lOVkFMSURfQ0FMTEJBQ0tdOiBDYWxsYmFjayBtdXN0IGJlIGEgZnVuY3Rpb24uIFJlY2VpdmVkICR7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lci5mdW5jXG4gICAgICAgICAgICAgICAgICAgIH0gb2YgdHlwZSAke3R5cGVvZiB0aW1lci5mdW5jfWAsXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc05lYXJJbmZpbml0ZUxpbWl0KSB7XG4gICAgICAgICAgICB0aW1lci5lcnJvciA9IG5ldyBFcnJvcigpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGltZXIudHlwZSA9IHRpbWVyLmltbWVkaWF0ZSA/IFwiSW1tZWRpYXRlXCIgOiBcIlRpbWVvdXRcIjtcblxuICAgICAgICBpZiAodGltZXIuaGFzT3duUHJvcGVydHkoXCJkZWxheVwiKSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aW1lci5kZWxheSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIHRpbWVyLmRlbGF5ID0gcGFyc2VJbnQodGltZXIuZGVsYXksIDEwKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFpc051bWJlckZpbml0ZSh0aW1lci5kZWxheSkpIHtcbiAgICAgICAgICAgICAgICB0aW1lci5kZWxheSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aW1lci5kZWxheSA9IHRpbWVyLmRlbGF5ID4gbWF4VGltZW91dCA/IDEgOiB0aW1lci5kZWxheTtcbiAgICAgICAgICAgIHRpbWVyLmRlbGF5ID0gTWF0aC5tYXgoMCwgdGltZXIuZGVsYXkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRpbWVyLmhhc093blByb3BlcnR5KFwiaW50ZXJ2YWxcIikpIHtcbiAgICAgICAgICAgIHRpbWVyLnR5cGUgPSBcIkludGVydmFsXCI7XG4gICAgICAgICAgICB0aW1lci5pbnRlcnZhbCA9IHRpbWVyLmludGVydmFsID4gbWF4VGltZW91dCA/IDEgOiB0aW1lci5pbnRlcnZhbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aW1lci5oYXNPd25Qcm9wZXJ0eShcImFuaW1hdGlvblwiKSkge1xuICAgICAgICAgICAgdGltZXIudHlwZSA9IFwiQW5pbWF0aW9uRnJhbWVcIjtcbiAgICAgICAgICAgIHRpbWVyLmFuaW1hdGlvbiA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGltZXIuaGFzT3duUHJvcGVydHkoXCJpZGxlQ2FsbGJhY2tcIikpIHtcbiAgICAgICAgICAgIHRpbWVyLnR5cGUgPSBcIklkbGVDYWxsYmFja1wiO1xuICAgICAgICAgICAgdGltZXIuaWRsZUNhbGxiYWNrID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghY2xvY2sudGltZXJzKSB7XG4gICAgICAgICAgICBjbG9jay50aW1lcnMgPSB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRpbWVyLmlkID0gdW5pcXVlVGltZXJJZCsrO1xuICAgICAgICB0aW1lci5jcmVhdGVkQXQgPSBjbG9jay5ub3c7XG4gICAgICAgIHRpbWVyLmNhbGxBdCA9XG4gICAgICAgICAgICBjbG9jay5ub3cgKyAocGFyc2VJbnQodGltZXIuZGVsYXkpIHx8IChjbG9jay5kdXJpbmdUaWNrID8gMSA6IDApKTtcblxuICAgICAgICBjbG9jay50aW1lcnNbdGltZXIuaWRdID0gdGltZXI7XG5cbiAgICAgICAgaWYgKGFkZFRpbWVyUmV0dXJuc09iamVjdCkge1xuICAgICAgICAgICAgY29uc3QgcmVzID0ge1xuICAgICAgICAgICAgICAgIHJlZmVkOiB0cnVlLFxuICAgICAgICAgICAgICAgIHJlZjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlZmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHVucmVmOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVmZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGhhc1JlZjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZWZlZDtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHJlZnJlc2g6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGltZXIuY2FsbEF0ID1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNsb2NrLm5vdyArXG4gICAgICAgICAgICAgICAgICAgICAgICAocGFyc2VJbnQodGltZXIuZGVsYXkpIHx8IChjbG9jay5kdXJpbmdUaWNrID8gMSA6IDApKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBpdCBfbWlnaHRfIGhhdmUgYmVlbiByZW1vdmVkLCBidXQgaWYgbm90IHRoZSBhc3NpZ25tZW50IGlzIHBlcmZlY3RseSBmaW5lXG4gICAgICAgICAgICAgICAgICAgIGNsb2NrLnRpbWVyc1t0aW1lci5pZF0gPSB0aW1lcjtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgW1N5bWJvbC50b1ByaW1pdGl2ZV06IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRpbWVyLmlkO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aW1lci5pZDtcbiAgICB9XG5cbiAgICAvKiBlc2xpbnQgY29uc2lzdGVudC1yZXR1cm46IFwib2ZmXCIgKi9cbiAgICAvKipcbiAgICAgKiBUaW1lciBjb21wYXJpdG9yXG4gICAgICogQHBhcmFtIHtUaW1lcn0gYVxuICAgICAqIEBwYXJhbSB7VGltZXJ9IGJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbXBhcmVUaW1lcnMoYSwgYikge1xuICAgICAgICAvLyBTb3J0IGZpcnN0IGJ5IGFic29sdXRlIHRpbWluZ1xuICAgICAgICBpZiAoYS5jYWxsQXQgPCBiLmNhbGxBdCkge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhLmNhbGxBdCA+IGIuY2FsbEF0KSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNvcnQgbmV4dCBieSBpbW1lZGlhdGUsIGltbWVkaWF0ZSB0aW1lcnMgdGFrZSBwcmVjZWRlbmNlXG4gICAgICAgIGlmIChhLmltbWVkaWF0ZSAmJiAhYi5pbW1lZGlhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWEuaW1tZWRpYXRlICYmIGIuaW1tZWRpYXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNvcnQgbmV4dCBieSBjcmVhdGlvbiB0aW1lLCBlYXJsaWVyLWNyZWF0ZWQgdGltZXJzIHRha2UgcHJlY2VkZW5jZVxuICAgICAgICBpZiAoYS5jcmVhdGVkQXQgPCBiLmNyZWF0ZWRBdCkge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhLmNyZWF0ZWRBdCA+IGIuY3JlYXRlZEF0KSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNvcnQgbmV4dCBieSBpZCwgbG93ZXItaWQgdGltZXJzIHRha2UgcHJlY2VkZW5jZVxuICAgICAgICBpZiAoYS5pZCA8IGIuaWQpIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYS5pZCA+IGIuaWQpIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQXMgdGltZXIgaWRzIGFyZSB1bmlxdWUsIG5vIGZhbGxiYWNrIGAwYCBpcyBuZWNlc3NhcnlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0Nsb2NrfSBjbG9ja1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRvXG4gICAgICogQHJldHVybnMge1RpbWVyfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpcnN0VGltZXJJblJhbmdlKGNsb2NrLCBmcm9tLCB0bykge1xuICAgICAgICBjb25zdCB0aW1lcnMgPSBjbG9jay50aW1lcnM7XG4gICAgICAgIGxldCB0aW1lciA9IG51bGw7XG4gICAgICAgIGxldCBpZCwgaXNJblJhbmdlO1xuXG4gICAgICAgIGZvciAoaWQgaW4gdGltZXJzKSB7XG4gICAgICAgICAgICBpZiAodGltZXJzLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgICAgICAgICAgICAgIGlzSW5SYW5nZSA9IGluUmFuZ2UoZnJvbSwgdG8sIHRpbWVyc1tpZF0pO1xuXG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICBpc0luUmFuZ2UgJiZcbiAgICAgICAgICAgICAgICAgICAgKCF0aW1lciB8fCBjb21wYXJlVGltZXJzKHRpbWVyLCB0aW1lcnNbaWRdKSA9PT0gMSlcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgdGltZXIgPSB0aW1lcnNbaWRdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aW1lcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0Nsb2NrfSBjbG9ja1xuICAgICAqIEByZXR1cm5zIHtUaW1lcn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaXJzdFRpbWVyKGNsb2NrKSB7XG4gICAgICAgIGNvbnN0IHRpbWVycyA9IGNsb2NrLnRpbWVycztcbiAgICAgICAgbGV0IHRpbWVyID0gbnVsbDtcbiAgICAgICAgbGV0IGlkO1xuXG4gICAgICAgIGZvciAoaWQgaW4gdGltZXJzKSB7XG4gICAgICAgICAgICBpZiAodGltZXJzLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgICAgICAgICAgICAgIGlmICghdGltZXIgfHwgY29tcGFyZVRpbWVycyh0aW1lciwgdGltZXJzW2lkXSkgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGltZXIgPSB0aW1lcnNbaWRdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aW1lcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0Nsb2NrfSBjbG9ja1xuICAgICAqIEByZXR1cm5zIHtUaW1lcn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsYXN0VGltZXIoY2xvY2spIHtcbiAgICAgICAgY29uc3QgdGltZXJzID0gY2xvY2sudGltZXJzO1xuICAgICAgICBsZXQgdGltZXIgPSBudWxsO1xuICAgICAgICBsZXQgaWQ7XG5cbiAgICAgICAgZm9yIChpZCBpbiB0aW1lcnMpIHtcbiAgICAgICAgICAgIGlmICh0aW1lcnMuaGFzT3duUHJvcGVydHkoaWQpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aW1lciB8fCBjb21wYXJlVGltZXJzKHRpbWVyLCB0aW1lcnNbaWRdKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGltZXIgPSB0aW1lcnNbaWRdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aW1lcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0Nsb2NrfSBjbG9ja1xuICAgICAqIEBwYXJhbSB7VGltZXJ9IHRpbWVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2FsbFRpbWVyKGNsb2NrLCB0aW1lcikge1xuICAgICAgICBpZiAodHlwZW9mIHRpbWVyLmludGVydmFsID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICBjbG9jay50aW1lcnNbdGltZXIuaWRdLmNhbGxBdCArPSB0aW1lci5pbnRlcnZhbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRlbGV0ZSBjbG9jay50aW1lcnNbdGltZXIuaWRdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiB0aW1lci5mdW5jID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHRpbWVyLmZ1bmMuYXBwbHkobnVsbCwgdGltZXIuYXJncyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvKiBlc2xpbnQgbm8tZXZhbDogXCJvZmZcIiAqL1xuICAgICAgICAgICAgY29uc3QgZXZhbDIgPSBldmFsO1xuICAgICAgICAgICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBldmFsMih0aW1lci5mdW5jKTtcbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGNsZWFyIGhhbmRsZXIgbmFtZSBmb3IgYSBnaXZlbiB0aW1lciB0eXBlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR0eXBlXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0Q2xlYXJIYW5kbGVyKHR0eXBlKSB7XG4gICAgICAgIGlmICh0dHlwZSA9PT0gXCJJZGxlQ2FsbGJhY2tcIiB8fCB0dHlwZSA9PT0gXCJBbmltYXRpb25GcmFtZVwiKSB7XG4gICAgICAgICAgICByZXR1cm4gYGNhbmNlbCR7dHR5cGV9YDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYGNsZWFyJHt0dHlwZX1gO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgc2NoZWR1bGUgaGFuZGxlciBuYW1lIGZvciBhIGdpdmVuIHRpbWVyIHR5cGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHR5cGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRTY2hlZHVsZUhhbmRsZXIodHR5cGUpIHtcbiAgICAgICAgaWYgKHR0eXBlID09PSBcIklkbGVDYWxsYmFja1wiIHx8IHR0eXBlID09PSBcIkFuaW1hdGlvbkZyYW1lXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBgcmVxdWVzdCR7dHR5cGV9YDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYHNldCR7dHR5cGV9YDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFub255bW91cyBmdW5jdGlvbiB0byB3YXJuIG9ubHkgb25jZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVdhcm5PbmNlKCkge1xuICAgICAgICBsZXQgY2FsbHMgPSAwO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG1zZykge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICAgICAgICAhY2FsbHMrKyAmJiBjb25zb2xlLndhcm4obXNnKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29uc3Qgd2Fybk9uY2UgPSBjcmVhdGVXYXJuT25jZSgpO1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtDbG9ja30gY2xvY2tcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdGltZXJJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0dHlwZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsZWFyVGltZXIoY2xvY2ssIHRpbWVySWQsIHR0eXBlKSB7XG4gICAgICAgIGlmICghdGltZXJJZCkge1xuICAgICAgICAgICAgLy8gbnVsbCBhcHBlYXJzIHRvIGJlIGFsbG93ZWQgaW4gbW9zdCBicm93c2VycywgYW5kIGFwcGVhcnMgdG8gYmVcbiAgICAgICAgICAgIC8vIHJlbGllZCB1cG9uIGJ5IHNvbWUgbGlicmFyaWVzLCBsaWtlIEJvb3RzdHJhcCBjYXJvdXNlbFxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFjbG9jay50aW1lcnMpIHtcbiAgICAgICAgICAgIGNsb2NrLnRpbWVycyA9IHt9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaW4gTm9kZSwgdGhlIElEIGlzIHN0b3JlZCBhcyB0aGUgcHJpbWl0aXZlIHZhbHVlIGZvciBgVGltZW91dGAgb2JqZWN0c1xuICAgICAgICAvLyBmb3IgYEltbWVkaWF0ZWAgb2JqZWN0cywgbm8gSUQgZXhpc3RzLCBzbyBpdCBnZXRzIGNvZXJjZWQgdG8gTmFOXG4gICAgICAgIGNvbnN0IGlkID0gTnVtYmVyKHRpbWVySWQpO1xuXG4gICAgICAgIGlmIChOdW1iZXIuaXNOYU4oaWQpIHx8IGlkIDwgaWRDb3VudGVyU3RhcnQpIHtcbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZXJOYW1lID0gZ2V0Q2xlYXJIYW5kbGVyKHR0eXBlKTtcblxuICAgICAgICAgICAgaWYgKGNsb2NrLnNob3VsZENsZWFyTmF0aXZlVGltZXJzID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmF0aXZlSGFuZGxlciA9IGNsb2NrW2BfJHtoYW5kbGVyTmFtZX1gXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZW9mIG5hdGl2ZUhhbmRsZXIgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICAgICAgICAgICAgICA/IG5hdGl2ZUhhbmRsZXIodGltZXJJZClcbiAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEluY2x1ZGUgdGhlIHN0YWNrdHJhY2UsIGV4Y2x1ZGluZyB0aGUgJ2Vycm9yJyBsaW5lXG4gICAgICAgICAgICBjb25zdCBzdGFja1RyYWNlID0gbmV3IEVycm9yKCkuc3RhY2tcbiAgICAgICAgICAgICAgICAuc3BsaXQoXCJcXG5cIilcbiAgICAgICAgICAgICAgICAuc2xpY2UoMSlcbiAgICAgICAgICAgICAgICAuam9pbihcIlxcblwiKTtcblxuICAgICAgICAgICAgd2Fybk9uY2UoXG4gICAgICAgICAgICAgICAgYEZha2VUaW1lcnM6ICR7aGFuZGxlck5hbWV9IHdhcyBpbnZva2VkIHRvIGNsZWFyIGEgbmF0aXZlIHRpbWVyIGluc3RlYWQgb2Ygb25lIGNyZWF0ZWQgYnkgdGhpcyBsaWJyYXJ5LmAgK1xuICAgICAgICAgICAgICAgICAgICBcIlxcblRvIGF1dG9tYXRpY2FsbHkgY2xlYW4tdXAgbmF0aXZlIHRpbWVycywgdXNlIGBzaG91bGRDbGVhck5hdGl2ZVRpbWVyc2AuXCIgK1xuICAgICAgICAgICAgICAgICAgICBgXFxuJHtzdGFja1RyYWNlfWAsXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNsb2NrLnRpbWVycy5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICAgICAgICAgIC8vIGNoZWNrIHRoYXQgdGhlIElEIG1hdGNoZXMgYSB0aW1lciBvZiB0aGUgY29ycmVjdCB0eXBlXG4gICAgICAgICAgICBjb25zdCB0aW1lciA9IGNsb2NrLnRpbWVyc1tpZF07XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgdGltZXIudHlwZSA9PT0gdHR5cGUgfHxcbiAgICAgICAgICAgICAgICAodGltZXIudHlwZSA9PT0gXCJUaW1lb3V0XCIgJiYgdHR5cGUgPT09IFwiSW50ZXJ2YWxcIikgfHxcbiAgICAgICAgICAgICAgICAodGltZXIudHlwZSA9PT0gXCJJbnRlcnZhbFwiICYmIHR0eXBlID09PSBcIlRpbWVvdXRcIilcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBjbG9jay50aW1lcnNbaWRdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjbGVhciA9IGdldENsZWFySGFuZGxlcih0dHlwZSk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2NoZWR1bGUgPSBnZXRTY2hlZHVsZUhhbmRsZXIodGltZXIudHlwZSk7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICBgQ2Fubm90IGNsZWFyIHRpbWVyOiB0aW1lciBjcmVhdGVkIHdpdGggJHtzY2hlZHVsZX0oKSBidXQgY2xlYXJlZCB3aXRoICR7Y2xlYXJ9KClgLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0Nsb2NrfSBjbG9ja1xuICAgICAqIEByZXR1cm5zIHtUaW1lcltdfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuaW5zdGFsbChjbG9jaykge1xuICAgICAgICBsZXQgbWV0aG9kLCBpLCBsO1xuICAgICAgICBjb25zdCBpbnN0YWxsZWRIclRpbWUgPSBcIl9ocnRpbWVcIjtcbiAgICAgICAgY29uc3QgaW5zdGFsbGVkTmV4dFRpY2sgPSBcIl9uZXh0VGlja1wiO1xuXG4gICAgICAgIGZvciAoaSA9IDAsIGwgPSBjbG9jay5tZXRob2RzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgbWV0aG9kID0gY2xvY2subWV0aG9kc1tpXTtcbiAgICAgICAgICAgIGlmIChtZXRob2QgPT09IFwiaHJ0aW1lXCIgJiYgX2dsb2JhbC5wcm9jZXNzKSB7XG4gICAgICAgICAgICAgICAgX2dsb2JhbC5wcm9jZXNzLmhydGltZSA9IGNsb2NrW2luc3RhbGxlZEhyVGltZV07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG1ldGhvZCA9PT0gXCJuZXh0VGlja1wiICYmIF9nbG9iYWwucHJvY2Vzcykge1xuICAgICAgICAgICAgICAgIF9nbG9iYWwucHJvY2Vzcy5uZXh0VGljayA9IGNsb2NrW2luc3RhbGxlZE5leHRUaWNrXTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobWV0aG9kID09PSBcInBlcmZvcm1hbmNlXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvcmlnaW5hbFBlcmZEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihcbiAgICAgICAgICAgICAgICAgICAgY2xvY2ssXG4gICAgICAgICAgICAgICAgICAgIGBfJHttZXRob2R9YCxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxQZXJmRGVzY3JpcHRvciAmJlxuICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbFBlcmZEZXNjcmlwdG9yLmdldCAmJlxuICAgICAgICAgICAgICAgICAgICAhb3JpZ2luYWxQZXJmRGVzY3JpcHRvci5zZXRcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFxuICAgICAgICAgICAgICAgICAgICAgICAgX2dsb2JhbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsUGVyZkRlc2NyaXB0b3IsXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChvcmlnaW5hbFBlcmZEZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSkge1xuICAgICAgICAgICAgICAgICAgICBfZ2xvYmFsW21ldGhvZF0gPSBjbG9ja1tgXyR7bWV0aG9kfWBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKF9nbG9iYWxbbWV0aG9kXSAmJiBfZ2xvYmFsW21ldGhvZF0uaGFkT3duUHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICAgICAgX2dsb2JhbFttZXRob2RdID0gY2xvY2tbYF8ke21ldGhvZH1gXTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIF9nbG9iYWxbbWV0aG9kXTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoaWdub3JlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvKiBlc2xpbnQgbm8tZW1wdHk6IFwib2ZmXCIgKi9cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjbG9jay50aW1lcnNNb2R1bGVNZXRob2RzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGNsb2NrLnRpbWVyc01vZHVsZU1ldGhvZHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZW50cnkgPSBjbG9jay50aW1lcnNNb2R1bGVNZXRob2RzW2pdO1xuICAgICAgICAgICAgICAgICAgICB0aW1lcnNNb2R1bGVbZW50cnkubWV0aG9kTmFtZV0gPSBlbnRyeS5vcmlnaW5hbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2xvY2sudGltZXJzUHJvbWlzZXNNb2R1bGVNZXRob2RzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgICAgICAgICBsZXQgaiA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGogPCBjbG9jay50aW1lcnNQcm9taXNlc01vZHVsZU1ldGhvZHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBqKytcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZW50cnkgPSBjbG9jay50aW1lcnNQcm9taXNlc01vZHVsZU1ldGhvZHNbal07XG4gICAgICAgICAgICAgICAgICAgIHRpbWVyc1Byb21pc2VzTW9kdWxlW2VudHJ5Lm1ldGhvZE5hbWVdID0gZW50cnkub3JpZ2luYWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY2xvY2suc2V0VGlja01vZGUoXCJtYW51YWxcIik7XG5cbiAgICAgICAgLy8gUHJldmVudCBtdWx0aXBsZSBleGVjdXRpb25zIHdoaWNoIHdpbGwgY29tcGxldGVseSByZW1vdmUgdGhlc2UgcHJvcHNcbiAgICAgICAgY2xvY2subWV0aG9kcyA9IFtdO1xuXG4gICAgICAgIGZvciAoY29uc3QgW2xpc3RlbmVyLCBzaWduYWxdIG9mIGNsb2NrLmFib3J0TGlzdGVuZXJNYXAuZW50cmllcygpKSB7XG4gICAgICAgICAgICBzaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIGxpc3RlbmVyKTtcbiAgICAgICAgICAgIGNsb2NrLmFib3J0TGlzdGVuZXJNYXAuZGVsZXRlKGxpc3RlbmVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJldHVybiBwZW5kaW5nIHRpbWVycywgdG8gZW5hYmxlIGNoZWNraW5nIHdoYXQgdGltZXJzIHJlbWFpbmVkIG9uIHVuaW5zdGFsbFxuICAgICAgICBpZiAoIWNsb2NrLnRpbWVycykge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhjbG9jay50aW1lcnMpLm1hcChmdW5jdGlvbiBtYXBwZXIoa2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gY2xvY2sudGltZXJzW2tleV07XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSB0YXJnZXQgdGhlIHRhcmdldCBjb250YWluaW5nIHRoZSBtZXRob2QgdG8gcmVwbGFjZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtZXRob2QgdGhlIGtleW5hbWUgb2YgdGhlIG1ldGhvZCBvbiB0aGUgdGFyZ2V0XG4gICAgICogQHBhcmFtIHtDbG9ja30gY2xvY2tcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBoaWphY2tNZXRob2QodGFyZ2V0LCBtZXRob2QsIGNsb2NrKSB7XG4gICAgICAgIGNsb2NrW21ldGhvZF0uaGFkT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoXG4gICAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgICBtZXRob2QsXG4gICAgICAgICk7XG4gICAgICAgIGNsb2NrW2BfJHttZXRob2R9YF0gPSB0YXJnZXRbbWV0aG9kXTtcblxuICAgICAgICBpZiAobWV0aG9kID09PSBcIkRhdGVcIikge1xuICAgICAgICAgICAgdGFyZ2V0W21ldGhvZF0gPSBjbG9ja1ttZXRob2RdO1xuICAgICAgICB9IGVsc2UgaWYgKG1ldGhvZCA9PT0gXCJJbnRsXCIpIHtcbiAgICAgICAgICAgIHRhcmdldFttZXRob2RdID0gY2xvY2tbbWV0aG9kXTtcbiAgICAgICAgfSBlbHNlIGlmIChtZXRob2QgPT09IFwicGVyZm9ybWFuY2VcIikge1xuICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxQZXJmRGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoXG4gICAgICAgICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgICAgICAgIG1ldGhvZCxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICAvLyBKU0RPTSBoYXMgYSByZWFkIG9ubHkgcGVyZm9ybWFuY2UgZmllbGQgc28gd2UgaGF2ZSB0byBzYXZlL2NvcHkgaXQgZGlmZmVyZW50bHlcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBvcmlnaW5hbFBlcmZEZXNjcmlwdG9yICYmXG4gICAgICAgICAgICAgICAgb3JpZ2luYWxQZXJmRGVzY3JpcHRvci5nZXQgJiZcbiAgICAgICAgICAgICAgICAhb3JpZ2luYWxQZXJmRGVzY3JpcHRvci5zZXRcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShcbiAgICAgICAgICAgICAgICAgICAgY2xvY2ssXG4gICAgICAgICAgICAgICAgICAgIGBfJHttZXRob2R9YCxcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxQZXJmRGVzY3JpcHRvcixcbiAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgcGVyZkRlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKFxuICAgICAgICAgICAgICAgICAgICBjbG9jayxcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgbWV0aG9kLCBwZXJmRGVzY3JpcHRvcik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRhcmdldFttZXRob2RdID0gY2xvY2tbbWV0aG9kXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRhcmdldFttZXRob2RdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjbG9ja1ttZXRob2RdLmFwcGx5KGNsb2NrLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoXG4gICAgICAgICAgICAgICAgdGFyZ2V0W21ldGhvZF0sXG4gICAgICAgICAgICAgICAgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoY2xvY2tbbWV0aG9kXSksXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgdGFyZ2V0W21ldGhvZF0uY2xvY2sgPSBjbG9jaztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0Nsb2NrfSBjbG9ja1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhZHZhbmNlVGltZURlbHRhXG4gICAgICovXG4gICAgZnVuY3Rpb24gZG9JbnRlcnZhbFRpY2soY2xvY2ssIGFkdmFuY2VUaW1lRGVsdGEpIHtcbiAgICAgICAgY2xvY2sudGljayhhZHZhbmNlVGltZURlbHRhKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZWRlZiB7b2JqZWN0fSBUaW1lcnNcbiAgICAgKiBAcHJvcGVydHkge3NldFRpbWVvdXR9IHNldFRpbWVvdXRcbiAgICAgKiBAcHJvcGVydHkge2NsZWFyVGltZW91dH0gY2xlYXJUaW1lb3V0XG4gICAgICogQHByb3BlcnR5IHtzZXRJbnRlcnZhbH0gc2V0SW50ZXJ2YWxcbiAgICAgKiBAcHJvcGVydHkge2NsZWFySW50ZXJ2YWx9IGNsZWFySW50ZXJ2YWxcbiAgICAgKiBAcHJvcGVydHkge0RhdGV9IERhdGVcbiAgICAgKiBAcHJvcGVydHkge0ludGx9IEludGxcbiAgICAgKiBAcHJvcGVydHkge1NldEltbWVkaWF0ZT19IHNldEltbWVkaWF0ZVxuICAgICAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb24oTm9kZUltbWVkaWF0ZSk6IHZvaWQ9fSBjbGVhckltbWVkaWF0ZVxuICAgICAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb24obnVtYmVyW10pOm51bWJlcltdPX0gaHJ0aW1lXG4gICAgICogQHByb3BlcnR5IHtOZXh0VGljaz19IG5leHRUaWNrXG4gICAgICogQHByb3BlcnR5IHtQZXJmb3JtYW5jZT19IHBlcmZvcm1hbmNlXG4gICAgICogQHByb3BlcnR5IHtSZXF1ZXN0QW5pbWF0aW9uRnJhbWU9fSByZXF1ZXN0QW5pbWF0aW9uRnJhbWVcbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW49fSBxdWV1ZU1pY3JvdGFza1xuICAgICAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb24obnVtYmVyKTogdm9pZD19IGNhbmNlbEFuaW1hdGlvbkZyYW1lXG4gICAgICogQHByb3BlcnR5IHtSZXF1ZXN0SWRsZUNhbGxiYWNrPX0gcmVxdWVzdElkbGVDYWxsYmFja1xuICAgICAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb24obnVtYmVyKTogdm9pZD19IGNhbmNlbElkbGVDYWxsYmFja1xuICAgICAqL1xuXG4gICAgLyoqIEB0eXBlIHtUaW1lcnN9ICovXG4gICAgY29uc3QgdGltZXJzID0ge1xuICAgICAgICBzZXRUaW1lb3V0OiBfZ2xvYmFsLnNldFRpbWVvdXQsXG4gICAgICAgIGNsZWFyVGltZW91dDogX2dsb2JhbC5jbGVhclRpbWVvdXQsXG4gICAgICAgIHNldEludGVydmFsOiBfZ2xvYmFsLnNldEludGVydmFsLFxuICAgICAgICBjbGVhckludGVydmFsOiBfZ2xvYmFsLmNsZWFySW50ZXJ2YWwsXG4gICAgICAgIERhdGU6IF9nbG9iYWwuRGF0ZSxcbiAgICB9O1xuXG4gICAgaWYgKGlzUHJlc2VudC5zZXRJbW1lZGlhdGUpIHtcbiAgICAgICAgdGltZXJzLnNldEltbWVkaWF0ZSA9IF9nbG9iYWwuc2V0SW1tZWRpYXRlO1xuICAgIH1cblxuICAgIGlmIChpc1ByZXNlbnQuY2xlYXJJbW1lZGlhdGUpIHtcbiAgICAgICAgdGltZXJzLmNsZWFySW1tZWRpYXRlID0gX2dsb2JhbC5jbGVhckltbWVkaWF0ZTtcbiAgICB9XG5cbiAgICBpZiAoaXNQcmVzZW50LmhydGltZSkge1xuICAgICAgICB0aW1lcnMuaHJ0aW1lID0gX2dsb2JhbC5wcm9jZXNzLmhydGltZTtcbiAgICB9XG5cbiAgICBpZiAoaXNQcmVzZW50Lm5leHRUaWNrKSB7XG4gICAgICAgIHRpbWVycy5uZXh0VGljayA9IF9nbG9iYWwucHJvY2Vzcy5uZXh0VGljaztcbiAgICB9XG5cbiAgICBpZiAoaXNQcmVzZW50LnBlcmZvcm1hbmNlKSB7XG4gICAgICAgIHRpbWVycy5wZXJmb3JtYW5jZSA9IF9nbG9iYWwucGVyZm9ybWFuY2U7XG4gICAgfVxuXG4gICAgaWYgKGlzUHJlc2VudC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpIHtcbiAgICAgICAgdGltZXJzLnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IF9nbG9iYWwucmVxdWVzdEFuaW1hdGlvbkZyYW1lO1xuICAgIH1cblxuICAgIGlmIChpc1ByZXNlbnQucXVldWVNaWNyb3Rhc2spIHtcbiAgICAgICAgdGltZXJzLnF1ZXVlTWljcm90YXNrID0gX2dsb2JhbC5xdWV1ZU1pY3JvdGFzaztcbiAgICB9XG5cbiAgICBpZiAoaXNQcmVzZW50LmNhbmNlbEFuaW1hdGlvbkZyYW1lKSB7XG4gICAgICAgIHRpbWVycy5jYW5jZWxBbmltYXRpb25GcmFtZSA9IF9nbG9iYWwuY2FuY2VsQW5pbWF0aW9uRnJhbWU7XG4gICAgfVxuXG4gICAgaWYgKGlzUHJlc2VudC5yZXF1ZXN0SWRsZUNhbGxiYWNrKSB7XG4gICAgICAgIHRpbWVycy5yZXF1ZXN0SWRsZUNhbGxiYWNrID0gX2dsb2JhbC5yZXF1ZXN0SWRsZUNhbGxiYWNrO1xuICAgIH1cblxuICAgIGlmIChpc1ByZXNlbnQuY2FuY2VsSWRsZUNhbGxiYWNrKSB7XG4gICAgICAgIHRpbWVycy5jYW5jZWxJZGxlQ2FsbGJhY2sgPSBfZ2xvYmFsLmNhbmNlbElkbGVDYWxsYmFjaztcbiAgICB9XG5cbiAgICBpZiAoaXNQcmVzZW50LkludGwpIHtcbiAgICAgICAgdGltZXJzLkludGwgPSBOYXRpdmVJbnRsO1xuICAgIH1cblxuICAgIGNvbnN0IG9yaWdpbmFsU2V0VGltZW91dCA9IF9nbG9iYWwuc2V0SW1tZWRpYXRlIHx8IF9nbG9iYWwuc2V0VGltZW91dDtcbiAgICBjb25zdCBvcmlnaW5hbENsZWFySW50ZXJ2YWwgPSBfZ2xvYmFsLmNsZWFySW50ZXJ2YWw7XG4gICAgY29uc3Qgb3JpZ2luYWxTZXRJbnRlcnZhbCA9IF9nbG9iYWwuc2V0SW50ZXJ2YWw7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0RhdGV8bnVtYmVyfSBbc3RhcnRdIHRoZSBzeXN0ZW0gdGltZSAtIG5vbi1pbnRlZ2VyIHZhbHVlcyBhcmUgZmxvb3JlZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbG9vcExpbWl0XSBtYXhpbXVtIG51bWJlciBvZiB0aW1lcnMgdGhhdCB3aWxsIGJlIHJ1biB3aGVuIGNhbGxpbmcgcnVuQWxsKClcbiAgICAgKiBAcmV0dXJucyB7Q2xvY2t9XG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlQ2xvY2soc3RhcnQsIGxvb3BMaW1pdCkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgc3RhcnQgPSBNYXRoLmZsb29yKGdldEVwb2NoKHN0YXJ0KSk7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICBsb29wTGltaXQgPSBsb29wTGltaXQgfHwgMTAwMDtcbiAgICAgICAgbGV0IG5hbm9zID0gMDtcbiAgICAgICAgY29uc3QgYWRqdXN0ZWRTeXN0ZW1UaW1lID0gWzAsIDBdOyAvLyBbbWlsbGlzLCBuYW5vcmVtYWluZGVyXVxuXG4gICAgICAgIGNvbnN0IGNsb2NrID0ge1xuICAgICAgICAgICAgbm93OiBzdGFydCxcbiAgICAgICAgICAgIERhdGU6IGNyZWF0ZURhdGUoKSxcbiAgICAgICAgICAgIGxvb3BMaW1pdDogbG9vcExpbWl0LFxuICAgICAgICAgICAgdGlja01vZGU6IHsgbW9kZTogXCJtYW51YWxcIiwgY291bnRlcjogMCwgZGVsdGE6IHVuZGVmaW5lZCB9LFxuICAgICAgICB9O1xuXG4gICAgICAgIGNsb2NrLkRhdGUuY2xvY2sgPSBjbG9jaztcblxuICAgICAgICAvL2VzbGludC1kaXNhYmxlLW5leHQtbGluZSBqc2RvYy9yZXF1aXJlLWpzZG9jXG4gICAgICAgIGZ1bmN0aW9uIGdldFRpbWVUb05leHRGcmFtZSgpIHtcbiAgICAgICAgICAgIHJldHVybiAxNiAtICgoY2xvY2subm93IC0gc3RhcnQpICUgMTYpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9lc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUganNkb2MvcmVxdWlyZS1qc2RvY1xuICAgICAgICBmdW5jdGlvbiBocnRpbWUocHJldikge1xuICAgICAgICAgICAgY29uc3QgbWlsbGlzU2luY2VTdGFydCA9IGNsb2NrLm5vdyAtIGFkanVzdGVkU3lzdGVtVGltZVswXSAtIHN0YXJ0O1xuICAgICAgICAgICAgY29uc3Qgc2Vjc1NpbmNlU3RhcnQgPSBNYXRoLmZsb29yKG1pbGxpc1NpbmNlU3RhcnQgLyAxMDAwKTtcbiAgICAgICAgICAgIGNvbnN0IHJlbWFpbmRlckluTmFub3MgPVxuICAgICAgICAgICAgICAgIChtaWxsaXNTaW5jZVN0YXJ0IC0gc2Vjc1NpbmNlU3RhcnQgKiAxZTMpICogMWU2ICtcbiAgICAgICAgICAgICAgICBuYW5vcyAtXG4gICAgICAgICAgICAgICAgYWRqdXN0ZWRTeXN0ZW1UaW1lWzFdO1xuXG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwcmV2KSkge1xuICAgICAgICAgICAgICAgIGlmIChwcmV2WzFdID4gMWU5KSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgICBcIk51bWJlciBvZiBuYW5vc2Vjb25kcyBjYW4ndCBleGNlZWQgYSBiaWxsaW9uXCIsXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29uc3Qgb2xkU2VjcyA9IHByZXZbMF07XG4gICAgICAgICAgICAgICAgbGV0IG5hbm9EaWZmID0gcmVtYWluZGVySW5OYW5vcyAtIHByZXZbMV07XG4gICAgICAgICAgICAgICAgbGV0IHNlY0RpZmYgPSBzZWNzU2luY2VTdGFydCAtIG9sZFNlY3M7XG5cbiAgICAgICAgICAgICAgICBpZiAobmFub0RpZmYgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG5hbm9EaWZmICs9IDFlOTtcbiAgICAgICAgICAgICAgICAgICAgc2VjRGlmZiAtPSAxO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBbc2VjRGlmZiwgbmFub0RpZmZdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFtzZWNzU2luY2VTdGFydCwgcmVtYWluZGVySW5OYW5vc107XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQSBoaWdoIHJlc29sdXRpb24gdGltZXN0YW1wIGluIG1pbGxpc2Vjb25kcy5cbiAgICAgICAgICogQHR5cGVkZWYge251bWJlcn0gRE9NSGlnaFJlc1RpbWVTdGFtcFxuICAgICAgICAgKi9cblxuICAgICAgICAvKipcbiAgICAgICAgICogcGVyZm9ybWFuY2Uubm93KClcbiAgICAgICAgICogQHJldHVybnMge0RPTUhpZ2hSZXNUaW1lU3RhbXB9XG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBmYWtlUGVyZm9ybWFuY2VOb3coKSB7XG4gICAgICAgICAgICBjb25zdCBocnQgPSBocnRpbWUoKTtcbiAgICAgICAgICAgIGNvbnN0IG1pbGxpcyA9IGhydFswXSAqIDEwMDAgKyBocnRbMV0gLyAxZTY7XG4gICAgICAgICAgICByZXR1cm4gbWlsbGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzUHJlc2VudC5ocnRpbWVCaWdpbnQpIHtcbiAgICAgICAgICAgIGhydGltZS5iaWdpbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFydHMgPSBocnRpbWUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gQmlnSW50KHBhcnRzWzBdKSAqIEJpZ0ludCgxZTkpICsgQmlnSW50KHBhcnRzWzFdKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc1ByZXNlbnQuSW50bCkge1xuICAgICAgICAgICAgY2xvY2suSW50bCA9IGNyZWF0ZUludGwoKTtcbiAgICAgICAgICAgIGNsb2NrLkludGwuY2xvY2sgPSBjbG9jaztcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge1RpbWVyVGlja01vZGV9IHRpY2tNb2RlQ29uZmlnIC0gVGhlIG5ldyBjb25maWd1cmF0aW9uIGZvciBob3cgdGhlIGNsb2NrIHNob3VsZCB0aWNrLlxuICAgICAgICAgKi9cbiAgICAgICAgY2xvY2suc2V0VGlja01vZGUgPSBmdW5jdGlvbiAodGlja01vZGVDb25maWcpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgbW9kZTogbmV3TW9kZSwgZGVsdGE6IG5ld0RlbHRhIH0gPSB0aWNrTW9kZUNvbmZpZztcbiAgICAgICAgICAgIGNvbnN0IHsgbW9kZTogb2xkTW9kZSwgZGVsdGE6IG9sZERlbHRhIH0gPSBjbG9jay50aWNrTW9kZTtcbiAgICAgICAgICAgIGlmIChuZXdNb2RlID09PSBvbGRNb2RlICYmIG5ld0RlbHRhID09PSBvbGREZWx0YSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG9sZE1vZGUgPT09IFwiaW50ZXJ2YWxcIikge1xuICAgICAgICAgICAgICAgIG9yaWdpbmFsQ2xlYXJJbnRlcnZhbChjbG9jay5hdHRhY2hlZEludGVydmFsKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2xvY2sudGlja01vZGUgPSB7XG4gICAgICAgICAgICAgICAgY291bnRlcjogY2xvY2sudGlja01vZGUuY291bnRlciArIDEsXG4gICAgICAgICAgICAgICAgbW9kZTogbmV3TW9kZSxcbiAgICAgICAgICAgICAgICBkZWx0YTogbmV3RGVsdGEsXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZiAobmV3TW9kZSA9PT0gXCJuZXh0QXN5bmNcIikge1xuICAgICAgICAgICAgICAgIGFkdmFuY2VVbnRpbE1vZGVDaGFuZ2VzKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG5ld01vZGUgPT09IFwiaW50ZXJ2YWxcIikge1xuICAgICAgICAgICAgICAgIGNyZWF0ZUludGVydmFsVGljayhjbG9jaywgbmV3RGVsdGEgfHwgMjApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGFzeW5jIGZ1bmN0aW9uIGFkdmFuY2VVbnRpbE1vZGVDaGFuZ2VzKCkge1xuICAgICAgICAgICAgYXN5bmMgZnVuY3Rpb24gbmV3TWFjcm90YXNrKCkge1xuICAgICAgICAgICAgICAgIC8vIE1lc3NhZ2VDaGFubmVsIGVuc3VyZXMgdGhhdCBzZXRUaW1lb3V0IGlzIG5vdCB0aHJvdHRsZWQgdG8gNG1zLlxuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9zZXRUaW1lb3V0I3JlYXNvbnNfZm9yX2RlbGF5c19sb25nZXJfdGhhbl9zcGVjaWZpZWRcbiAgICAgICAgICAgICAgICAvLyBodHRwczovL3N0YWNrYmxpdHouY29tL2VkaXQvc3RhY2tibGl0ei1zdGFydGVycy1xdGxwY2NcbiAgICAgICAgICAgICAgICBjb25zdCBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgICAgICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFubmVsLnBvcnQxLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGNoYW5uZWwucG9ydDIucG9zdE1lc3NhZ2UodW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjaGFubmVsLnBvcnQxLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgY2hhbm5lbC5wb3J0Mi5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIC8vIHNldFRpbWVvdXQgZW5zdXJlcyBtaWNyb3Rhc2sgcXVldWUgaXMgZW1wdGllZFxuICAgICAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsU2V0VGltZW91dChyZXNvbHZlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgeyBjb3VudGVyIH0gPSBjbG9jay50aWNrTW9kZTtcbiAgICAgICAgICAgIHdoaWxlIChjbG9jay50aWNrTW9kZS5jb3VudGVyID09PSBjb3VudGVyKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgbmV3TWFjcm90YXNrKCk7XG4gICAgICAgICAgICAgICAgaWYgKGNsb2NrLnRpY2tNb2RlLmNvdW50ZXIgIT09IGNvdW50ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjbG9jay5uZXh0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBwYXVzZUF1dG9UaWNrVW50aWxGaW5pc2hlZChwcm9taXNlKSB7XG4gICAgICAgICAgICBpZiAoY2xvY2sudGlja01vZGUubW9kZSAhPT0gXCJuZXh0QXN5bmNcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2xvY2suc2V0VGlja01vZGUoeyBtb2RlOiBcIm1hbnVhbFwiIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2UuZmluYWxseSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgY2xvY2suc2V0VGlja01vZGUoeyBtb2RlOiBcIm5leHRBc3luY1wiIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBjbG9jay5yZXF1ZXN0SWRsZUNhbGxiYWNrID0gZnVuY3Rpb24gcmVxdWVzdElkbGVDYWxsYmFjayhcbiAgICAgICAgICAgIGZ1bmMsXG4gICAgICAgICAgICB0aW1lb3V0LFxuICAgICAgICApIHtcbiAgICAgICAgICAgIGxldCB0aW1lVG9OZXh0SWRsZVBlcmlvZCA9IDA7XG5cbiAgICAgICAgICAgIGlmIChjbG9jay5jb3VudFRpbWVycygpID4gMCkge1xuICAgICAgICAgICAgICAgIHRpbWVUb05leHRJZGxlUGVyaW9kID0gNTA7IC8vIGNvbnN0IGZvciBub3dcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYWRkVGltZXIoY2xvY2ssIHtcbiAgICAgICAgICAgICAgICBmdW5jOiBmdW5jLFxuICAgICAgICAgICAgICAgIGFyZ3M6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMiksXG4gICAgICAgICAgICAgICAgZGVsYXk6XG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiB0aW1lb3V0ID09PSBcInVuZGVmaW5lZFwiXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHRpbWVUb05leHRJZGxlUGVyaW9kXG4gICAgICAgICAgICAgICAgICAgICAgICA6IE1hdGgubWluKHRpbWVvdXQsIHRpbWVUb05leHRJZGxlUGVyaW9kKSxcbiAgICAgICAgICAgICAgICBpZGxlQ2FsbGJhY2s6IHRydWUsXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIE51bWJlcihyZXN1bHQpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNsb2NrLmNhbmNlbElkbGVDYWxsYmFjayA9IGZ1bmN0aW9uIGNhbmNlbElkbGVDYWxsYmFjayh0aW1lcklkKSB7XG4gICAgICAgICAgICByZXR1cm4gY2xlYXJUaW1lcihjbG9jaywgdGltZXJJZCwgXCJJZGxlQ2FsbGJhY2tcIik7XG4gICAgICAgIH07XG5cbiAgICAgICAgY2xvY2suc2V0VGltZW91dCA9IGZ1bmN0aW9uIHNldFRpbWVvdXQoZnVuYywgdGltZW91dCkge1xuICAgICAgICAgICAgcmV0dXJuIGFkZFRpbWVyKGNsb2NrLCB7XG4gICAgICAgICAgICAgICAgZnVuYzogZnVuYyxcbiAgICAgICAgICAgICAgICBhcmdzOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpLFxuICAgICAgICAgICAgICAgIGRlbGF5OiB0aW1lb3V0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIGlmICh0eXBlb2YgX2dsb2JhbC5Qcm9taXNlICE9PSBcInVuZGVmaW5lZFwiICYmIHV0aWxQcm9taXNpZnkpIHtcbiAgICAgICAgICAgIGNsb2NrLnNldFRpbWVvdXRbdXRpbFByb21pc2lmeS5jdXN0b21dID1cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBwcm9taXNpZmllZFNldFRpbWVvdXQodGltZW91dCwgYXJnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgX2dsb2JhbC5Qcm9taXNlKGZ1bmN0aW9uIHNldFRpbWVvdXRFeGVjdXRvcihcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUsXG4gICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkVGltZXIoY2xvY2ssIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jOiByZXNvbHZlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3M6IFthcmddLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGF5OiB0aW1lb3V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBjbG9jay5jbGVhclRpbWVvdXQgPSBmdW5jdGlvbiBjbGVhclRpbWVvdXQodGltZXJJZCkge1xuICAgICAgICAgICAgcmV0dXJuIGNsZWFyVGltZXIoY2xvY2ssIHRpbWVySWQsIFwiVGltZW91dFwiKTtcbiAgICAgICAgfTtcblxuICAgICAgICBjbG9jay5uZXh0VGljayA9IGZ1bmN0aW9uIG5leHRUaWNrKGZ1bmMpIHtcbiAgICAgICAgICAgIHJldHVybiBlbnF1ZXVlSm9iKGNsb2NrLCB7XG4gICAgICAgICAgICAgICAgZnVuYzogZnVuYyxcbiAgICAgICAgICAgICAgICBhcmdzOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpLFxuICAgICAgICAgICAgICAgIGVycm9yOiBpc05lYXJJbmZpbml0ZUxpbWl0ID8gbmV3IEVycm9yKCkgOiBudWxsLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgY2xvY2sucXVldWVNaWNyb3Rhc2sgPSBmdW5jdGlvbiBxdWV1ZU1pY3JvdGFzayhmdW5jKSB7XG4gICAgICAgICAgICByZXR1cm4gY2xvY2submV4dFRpY2soZnVuYyk7IC8vIGV4cGxpY2l0bHkgZHJvcCBhZGRpdGlvbmFsIGFyZ3VtZW50c1xuICAgICAgICB9O1xuXG4gICAgICAgIGNsb2NrLnNldEludGVydmFsID0gZnVuY3Rpb24gc2V0SW50ZXJ2YWwoZnVuYywgdGltZW91dCkge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgICAgICB0aW1lb3V0ID0gcGFyc2VJbnQodGltZW91dCwgMTApO1xuICAgICAgICAgICAgcmV0dXJuIGFkZFRpbWVyKGNsb2NrLCB7XG4gICAgICAgICAgICAgICAgZnVuYzogZnVuYyxcbiAgICAgICAgICAgICAgICBhcmdzOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpLFxuICAgICAgICAgICAgICAgIGRlbGF5OiB0aW1lb3V0LFxuICAgICAgICAgICAgICAgIGludGVydmFsOiB0aW1lb3V0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgY2xvY2suY2xlYXJJbnRlcnZhbCA9IGZ1bmN0aW9uIGNsZWFySW50ZXJ2YWwodGltZXJJZCkge1xuICAgICAgICAgICAgcmV0dXJuIGNsZWFyVGltZXIoY2xvY2ssIHRpbWVySWQsIFwiSW50ZXJ2YWxcIik7XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGlzUHJlc2VudC5zZXRJbW1lZGlhdGUpIHtcbiAgICAgICAgICAgIGNsb2NrLnNldEltbWVkaWF0ZSA9IGZ1bmN0aW9uIHNldEltbWVkaWF0ZShmdW5jKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFkZFRpbWVyKGNsb2NrLCB7XG4gICAgICAgICAgICAgICAgICAgIGZ1bmM6IGZ1bmMsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSksXG4gICAgICAgICAgICAgICAgICAgIGltbWVkaWF0ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgX2dsb2JhbC5Qcm9taXNlICE9PSBcInVuZGVmaW5lZFwiICYmIHV0aWxQcm9taXNpZnkpIHtcbiAgICAgICAgICAgICAgICBjbG9jay5zZXRJbW1lZGlhdGVbdXRpbFByb21pc2lmeS5jdXN0b21dID1cbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gcHJvbWlzaWZpZWRTZXRJbW1lZGlhdGUoYXJnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IF9nbG9iYWwuUHJvbWlzZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBzZXRJbW1lZGlhdGVFeGVjdXRvcihyZXNvbHZlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZFRpbWVyKGNsb2NrLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jOiByZXNvbHZlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJnczogW2FyZ10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbW1lZGlhdGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjbG9jay5jbGVhckltbWVkaWF0ZSA9IGZ1bmN0aW9uIGNsZWFySW1tZWRpYXRlKHRpbWVySWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2xlYXJUaW1lcihjbG9jaywgdGltZXJJZCwgXCJJbW1lZGlhdGVcIik7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgY2xvY2suY291bnRUaW1lcnMgPSBmdW5jdGlvbiBjb3VudFRpbWVycygpIHtcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoY2xvY2sudGltZXJzIHx8IHt9KS5sZW5ndGggK1xuICAgICAgICAgICAgICAgIChjbG9jay5qb2JzIHx8IFtdKS5sZW5ndGhcbiAgICAgICAgICAgICk7XG4gICAgICAgIH07XG5cbiAgICAgICAgY2xvY2sucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gZnVuY3Rpb24gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmMpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGFkZFRpbWVyKGNsb2NrLCB7XG4gICAgICAgICAgICAgICAgZnVuYzogZnVuYyxcbiAgICAgICAgICAgICAgICBkZWxheTogZ2V0VGltZVRvTmV4dEZyYW1lKCksXG4gICAgICAgICAgICAgICAgZ2V0IGFyZ3MoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbZmFrZVBlcmZvcm1hbmNlTm93KCldO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uOiB0cnVlLFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiBOdW1iZXIocmVzdWx0KTtcbiAgICAgICAgfTtcblxuICAgICAgICBjbG9jay5jYW5jZWxBbmltYXRpb25GcmFtZSA9IGZ1bmN0aW9uIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRpbWVySWQpIHtcbiAgICAgICAgICAgIHJldHVybiBjbGVhclRpbWVyKGNsb2NrLCB0aW1lcklkLCBcIkFuaW1hdGlvbkZyYW1lXCIpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNsb2NrLnJ1bk1pY3JvdGFza3MgPSBmdW5jdGlvbiBydW5NaWNyb3Rhc2tzKCkge1xuICAgICAgICAgICAgcnVuSm9icyhjbG9jayk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gdGlja1ZhbHVlIG1pbGxpc2Vjb25kcyBvciBhIHN0cmluZyBwYXJzZWFibGUgYnkgcGFyc2VUaW1lXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNBc3luY1xuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSByZXNvbHZlXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHJlamVjdFxuICAgICAgICAgKiBAcmV0dXJucyB7bnVtYmVyfHVuZGVmaW5lZH0gd2lsbCByZXR1cm4gdGhlIG5ldyBgbm93YCB2YWx1ZSBvciBub3RoaW5nIGZvciBhc3luY1xuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gZG9UaWNrKHRpY2tWYWx1ZSwgaXNBc3luYywgcmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICBjb25zdCBtc0Zsb2F0ID1cbiAgICAgICAgICAgICAgICB0eXBlb2YgdGlja1ZhbHVlID09PSBcIm51bWJlclwiXG4gICAgICAgICAgICAgICAgICAgID8gdGlja1ZhbHVlXG4gICAgICAgICAgICAgICAgICAgIDogcGFyc2VUaW1lKHRpY2tWYWx1ZSk7XG4gICAgICAgICAgICBjb25zdCBtcyA9IE1hdGguZmxvb3IobXNGbG9hdCk7XG4gICAgICAgICAgICBjb25zdCByZW1haW5kZXIgPSBuYW5vUmVtYWluZGVyKG1zRmxvYXQpO1xuICAgICAgICAgICAgbGV0IG5hbm9zVG90YWwgPSBuYW5vcyArIHJlbWFpbmRlcjtcbiAgICAgICAgICAgIGxldCB0aWNrVG8gPSBjbG9jay5ub3cgKyBtcztcblxuICAgICAgICAgICAgaWYgKG1zRmxvYXQgPCAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk5lZ2F0aXZlIHRpY2tzIGFyZSBub3Qgc3VwcG9ydGVkXCIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBhZGp1c3QgZm9yIHBvc2l0aXZlIG92ZXJmbG93XG4gICAgICAgICAgICBpZiAobmFub3NUb3RhbCA+PSAxZTYpIHtcbiAgICAgICAgICAgICAgICB0aWNrVG8gKz0gMTtcbiAgICAgICAgICAgICAgICBuYW5vc1RvdGFsIC09IDFlNjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbmFub3MgPSBuYW5vc1RvdGFsO1xuICAgICAgICAgICAgbGV0IHRpY2tGcm9tID0gY2xvY2subm93O1xuICAgICAgICAgICAgbGV0IHByZXZpb3VzID0gY2xvY2subm93O1xuICAgICAgICAgICAgLy8gRVNMaW50IGZhaWxzIHRvIGRldGVjdCB0aGlzIGNvcnJlY3RseVxuICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgcHJlZmVyLWNvbnN0ICovXG4gICAgICAgICAgICBsZXQgdGltZXIsXG4gICAgICAgICAgICAgICAgZmlyc3RFeGNlcHRpb24sXG4gICAgICAgICAgICAgICAgb2xkTm93LFxuICAgICAgICAgICAgICAgIG5leHRQcm9taXNlVGljayxcbiAgICAgICAgICAgICAgICBjb21wZW5zYXRpb25DaGVjayxcbiAgICAgICAgICAgICAgICBwb3N0VGltZXJDYWxsO1xuICAgICAgICAgICAgLyogZXNsaW50LWVuYWJsZSBwcmVmZXItY29uc3QgKi9cblxuICAgICAgICAgICAgY2xvY2suZHVyaW5nVGljayA9IHRydWU7XG5cbiAgICAgICAgICAgIC8vIHBlcmZvcm0gbWljcm90YXNrc1xuICAgICAgICAgICAgb2xkTm93ID0gY2xvY2subm93O1xuICAgICAgICAgICAgcnVuSm9icyhjbG9jayk7XG4gICAgICAgICAgICBpZiAob2xkTm93ICE9PSBjbG9jay5ub3cpIHtcbiAgICAgICAgICAgICAgICAvLyBjb21wZW5zYXRlIGZvciBhbnkgc2V0U3lzdGVtVGltZSgpIGNhbGwgZHVyaW5nIG1pY3JvdGFzayBjYWxsYmFja1xuICAgICAgICAgICAgICAgIHRpY2tGcm9tICs9IGNsb2NrLm5vdyAtIG9sZE5vdztcbiAgICAgICAgICAgICAgICB0aWNrVG8gKz0gY2xvY2subm93IC0gb2xkTm93O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL2VzbGludC1kaXNhYmxlLW5leHQtbGluZSBqc2RvYy9yZXF1aXJlLWpzZG9jXG4gICAgICAgICAgICBmdW5jdGlvbiBkb1RpY2tJbm5lcigpIHtcbiAgICAgICAgICAgICAgICAvLyBwZXJmb3JtIGVhY2ggdGltZXIgaW4gdGhlIHJlcXVlc3RlZCByYW5nZVxuICAgICAgICAgICAgICAgIHRpbWVyID0gZmlyc3RUaW1lckluUmFuZ2UoY2xvY2ssIHRpY2tGcm9tLCB0aWNrVG8pO1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bm1vZGlmaWVkLWxvb3AtY29uZGl0aW9uXG4gICAgICAgICAgICAgICAgd2hpbGUgKHRpbWVyICYmIHRpY2tGcm9tIDw9IHRpY2tUbykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2xvY2sudGltZXJzW3RpbWVyLmlkXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGlja0Zyb20gPSB0aW1lci5jYWxsQXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbG9jay5ub3cgPSB0aW1lci5jYWxsQXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbGROb3cgPSBjbG9jay5ub3c7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ1bkpvYnMoY2xvY2spO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxUaW1lcihjbG9jaywgdGltZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0RXhjZXB0aW9uID0gZmlyc3RFeGNlcHRpb24gfHwgZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzQXN5bmMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBmaW5pc2ggdXAgYWZ0ZXIgbmF0aXZlIHNldEltbWVkaWF0ZSBjYWxsYmFjayB0byBhbGxvd1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFsbCBuYXRpdmUgZXM2IHByb21pc2VzIHRvIHByb2Nlc3MgdGhlaXIgY2FsbGJhY2tzIGFmdGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZWFjaCB0aW1lciBmaXJlcy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbFNldFRpbWVvdXQobmV4dFByb21pc2VUaWNrKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBlbnNhdGlvbkNoZWNrKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBwb3N0VGltZXJDYWxsKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gcGVyZm9ybSBwcm9jZXNzLm5leHRUaWNrKClzIGFnYWluXG4gICAgICAgICAgICAgICAgb2xkTm93ID0gY2xvY2subm93O1xuICAgICAgICAgICAgICAgIHJ1bkpvYnMoY2xvY2spO1xuICAgICAgICAgICAgICAgIGlmIChvbGROb3cgIT09IGNsb2NrLm5vdykge1xuICAgICAgICAgICAgICAgICAgICAvLyBjb21wZW5zYXRlIGZvciBhbnkgc2V0U3lzdGVtVGltZSgpIGNhbGwgZHVyaW5nIHByb2Nlc3MubmV4dFRpY2soKSBjYWxsYmFja1xuICAgICAgICAgICAgICAgICAgICB0aWNrRnJvbSArPSBjbG9jay5ub3cgLSBvbGROb3c7XG4gICAgICAgICAgICAgICAgICAgIHRpY2tUbyArPSBjbG9jay5ub3cgLSBvbGROb3c7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNsb2NrLmR1cmluZ1RpY2sgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgIC8vIGNvcm5lciBjYXNlOiBkdXJpbmcgcnVuSm9icyBuZXcgdGltZXJzIHdlcmUgc2NoZWR1bGVkIHdoaWNoIGNvdWxkIGJlIGluIHRoZSByYW5nZSBbY2xvY2subm93LCB0aWNrVG9dXG4gICAgICAgICAgICAgICAgdGltZXIgPSBmaXJzdFRpbWVySW5SYW5nZShjbG9jaywgdGlja0Zyb20sIHRpY2tUbyk7XG4gICAgICAgICAgICAgICAgaWYgKHRpbWVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbG9jay50aWNrKHRpY2tUbyAtIGNsb2NrLm5vdyk7IC8vIGRvIGl0IGFsbCBhZ2FpbiAtIGZvciB0aGUgcmVtYWluZGVyIG9mIHRoZSByZXF1ZXN0ZWQgcmFuZ2VcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlyc3RFeGNlcHRpb24gPSBmaXJzdEV4Y2VwdGlvbiB8fCBlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbm8gdGltZXJzIHJlbWFpbmluZyBpbiB0aGUgcmVxdWVzdGVkIHJhbmdlOiBtb3ZlIHRoZSBjbG9jayBhbGwgdGhlIHdheSB0byB0aGUgZW5kXG4gICAgICAgICAgICAgICAgICAgIGNsb2NrLm5vdyA9IHRpY2tUbztcblxuICAgICAgICAgICAgICAgICAgICAvLyB1cGRhdGUgbmFub3NcbiAgICAgICAgICAgICAgICAgICAgbmFub3MgPSBuYW5vc1RvdGFsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZmlyc3RFeGNlcHRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZmlyc3RFeGNlcHRpb247XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGlzQXN5bmMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShjbG9jay5ub3cpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjbG9jay5ub3c7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBuZXh0UHJvbWlzZVRpY2sgPVxuICAgICAgICAgICAgICAgIGlzQXN5bmMgJiZcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wZW5zYXRpb25DaGVjaygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9zdFRpbWVyQ2FsbCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9UaWNrSW5uZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgY29tcGVuc2F0aW9uQ2hlY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgLy8gY29tcGVuc2F0ZSBmb3IgYW55IHNldFN5c3RlbVRpbWUoKSBjYWxsIGR1cmluZyB0aW1lciBjYWxsYmFja1xuICAgICAgICAgICAgICAgIGlmIChvbGROb3cgIT09IGNsb2NrLm5vdykge1xuICAgICAgICAgICAgICAgICAgICB0aWNrRnJvbSArPSBjbG9jay5ub3cgLSBvbGROb3c7XG4gICAgICAgICAgICAgICAgICAgIHRpY2tUbyArPSBjbG9jay5ub3cgLSBvbGROb3c7XG4gICAgICAgICAgICAgICAgICAgIHByZXZpb3VzICs9IGNsb2NrLm5vdyAtIG9sZE5vdztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBwb3N0VGltZXJDYWxsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHRpbWVyID0gZmlyc3RUaW1lckluUmFuZ2UoY2xvY2ssIHByZXZpb3VzLCB0aWNrVG8pO1xuICAgICAgICAgICAgICAgIHByZXZpb3VzID0gdGlja0Zyb207XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByZXR1cm4gZG9UaWNrSW5uZXIoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IHRpY2tWYWx1ZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIG9yIGEgaHVtYW4tcmVhZGFibGUgdmFsdWUgbGlrZSBcIjAxOjExOjE1XCJcbiAgICAgICAgICogQHJldHVybnMge251bWJlcn0gd2lsbCByZXR1cm4gdGhlIG5ldyBgbm93YCB2YWx1ZVxuICAgICAgICAgKi9cbiAgICAgICAgY2xvY2sudGljayA9IGZ1bmN0aW9uIHRpY2sodGlja1ZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gZG9UaWNrKHRpY2tWYWx1ZSwgZmFsc2UpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmICh0eXBlb2YgX2dsb2JhbC5Qcm9taXNlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gdGlja1ZhbHVlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgb3IgYSBodW1hbi1yZWFkYWJsZSB2YWx1ZSBsaWtlIFwiMDE6MTE6MTVcIlxuICAgICAgICAgICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGNsb2NrLnRpY2tBc3luYyA9IGZ1bmN0aW9uIHRpY2tBc3luYyh0aWNrVmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGF1c2VBdXRvVGlja1VudGlsRmluaXNoZWQoXG4gICAgICAgICAgICAgICAgICAgIG5ldyBfZ2xvYmFsLlByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxTZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb1RpY2sodGlja1ZhbHVlLCB0cnVlLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNsb2NrLm5leHQgPSBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICAgICAgcnVuSm9icyhjbG9jayk7XG4gICAgICAgICAgICBjb25zdCB0aW1lciA9IGZpcnN0VGltZXIoY2xvY2spO1xuICAgICAgICAgICAgaWYgKCF0aW1lcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBjbG9jay5ub3c7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNsb2NrLmR1cmluZ1RpY2sgPSB0cnVlO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjbG9jay5ub3cgPSB0aW1lci5jYWxsQXQ7XG4gICAgICAgICAgICAgICAgY2FsbFRpbWVyKGNsb2NrLCB0aW1lcik7XG4gICAgICAgICAgICAgICAgcnVuSm9icyhjbG9jayk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNsb2NrLm5vdztcbiAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgY2xvY2suZHVyaW5nVGljayA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmICh0eXBlb2YgX2dsb2JhbC5Qcm9taXNlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICBjbG9jay5uZXh0QXN5bmMgPSBmdW5jdGlvbiBuZXh0QXN5bmMoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhdXNlQXV0b1RpY2tVbnRpbEZpbmlzaGVkKFxuICAgICAgICAgICAgICAgICAgICBuZXcgX2dsb2JhbC5Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsU2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdGltZXIgPSBmaXJzdFRpbWVyKGNsb2NrKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aW1lcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShjbG9jay5ub3cpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGVycjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xvY2suZHVyaW5nVGljayA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsb2NrLm5vdyA9IHRpbWVyLmNhbGxBdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxUaW1lcihjbG9jaywgdGltZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnIgPSBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsb2NrLmR1cmluZ1RpY2sgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbFNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGNsb2NrLm5vdyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNsb2NrLnJ1bkFsbCA9IGZ1bmN0aW9uIHJ1bkFsbCgpIHtcbiAgICAgICAgICAgIGxldCBudW1UaW1lcnMsIGk7XG4gICAgICAgICAgICBydW5Kb2JzKGNsb2NrKTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjbG9jay5sb29wTGltaXQ7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICghY2xvY2sudGltZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc2V0SXNOZWFySW5maW5pdGVMaW1pdCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2xvY2subm93O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG51bVRpbWVycyA9IE9iamVjdC5rZXlzKGNsb2NrLnRpbWVycykubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlmIChudW1UaW1lcnMgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzZXRJc05lYXJJbmZpbml0ZUxpbWl0KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjbG9jay5ub3c7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY2xvY2submV4dCgpO1xuICAgICAgICAgICAgICAgIGNoZWNrSXNOZWFySW5maW5pdGVMaW1pdChjbG9jaywgaSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGV4Y2Vzc0pvYiA9IGZpcnN0VGltZXIoY2xvY2spO1xuICAgICAgICAgICAgdGhyb3cgZ2V0SW5maW5pdGVMb29wRXJyb3IoY2xvY2ssIGV4Y2Vzc0pvYik7XG4gICAgICAgIH07XG5cbiAgICAgICAgY2xvY2sucnVuVG9GcmFtZSA9IGZ1bmN0aW9uIHJ1blRvRnJhbWUoKSB7XG4gICAgICAgICAgICByZXR1cm4gY2xvY2sudGljayhnZXRUaW1lVG9OZXh0RnJhbWUoKSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHR5cGVvZiBfZ2xvYmFsLlByb21pc2UgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIGNsb2NrLnJ1bkFsbEFzeW5jID0gZnVuY3Rpb24gcnVuQWxsQXN5bmMoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhdXNlQXV0b1RpY2tVbnRpbEZpbmlzaGVkKFxuICAgICAgICAgICAgICAgICAgICBuZXcgX2dsb2JhbC5Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gZG9SdW4oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxTZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ1bkpvYnMoY2xvY2spO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgbnVtVGltZXJzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgPCBjbG9jay5sb29wTGltaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNsb2NrLnRpbWVycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNldElzTmVhckluZmluaXRlTGltaXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShjbG9jay5ub3cpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVtVGltZXJzID0gT2JqZWN0LmtleXMoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsb2NrLnRpbWVycyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobnVtVGltZXJzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc2V0SXNOZWFySW5maW5pdGVMaW1pdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGNsb2NrLm5vdyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbG9jay5uZXh0KCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpKys7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb1J1bigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrSXNOZWFySW5maW5pdGVMaW1pdChjbG9jaywgaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBleGNlc3NKb2IgPSBmaXJzdFRpbWVyKGNsb2NrKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRJbmZpbml0ZUxvb3BFcnJvcihjbG9jaywgZXhjZXNzSm9iKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZG9SdW4oKTtcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBjbG9jay5ydW5Ub0xhc3QgPSBmdW5jdGlvbiBydW5Ub0xhc3QoKSB7XG4gICAgICAgICAgICBjb25zdCB0aW1lciA9IGxhc3RUaW1lcihjbG9jayk7XG4gICAgICAgICAgICBpZiAoIXRpbWVyKSB7XG4gICAgICAgICAgICAgICAgcnVuSm9icyhjbG9jayk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNsb2NrLm5vdztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGNsb2NrLnRpY2sodGltZXIuY2FsbEF0IC0gY2xvY2subm93KTtcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAodHlwZW9mIF9nbG9iYWwuUHJvbWlzZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgY2xvY2sucnVuVG9MYXN0QXN5bmMgPSBmdW5jdGlvbiBydW5Ub0xhc3RBc3luYygpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGF1c2VBdXRvVGlja1VudGlsRmluaXNoZWQoXG4gICAgICAgICAgICAgICAgICAgIG5ldyBfZ2xvYmFsLlByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxTZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0aW1lciA9IGxhc3RUaW1lcihjbG9jayk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGltZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ1bkpvYnMoY2xvY2spO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShjbG9jay5ub3cpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsb2NrLnRpY2tBc3luYyh0aW1lci5jYWxsQXQgLSBjbG9jay5ub3cpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNsb2NrLnJlc2V0ID0gZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgICAgICAgICBuYW5vcyA9IDA7XG4gICAgICAgICAgICBjbG9jay50aW1lcnMgPSB7fTtcbiAgICAgICAgICAgIGNsb2NrLmpvYnMgPSBbXTtcbiAgICAgICAgICAgIGNsb2NrLm5vdyA9IHN0YXJ0O1xuICAgICAgICB9O1xuXG4gICAgICAgIGNsb2NrLnNldFN5c3RlbVRpbWUgPSBmdW5jdGlvbiBzZXRTeXN0ZW1UaW1lKHN5c3RlbVRpbWUpIHtcbiAgICAgICAgICAgIC8vIGRldGVybWluZSB0aW1lIGRpZmZlcmVuY2VcbiAgICAgICAgICAgIGNvbnN0IG5ld05vdyA9IGdldEVwb2NoKHN5c3RlbVRpbWUpO1xuICAgICAgICAgICAgY29uc3QgZGlmZmVyZW5jZSA9IG5ld05vdyAtIGNsb2NrLm5vdztcbiAgICAgICAgICAgIGxldCBpZCwgdGltZXI7XG5cbiAgICAgICAgICAgIGFkanVzdGVkU3lzdGVtVGltZVswXSA9IGFkanVzdGVkU3lzdGVtVGltZVswXSArIGRpZmZlcmVuY2U7XG4gICAgICAgICAgICBhZGp1c3RlZFN5c3RlbVRpbWVbMV0gPSBhZGp1c3RlZFN5c3RlbVRpbWVbMV0gKyBuYW5vcztcbiAgICAgICAgICAgIC8vIHVwZGF0ZSAnc3lzdGVtIGNsb2NrJ1xuICAgICAgICAgICAgY2xvY2subm93ID0gbmV3Tm93O1xuICAgICAgICAgICAgbmFub3MgPSAwO1xuXG4gICAgICAgICAgICAvLyB1cGRhdGUgdGltZXJzIGFuZCBpbnRlcnZhbHMgdG8ga2VlcCB0aGVtIHN0YWJsZVxuICAgICAgICAgICAgZm9yIChpZCBpbiBjbG9jay50aW1lcnMpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2xvY2sudGltZXJzLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgICAgICAgICAgICAgICAgICB0aW1lciA9IGNsb2NrLnRpbWVyc1tpZF07XG4gICAgICAgICAgICAgICAgICAgIHRpbWVyLmNyZWF0ZWRBdCArPSBkaWZmZXJlbmNlO1xuICAgICAgICAgICAgICAgICAgICB0aW1lci5jYWxsQXQgKz0gZGlmZmVyZW5jZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gdGlja1ZhbHVlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgb3IgYSBodW1hbi1yZWFkYWJsZSB2YWx1ZSBsaWtlIFwiMDE6MTE6MTVcIlxuICAgICAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSB3aWxsIHJldHVybiB0aGUgbmV3IGBub3dgIHZhbHVlXG4gICAgICAgICAqL1xuICAgICAgICBjbG9jay5qdW1wID0gZnVuY3Rpb24ganVtcCh0aWNrVmFsdWUpIHtcbiAgICAgICAgICAgIGNvbnN0IG1zRmxvYXQgPVxuICAgICAgICAgICAgICAgIHR5cGVvZiB0aWNrVmFsdWUgPT09IFwibnVtYmVyXCJcbiAgICAgICAgICAgICAgICAgICAgPyB0aWNrVmFsdWVcbiAgICAgICAgICAgICAgICAgICAgOiBwYXJzZVRpbWUodGlja1ZhbHVlKTtcbiAgICAgICAgICAgIGNvbnN0IG1zID0gTWF0aC5mbG9vcihtc0Zsb2F0KTtcblxuICAgICAgICAgICAgZm9yIChjb25zdCB0aW1lciBvZiBPYmplY3QudmFsdWVzKGNsb2NrLnRpbWVycykpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2xvY2subm93ICsgbXMgPiB0aW1lci5jYWxsQXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGltZXIuY2FsbEF0ID0gY2xvY2subm93ICsgbXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2xvY2sudGljayhtcyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGlzUHJlc2VudC5wZXJmb3JtYW5jZSkge1xuICAgICAgICAgICAgY2xvY2sucGVyZm9ybWFuY2UgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgICAgY2xvY2sucGVyZm9ybWFuY2Uubm93ID0gZmFrZVBlcmZvcm1hbmNlTm93O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzUHJlc2VudC5ocnRpbWUpIHtcbiAgICAgICAgICAgIGNsb2NrLmhydGltZSA9IGhydGltZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjbG9jaztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVJbnRlcnZhbFRpY2soY2xvY2ssIGRlbHRhKSB7XG4gICAgICAgIGNvbnN0IGludGVydmFsVGljayA9IGRvSW50ZXJ2YWxUaWNrLmJpbmQobnVsbCwgY2xvY2ssIGRlbHRhKTtcbiAgICAgICAgY29uc3QgaW50ZXJ2YWxJZCA9IG9yaWdpbmFsU2V0SW50ZXJ2YWwoaW50ZXJ2YWxUaWNrLCBkZWx0YSk7XG4gICAgICAgIGNsb2NrLmF0dGFjaGVkSW50ZXJ2YWwgPSBpbnRlcnZhbElkO1xuICAgIH1cblxuICAgIC8qIGVzbGludC1kaXNhYmxlIGNvbXBsZXhpdHkgKi9cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Q29uZmlnPX0gW2NvbmZpZ10gT3B0aW9uYWwgY29uZmlnXG4gICAgICogQHJldHVybnMge0Nsb2NrfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluc3RhbGwoY29uZmlnKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIGFyZ3VtZW50cy5sZW5ndGggPiAxIHx8XG4gICAgICAgICAgICBjb25maWcgaW5zdGFuY2VvZiBEYXRlIHx8XG4gICAgICAgICAgICBBcnJheS5pc0FycmF5KGNvbmZpZykgfHxcbiAgICAgICAgICAgIHR5cGVvZiBjb25maWcgPT09IFwibnVtYmVyXCJcbiAgICAgICAgKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgICAgIGBGYWtlVGltZXJzLmluc3RhbGwgY2FsbGVkIHdpdGggJHtTdHJpbmcoXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZyxcbiAgICAgICAgICAgICAgICApfSBpbnN0YWxsIHJlcXVpcmVzIGFuIG9iamVjdCBwYXJhbWV0ZXJgLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChfZ2xvYmFsLkRhdGUuaXNGYWtlID09PSB0cnVlKSB7XG4gICAgICAgICAgICAvLyBUaW1lcnMgYXJlIGFscmVhZHkgZmFrZWQ7IHRoaXMgaXMgYSBwcm9ibGVtLlxuICAgICAgICAgICAgLy8gTWFrZSB0aGUgdXNlciByZXNldCB0aW1lcnMgYmVmb3JlIGNvbnRpbnVpbmcuXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgICAgIFwiQ2FuJ3QgaW5zdGFsbCBmYWtlIHRpbWVycyB0d2ljZSBvbiB0aGUgc2FtZSBnbG9iYWwgb2JqZWN0LlwiLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICBjb25maWcgPSB0eXBlb2YgY29uZmlnICE9PSBcInVuZGVmaW5lZFwiID8gY29uZmlnIDoge307XG4gICAgICAgIGNvbmZpZy5zaG91bGRBZHZhbmNlVGltZSA9IGNvbmZpZy5zaG91bGRBZHZhbmNlVGltZSB8fCBmYWxzZTtcbiAgICAgICAgY29uZmlnLmFkdmFuY2VUaW1lRGVsdGEgPSBjb25maWcuYWR2YW5jZVRpbWVEZWx0YSB8fCAyMDtcbiAgICAgICAgY29uZmlnLnNob3VsZENsZWFyTmF0aXZlVGltZXJzID1cbiAgICAgICAgICAgIGNvbmZpZy5zaG91bGRDbGVhck5hdGl2ZVRpbWVycyB8fCBmYWxzZTtcblxuICAgICAgICBpZiAoY29uZmlnLnRhcmdldCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgICAgICBcImNvbmZpZy50YXJnZXQgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZC4gVXNlIGB3aXRoR2xvYmFsKHRhcmdldClgIGluc3RlYWQuXCIsXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0aW1lci9vYmplY3QgdGhlIG5hbWUgb2YgdGhlIHRoaW5nIHRoYXQgaXMgbm90IHByZXNlbnRcbiAgICAgICAgICogQHBhcmFtIHRpbWVyXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBoYW5kbGVNaXNzaW5nVGltZXIodGltZXIpIHtcbiAgICAgICAgICAgIGlmIChjb25maWcuaWdub3JlTWlzc2luZ1RpbWVycykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFxuICAgICAgICAgICAgICAgIGBub24tZXhpc3RlbnQgdGltZXJzIGFuZC9vciBvYmplY3RzIGNhbm5vdCBiZSBmYWtlZDogJyR7dGltZXJ9J2AsXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGksIGw7XG4gICAgICAgIGNvbnN0IGNsb2NrID0gY3JlYXRlQ2xvY2soY29uZmlnLm5vdywgY29uZmlnLmxvb3BMaW1pdCk7XG4gICAgICAgIGNsb2NrLnNob3VsZENsZWFyTmF0aXZlVGltZXJzID0gY29uZmlnLnNob3VsZENsZWFyTmF0aXZlVGltZXJzO1xuXG4gICAgICAgIGNsb2NrLnVuaW5zdGFsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmluc3RhbGwoY2xvY2spO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNsb2NrLmFib3J0TGlzdGVuZXJNYXAgPSBuZXcgTWFwKCk7XG5cbiAgICAgICAgY2xvY2subWV0aG9kcyA9IGNvbmZpZy50b0Zha2UgfHwgW107XG5cbiAgICAgICAgaWYgKGNsb2NrLm1ldGhvZHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBjbG9jay5tZXRob2RzID0gT2JqZWN0LmtleXModGltZXJzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb25maWcuc2hvdWxkQWR2YW5jZVRpbWUgPT09IHRydWUpIHtcbiAgICAgICAgICAgIGNsb2NrLnNldFRpY2tNb2RlKHtcbiAgICAgICAgICAgICAgICBtb2RlOiBcImludGVydmFsXCIsXG4gICAgICAgICAgICAgICAgZGVsdGE6IGNvbmZpZy5hZHZhbmNlVGltZURlbHRhLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2xvY2subWV0aG9kcy5pbmNsdWRlcyhcInBlcmZvcm1hbmNlXCIpKSB7XG4gICAgICAgICAgICBjb25zdCBwcm90byA9ICgoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGhhc1BlcmZvcm1hbmNlQ29uc3RydWN0b3JQcm90b3R5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9nbG9iYWwucGVyZm9ybWFuY2UuY29uc3RydWN0b3IucHJvdG90eXBlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaGFzUGVyZm9ybWFuY2VQcm90b3R5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9nbG9iYWwuUGVyZm9ybWFuY2UucHJvdG90eXBlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICBpZiAocHJvdG8pIHtcbiAgICAgICAgICAgICAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhwcm90bykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobmFtZSAhPT0gXCJub3dcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xvY2sucGVyZm9ybWFuY2VbbmFtZV0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUuaW5kZXhPZihcImdldEVudHJpZXNcIikgPT09IDBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBOT09QX0FSUkFZXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogTk9PUDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIC8vIGVuc3VyZSBgbWFya2AgcmV0dXJucyBhIHZhbHVlIHRoYXQgaXMgdmFsaWRcbiAgICAgICAgICAgICAgICBjbG9jay5wZXJmb3JtYW5jZS5tYXJrID0gKG5hbWUpID0+XG4gICAgICAgICAgICAgICAgICAgIG5ldyBGYWtlUGVyZm9ybWFuY2VFbnRyeShuYW1lLCBcIm1hcmtcIiwgMCwgMCk7XG4gICAgICAgICAgICAgICAgY2xvY2sucGVyZm9ybWFuY2UubWVhc3VyZSA9IChuYW1lKSA9PlxuICAgICAgICAgICAgICAgICAgICBuZXcgRmFrZVBlcmZvcm1hbmNlRW50cnkobmFtZSwgXCJtZWFzdXJlXCIsIDAsIDEwMCk7XG4gICAgICAgICAgICAgICAgLy8gYHRpbWVPcmlnaW5gIHNob3VsZCByZXR1cm4gdGhlIHRpbWUgb2Ygd2hlbiB0aGUgV2luZG93IHNlc3Npb24gc3RhcnRlZFxuICAgICAgICAgICAgICAgIC8vIChvciB0aGUgV29ya2VyIHdhcyBpbnN0YWxsZWQpXG4gICAgICAgICAgICAgICAgY2xvY2sucGVyZm9ybWFuY2UudGltZU9yaWdpbiA9IGdldEVwb2NoKGNvbmZpZy5ub3cpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICgoY29uZmlnLnRvRmFrZSB8fCBbXSkuaW5jbHVkZXMoXCJwZXJmb3JtYW5jZVwiKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBoYW5kbGVNaXNzaW5nVGltZXIoXCJwZXJmb3JtYW5jZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoX2dsb2JhbCA9PT0gZ2xvYmFsT2JqZWN0ICYmIHRpbWVyc01vZHVsZSkge1xuICAgICAgICAgICAgY2xvY2sudGltZXJzTW9kdWxlTWV0aG9kcyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChfZ2xvYmFsID09PSBnbG9iYWxPYmplY3QgJiYgdGltZXJzUHJvbWlzZXNNb2R1bGUpIHtcbiAgICAgICAgICAgIGNsb2NrLnRpbWVyc1Byb21pc2VzTW9kdWxlTWV0aG9kcyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IDAsIGwgPSBjbG9jay5tZXRob2RzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgbmFtZU9mTWV0aG9kVG9SZXBsYWNlID0gY2xvY2subWV0aG9kc1tpXTtcblxuICAgICAgICAgICAgaWYgKCFpc1ByZXNlbnRbbmFtZU9mTWV0aG9kVG9SZXBsYWNlXSkge1xuICAgICAgICAgICAgICAgIGhhbmRsZU1pc3NpbmdUaW1lcihuYW1lT2ZNZXRob2RUb1JlcGxhY2UpO1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobmFtZU9mTWV0aG9kVG9SZXBsYWNlID09PSBcImhydGltZVwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICBfZ2xvYmFsLnByb2Nlc3MgJiZcbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIF9nbG9iYWwucHJvY2Vzcy5ocnRpbWUgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICBoaWphY2tNZXRob2QoX2dsb2JhbC5wcm9jZXNzLCBuYW1lT2ZNZXRob2RUb1JlcGxhY2UsIGNsb2NrKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG5hbWVPZk1ldGhvZFRvUmVwbGFjZSA9PT0gXCJuZXh0VGlja1wiKSB7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICBfZ2xvYmFsLnByb2Nlc3MgJiZcbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIF9nbG9iYWwucHJvY2Vzcy5uZXh0VGljayA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIGhpamFja01ldGhvZChfZ2xvYmFsLnByb2Nlc3MsIG5hbWVPZk1ldGhvZFRvUmVwbGFjZSwgY2xvY2spO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaGlqYWNrTWV0aG9kKF9nbG9iYWwsIG5hbWVPZk1ldGhvZFRvUmVwbGFjZSwgY2xvY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIGNsb2NrLnRpbWVyc01vZHVsZU1ldGhvZHMgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgIHRpbWVyc01vZHVsZVtuYW1lT2ZNZXRob2RUb1JlcGxhY2VdXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvcmlnaW5hbCA9IHRpbWVyc01vZHVsZVtuYW1lT2ZNZXRob2RUb1JlcGxhY2VdO1xuICAgICAgICAgICAgICAgIGNsb2NrLnRpbWVyc01vZHVsZU1ldGhvZHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZE5hbWU6IG5hbWVPZk1ldGhvZFRvUmVwbGFjZSxcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWw6IG9yaWdpbmFsLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRpbWVyc01vZHVsZVtuYW1lT2ZNZXRob2RUb1JlcGxhY2VdID1cbiAgICAgICAgICAgICAgICAgICAgX2dsb2JhbFtuYW1lT2ZNZXRob2RUb1JlcGxhY2VdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNsb2NrLnRpbWVyc1Byb21pc2VzTW9kdWxlTWV0aG9kcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5hbWVPZk1ldGhvZFRvUmVwbGFjZSA9PT0gXCJzZXRUaW1lb3V0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xvY2sudGltZXJzUHJvbWlzZXNNb2R1bGVNZXRob2RzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kTmFtZTogXCJzZXRUaW1lb3V0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbDogdGltZXJzUHJvbWlzZXNNb2R1bGUuc2V0VGltZW91dCxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgdGltZXJzUHJvbWlzZXNNb2R1bGUuc2V0VGltZW91dCA9IChcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGF5LFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zID0ge30sXG4gICAgICAgICAgICAgICAgICAgICkgPT5cbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBhYm9ydCA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5zaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiYWJvcnRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFib3J0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbG9jay5hYm9ydExpc3RlbmVyTWFwLmRlbGV0ZShhYm9ydCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBzYWZlLCB0aGVyZSBpcyBubyBjb2RlIHBhdGggdGhhdCBsZWFkcyB0byB0aGlzIGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJlaW5nIGludm9rZWQgYmVmb3JlIGhhbmRsZSBoYXMgYmVlbiBhc3NpZ25lZC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVzZS1iZWZvcmUtZGVmaW5lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsb2NrLmNsZWFyVGltZW91dChoYW5kbGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3Qob3B0aW9ucy5zaWduYWwucmVhc29uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaGFuZGxlID0gY2xvY2suc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnNpZ25hbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5zaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImFib3J0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWJvcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xvY2suYWJvcnRMaXN0ZW5lck1hcC5kZWxldGUoYWJvcnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgZGVsYXkpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuc2lnbmFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5zaWduYWwuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImFib3J0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWJvcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xvY2suYWJvcnRMaXN0ZW5lck1hcC5zZXQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWJvcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5zaWduYWwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChuYW1lT2ZNZXRob2RUb1JlcGxhY2UgPT09IFwic2V0SW1tZWRpYXRlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xvY2sudGltZXJzUHJvbWlzZXNNb2R1bGVNZXRob2RzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kTmFtZTogXCJzZXRJbW1lZGlhdGVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsOiB0aW1lcnNQcm9taXNlc01vZHVsZS5zZXRJbW1lZGlhdGUsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIHRpbWVyc1Byb21pc2VzTW9kdWxlLnNldEltbWVkaWF0ZSA9ICh2YWx1ZSwgb3B0aW9ucyA9IHt9KSA9PlxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGFib3J0ID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJhYm9ydFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWJvcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsb2NrLmFib3J0TGlzdGVuZXJNYXAuZGVsZXRlKGFib3J0KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIHNhZmUsIHRoZXJlIGlzIG5vIGNvZGUgcGF0aCB0aGF0IGxlYWRzIHRvIHRoaXMgZnVuY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYmVpbmcgaW52b2tlZCBiZWZvcmUgaGFuZGxlIGhhcyBiZWVuIGFzc2lnbmVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdXNlLWJlZm9yZS1kZWZpbmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xvY2suY2xlYXJJbW1lZGlhdGUoaGFuZGxlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG9wdGlvbnMuc2lnbmFsLnJlYXNvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGhhbmRsZSA9IGNsb2NrLnNldEltbWVkaWF0ZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnNpZ25hbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5zaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImFib3J0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWJvcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xvY2suYWJvcnRMaXN0ZW5lck1hcC5kZWxldGUoYWJvcnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5zaWduYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnNpZ25hbC5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiYWJvcnRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhYm9ydCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbG9jay5hYm9ydExpc3RlbmVyTWFwLnNldChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhYm9ydCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnNpZ25hbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG5hbWVPZk1ldGhvZFRvUmVwbGFjZSA9PT0gXCJzZXRJbnRlcnZhbFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsb2NrLnRpbWVyc1Byb21pc2VzTW9kdWxlTWV0aG9kcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZE5hbWU6IFwic2V0SW50ZXJ2YWxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsOiB0aW1lcnNQcm9taXNlc01vZHVsZS5zZXRJbnRlcnZhbCxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgdGltZXJzUHJvbWlzZXNNb2R1bGUuc2V0SW50ZXJ2YWwgPSAoXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxheSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyA9IHt9LFxuICAgICAgICAgICAgICAgICAgICApID0+ICh7XG4gICAgICAgICAgICAgICAgICAgICAgICBbU3ltYm9sLmFzeW5jSXRlcmF0b3JdOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY3JlYXRlUmVzb2x2YWJsZSA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJlc29sdmUsIHJlamVjdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXMsIHJlaikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSA9IHJlcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdCA9IHJlajtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2UucmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2UucmVqZWN0ID0gcmVqZWN0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGRvbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgaGFzVGhyb3duID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJldHVybkNhbGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG5leHRBdmFpbGFibGUgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5leHRRdWV1ZSA9IFtdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaGFuZGxlID0gY2xvY2suc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV4dFF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHRRdWV1ZS5zaGlmdCgpLnJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHRBdmFpbGFibGUrKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIGRlbGF5KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGFib3J0ID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJhYm9ydFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWJvcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsb2NrLmFib3J0TGlzdGVuZXJNYXAuZGVsZXRlKGFib3J0KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbG9jay5jbGVhckludGVydmFsKGhhbmRsZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHJlc29sdmFibGUgb2YgbmV4dFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZhYmxlLnJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5zaWduYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5zaWduYWwuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImFib3J0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWJvcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xvY2suYWJvcnRMaXN0ZW5lck1hcC5zZXQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWJvcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5zaWduYWwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dDogYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuc2lnbmFsPy5hYm9ydGVkICYmICFoYXNUaHJvd24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNUaHJvd24gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG9wdGlvbnMuc2lnbmFsLnJlYXNvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBkb25lOiB0cnVlLCB2YWx1ZTogdW5kZWZpbmVkIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXh0QXZhaWxhYmxlID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHRBdmFpbGFibGUtLTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IHZhbHVlIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc29sdmFibGUgPSBjcmVhdGVSZXNvbHZhYmxlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0UXVldWUucHVzaChyZXNvbHZhYmxlKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgcmVzb2x2YWJsZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJldHVybkNhbGwgJiYgbmV4dFF1ZXVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybkNhbGwucmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5zaWduYWw/LmFib3J0ZWQgJiYgIWhhc1Rocm93bikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhc1Rocm93biA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgb3B0aW9ucy5zaWduYWwucmVhc29uO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGRvbmU6IHRydWUsIHZhbHVlOiB1bmRlZmluZWQgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiB2YWx1ZSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm46IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZG9uZTogdHJ1ZSwgdmFsdWU6IHVuZGVmaW5lZCB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV4dFF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5DYWxsID0gY3JlYXRlUmVzb2x2YWJsZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHJldHVybkNhbGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsb2NrLmNsZWFySW50ZXJ2YWwoaGFuZGxlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5zaWduYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImFib3J0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFib3J0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xvY2suYWJvcnRMaXN0ZW5lck1hcC5kZWxldGUoYWJvcnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBkb25lOiB0cnVlLCB2YWx1ZTogdW5kZWZpbmVkIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjbG9jaztcbiAgICB9XG5cbiAgICAvKiBlc2xpbnQtZW5hYmxlIGNvbXBsZXhpdHkgKi9cblxuICAgIHJldHVybiB7XG4gICAgICAgIHRpbWVyczogdGltZXJzLFxuICAgICAgICBjcmVhdGVDbG9jazogY3JlYXRlQ2xvY2ssXG4gICAgICAgIGluc3RhbGw6IGluc3RhbGwsXG4gICAgICAgIHdpdGhHbG9iYWw6IHdpdGhHbG9iYWwsXG4gICAgfTtcbn1cblxuLyoqXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBGYWtlVGltZXJzXG4gKiBAcHJvcGVydHkge1RpbWVyc30gdGltZXJzXG4gKiBAcHJvcGVydHkge2NyZWF0ZUNsb2NrfSBjcmVhdGVDbG9ja1xuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gaW5zdGFsbFxuICogQHByb3BlcnR5IHt3aXRoR2xvYmFsfSB3aXRoR2xvYmFsXG4gKi9cblxuLyogZXNsaW50LWVuYWJsZSBjb21wbGV4aXR5ICovXG5cbi8qKiBAdHlwZSB7RmFrZVRpbWVyc30gKi9cbmNvbnN0IGRlZmF1bHRJbXBsZW1lbnRhdGlvbiA9IHdpdGhHbG9iYWwoZ2xvYmFsT2JqZWN0KTtcblxuZXhwb3J0cy50aW1lcnMgPSBkZWZhdWx0SW1wbGVtZW50YXRpb24udGltZXJzO1xuZXhwb3J0cy5jcmVhdGVDbG9jayA9IGRlZmF1bHRJbXBsZW1lbnRhdGlvbi5jcmVhdGVDbG9jaztcbmV4cG9ydHMuaW5zdGFsbCA9IGRlZmF1bHRJbXBsZW1lbnRhdGlvbi5pbnN0YWxsO1xuZXhwb3J0cy53aXRoR2xvYmFsID0gd2l0aEdsb2JhbDtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuY29uc3QgZXh0ZW5kID0gcmVxdWlyZShcIi4vY29yZS9leHRlbmRcIik7XG5jb25zdCBGYWtlVGltZXJzID0gcmVxdWlyZShcIkBzaW5vbmpzL2Zha2UtdGltZXJzXCIpO1xuY29uc3QgZ2xvYmFsT2JqZWN0ID0gcmVxdWlyZShcIkBzaW5vbmpzL2NvbW1vbnNcIikuZ2xvYmFsO1xuXG4vKipcbiAqXG4gKiBAcGFyYW0gY29uZmlnXG4gKiBAcGFyYW0gZ2xvYmFsQ3R4XG4gKlxuICogQHJldHVybnMge29iamVjdH0gdGhlIGNsb2NrLCBhZnRlciBpbnN0YWxsaW5nIGl0IG9uIHRoZSBnbG9iYWwgY29udGV4dCwgaWYgZ2l2ZW5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ2xvY2soY29uZmlnLCBnbG9iYWxDdHgpIHtcbiAgICBsZXQgRmFrZVRpbWVyc0N0eCA9IEZha2VUaW1lcnM7XG4gICAgaWYgKGdsb2JhbEN0eCAhPT0gbnVsbCAmJiB0eXBlb2YgZ2xvYmFsQ3R4ID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIEZha2VUaW1lcnNDdHggPSBGYWtlVGltZXJzLndpdGhHbG9iYWwoZ2xvYmFsQ3R4KTtcbiAgICB9XG4gICAgY29uc3QgY2xvY2sgPSBGYWtlVGltZXJzQ3R4Lmluc3RhbGwoY29uZmlnKTtcbiAgICBjbG9jay5yZXN0b3JlID0gY2xvY2sudW5pbnN0YWxsO1xuICAgIHJldHVybiBjbG9jaztcbn1cblxuLyoqXG4gKlxuICogQHBhcmFtIG9ialxuICogQHBhcmFtIGdsb2JhbFByb3BOYW1lXG4gKi9cbmZ1bmN0aW9uIGFkZElmRGVmaW5lZChvYmosIGdsb2JhbFByb3BOYW1lKSB7XG4gICAgY29uc3QgZ2xvYmFsUHJvcCA9IGdsb2JhbE9iamVjdFtnbG9iYWxQcm9wTmFtZV07XG4gICAgaWYgKHR5cGVvZiBnbG9iYWxQcm9wICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIG9ialtnbG9iYWxQcm9wTmFtZV0gPSBnbG9iYWxQcm9wO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcnxEYXRlfG9iamVjdH0gZGF0ZU9yQ29uZmlnIFRoZSB1bml4IGVwb2NoIHZhbHVlIHRvIGluc3RhbGwgd2l0aCAoZGVmYXVsdCAwKVxuICogQHJldHVybnMge29iamVjdH0gUmV0dXJucyBhIGxvbGV4IGNsb2NrIGluc3RhbmNlXG4gKi9cbmV4cG9ydHMudXNlRmFrZVRpbWVycyA9IGZ1bmN0aW9uIChkYXRlT3JDb25maWcpIHtcbiAgICBjb25zdCBoYXNBcmd1bWVudHMgPSB0eXBlb2YgZGF0ZU9yQ29uZmlnICE9PSBcInVuZGVmaW5lZFwiO1xuICAgIGNvbnN0IGFyZ3VtZW50SXNEYXRlTGlrZSA9XG4gICAgICAgICh0eXBlb2YgZGF0ZU9yQ29uZmlnID09PSBcIm51bWJlclwiIHx8IGRhdGVPckNvbmZpZyBpbnN0YW5jZW9mIERhdGUpICYmXG4gICAgICAgIGFyZ3VtZW50cy5sZW5ndGggPT09IDE7XG4gICAgY29uc3QgYXJndW1lbnRJc09iamVjdCA9XG4gICAgICAgIGRhdGVPckNvbmZpZyAhPT0gbnVsbCAmJlxuICAgICAgICB0eXBlb2YgZGF0ZU9yQ29uZmlnID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgIGFyZ3VtZW50cy5sZW5ndGggPT09IDE7XG5cbiAgICBpZiAoIWhhc0FyZ3VtZW50cykge1xuICAgICAgICByZXR1cm4gY3JlYXRlQ2xvY2soe1xuICAgICAgICAgICAgbm93OiAwLFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoYXJndW1lbnRJc0RhdGVMaWtlKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVDbG9jayh7XG4gICAgICAgICAgICBub3c6IGRhdGVPckNvbmZpZyxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKGFyZ3VtZW50SXNPYmplY3QpIHtcbiAgICAgICAgY29uc3QgY29uZmlnID0gZXh0ZW5kLm5vbkVudW0oe30sIGRhdGVPckNvbmZpZyk7XG4gICAgICAgIGNvbnN0IGdsb2JhbEN0eCA9IGNvbmZpZy5nbG9iYWw7XG4gICAgICAgIGRlbGV0ZSBjb25maWcuZ2xvYmFsO1xuICAgICAgICByZXR1cm4gY3JlYXRlQ2xvY2soY29uZmlnLCBnbG9iYWxDdHgpO1xuICAgIH1cblxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgIFwidXNlRmFrZVRpbWVycyBleHBlY3RlZCBlcG9jaCBvciBjb25maWcgb2JqZWN0LiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3Npbm9uanMvc2lub25cIixcbiAgICApO1xufTtcblxuZXhwb3J0cy5jbG9jayA9IHtcbiAgICBjcmVhdGU6IGZ1bmN0aW9uIChub3cpIHtcbiAgICAgICAgcmV0dXJuIEZha2VUaW1lcnMuY3JlYXRlQ2xvY2sobm93KTtcbiAgICB9LFxufTtcblxuY29uc3QgdGltZXJzID0ge1xuICAgIHNldFRpbWVvdXQ6IHNldFRpbWVvdXQsXG4gICAgY2xlYXJUaW1lb3V0OiBjbGVhclRpbWVvdXQsXG4gICAgc2V0SW50ZXJ2YWw6IHNldEludGVydmFsLFxuICAgIGNsZWFySW50ZXJ2YWw6IGNsZWFySW50ZXJ2YWwsXG4gICAgRGF0ZTogRGF0ZSxcbn07XG5hZGRJZkRlZmluZWQodGltZXJzLCBcInNldEltbWVkaWF0ZVwiKTtcbmFkZElmRGVmaW5lZCh0aW1lcnMsIFwiY2xlYXJJbW1lZGlhdGVcIik7XG5cbmV4cG9ydHMudGltZXJzID0gdGltZXJzO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5jb25zdCBwdXNoID0gcmVxdWlyZShcIkBzaW5vbmpzL2NvbW1vbnNcIikucHJvdG90eXBlcy5hcnJheS5wdXNoO1xuXG5leHBvcnRzLmluY3JlbWVudENhbGxDb3VudCA9IGZ1bmN0aW9uIGluY3JlbWVudENhbGxDb3VudChwcm94eSkge1xuICAgIHByb3h5LmNhbGxlZCA9IHRydWU7XG4gICAgcHJveHkuY2FsbENvdW50ICs9IDE7XG4gICAgcHJveHkubm90Q2FsbGVkID0gZmFsc2U7XG4gICAgcHJveHkuY2FsbGVkT25jZSA9IHByb3h5LmNhbGxDb3VudCA9PT0gMTtcbiAgICBwcm94eS5jYWxsZWRUd2ljZSA9IHByb3h5LmNhbGxDb3VudCA9PT0gMjtcbiAgICBwcm94eS5jYWxsZWRUaHJpY2UgPSBwcm94eS5jYWxsQ291bnQgPT09IDM7XG59O1xuXG5leHBvcnRzLmNyZWF0ZUNhbGxQcm9wZXJ0aWVzID0gZnVuY3Rpb24gY3JlYXRlQ2FsbFByb3BlcnRpZXMocHJveHkpIHtcbiAgICBwcm94eS5maXJzdENhbGwgPSBwcm94eS5nZXRDYWxsKDApO1xuICAgIHByb3h5LnNlY29uZENhbGwgPSBwcm94eS5nZXRDYWxsKDEpO1xuICAgIHByb3h5LnRoaXJkQ2FsbCA9IHByb3h5LmdldENhbGwoMik7XG4gICAgcHJveHkubGFzdENhbGwgPSBwcm94eS5nZXRDYWxsKHByb3h5LmNhbGxDb3VudCAtIDEpO1xufTtcblxuZXhwb3J0cy5kZWxlZ2F0ZVRvQ2FsbHMgPSBmdW5jdGlvbiBkZWxlZ2F0ZVRvQ2FsbHMoXG4gICAgcHJveHksXG4gICAgbWV0aG9kLFxuICAgIG1hdGNoQW55LFxuICAgIGFjdHVhbCxcbiAgICByZXR1cm5zVmFsdWVzLFxuICAgIG5vdENhbGxlZCxcbiAgICB0b3RhbENhbGxDb3VudCxcbikge1xuICAgIHByb3h5W21ldGhvZF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5jYWxsZWQpIHtcbiAgICAgICAgICAgIGlmIChub3RDYWxsZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm90Q2FsbGVkLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodG90YWxDYWxsQ291bnQgIT09IHVuZGVmaW5lZCAmJiB0aGlzLmNhbGxDb3VudCAhPT0gdG90YWxDYWxsQ291bnQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBjdXJyZW50Q2FsbDtcbiAgICAgICAgbGV0IG1hdGNoZXMgPSAwO1xuICAgICAgICBjb25zdCByZXR1cm5WYWx1ZXMgPSBbXTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMCwgbCA9IHRoaXMuY2FsbENvdW50OyBpIDwgbDsgaSArPSAxKSB7XG4gICAgICAgICAgICBjdXJyZW50Q2FsbCA9IHRoaXMuZ2V0Q2FsbChpKTtcbiAgICAgICAgICAgIGNvbnN0IHJldHVyblZhbHVlID0gY3VycmVudENhbGxbYWN0dWFsIHx8IG1ldGhvZF0uYXBwbHkoXG4gICAgICAgICAgICAgICAgY3VycmVudENhbGwsXG4gICAgICAgICAgICAgICAgYXJndW1lbnRzLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHB1c2gocmV0dXJuVmFsdWVzLCByZXR1cm5WYWx1ZSk7XG4gICAgICAgICAgICBpZiAocmV0dXJuVmFsdWUpIHtcbiAgICAgICAgICAgICAgICBtYXRjaGVzICs9IDE7XG5cbiAgICAgICAgICAgICAgICBpZiAobWF0Y2hBbnkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJldHVybnNWYWx1ZXMpIHtcbiAgICAgICAgICAgIHJldHVybiByZXR1cm5WYWx1ZXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1hdGNoZXMgPT09IHRoaXMuY2FsbENvdW50O1xuICAgIH07XG59O1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5jb25zdCBhcnJheVByb3RvID0gcmVxdWlyZShcIkBzaW5vbmpzL2NvbW1vbnNcIikucHJvdG90eXBlcy5hcnJheTtcbmNvbnN0IHByb3h5Q2FsbFV0aWwgPSByZXF1aXJlKFwiLi9wcm94eS1jYWxsLXV0aWxcIik7XG5cbmNvbnN0IHB1c2ggPSBhcnJheVByb3RvLnB1c2g7XG5jb25zdCBmb3JFYWNoID0gYXJyYXlQcm90by5mb3JFYWNoO1xuY29uc3QgY29uY2F0ID0gYXJyYXlQcm90by5jb25jYXQ7XG5jb25zdCBFcnJvckNvbnN0cnVjdG9yID0gRXJyb3IucHJvdG90eXBlLmNvbnN0cnVjdG9yO1xuY29uc3QgYmluZCA9IEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kO1xuXG5sZXQgY2FsbElkID0gMDtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbnZva2UoZnVuYywgdGhpc1ZhbHVlLCBhcmdzKSB7XG4gICAgY29uc3QgbWF0Y2hpbmdzID0gdGhpcy5tYXRjaGluZ0Zha2VzKGFyZ3MpO1xuICAgIGNvbnN0IGN1cnJlbnRDYWxsSWQgPSBjYWxsSWQrKztcbiAgICBsZXQgZXhjZXB0aW9uLCByZXR1cm5WYWx1ZTtcblxuICAgIHByb3h5Q2FsbFV0aWwuaW5jcmVtZW50Q2FsbENvdW50KHRoaXMpO1xuICAgIHB1c2godGhpcy50aGlzVmFsdWVzLCB0aGlzVmFsdWUpO1xuICAgIHB1c2godGhpcy5hcmdzLCBhcmdzKTtcbiAgICBwdXNoKHRoaXMuY2FsbElkcywgY3VycmVudENhbGxJZCk7XG4gICAgZm9yRWFjaChtYXRjaGluZ3MsIGZ1bmN0aW9uIChtYXRjaGluZykge1xuICAgICAgICBwcm94eUNhbGxVdGlsLmluY3JlbWVudENhbGxDb3VudChtYXRjaGluZyk7XG4gICAgICAgIHB1c2gobWF0Y2hpbmcudGhpc1ZhbHVlcywgdGhpc1ZhbHVlKTtcbiAgICAgICAgcHVzaChtYXRjaGluZy5hcmdzLCBhcmdzKTtcbiAgICAgICAgcHVzaChtYXRjaGluZy5jYWxsSWRzLCBjdXJyZW50Q2FsbElkKTtcbiAgICB9KTtcblxuICAgIC8vIE1ha2UgY2FsbCBwcm9wZXJ0aWVzIGF2YWlsYWJsZSBmcm9tIHdpdGhpbiB0aGUgc3BpZWQgZnVuY3Rpb246XG4gICAgcHJveHlDYWxsVXRpbC5jcmVhdGVDYWxsUHJvcGVydGllcyh0aGlzKTtcbiAgICBmb3JFYWNoKG1hdGNoaW5ncywgcHJveHlDYWxsVXRpbC5jcmVhdGVDYWxsUHJvcGVydGllcyk7XG5cbiAgICB0cnkge1xuICAgICAgICB0aGlzLmludm9raW5nID0gdHJ1ZTtcblxuICAgICAgICBjb25zdCB0aGlzQ2FsbCA9IHRoaXMuZ2V0Q2FsbCh0aGlzLmNhbGxDb3VudCAtIDEpO1xuXG4gICAgICAgIGlmICh0aGlzQ2FsbC5jYWxsZWRXaXRoTmV3KCkpIHtcbiAgICAgICAgICAgIC8vIENhbGwgdGhyb3VnaCB3aXRoIGBuZXdgXG4gICAgICAgICAgICByZXR1cm5WYWx1ZSA9IG5ldyAoYmluZC5hcHBseShcbiAgICAgICAgICAgICAgICB0aGlzLmZ1bmMgfHwgZnVuYyxcbiAgICAgICAgICAgICAgICBjb25jYXQoW3RoaXNWYWx1ZV0sIGFyZ3MpLFxuICAgICAgICAgICAgKSkoKTtcblxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIHR5cGVvZiByZXR1cm5WYWx1ZSAhPT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiByZXR1cm5WYWx1ZSAhPT0gXCJmdW5jdGlvblwiXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICByZXR1cm5WYWx1ZSA9IHRoaXNWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVyblZhbHVlID0gKHRoaXMuZnVuYyB8fCBmdW5jKS5hcHBseSh0aGlzVmFsdWUsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBleGNlcHRpb24gPSBlO1xuICAgIH0gZmluYWxseSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmludm9raW5nO1xuICAgIH1cblxuICAgIHB1c2godGhpcy5leGNlcHRpb25zLCBleGNlcHRpb24pO1xuICAgIHB1c2godGhpcy5yZXR1cm5WYWx1ZXMsIHJldHVyblZhbHVlKTtcbiAgICBmb3JFYWNoKG1hdGNoaW5ncywgZnVuY3Rpb24gKG1hdGNoaW5nKSB7XG4gICAgICAgIHB1c2gobWF0Y2hpbmcuZXhjZXB0aW9ucywgZXhjZXB0aW9uKTtcbiAgICAgICAgcHVzaChtYXRjaGluZy5yZXR1cm5WYWx1ZXMsIHJldHVyblZhbHVlKTtcbiAgICB9KTtcblxuICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvckNvbnN0cnVjdG9yKCk7XG4gICAgLy8gMS4gUGxlYXNlIGRvIG5vdCBnZXQgc3RhY2sgYXQgdGhpcyBwb2ludC4gSXQgbWF5IGJlIHNvIHZlcnkgc2xvdywgYW5kIG5vdCBhY3R1YWxseSB1c2VkXG4gICAgLy8gMi4gUGhhbnRvbUpTIGRvZXMgbm90IHNlcmlhbGl6ZSB0aGUgc3RhY2sgdHJhY2UgdW50aWwgdGhlIGVycm9yIGhhcyBiZWVuIHRocm93bjpcbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9FcnJvci9TdGFja1xuICAgIHRyeSB7XG4gICAgICAgIHRocm93IGVycjtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8qIGVtcHR5ICovXG4gICAgfVxuICAgIHB1c2godGhpcy5lcnJvcnNXaXRoQ2FsbFN0YWNrLCBlcnIpO1xuICAgIGZvckVhY2gobWF0Y2hpbmdzLCBmdW5jdGlvbiAobWF0Y2hpbmcpIHtcbiAgICAgICAgcHVzaChtYXRjaGluZy5lcnJvcnNXaXRoQ2FsbFN0YWNrLCBlcnIpO1xuICAgIH0pO1xuXG4gICAgLy8gTWFrZSByZXR1cm4gdmFsdWUgYW5kIGV4Y2VwdGlvbiBhdmFpbGFibGUgaW4gdGhlIGNhbGxzOlxuICAgIHByb3h5Q2FsbFV0aWwuY3JlYXRlQ2FsbFByb3BlcnRpZXModGhpcyk7XG4gICAgZm9yRWFjaChtYXRjaGluZ3MsIHByb3h5Q2FsbFV0aWwuY3JlYXRlQ2FsbFByb3BlcnRpZXMpO1xuXG4gICAgaWYgKGV4Y2VwdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IGV4Y2VwdGlvbjtcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG59O1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5jb25zdCBhcnJheVByb3RvID0gcmVxdWlyZShcIkBzaW5vbmpzL2NvbW1vbnNcIikucHJvdG90eXBlcy5hcnJheTtcbmNvbnN0IG1hdGNoID0gcmVxdWlyZShcIkBzaW5vbmpzL3NhbXNhbVwiKS5jcmVhdGVNYXRjaGVyO1xuY29uc3QgZGVlcEVxdWFsID0gcmVxdWlyZShcIkBzaW5vbmpzL3NhbXNhbVwiKS5kZWVwRXF1YWw7XG5jb25zdCBmdW5jdGlvbk5hbWUgPSByZXF1aXJlKFwiQHNpbm9uanMvY29tbW9uc1wiKS5mdW5jdGlvbk5hbWU7XG5jb25zdCBpbnNwZWN0ID0gcmVxdWlyZShcInV0aWxcIikuaW5zcGVjdDtcbmNvbnN0IHZhbHVlVG9TdHJpbmcgPSByZXF1aXJlKFwiQHNpbm9uanMvY29tbW9uc1wiKS52YWx1ZVRvU3RyaW5nO1xuXG5jb25zdCBjb25jYXQgPSBhcnJheVByb3RvLmNvbmNhdDtcbmNvbnN0IGZpbHRlciA9IGFycmF5UHJvdG8uZmlsdGVyO1xuY29uc3Qgam9pbiA9IGFycmF5UHJvdG8uam9pbjtcbmNvbnN0IG1hcCA9IGFycmF5UHJvdG8ubWFwO1xuY29uc3QgcmVkdWNlID0gYXJyYXlQcm90by5yZWR1Y2U7XG5jb25zdCBzbGljZSA9IGFycmF5UHJvdG8uc2xpY2U7XG5cbi8qKlxuICogQHBhcmFtIHByb3h5XG4gKiBAcGFyYW0gdGV4dFxuICogQHBhcmFtIGFyZ3NcbiAqL1xuZnVuY3Rpb24gdGhyb3dZaWVsZEVycm9yKHByb3h5LCB0ZXh0LCBhcmdzKSB7XG4gICAgbGV0IG1zZyA9IGZ1bmN0aW9uTmFtZShwcm94eSkgKyB0ZXh0O1xuICAgIGlmIChhcmdzLmxlbmd0aCkge1xuICAgICAgICBtc2cgKz0gYCBSZWNlaXZlZCBbJHtqb2luKHNsaWNlKGFyZ3MpLCBcIiwgXCIpfV1gO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbn1cblxuY29uc3QgY2FsbFByb3RvID0ge1xuICAgIGNhbGxlZE9uOiBmdW5jdGlvbiBjYWxsZWRPbih0aGlzVmFsdWUpIHtcbiAgICAgICAgaWYgKG1hdGNoLmlzTWF0Y2hlcih0aGlzVmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpc1ZhbHVlLnRlc3QodGhpcy50aGlzVmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnRoaXNWYWx1ZSA9PT0gdGhpc1ZhbHVlO1xuICAgIH0sXG5cbiAgICBjYWxsZWRXaXRoOiBmdW5jdGlvbiBjYWxsZWRXaXRoKCkge1xuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgICAgY29uc3QgY2FsbGVkV2l0aEFyZ3MgPSBzbGljZShhcmd1bWVudHMpO1xuXG4gICAgICAgIGlmIChjYWxsZWRXaXRoQXJncy5sZW5ndGggPiBzZWxmLmFyZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVkdWNlKFxuICAgICAgICAgICAgY2FsbGVkV2l0aEFyZ3MsXG4gICAgICAgICAgICBmdW5jdGlvbiAocHJldiwgYXJnLCBpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByZXYgJiYgZGVlcEVxdWFsKHNlbGYuYXJnc1tpXSwgYXJnKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0cnVlLFxuICAgICAgICApO1xuICAgIH0sXG5cbiAgICBjYWxsZWRXaXRoTWF0Y2g6IGZ1bmN0aW9uIGNhbGxlZFdpdGhNYXRjaCgpIHtcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGNhbGxlZFdpdGhNYXRjaEFyZ3MgPSBzbGljZShhcmd1bWVudHMpO1xuXG4gICAgICAgIGlmIChjYWxsZWRXaXRoTWF0Y2hBcmdzLmxlbmd0aCA+IHNlbGYuYXJncy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZWR1Y2UoXG4gICAgICAgICAgICBjYWxsZWRXaXRoTWF0Y2hBcmdzLFxuICAgICAgICAgICAgZnVuY3Rpb24gKHByZXYsIGV4cGVjdGF0aW9uLCBpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYWN0dWFsID0gc2VsZi5hcmdzW2ldO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByZXYgJiYgbWF0Y2goZXhwZWN0YXRpb24pLnRlc3QoYWN0dWFsKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0cnVlLFxuICAgICAgICApO1xuICAgIH0sXG5cbiAgICBjYWxsZWRXaXRoRXhhY3RseTogZnVuY3Rpb24gY2FsbGVkV2l0aEV4YWN0bHkoKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBhcmd1bWVudHMubGVuZ3RoID09PSB0aGlzLmFyZ3MubGVuZ3RoICYmXG4gICAgICAgICAgICB0aGlzLmNhbGxlZFdpdGguYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICAgICAgICApO1xuICAgIH0sXG5cbiAgICBub3RDYWxsZWRXaXRoOiBmdW5jdGlvbiBub3RDYWxsZWRXaXRoKCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuY2FsbGVkV2l0aC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0sXG5cbiAgICBub3RDYWxsZWRXaXRoTWF0Y2g6IGZ1bmN0aW9uIG5vdENhbGxlZFdpdGhNYXRjaCgpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmNhbGxlZFdpdGhNYXRjaC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0sXG5cbiAgICByZXR1cm5lZDogZnVuY3Rpb24gcmV0dXJuZWQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGRlZXBFcXVhbCh0aGlzLnJldHVyblZhbHVlLCB2YWx1ZSk7XG4gICAgfSxcblxuICAgIHRocmV3OiBmdW5jdGlvbiB0aHJldyhlcnJvcikge1xuICAgICAgICBpZiAodHlwZW9mIGVycm9yID09PSBcInVuZGVmaW5lZFwiIHx8ICF0aGlzLmV4Y2VwdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIEJvb2xlYW4odGhpcy5leGNlcHRpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZXhjZXB0aW9uID09PSBlcnJvciB8fCB0aGlzLmV4Y2VwdGlvbi5uYW1lID09PSBlcnJvcjtcbiAgICB9LFxuXG4gICAgY2FsbGVkV2l0aE5ldzogZnVuY3Rpb24gY2FsbGVkV2l0aE5ldygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJveHkucHJvdG90eXBlICYmIHRoaXMudGhpc1ZhbHVlIGluc3RhbmNlb2YgdGhpcy5wcm94eTtcbiAgICB9LFxuXG4gICAgY2FsbGVkQmVmb3JlOiBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbElkIDwgb3RoZXIuY2FsbElkO1xuICAgIH0sXG5cbiAgICBjYWxsZWRBZnRlcjogZnVuY3Rpb24gKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGxJZCA+IG90aGVyLmNhbGxJZDtcbiAgICB9LFxuXG4gICAgY2FsbGVkSW1tZWRpYXRlbHlCZWZvcmU6IGZ1bmN0aW9uIChvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxsSWQgPT09IG90aGVyLmNhbGxJZCAtIDE7XG4gICAgfSxcblxuICAgIGNhbGxlZEltbWVkaWF0ZWx5QWZ0ZXI6IGZ1bmN0aW9uIChvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxsSWQgPT09IG90aGVyLmNhbGxJZCArIDE7XG4gICAgfSxcblxuICAgIGNhbGxBcmc6IGZ1bmN0aW9uIChwb3MpIHtcbiAgICAgICAgdGhpcy5lbnN1cmVBcmdJc0FGdW5jdGlvbihwb3MpO1xuICAgICAgICByZXR1cm4gdGhpcy5hcmdzW3Bvc10oKTtcbiAgICB9LFxuXG4gICAgY2FsbEFyZ09uOiBmdW5jdGlvbiAocG9zLCB0aGlzVmFsdWUpIHtcbiAgICAgICAgdGhpcy5lbnN1cmVBcmdJc0FGdW5jdGlvbihwb3MpO1xuICAgICAgICByZXR1cm4gdGhpcy5hcmdzW3Bvc10uYXBwbHkodGhpc1ZhbHVlKTtcbiAgICB9LFxuXG4gICAgY2FsbEFyZ1dpdGg6IGZ1bmN0aW9uIChwb3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbEFyZ09uV2l0aC5hcHBseShcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICBjb25jYXQoW3BvcywgbnVsbF0sIHNsaWNlKGFyZ3VtZW50cywgMSkpLFxuICAgICAgICApO1xuICAgIH0sXG5cbiAgICBjYWxsQXJnT25XaXRoOiBmdW5jdGlvbiAocG9zLCB0aGlzVmFsdWUpIHtcbiAgICAgICAgdGhpcy5lbnN1cmVBcmdJc0FGdW5jdGlvbihwb3MpO1xuICAgICAgICBjb25zdCBhcmdzID0gc2xpY2UoYXJndW1lbnRzLCAyKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXJnc1twb3NdLmFwcGx5KHRoaXNWYWx1ZSwgYXJncyk7XG4gICAgfSxcblxuICAgIHRocm93QXJnOiBmdW5jdGlvbiAocG9zKSB7XG4gICAgICAgIGlmIChwb3MgPiB0aGlzLmFyZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgICAgIGBOb3QgZW5vdWdoIGFyZ3VtZW50czogJHtwb3N9IHJlcXVpcmVkIGJ1dCBvbmx5ICR7dGhpcy5hcmdzLmxlbmd0aH0gcHJlc2VudGAsXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhyb3cgdGhpcy5hcmdzW3Bvc107XG4gICAgfSxcblxuICAgIHlpZWxkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnlpZWxkT24uYXBwbHkodGhpcywgY29uY2F0KFtudWxsXSwgc2xpY2UoYXJndW1lbnRzLCAwKSkpO1xuICAgIH0sXG5cbiAgICB5aWVsZE9uOiBmdW5jdGlvbiAodGhpc1ZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSBzbGljZSh0aGlzLmFyZ3MpO1xuICAgICAgICBjb25zdCB5aWVsZEZuID0gZmlsdGVyKGFyZ3MsIGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgYXJnID09PSBcImZ1bmN0aW9uXCI7XG4gICAgICAgIH0pWzBdO1xuXG4gICAgICAgIGlmICgheWllbGRGbikge1xuICAgICAgICAgICAgdGhyb3dZaWVsZEVycm9yKFxuICAgICAgICAgICAgICAgIHRoaXMucHJveHksXG4gICAgICAgICAgICAgICAgXCIgY2Fubm90IHlpZWxkIHNpbmNlIG5vIGNhbGxiYWNrIHdhcyBwYXNzZWQuXCIsXG4gICAgICAgICAgICAgICAgYXJncyxcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4geWllbGRGbi5hcHBseSh0aGlzVmFsdWUsIHNsaWNlKGFyZ3VtZW50cywgMSkpO1xuICAgIH0sXG5cbiAgICB5aWVsZFRvOiBmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICByZXR1cm4gdGhpcy55aWVsZFRvT24uYXBwbHkoXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgY29uY2F0KFtwcm9wLCBudWxsXSwgc2xpY2UoYXJndW1lbnRzLCAxKSksXG4gICAgICAgICk7XG4gICAgfSxcblxuICAgIHlpZWxkVG9PbjogZnVuY3Rpb24gKHByb3AsIHRoaXNWYWx1ZSkge1xuICAgICAgICBjb25zdCBhcmdzID0gc2xpY2UodGhpcy5hcmdzKTtcbiAgICAgICAgY29uc3QgeWllbGRBcmcgPSBmaWx0ZXIoYXJncywgZnVuY3Rpb24gKGFyZykge1xuICAgICAgICAgICAgcmV0dXJuIGFyZyAmJiB0eXBlb2YgYXJnW3Byb3BdID09PSBcImZ1bmN0aW9uXCI7XG4gICAgICAgIH0pWzBdO1xuICAgICAgICBjb25zdCB5aWVsZEZuID0geWllbGRBcmcgJiYgeWllbGRBcmdbcHJvcF07XG5cbiAgICAgICAgaWYgKCF5aWVsZEZuKSB7XG4gICAgICAgICAgICB0aHJvd1lpZWxkRXJyb3IoXG4gICAgICAgICAgICAgICAgdGhpcy5wcm94eSxcbiAgICAgICAgICAgICAgICBgIGNhbm5vdCB5aWVsZCB0byAnJHt2YWx1ZVRvU3RyaW5nKFxuICAgICAgICAgICAgICAgICAgICBwcm9wLFxuICAgICAgICAgICAgICAgICl9JyBzaW5jZSBubyBjYWxsYmFjayB3YXMgcGFzc2VkLmAsXG4gICAgICAgICAgICAgICAgYXJncyxcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4geWllbGRGbi5hcHBseSh0aGlzVmFsdWUsIHNsaWNlKGFyZ3VtZW50cywgMikpO1xuICAgIH0sXG5cbiAgICB0b1N0cmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuYXJncykge1xuICAgICAgICAgICAgcmV0dXJuIFwiOihcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBjYWxsU3RyID0gdGhpcy5wcm94eSA/IGAke1N0cmluZyh0aGlzLnByb3h5KX0oYCA6IFwiXCI7XG4gICAgICAgIGNvbnN0IGZvcm1hdHRlZEFyZ3MgPSBtYXAodGhpcy5hcmdzLCBmdW5jdGlvbiAoYXJnKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5zcGVjdChhcmcpO1xuICAgICAgICB9KTtcblxuICAgICAgICBjYWxsU3RyID0gYCR7Y2FsbFN0ciArIGpvaW4oZm9ybWF0dGVkQXJncywgXCIsIFwiKX0pYDtcblxuICAgICAgICBpZiAodHlwZW9mIHRoaXMucmV0dXJuVmFsdWUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIGNhbGxTdHIgKz0gYCA9PiAke2luc3BlY3QodGhpcy5yZXR1cm5WYWx1ZSl9YDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmV4Y2VwdGlvbikge1xuICAgICAgICAgICAgY2FsbFN0ciArPSBgICEke3RoaXMuZXhjZXB0aW9uLm5hbWV9YDtcblxuICAgICAgICAgICAgaWYgKHRoaXMuZXhjZXB0aW9uLm1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICBjYWxsU3RyICs9IGAoJHt0aGlzLmV4Y2VwdGlvbi5tZXNzYWdlfSlgO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnN0YWNrKSB7XG4gICAgICAgICAgICAvLyBJZiB3ZSBoYXZlIGEgc3RhY2ssIGFkZCB0aGUgZmlyc3QgZnJhbWUgdGhhdCdzIGluIGVuZC11c2VyIGNvZGVcbiAgICAgICAgICAgIC8vIFNraXAgdGhlIGZpcnN0IHR3byBmcmFtZXMgYmVjYXVzZSB0aGV5IHdpbGwgcmVmZXIgdG8gU2lub24gY29kZVxuICAgICAgICAgICAgY2FsbFN0ciArPSAodGhpcy5zdGFjay5zcGxpdChcIlxcblwiKVszXSB8fCBcInVua25vd25cIikucmVwbGFjZShcbiAgICAgICAgICAgICAgICAvXlxccyooPzphdFxccyt8QCk/LyxcbiAgICAgICAgICAgICAgICBcIiBhdCBcIixcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2FsbFN0cjtcbiAgICB9LFxuXG4gICAgZW5zdXJlQXJnSXNBRnVuY3Rpb246IGZ1bmN0aW9uIChwb3MpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmFyZ3NbcG9zXSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgICAgIGBFeHBlY3RlZCBhcmd1bWVudCBhdCBwb3NpdGlvbiAke3Bvc30gdG8gYmUgYSBGdW5jdGlvbiwgYnV0IHdhcyAke3R5cGVvZiB0aGlzXG4gICAgICAgICAgICAgICAgICAgIC5hcmdzW3Bvc119YCxcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9LFxufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShjYWxsUHJvdG8sIFwic3RhY2tcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuZXJyb3JXaXRoQ2FsbFN0YWNrICYmIHRoaXMuZXJyb3JXaXRoQ2FsbFN0YWNrLnN0YWNrKSB8fCBcIlwiO1xuICAgIH0sXG59KTtcblxuY2FsbFByb3RvLmludm9rZUNhbGxiYWNrID0gY2FsbFByb3RvLnlpZWxkO1xuXG4vKipcbiAqIEBwYXJhbSBwcm94eVxuICogQHBhcmFtIHRoaXNWYWx1ZVxuICogQHBhcmFtIGFyZ3NcbiAqIEBwYXJhbSByZXR1cm5WYWx1ZVxuICogQHBhcmFtIGV4Y2VwdGlvblxuICogQHBhcmFtIGlkXG4gKiBAcGFyYW0gZXJyb3JXaXRoQ2FsbFN0YWNrXG4gKlxuICogQHJldHVybnMge29iamVjdH0gcHJveHlDYWxsXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVByb3h5Q2FsbChcbiAgICBwcm94eSxcbiAgICB0aGlzVmFsdWUsXG4gICAgYXJncyxcbiAgICByZXR1cm5WYWx1ZSxcbiAgICBleGNlcHRpb24sXG4gICAgaWQsXG4gICAgZXJyb3JXaXRoQ2FsbFN0YWNrLFxuKSB7XG4gICAgaWYgKHR5cGVvZiBpZCAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2FsbCBpZCBpcyBub3QgYSBudW1iZXJcIik7XG4gICAgfVxuXG4gICAgbGV0IGZpcnN0QXJnLCBsYXN0QXJnO1xuXG4gICAgaWYgKGFyZ3MubGVuZ3RoID4gMCkge1xuICAgICAgICBmaXJzdEFyZyA9IGFyZ3NbMF07XG4gICAgICAgIGxhc3RBcmcgPSBhcmdzW2FyZ3MubGVuZ3RoIC0gMV07XG4gICAgfVxuXG4gICAgY29uc3QgcHJveHlDYWxsID0gT2JqZWN0LmNyZWF0ZShjYWxsUHJvdG8pO1xuICAgIGNvbnN0IGNhbGxiYWNrID1cbiAgICAgICAgbGFzdEFyZyAmJiB0eXBlb2YgbGFzdEFyZyA9PT0gXCJmdW5jdGlvblwiID8gbGFzdEFyZyA6IHVuZGVmaW5lZDtcblxuICAgIHByb3h5Q2FsbC5wcm94eSA9IHByb3h5O1xuICAgIHByb3h5Q2FsbC50aGlzVmFsdWUgPSB0aGlzVmFsdWU7XG4gICAgcHJveHlDYWxsLmFyZ3MgPSBhcmdzO1xuICAgIHByb3h5Q2FsbC5maXJzdEFyZyA9IGZpcnN0QXJnO1xuICAgIHByb3h5Q2FsbC5sYXN0QXJnID0gbGFzdEFyZztcbiAgICBwcm94eUNhbGwuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICBwcm94eUNhbGwucmV0dXJuVmFsdWUgPSByZXR1cm5WYWx1ZTtcbiAgICBwcm94eUNhbGwuZXhjZXB0aW9uID0gZXhjZXB0aW9uO1xuICAgIHByb3h5Q2FsbC5jYWxsSWQgPSBpZDtcbiAgICBwcm94eUNhbGwuZXJyb3JXaXRoQ2FsbFN0YWNrID0gZXJyb3JXaXRoQ2FsbFN0YWNrO1xuXG4gICAgcmV0dXJuIHByb3h5Q2FsbDtcbn1cbmNyZWF0ZVByb3h5Q2FsbC50b1N0cmluZyA9IGNhbGxQcm90by50b1N0cmluZzsgLy8gdXNlZCBieSBtb2Nrc1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZVByb3h5Q2FsbDtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuY29uc3QgYXJyYXlQcm90byA9IHJlcXVpcmUoXCJAc2lub25qcy9jb21tb25zXCIpLnByb3RvdHlwZXMuYXJyYXk7XG5jb25zdCBpc1Byb3BlcnR5Q29uZmlndXJhYmxlID0gcmVxdWlyZShcIi4vdXRpbC9jb3JlL2lzLXByb3BlcnR5LWNvbmZpZ3VyYWJsZVwiKTtcbmNvbnN0IGV4cG9ydEFzeW5jQmVoYXZpb3JzID0gcmVxdWlyZShcIi4vdXRpbC9jb3JlL2V4cG9ydC1hc3luYy1iZWhhdmlvcnNcIik7XG5jb25zdCBleHRlbmQgPSByZXF1aXJlKFwiLi91dGlsL2NvcmUvZXh0ZW5kXCIpO1xuXG5jb25zdCBzbGljZSA9IGFycmF5UHJvdG8uc2xpY2U7XG5cbmNvbnN0IHVzZUxlZnRNb3N0Q2FsbGJhY2sgPSAtMTtcbmNvbnN0IHVzZVJpZ2h0TW9zdENhbGxiYWNrID0gLTI7XG5cbmZ1bmN0aW9uIHRocm93c0V4Y2VwdGlvbihmYWtlLCBlcnJvciwgbWVzc2FnZSkge1xuICAgIGlmICh0eXBlb2YgZXJyb3IgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBmYWtlLmV4Y2VwdGlvbkNyZWF0b3IgPSBlcnJvcjtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlcnJvciA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBmYWtlLmV4Y2VwdGlvbkNyZWF0b3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjb25zdCBuZXdFeGNlcHRpb24gPSBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgbWVzc2FnZSB8fCBgU2lub24tcHJvdmlkZWQgJHtlcnJvcn1gLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIG5ld0V4Y2VwdGlvbi5uYW1lID0gZXJyb3I7XG4gICAgICAgICAgICByZXR1cm4gbmV3RXhjZXB0aW9uO1xuICAgICAgICB9O1xuICAgIH0gZWxzZSBpZiAoIWVycm9yKSB7XG4gICAgICAgIGZha2UuZXhjZXB0aW9uQ3JlYXRvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRXJyb3IoXCJFcnJvclwiKTtcbiAgICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBmYWtlLmV4Y2VwdGlvbiA9IGVycm9yO1xuICAgIH1cbn1cblxuY29uc3QgZGVmYXVsdEJlaGF2aW9ycyA9IHtcbiAgICBjYWxsc0Zha2U6IGZ1bmN0aW9uIGNhbGxzRmFrZShmYWtlLCBmbikge1xuICAgICAgICBmYWtlLmZha2VGbiA9IGZuO1xuICAgICAgICBmYWtlLmV4Y2VwdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgZmFrZS5leGNlcHRpb25DcmVhdG9yID0gdW5kZWZpbmVkO1xuICAgICAgICBmYWtlLmNhbGxzVGhyb3VnaCA9IGZhbHNlO1xuICAgIH0sXG5cbiAgICBjYWxsc0FyZzogZnVuY3Rpb24gY2FsbHNBcmcoZmFrZSwgaW5kZXgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpbmRleCAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImFyZ3VtZW50IGluZGV4IGlzIG5vdCBudW1iZXJcIik7XG4gICAgICAgIH1cblxuICAgICAgICBmYWtlLmNhbGxBcmdBdCA9IGluZGV4O1xuICAgICAgICBmYWtlLmNhbGxiYWNrQXJndW1lbnRzID0gW107XG4gICAgICAgIGZha2UuY2FsbGJhY2tDb250ZXh0ID0gdW5kZWZpbmVkO1xuICAgICAgICBmYWtlLmNhbGxBcmdQcm9wID0gdW5kZWZpbmVkO1xuICAgICAgICBmYWtlLmNhbGxiYWNrQXN5bmMgPSBmYWxzZTtcbiAgICAgICAgZmFrZS5jYWxsc1Rocm91Z2ggPSBmYWxzZTtcbiAgICB9LFxuXG4gICAgY2FsbHNBcmdPbjogZnVuY3Rpb24gY2FsbHNBcmdPbihmYWtlLCBpbmRleCwgY29udGV4dCkge1xuICAgICAgICBpZiAodHlwZW9mIGluZGV4ICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiYXJndW1lbnQgaW5kZXggaXMgbm90IG51bWJlclwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZha2UuY2FsbEFyZ0F0ID0gaW5kZXg7XG4gICAgICAgIGZha2UuY2FsbGJhY2tBcmd1bWVudHMgPSBbXTtcbiAgICAgICAgZmFrZS5jYWxsYmFja0NvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICBmYWtlLmNhbGxBcmdQcm9wID0gdW5kZWZpbmVkO1xuICAgICAgICBmYWtlLmNhbGxiYWNrQXN5bmMgPSBmYWxzZTtcbiAgICAgICAgZmFrZS5jYWxsc1Rocm91Z2ggPSBmYWxzZTtcbiAgICB9LFxuXG4gICAgY2FsbHNBcmdXaXRoOiBmdW5jdGlvbiBjYWxsc0FyZ1dpdGgoZmFrZSwgaW5kZXgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpbmRleCAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImFyZ3VtZW50IGluZGV4IGlzIG5vdCBudW1iZXJcIik7XG4gICAgICAgIH1cblxuICAgICAgICBmYWtlLmNhbGxBcmdBdCA9IGluZGV4O1xuICAgICAgICBmYWtlLmNhbGxiYWNrQXJndW1lbnRzID0gc2xpY2UoYXJndW1lbnRzLCAyKTtcbiAgICAgICAgZmFrZS5jYWxsYmFja0NvbnRleHQgPSB1bmRlZmluZWQ7XG4gICAgICAgIGZha2UuY2FsbEFyZ1Byb3AgPSB1bmRlZmluZWQ7XG4gICAgICAgIGZha2UuY2FsbGJhY2tBc3luYyA9IGZhbHNlO1xuICAgICAgICBmYWtlLmNhbGxzVGhyb3VnaCA9IGZhbHNlO1xuICAgIH0sXG5cbiAgICBjYWxsc0FyZ09uV2l0aDogZnVuY3Rpb24gY2FsbHNBcmdXaXRoKGZha2UsIGluZGV4LCBjb250ZXh0KSB7XG4gICAgICAgIGlmICh0eXBlb2YgaW5kZXggIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJhcmd1bWVudCBpbmRleCBpcyBub3QgbnVtYmVyXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgZmFrZS5jYWxsQXJnQXQgPSBpbmRleDtcbiAgICAgICAgZmFrZS5jYWxsYmFja0FyZ3VtZW50cyA9IHNsaWNlKGFyZ3VtZW50cywgMyk7XG4gICAgICAgIGZha2UuY2FsbGJhY2tDb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgZmFrZS5jYWxsQXJnUHJvcCA9IHVuZGVmaW5lZDtcbiAgICAgICAgZmFrZS5jYWxsYmFja0FzeW5jID0gZmFsc2U7XG4gICAgICAgIGZha2UuY2FsbHNUaHJvdWdoID0gZmFsc2U7XG4gICAgfSxcblxuICAgIHlpZWxkczogZnVuY3Rpb24gKGZha2UpIHtcbiAgICAgICAgZmFrZS5jYWxsQXJnQXQgPSB1c2VMZWZ0TW9zdENhbGxiYWNrO1xuICAgICAgICBmYWtlLmNhbGxiYWNrQXJndW1lbnRzID0gc2xpY2UoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgZmFrZS5jYWxsYmFja0NvbnRleHQgPSB1bmRlZmluZWQ7XG4gICAgICAgIGZha2UuY2FsbEFyZ1Byb3AgPSB1bmRlZmluZWQ7XG4gICAgICAgIGZha2UuY2FsbGJhY2tBc3luYyA9IGZhbHNlO1xuICAgICAgICBmYWtlLmZha2VGbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgZmFrZS5jYWxsc1Rocm91Z2ggPSBmYWxzZTtcbiAgICB9LFxuXG4gICAgeWllbGRzUmlnaHQ6IGZ1bmN0aW9uIChmYWtlKSB7XG4gICAgICAgIGZha2UuY2FsbEFyZ0F0ID0gdXNlUmlnaHRNb3N0Q2FsbGJhY2s7XG4gICAgICAgIGZha2UuY2FsbGJhY2tBcmd1bWVudHMgPSBzbGljZShhcmd1bWVudHMsIDEpO1xuICAgICAgICBmYWtlLmNhbGxiYWNrQ29udGV4dCA9IHVuZGVmaW5lZDtcbiAgICAgICAgZmFrZS5jYWxsQXJnUHJvcCA9IHVuZGVmaW5lZDtcbiAgICAgICAgZmFrZS5jYWxsYmFja0FzeW5jID0gZmFsc2U7XG4gICAgICAgIGZha2UuY2FsbHNUaHJvdWdoID0gZmFsc2U7XG4gICAgICAgIGZha2UuZmFrZUZuID0gdW5kZWZpbmVkO1xuICAgIH0sXG5cbiAgICB5aWVsZHNPbjogZnVuY3Rpb24gKGZha2UsIGNvbnRleHQpIHtcbiAgICAgICAgZmFrZS5jYWxsQXJnQXQgPSB1c2VMZWZ0TW9zdENhbGxiYWNrO1xuICAgICAgICBmYWtlLmNhbGxiYWNrQXJndW1lbnRzID0gc2xpY2UoYXJndW1lbnRzLCAyKTtcbiAgICAgICAgZmFrZS5jYWxsYmFja0NvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICBmYWtlLmNhbGxBcmdQcm9wID0gdW5kZWZpbmVkO1xuICAgICAgICBmYWtlLmNhbGxiYWNrQXN5bmMgPSBmYWxzZTtcbiAgICAgICAgZmFrZS5jYWxsc1Rocm91Z2ggPSBmYWxzZTtcbiAgICAgICAgZmFrZS5mYWtlRm4gPSB1bmRlZmluZWQ7XG4gICAgfSxcblxuICAgIHlpZWxkc1RvOiBmdW5jdGlvbiAoZmFrZSwgcHJvcCkge1xuICAgICAgICBmYWtlLmNhbGxBcmdBdCA9IHVzZUxlZnRNb3N0Q2FsbGJhY2s7XG4gICAgICAgIGZha2UuY2FsbGJhY2tBcmd1bWVudHMgPSBzbGljZShhcmd1bWVudHMsIDIpO1xuICAgICAgICBmYWtlLmNhbGxiYWNrQ29udGV4dCA9IHVuZGVmaW5lZDtcbiAgICAgICAgZmFrZS5jYWxsQXJnUHJvcCA9IHByb3A7XG4gICAgICAgIGZha2UuY2FsbGJhY2tBc3luYyA9IGZhbHNlO1xuICAgICAgICBmYWtlLmNhbGxzVGhyb3VnaCA9IGZhbHNlO1xuICAgICAgICBmYWtlLmZha2VGbiA9IHVuZGVmaW5lZDtcbiAgICB9LFxuXG4gICAgeWllbGRzVG9PbjogZnVuY3Rpb24gKGZha2UsIHByb3AsIGNvbnRleHQpIHtcbiAgICAgICAgZmFrZS5jYWxsQXJnQXQgPSB1c2VMZWZ0TW9zdENhbGxiYWNrO1xuICAgICAgICBmYWtlLmNhbGxiYWNrQXJndW1lbnRzID0gc2xpY2UoYXJndW1lbnRzLCAzKTtcbiAgICAgICAgZmFrZS5jYWxsYmFja0NvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICBmYWtlLmNhbGxBcmdQcm9wID0gcHJvcDtcbiAgICAgICAgZmFrZS5jYWxsYmFja0FzeW5jID0gZmFsc2U7XG4gICAgICAgIGZha2UuZmFrZUZuID0gdW5kZWZpbmVkO1xuICAgIH0sXG5cbiAgICB0aHJvd3M6IHRocm93c0V4Y2VwdGlvbixcbiAgICB0aHJvd3NFeGNlcHRpb246IHRocm93c0V4Y2VwdGlvbixcblxuICAgIHJldHVybnM6IGZ1bmN0aW9uIHJldHVybnMoZmFrZSwgdmFsdWUpIHtcbiAgICAgICAgZmFrZS5jYWxsc1Rocm91Z2ggPSBmYWxzZTtcbiAgICAgICAgZmFrZS5yZXR1cm5WYWx1ZSA9IHZhbHVlO1xuICAgICAgICBmYWtlLnJlc29sdmUgPSBmYWxzZTtcbiAgICAgICAgZmFrZS5yZWplY3QgPSBmYWxzZTtcbiAgICAgICAgZmFrZS5yZXR1cm5WYWx1ZURlZmluZWQgPSB0cnVlO1xuICAgICAgICBmYWtlLmV4Y2VwdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgZmFrZS5leGNlcHRpb25DcmVhdG9yID0gdW5kZWZpbmVkO1xuICAgICAgICBmYWtlLmZha2VGbiA9IHVuZGVmaW5lZDtcbiAgICB9LFxuXG4gICAgcmV0dXJuc0FyZzogZnVuY3Rpb24gcmV0dXJuc0FyZyhmYWtlLCBpbmRleCkge1xuICAgICAgICBpZiAodHlwZW9mIGluZGV4ICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiYXJndW1lbnQgaW5kZXggaXMgbm90IG51bWJlclwiKTtcbiAgICAgICAgfVxuICAgICAgICBmYWtlLmNhbGxzVGhyb3VnaCA9IGZhbHNlO1xuXG4gICAgICAgIGZha2UucmV0dXJuQXJnQXQgPSBpbmRleDtcbiAgICB9LFxuXG4gICAgdGhyb3dzQXJnOiBmdW5jdGlvbiB0aHJvd3NBcmcoZmFrZSwgaW5kZXgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpbmRleCAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImFyZ3VtZW50IGluZGV4IGlzIG5vdCBudW1iZXJcIik7XG4gICAgICAgIH1cbiAgICAgICAgZmFrZS5jYWxsc1Rocm91Z2ggPSBmYWxzZTtcblxuICAgICAgICBmYWtlLnRocm93QXJnQXQgPSBpbmRleDtcbiAgICB9LFxuXG4gICAgcmV0dXJuc1RoaXM6IGZ1bmN0aW9uIHJldHVybnNUaGlzKGZha2UpIHtcbiAgICAgICAgZmFrZS5yZXR1cm5UaGlzID0gdHJ1ZTtcbiAgICAgICAgZmFrZS5jYWxsc1Rocm91Z2ggPSBmYWxzZTtcbiAgICB9LFxuXG4gICAgcmVzb2x2ZXM6IGZ1bmN0aW9uIHJlc29sdmVzKGZha2UsIHZhbHVlKSB7XG4gICAgICAgIGZha2UucmV0dXJuVmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgZmFrZS5yZXNvbHZlID0gdHJ1ZTtcbiAgICAgICAgZmFrZS5yZXNvbHZlVGhpcyA9IGZhbHNlO1xuICAgICAgICBmYWtlLnJlamVjdCA9IGZhbHNlO1xuICAgICAgICBmYWtlLnJldHVyblZhbHVlRGVmaW5lZCA9IHRydWU7XG4gICAgICAgIGZha2UuZXhjZXB0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgICBmYWtlLmV4Y2VwdGlvbkNyZWF0b3IgPSB1bmRlZmluZWQ7XG4gICAgICAgIGZha2UuZmFrZUZuID0gdW5kZWZpbmVkO1xuICAgICAgICBmYWtlLmNhbGxzVGhyb3VnaCA9IGZhbHNlO1xuICAgIH0sXG5cbiAgICByZXNvbHZlc0FyZzogZnVuY3Rpb24gcmVzb2x2ZXNBcmcoZmFrZSwgaW5kZXgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpbmRleCAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImFyZ3VtZW50IGluZGV4IGlzIG5vdCBudW1iZXJcIik7XG4gICAgICAgIH1cbiAgICAgICAgZmFrZS5yZXNvbHZlQXJnQXQgPSBpbmRleDtcbiAgICAgICAgZmFrZS5yZXR1cm5WYWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgZmFrZS5yZXNvbHZlID0gdHJ1ZTtcbiAgICAgICAgZmFrZS5yZXNvbHZlVGhpcyA9IGZhbHNlO1xuICAgICAgICBmYWtlLnJlamVjdCA9IGZhbHNlO1xuICAgICAgICBmYWtlLnJldHVyblZhbHVlRGVmaW5lZCA9IGZhbHNlO1xuICAgICAgICBmYWtlLmV4Y2VwdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgZmFrZS5leGNlcHRpb25DcmVhdG9yID0gdW5kZWZpbmVkO1xuICAgICAgICBmYWtlLmZha2VGbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgZmFrZS5jYWxsc1Rocm91Z2ggPSBmYWxzZTtcbiAgICB9LFxuXG4gICAgcmVqZWN0czogZnVuY3Rpb24gcmVqZWN0cyhmYWtlLCBlcnJvciwgbWVzc2FnZSkge1xuICAgICAgICBsZXQgcmVhc29uO1xuICAgICAgICBpZiAodHlwZW9mIGVycm9yID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZWFzb24gPSBuZXcgRXJyb3IobWVzc2FnZSB8fCBcIlwiKTtcbiAgICAgICAgICAgIHJlYXNvbi5uYW1lID0gZXJyb3I7XG4gICAgICAgIH0gZWxzZSBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICByZWFzb24gPSBuZXcgRXJyb3IoXCJFcnJvclwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlYXNvbiA9IGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIGZha2UucmV0dXJuVmFsdWUgPSByZWFzb247XG4gICAgICAgIGZha2UucmVzb2x2ZSA9IGZhbHNlO1xuICAgICAgICBmYWtlLnJlc29sdmVUaGlzID0gZmFsc2U7XG4gICAgICAgIGZha2UucmVqZWN0ID0gdHJ1ZTtcbiAgICAgICAgZmFrZS5yZXR1cm5WYWx1ZURlZmluZWQgPSB0cnVlO1xuICAgICAgICBmYWtlLmV4Y2VwdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgZmFrZS5leGNlcHRpb25DcmVhdG9yID0gdW5kZWZpbmVkO1xuICAgICAgICBmYWtlLmZha2VGbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgZmFrZS5jYWxsc1Rocm91Z2ggPSBmYWxzZTtcblxuICAgICAgICByZXR1cm4gZmFrZTtcbiAgICB9LFxuXG4gICAgcmVzb2x2ZXNUaGlzOiBmdW5jdGlvbiByZXNvbHZlc1RoaXMoZmFrZSkge1xuICAgICAgICBmYWtlLnJldHVyblZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICBmYWtlLnJlc29sdmUgPSBmYWxzZTtcbiAgICAgICAgZmFrZS5yZXNvbHZlVGhpcyA9IHRydWU7XG4gICAgICAgIGZha2UucmVqZWN0ID0gZmFsc2U7XG4gICAgICAgIGZha2UucmV0dXJuVmFsdWVEZWZpbmVkID0gZmFsc2U7XG4gICAgICAgIGZha2UuZXhjZXB0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgICBmYWtlLmV4Y2VwdGlvbkNyZWF0b3IgPSB1bmRlZmluZWQ7XG4gICAgICAgIGZha2UuZmFrZUZuID0gdW5kZWZpbmVkO1xuICAgICAgICBmYWtlLmNhbGxzVGhyb3VnaCA9IGZhbHNlO1xuICAgIH0sXG5cbiAgICBjYWxsVGhyb3VnaDogZnVuY3Rpb24gY2FsbFRocm91Z2goZmFrZSkge1xuICAgICAgICBmYWtlLmNhbGxzVGhyb3VnaCA9IHRydWU7XG4gICAgfSxcblxuICAgIGNhbGxUaHJvdWdoV2l0aE5ldzogZnVuY3Rpb24gY2FsbFRocm91Z2hXaXRoTmV3KGZha2UpIHtcbiAgICAgICAgZmFrZS5jYWxsc1Rocm91Z2hXaXRoTmV3ID0gdHJ1ZTtcbiAgICB9LFxuXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoZmFrZSwgZ2V0dGVyRnVuY3Rpb24pIHtcbiAgICAgICAgY29uc3Qgcm9vdFN0dWIgPSBmYWtlLnN0dWIgfHwgZmFrZTtcblxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocm9vdFN0dWIucm9vdE9iaiwgcm9vdFN0dWIucHJvcE5hbWUsIHtcbiAgICAgICAgICAgIGdldDogZ2V0dGVyRnVuY3Rpb24sXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IGlzUHJvcGVydHlDb25maWd1cmFibGUoXG4gICAgICAgICAgICAgICAgcm9vdFN0dWIucm9vdE9iaixcbiAgICAgICAgICAgICAgICByb290U3R1Yi5wcm9wTmFtZSxcbiAgICAgICAgICAgICksXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBmYWtlO1xuICAgIH0sXG5cbiAgICBzZXQ6IGZ1bmN0aW9uIHNldChmYWtlLCBzZXR0ZXJGdW5jdGlvbikge1xuICAgICAgICBjb25zdCByb290U3R1YiA9IGZha2Uuc3R1YiB8fCBmYWtlO1xuXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShcbiAgICAgICAgICAgIHJvb3RTdHViLnJvb3RPYmosXG4gICAgICAgICAgICByb290U3R1Yi5wcm9wTmFtZSxcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBhY2Nlc3Nvci1wYWlyc1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHNldDogc2V0dGVyRnVuY3Rpb24sXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiBpc1Byb3BlcnR5Q29uZmlndXJhYmxlKFxuICAgICAgICAgICAgICAgICAgICByb290U3R1Yi5yb290T2JqLFxuICAgICAgICAgICAgICAgICAgICByb290U3R1Yi5wcm9wTmFtZSxcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgKTtcblxuICAgICAgICByZXR1cm4gZmFrZTtcbiAgICB9LFxuXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKGZha2UsIG5ld1ZhbCkge1xuICAgICAgICBjb25zdCByb290U3R1YiA9IGZha2Uuc3R1YiB8fCBmYWtlO1xuXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyb290U3R1Yi5yb290T2JqLCByb290U3R1Yi5wcm9wTmFtZSwge1xuICAgICAgICAgICAgdmFsdWU6IG5ld1ZhbCxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTpcbiAgICAgICAgICAgICAgICByb290U3R1Yi5zaGFkb3dzUHJvcE9uUHJvdG90eXBlIHx8XG4gICAgICAgICAgICAgICAgaXNQcm9wZXJ0eUNvbmZpZ3VyYWJsZShyb290U3R1Yi5yb290T2JqLCByb290U3R1Yi5wcm9wTmFtZSksXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBmYWtlO1xuICAgIH0sXG59O1xuXG5jb25zdCBhc3luY0JlaGF2aW9ycyA9IGV4cG9ydEFzeW5jQmVoYXZpb3JzKGRlZmF1bHRCZWhhdmlvcnMpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4dGVuZCh7fSwgZGVmYXVsdEJlaGF2aW9ycywgYXN5bmNCZWhhdmlvcnMpO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIGxldCBpLCBwcm9wLCB0aGlzVmFsdWU7XG4gICAgaWYgKHRoaXMuZ2V0Q2FsbCAmJiB0aGlzLmNhbGxDb3VudCkge1xuICAgICAgICBpID0gdGhpcy5jYWxsQ291bnQ7XG5cbiAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgdGhpc1ZhbHVlID0gdGhpcy5nZXRDYWxsKGkpLnRoaXNWYWx1ZTtcblxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGd1YXJkLWZvci1pblxuICAgICAgICAgICAgZm9yIChwcm9wIGluIHRoaXNWYWx1ZSkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzVmFsdWVbcHJvcF0gPT09IHRoaXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9wO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBuby1vcCAtIGFjY2Vzc2luZyBwcm9wcyBjYW4gdGhyb3cgYW4gZXJyb3IsIG5vdGhpbmcgdG8gZG8gaGVyZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmRpc3BsYXlOYW1lIHx8IFwic2lub24gZmFrZVwiO1xufTtcbiIsICIndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0c3Rkb3V0OiBmYWxzZSxcblx0c3RkZXJyOiBmYWxzZVxufTtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBDb2xvcml6ZXIge1xuICAgIGNvbnN0cnVjdG9yKHN1cHBvcnRzQ29sb3IgPSByZXF1aXJlKFwic3VwcG9ydHMtY29sb3JcIikpIHtcbiAgICAgICAgdGhpcy5zdXBwb3J0c0NvbG9yID0gc3VwcG9ydHNDb2xvcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTaG91bGQgYmUgcmVuYW1lZCB0byB0cnVlICNwcml2YXRlRmllbGRcbiAgICAgKiB3aGVuIHdlIGNhbiBlbnN1cmUgRVMyMDIyIHN1cHBvcnRcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgY29sb3JpemUoc3RyLCBjb2xvcikge1xuICAgICAgICBpZiAodGhpcy5zdXBwb3J0c0NvbG9yLnN0ZG91dCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBzdHI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYFxceDFiWyR7Y29sb3J9bSR7c3RyfVxceDFiWzBtYDtcbiAgICB9XG5cbiAgICByZWQoc3RyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbG9yaXplKHN0ciwgMzEpO1xuICAgIH1cblxuICAgIGdyZWVuKHN0cikge1xuICAgICAgICByZXR1cm4gdGhpcy5jb2xvcml6ZShzdHIsIDMyKTtcbiAgICB9XG5cbiAgICBjeWFuKHN0cikge1xuICAgICAgICByZXR1cm4gdGhpcy5jb2xvcml6ZShzdHIsIDk2KTtcbiAgICB9XG5cbiAgICB3aGl0ZShzdHIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29sb3JpemUoc3RyLCAzOSk7XG4gICAgfVxuXG4gICAgYm9sZChzdHIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29sb3JpemUoc3RyLCAxKTtcbiAgICB9XG59O1xuIiwgIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIERpZmYgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRGlmZigpIHtcbiAgICB9XG4gICAgRGlmZi5wcm90b3R5cGUuZGlmZiA9IGZ1bmN0aW9uIChvbGRTdHIsIG5ld1N0ciwgXG4gICAgLy8gVHlwZSBiZWxvdyBpcyBub3QgYWNjdXJhdGUvY29tcGxldGUgLSBzZWUgYWJvdmUgZm9yIGZ1bGwgcG9zc2liaWxpdGllcyAtIGJ1dCBpdCBjb21waWxlc1xuICAgIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAgICAgdmFyIGNhbGxiYWNrO1xuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrID0gb3B0aW9ucztcbiAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgnY2FsbGJhY2snIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrID0gb3B0aW9ucy5jYWxsYmFjaztcbiAgICAgICAgfVxuICAgICAgICAvLyBBbGxvdyBzdWJjbGFzc2VzIHRvIG1hc3NhZ2UgdGhlIGlucHV0IHByaW9yIHRvIHJ1bm5pbmdcbiAgICAgICAgdmFyIG9sZFN0cmluZyA9IHRoaXMuY2FzdElucHV0KG9sZFN0ciwgb3B0aW9ucyk7XG4gICAgICAgIHZhciBuZXdTdHJpbmcgPSB0aGlzLmNhc3RJbnB1dChuZXdTdHIsIG9wdGlvbnMpO1xuICAgICAgICB2YXIgb2xkVG9rZW5zID0gdGhpcy5yZW1vdmVFbXB0eSh0aGlzLnRva2VuaXplKG9sZFN0cmluZywgb3B0aW9ucykpO1xuICAgICAgICB2YXIgbmV3VG9rZW5zID0gdGhpcy5yZW1vdmVFbXB0eSh0aGlzLnRva2VuaXplKG5ld1N0cmluZywgb3B0aW9ucykpO1xuICAgICAgICByZXR1cm4gdGhpcy5kaWZmV2l0aE9wdGlvbnNPYmoob2xkVG9rZW5zLCBuZXdUb2tlbnMsIG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgICB9O1xuICAgIERpZmYucHJvdG90eXBlLmRpZmZXaXRoT3B0aW9uc09iaiA9IGZ1bmN0aW9uIChvbGRUb2tlbnMsIG5ld1Rva2Vucywgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB2YXIgZG9uZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdmFsdWUgPSBfdGhpcy5wb3N0UHJvY2Vzcyh2YWx1ZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgY2FsbGJhY2sodmFsdWUpOyB9LCAwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB2YXIgbmV3TGVuID0gbmV3VG9rZW5zLmxlbmd0aCwgb2xkTGVuID0gb2xkVG9rZW5zLmxlbmd0aDtcbiAgICAgICAgdmFyIGVkaXRMZW5ndGggPSAxO1xuICAgICAgICB2YXIgbWF4RWRpdExlbmd0aCA9IG5ld0xlbiArIG9sZExlbjtcbiAgICAgICAgaWYgKG9wdGlvbnMubWF4RWRpdExlbmd0aCAhPSBudWxsKSB7XG4gICAgICAgICAgICBtYXhFZGl0TGVuZ3RoID0gTWF0aC5taW4obWF4RWRpdExlbmd0aCwgb3B0aW9ucy5tYXhFZGl0TGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbWF4RXhlY3V0aW9uVGltZSA9IChfYSA9IG9wdGlvbnMudGltZW91dCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogSW5maW5pdHk7XG4gICAgICAgIHZhciBhYm9ydEFmdGVyVGltZXN0YW1wID0gRGF0ZS5ub3coKSArIG1heEV4ZWN1dGlvblRpbWU7XG4gICAgICAgIHZhciBiZXN0UGF0aCA9IFt7IG9sZFBvczogLTEsIGxhc3RDb21wb25lbnQ6IHVuZGVmaW5lZCB9XTtcbiAgICAgICAgLy8gU2VlZCBlZGl0TGVuZ3RoID0gMCwgaS5lLiB0aGUgY29udGVudCBzdGFydHMgd2l0aCB0aGUgc2FtZSB2YWx1ZXNcbiAgICAgICAgdmFyIG5ld1BvcyA9IHRoaXMuZXh0cmFjdENvbW1vbihiZXN0UGF0aFswXSwgbmV3VG9rZW5zLCBvbGRUb2tlbnMsIDAsIG9wdGlvbnMpO1xuICAgICAgICBpZiAoYmVzdFBhdGhbMF0ub2xkUG9zICsgMSA+PSBvbGRMZW4gJiYgbmV3UG9zICsgMSA+PSBuZXdMZW4pIHtcbiAgICAgICAgICAgIC8vIElkZW50aXR5IHBlciB0aGUgZXF1YWxpdHkgYW5kIHRva2VuaXplclxuICAgICAgICAgICAgcmV0dXJuIGRvbmUodGhpcy5idWlsZFZhbHVlcyhiZXN0UGF0aFswXS5sYXN0Q29tcG9uZW50LCBuZXdUb2tlbnMsIG9sZFRva2VucykpO1xuICAgICAgICB9XG4gICAgICAgIC8vIE9uY2Ugd2UgaGl0IHRoZSByaWdodCBlZGdlIG9mIHRoZSBlZGl0IGdyYXBoIG9uIHNvbWUgZGlhZ29uYWwgaywgd2UgY2FuXG4gICAgICAgIC8vIGRlZmluaXRlbHkgcmVhY2ggdGhlIGVuZCBvZiB0aGUgZWRpdCBncmFwaCBpbiBubyBtb3JlIHRoYW4gayBlZGl0cywgc29cbiAgICAgICAgLy8gdGhlcmUncyBubyBwb2ludCBpbiBjb25zaWRlcmluZyBhbnkgbW92ZXMgdG8gZGlhZ29uYWwgaysxIGFueSBtb3JlIChmcm9tXG4gICAgICAgIC8vIHdoaWNoIHdlJ3JlIGd1YXJhbnRlZWQgdG8gbmVlZCBhdCBsZWFzdCBrKzEgbW9yZSBlZGl0cykuXG4gICAgICAgIC8vIFNpbWlsYXJseSwgb25jZSB3ZSd2ZSByZWFjaGVkIHRoZSBib3R0b20gb2YgdGhlIGVkaXQgZ3JhcGgsIHRoZXJlJ3Mgbm9cbiAgICAgICAgLy8gcG9pbnQgY29uc2lkZXJpbmcgbW92ZXMgdG8gbG93ZXIgZGlhZ29uYWxzLlxuICAgICAgICAvLyBXZSByZWNvcmQgdGhpcyBmYWN0IGJ5IHNldHRpbmcgbWluRGlhZ29uYWxUb0NvbnNpZGVyIGFuZFxuICAgICAgICAvLyBtYXhEaWFnb25hbFRvQ29uc2lkZXIgdG8gc29tZSBmaW5pdGUgdmFsdWUgb25jZSB3ZSd2ZSBoaXQgdGhlIGVkZ2Ugb2ZcbiAgICAgICAgLy8gdGhlIGVkaXQgZ3JhcGguXG4gICAgICAgIC8vIFRoaXMgb3B0aW1pemF0aW9uIGlzIG5vdCBmYWl0aGZ1bCB0byB0aGUgb3JpZ2luYWwgYWxnb3JpdGhtIHByZXNlbnRlZCBpblxuICAgICAgICAvLyBNeWVycydzIHBhcGVyLCB3aGljaCBpbnN0ZWFkIHBvaW50bGVzc2x5IGV4dGVuZHMgRC1wYXRocyBvZmYgdGhlIGVuZCBvZlxuICAgICAgICAvLyB0aGUgZWRpdCBncmFwaCAtIHNlZSBwYWdlIDcgb2YgTXllcnMncyBwYXBlciB3aGljaCBub3RlcyB0aGlzIHBvaW50XG4gICAgICAgIC8vIGV4cGxpY2l0bHkgYW5kIGlsbHVzdHJhdGVzIGl0IHdpdGggYSBkaWFncmFtLiBUaGlzIGhhcyBtYWpvciBwZXJmb3JtYW5jZVxuICAgICAgICAvLyBpbXBsaWNhdGlvbnMgZm9yIHNvbWUgY29tbW9uIHNjZW5hcmlvcy4gRm9yIGluc3RhbmNlLCB0byBjb21wdXRlIGEgZGlmZlxuICAgICAgICAvLyB3aGVyZSB0aGUgbmV3IHRleHQgc2ltcGx5IGFwcGVuZHMgZCBjaGFyYWN0ZXJzIG9uIHRoZSBlbmQgb2YgdGhlXG4gICAgICAgIC8vIG9yaWdpbmFsIHRleHQgb2YgbGVuZ3RoIG4sIHRoZSB0cnVlIE15ZXJzIGFsZ29yaXRobSB3aWxsIHRha2UgTyhuK2ReMilcbiAgICAgICAgLy8gdGltZSB3aGlsZSB0aGlzIG9wdGltaXphdGlvbiBuZWVkcyBvbmx5IE8obitkKSB0aW1lLlxuICAgICAgICB2YXIgbWluRGlhZ29uYWxUb0NvbnNpZGVyID0gLUluZmluaXR5LCBtYXhEaWFnb25hbFRvQ29uc2lkZXIgPSBJbmZpbml0eTtcbiAgICAgICAgLy8gTWFpbiB3b3JrZXIgbWV0aG9kLiBjaGVja3MgYWxsIHBlcm11dGF0aW9ucyBvZiBhIGdpdmVuIGVkaXQgbGVuZ3RoIGZvciBhY2NlcHRhbmNlLlxuICAgICAgICB2YXIgZXhlY0VkaXRMZW5ndGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBkaWFnb25hbFBhdGggPSBNYXRoLm1heChtaW5EaWFnb25hbFRvQ29uc2lkZXIsIC1lZGl0TGVuZ3RoKTsgZGlhZ29uYWxQYXRoIDw9IE1hdGgubWluKG1heERpYWdvbmFsVG9Db25zaWRlciwgZWRpdExlbmd0aCk7IGRpYWdvbmFsUGF0aCArPSAyKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJhc2VQYXRoID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgIHZhciByZW1vdmVQYXRoID0gYmVzdFBhdGhbZGlhZ29uYWxQYXRoIC0gMV0sIGFkZFBhdGggPSBiZXN0UGF0aFtkaWFnb25hbFBhdGggKyAxXTtcbiAgICAgICAgICAgICAgICBpZiAocmVtb3ZlUGF0aCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBObyBvbmUgZWxzZSBpcyBnb2luZyB0byBhdHRlbXB0IHRvIHVzZSB0aGlzIHZhbHVlLCBjbGVhciBpdFxuICAgICAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIC0gcGVyZiBvcHRpbWlzYXRpb24uIFRoaXMgdHlwZS12aW9sYXRpbmcgdmFsdWUgd2lsbCBuZXZlciBiZSByZWFkLlxuICAgICAgICAgICAgICAgICAgICBiZXN0UGF0aFtkaWFnb25hbFBhdGggLSAxXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGNhbkFkZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlmIChhZGRQYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHdoYXQgbmV3UG9zIHdpbGwgYmUgYWZ0ZXIgd2UgZG8gYW4gaW5zZXJ0aW9uOlxuICAgICAgICAgICAgICAgICAgICB2YXIgYWRkUGF0aE5ld1BvcyA9IGFkZFBhdGgub2xkUG9zIC0gZGlhZ29uYWxQYXRoO1xuICAgICAgICAgICAgICAgICAgICBjYW5BZGQgPSBhZGRQYXRoICYmIDAgPD0gYWRkUGF0aE5ld1BvcyAmJiBhZGRQYXRoTmV3UG9zIDwgbmV3TGVuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgY2FuUmVtb3ZlID0gcmVtb3ZlUGF0aCAmJiByZW1vdmVQYXRoLm9sZFBvcyArIDEgPCBvbGRMZW47XG4gICAgICAgICAgICAgICAgaWYgKCFjYW5BZGQgJiYgIWNhblJlbW92ZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGlzIHBhdGggaXMgYSB0ZXJtaW5hbCB0aGVuIHBydW5lXG4gICAgICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgLSBwZXJmIG9wdGltaXNhdGlvbi4gVGhpcyB0eXBlLXZpb2xhdGluZyB2YWx1ZSB3aWxsIG5ldmVyIGJlIHJlYWQuXG4gICAgICAgICAgICAgICAgICAgIGJlc3RQYXRoW2RpYWdvbmFsUGF0aF0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBTZWxlY3QgdGhlIGRpYWdvbmFsIHRoYXQgd2Ugd2FudCB0byBicmFuY2ggZnJvbS4gV2Ugc2VsZWN0IHRoZSBwcmlvclxuICAgICAgICAgICAgICAgIC8vIHBhdGggd2hvc2UgcG9zaXRpb24gaW4gdGhlIG9sZCBzdHJpbmcgaXMgdGhlIGZhcnRoZXN0IGZyb20gdGhlIG9yaWdpblxuICAgICAgICAgICAgICAgIC8vIGFuZCBkb2VzIG5vdCBwYXNzIHRoZSBib3VuZHMgb2YgdGhlIGRpZmYgZ3JhcGhcbiAgICAgICAgICAgICAgICBpZiAoIWNhblJlbW92ZSB8fCAoY2FuQWRkICYmIHJlbW92ZVBhdGgub2xkUG9zIDwgYWRkUGF0aC5vbGRQb3MpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJhc2VQYXRoID0gX3RoaXMuYWRkVG9QYXRoKGFkZFBhdGgsIHRydWUsIGZhbHNlLCAwLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJhc2VQYXRoID0gX3RoaXMuYWRkVG9QYXRoKHJlbW92ZVBhdGgsIGZhbHNlLCB0cnVlLCAxLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbmV3UG9zID0gX3RoaXMuZXh0cmFjdENvbW1vbihiYXNlUGF0aCwgbmV3VG9rZW5zLCBvbGRUb2tlbnMsIGRpYWdvbmFsUGF0aCwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgaWYgKGJhc2VQYXRoLm9sZFBvcyArIDEgPj0gb2xkTGVuICYmIG5ld1BvcyArIDEgPj0gbmV3TGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHdlIGhhdmUgaGl0IHRoZSBlbmQgb2YgYm90aCBzdHJpbmdzLCB0aGVuIHdlIGFyZSBkb25lXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkb25lKF90aGlzLmJ1aWxkVmFsdWVzKGJhc2VQYXRoLmxhc3RDb21wb25lbnQsIG5ld1Rva2Vucywgb2xkVG9rZW5zKSkgfHwgdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJlc3RQYXRoW2RpYWdvbmFsUGF0aF0gPSBiYXNlUGF0aDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJhc2VQYXRoLm9sZFBvcyArIDEgPj0gb2xkTGVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhEaWFnb25hbFRvQ29uc2lkZXIgPSBNYXRoLm1pbihtYXhEaWFnb25hbFRvQ29uc2lkZXIsIGRpYWdvbmFsUGF0aCAtIDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXdQb3MgKyAxID49IG5ld0xlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWluRGlhZ29uYWxUb0NvbnNpZGVyID0gTWF0aC5tYXgobWluRGlhZ29uYWxUb0NvbnNpZGVyLCBkaWFnb25hbFBhdGggKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVkaXRMZW5ndGgrKztcbiAgICAgICAgfTtcbiAgICAgICAgLy8gUGVyZm9ybXMgdGhlIGxlbmd0aCBvZiBlZGl0IGl0ZXJhdGlvbi4gSXMgYSBiaXQgZnVnbHkgYXMgdGhpcyBoYXMgdG8gc3VwcG9ydCB0aGVcbiAgICAgICAgLy8gc3luYyBhbmQgYXN5bmMgbW9kZSB3aGljaCBpcyBuZXZlciBmdW4uIExvb3BzIG92ZXIgZXhlY0VkaXRMZW5ndGggdW50aWwgYSB2YWx1ZVxuICAgICAgICAvLyBpcyBwcm9kdWNlZCwgb3IgdW50aWwgdGhlIGVkaXQgbGVuZ3RoIGV4Y2VlZHMgb3B0aW9ucy5tYXhFZGl0TGVuZ3RoIChpZiBnaXZlbiksXG4gICAgICAgIC8vIGluIHdoaWNoIGNhc2UgaXQgd2lsbCByZXR1cm4gdW5kZWZpbmVkLlxuICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIChmdW5jdGlvbiBleGVjKCkge1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZWRpdExlbmd0aCA+IG1heEVkaXRMZW5ndGggfHwgRGF0ZS5ub3coKSA+IGFib3J0QWZ0ZXJUaW1lc3RhbXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayh1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghZXhlY0VkaXRMZW5ndGgoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhlYygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICB9KCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgd2hpbGUgKGVkaXRMZW5ndGggPD0gbWF4RWRpdExlbmd0aCAmJiBEYXRlLm5vdygpIDw9IGFib3J0QWZ0ZXJUaW1lc3RhbXApIHtcbiAgICAgICAgICAgICAgICB2YXIgcmV0ID0gZXhlY0VkaXRMZW5ndGgoKTtcbiAgICAgICAgICAgICAgICBpZiAocmV0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBEaWZmLnByb3RvdHlwZS5hZGRUb1BhdGggPSBmdW5jdGlvbiAocGF0aCwgYWRkZWQsIHJlbW92ZWQsIG9sZFBvc0luYywgb3B0aW9ucykge1xuICAgICAgICB2YXIgbGFzdCA9IHBhdGgubGFzdENvbXBvbmVudDtcbiAgICAgICAgaWYgKGxhc3QgJiYgIW9wdGlvbnMub25lQ2hhbmdlUGVyVG9rZW4gJiYgbGFzdC5hZGRlZCA9PT0gYWRkZWQgJiYgbGFzdC5yZW1vdmVkID09PSByZW1vdmVkKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG9sZFBvczogcGF0aC5vbGRQb3MgKyBvbGRQb3NJbmMsXG4gICAgICAgICAgICAgICAgbGFzdENvbXBvbmVudDogeyBjb3VudDogbGFzdC5jb3VudCArIDEsIGFkZGVkOiBhZGRlZCwgcmVtb3ZlZDogcmVtb3ZlZCwgcHJldmlvdXNDb21wb25lbnQ6IGxhc3QucHJldmlvdXNDb21wb25lbnQgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgb2xkUG9zOiBwYXRoLm9sZFBvcyArIG9sZFBvc0luYyxcbiAgICAgICAgICAgICAgICBsYXN0Q29tcG9uZW50OiB7IGNvdW50OiAxLCBhZGRlZDogYWRkZWQsIHJlbW92ZWQ6IHJlbW92ZWQsIHByZXZpb3VzQ29tcG9uZW50OiBsYXN0IH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERpZmYucHJvdG90eXBlLmV4dHJhY3RDb21tb24gPSBmdW5jdGlvbiAoYmFzZVBhdGgsIG5ld1Rva2Vucywgb2xkVG9rZW5zLCBkaWFnb25hbFBhdGgsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIG5ld0xlbiA9IG5ld1Rva2Vucy5sZW5ndGgsIG9sZExlbiA9IG9sZFRva2Vucy5sZW5ndGg7XG4gICAgICAgIHZhciBvbGRQb3MgPSBiYXNlUGF0aC5vbGRQb3MsIG5ld1BvcyA9IG9sZFBvcyAtIGRpYWdvbmFsUGF0aCwgY29tbW9uQ291bnQgPSAwO1xuICAgICAgICB3aGlsZSAobmV3UG9zICsgMSA8IG5ld0xlbiAmJiBvbGRQb3MgKyAxIDwgb2xkTGVuICYmIHRoaXMuZXF1YWxzKG9sZFRva2Vuc1tvbGRQb3MgKyAxXSwgbmV3VG9rZW5zW25ld1BvcyArIDFdLCBvcHRpb25zKSkge1xuICAgICAgICAgICAgbmV3UG9zKys7XG4gICAgICAgICAgICBvbGRQb3MrKztcbiAgICAgICAgICAgIGNvbW1vbkNvdW50Kys7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5vbmVDaGFuZ2VQZXJUb2tlbikge1xuICAgICAgICAgICAgICAgIGJhc2VQYXRoLmxhc3RDb21wb25lbnQgPSB7IGNvdW50OiAxLCBwcmV2aW91c0NvbXBvbmVudDogYmFzZVBhdGgubGFzdENvbXBvbmVudCwgYWRkZWQ6IGZhbHNlLCByZW1vdmVkOiBmYWxzZSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjb21tb25Db3VudCAmJiAhb3B0aW9ucy5vbmVDaGFuZ2VQZXJUb2tlbikge1xuICAgICAgICAgICAgYmFzZVBhdGgubGFzdENvbXBvbmVudCA9IHsgY291bnQ6IGNvbW1vbkNvdW50LCBwcmV2aW91c0NvbXBvbmVudDogYmFzZVBhdGgubGFzdENvbXBvbmVudCwgYWRkZWQ6IGZhbHNlLCByZW1vdmVkOiBmYWxzZSB9O1xuICAgICAgICB9XG4gICAgICAgIGJhc2VQYXRoLm9sZFBvcyA9IG9sZFBvcztcbiAgICAgICAgcmV0dXJuIG5ld1BvcztcbiAgICB9O1xuICAgIERpZmYucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIChsZWZ0LCByaWdodCwgb3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucy5jb21wYXJhdG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5jb21wYXJhdG9yKGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBsZWZ0ID09PSByaWdodFxuICAgICAgICAgICAgICAgIHx8ICghIW9wdGlvbnMuaWdub3JlQ2FzZSAmJiBsZWZ0LnRvTG93ZXJDYXNlKCkgPT09IHJpZ2h0LnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEaWZmLnByb3RvdHlwZS5yZW1vdmVFbXB0eSA9IGZ1bmN0aW9uIChhcnJheSkge1xuICAgICAgICB2YXIgcmV0ID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChhcnJheVtpXSkge1xuICAgICAgICAgICAgICAgIHJldC5wdXNoKGFycmF5W2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgIERpZmYucHJvdG90eXBlLmNhc3RJbnB1dCA9IGZ1bmN0aW9uICh2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgRGlmZi5wcm90b3R5cGUudG9rZW5pemUgPSBmdW5jdGlvbiAodmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odmFsdWUpO1xuICAgIH07XG4gICAgRGlmZi5wcm90b3R5cGUuam9pbiA9IGZ1bmN0aW9uIChjaGFycykge1xuICAgICAgICAvLyBBc3N1bWVzIFZhbHVlVCBpcyBzdHJpbmcsIHdoaWNoIGlzIHRoZSBjYXNlIGZvciBtb3N0IHN1YmNsYXNzZXMuXG4gICAgICAgIC8vIFdoZW4gaXQncyBmYWxzZSwgZS5nLiBpbiBkaWZmQXJyYXlzLCB0aGlzIG1ldGhvZCBuZWVkcyB0byBiZSBvdmVycmlkZGVuIChlLmcuIHdpdGggYSBuby1vcClcbiAgICAgICAgLy8gWWVzLCB0aGUgY2FzdHMgYXJlIHZlcmJvc2UgYW5kIHVnbHksIGJlY2F1c2UgdGhpcyBwYXR0ZXJuIC0gb2YgaGF2aW5nIHRoZSBiYXNlIGNsYXNzIFNPUlQgT0ZcbiAgICAgICAgLy8gYXNzdW1lIHRva2VucyBhbmQgdmFsdWVzIGFyZSBzdHJpbmdzLCBidXQgbm90IGNvbXBsZXRlbHkgLSBpcyB3ZWlyZCBhbmQgamFua3kuXG4gICAgICAgIHJldHVybiBjaGFycy5qb2luKCcnKTtcbiAgICB9O1xuICAgIERpZmYucHJvdG90eXBlLnBvc3RQcm9jZXNzID0gZnVuY3Rpb24gKGNoYW5nZU9iamVjdHMsIFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBjaGFuZ2VPYmplY3RzO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERpZmYucHJvdG90eXBlLCBcInVzZUxvbmdlc3RUb2tlblwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgRGlmZi5wcm90b3R5cGUuYnVpbGRWYWx1ZXMgPSBmdW5jdGlvbiAobGFzdENvbXBvbmVudCwgbmV3VG9rZW5zLCBvbGRUb2tlbnMpIHtcbiAgICAgICAgLy8gRmlyc3Qgd2UgY29udmVydCBvdXIgbGlua2VkIGxpc3Qgb2YgY29tcG9uZW50cyBpbiByZXZlcnNlIG9yZGVyIHRvIGFuXG4gICAgICAgIC8vIGFycmF5IGluIHRoZSByaWdodCBvcmRlcjpcbiAgICAgICAgdmFyIGNvbXBvbmVudHMgPSBbXTtcbiAgICAgICAgdmFyIG5leHRDb21wb25lbnQ7XG4gICAgICAgIHdoaWxlIChsYXN0Q29tcG9uZW50KSB7XG4gICAgICAgICAgICBjb21wb25lbnRzLnB1c2gobGFzdENvbXBvbmVudCk7XG4gICAgICAgICAgICBuZXh0Q29tcG9uZW50ID0gbGFzdENvbXBvbmVudC5wcmV2aW91c0NvbXBvbmVudDtcbiAgICAgICAgICAgIGRlbGV0ZSBsYXN0Q29tcG9uZW50LnByZXZpb3VzQ29tcG9uZW50O1xuICAgICAgICAgICAgbGFzdENvbXBvbmVudCA9IG5leHRDb21wb25lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgY29tcG9uZW50cy5yZXZlcnNlKCk7XG4gICAgICAgIHZhciBjb21wb25lbnRMZW4gPSBjb21wb25lbnRzLmxlbmd0aDtcbiAgICAgICAgdmFyIGNvbXBvbmVudFBvcyA9IDAsIG5ld1BvcyA9IDAsIG9sZFBvcyA9IDA7XG4gICAgICAgIGZvciAoOyBjb21wb25lbnRQb3MgPCBjb21wb25lbnRMZW47IGNvbXBvbmVudFBvcysrKSB7XG4gICAgICAgICAgICB2YXIgY29tcG9uZW50ID0gY29tcG9uZW50c1tjb21wb25lbnRQb3NdO1xuICAgICAgICAgICAgaWYgKCFjb21wb25lbnQucmVtb3ZlZCkge1xuICAgICAgICAgICAgICAgIGlmICghY29tcG9uZW50LmFkZGVkICYmIHRoaXMudXNlTG9uZ2VzdFRva2VuKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IG5ld1Rva2Vucy5zbGljZShuZXdQb3MsIG5ld1BvcyArIGNvbXBvbmVudC5jb3VudCk7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUubWFwKGZ1bmN0aW9uICh2YWx1ZSwgaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9sZFZhbHVlID0gb2xkVG9rZW5zW29sZFBvcyArIGldO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9sZFZhbHVlLmxlbmd0aCA+IHZhbHVlLmxlbmd0aCA/IG9sZFZhbHVlIDogdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQudmFsdWUgPSB0aGlzLmpvaW4odmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50LnZhbHVlID0gdGhpcy5qb2luKG5ld1Rva2Vucy5zbGljZShuZXdQb3MsIG5ld1BvcyArIGNvbXBvbmVudC5jb3VudCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuZXdQb3MgKz0gY29tcG9uZW50LmNvdW50O1xuICAgICAgICAgICAgICAgIC8vIENvbW1vbiBjYXNlXG4gICAgICAgICAgICAgICAgaWYgKCFjb21wb25lbnQuYWRkZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgb2xkUG9zICs9IGNvbXBvbmVudC5jb3VudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb21wb25lbnQudmFsdWUgPSB0aGlzLmpvaW4ob2xkVG9rZW5zLnNsaWNlKG9sZFBvcywgb2xkUG9zICsgY29tcG9uZW50LmNvdW50KSk7XG4gICAgICAgICAgICAgICAgb2xkUG9zICs9IGNvbXBvbmVudC5jb3VudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29tcG9uZW50cztcbiAgICB9O1xuICAgIHJldHVybiBEaWZmO1xufSgpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IERpZmY7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jaGFyYWN0ZXJEaWZmID0gdm9pZCAwO1xuZXhwb3J0cy5kaWZmQ2hhcnMgPSBkaWZmQ2hhcnM7XG52YXIgYmFzZV9qc18xID0gcmVxdWlyZShcIi4vYmFzZS5qc1wiKTtcbnZhciBDaGFyYWN0ZXJEaWZmID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDaGFyYWN0ZXJEaWZmLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENoYXJhY3RlckRpZmYoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIENoYXJhY3RlckRpZmY7XG59KGJhc2VfanNfMS5kZWZhdWx0KSk7XG5leHBvcnRzLmNoYXJhY3RlckRpZmYgPSBuZXcgQ2hhcmFjdGVyRGlmZigpO1xuZnVuY3Rpb24gZGlmZkNoYXJzKG9sZFN0ciwgbmV3U3RyLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGV4cG9ydHMuY2hhcmFjdGVyRGlmZi5kaWZmKG9sZFN0ciwgbmV3U3RyLCBvcHRpb25zKTtcbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMubG9uZ2VzdENvbW1vblByZWZpeCA9IGxvbmdlc3RDb21tb25QcmVmaXg7XG5leHBvcnRzLmxvbmdlc3RDb21tb25TdWZmaXggPSBsb25nZXN0Q29tbW9uU3VmZml4O1xuZXhwb3J0cy5yZXBsYWNlUHJlZml4ID0gcmVwbGFjZVByZWZpeDtcbmV4cG9ydHMucmVwbGFjZVN1ZmZpeCA9IHJlcGxhY2VTdWZmaXg7XG5leHBvcnRzLnJlbW92ZVByZWZpeCA9IHJlbW92ZVByZWZpeDtcbmV4cG9ydHMucmVtb3ZlU3VmZml4ID0gcmVtb3ZlU3VmZml4O1xuZXhwb3J0cy5tYXhpbXVtT3ZlcmxhcCA9IG1heGltdW1PdmVybGFwO1xuZXhwb3J0cy5oYXNPbmx5V2luTGluZUVuZGluZ3MgPSBoYXNPbmx5V2luTGluZUVuZGluZ3M7XG5leHBvcnRzLmhhc09ubHlVbml4TGluZUVuZGluZ3MgPSBoYXNPbmx5VW5peExpbmVFbmRpbmdzO1xuZXhwb3J0cy50cmFpbGluZ1dzID0gdHJhaWxpbmdXcztcbmV4cG9ydHMubGVhZGluZ1dzID0gbGVhZGluZ1dzO1xuZnVuY3Rpb24gbG9uZ2VzdENvbW1vblByZWZpeChzdHIxLCBzdHIyKSB7XG4gICAgdmFyIGk7XG4gICAgZm9yIChpID0gMDsgaSA8IHN0cjEubGVuZ3RoICYmIGkgPCBzdHIyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChzdHIxW2ldICE9IHN0cjJbaV0pIHtcbiAgICAgICAgICAgIHJldHVybiBzdHIxLnNsaWNlKDAsIGkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdHIxLnNsaWNlKDAsIGkpO1xufVxuZnVuY3Rpb24gbG9uZ2VzdENvbW1vblN1ZmZpeChzdHIxLCBzdHIyKSB7XG4gICAgdmFyIGk7XG4gICAgLy8gVW5saWtlIGxvbmdlc3RDb21tb25QcmVmaXgsIHdlIG5lZWQgYSBzcGVjaWFsIGNhc2UgdG8gaGFuZGxlIGFsbCBzY2VuYXJpb3NcbiAgICAvLyB3aGVyZSB3ZSByZXR1cm4gdGhlIGVtcHR5IHN0cmluZyBzaW5jZSBzdHIxLnNsaWNlKC0wKSB3aWxsIHJldHVybiB0aGVcbiAgICAvLyBlbnRpcmUgc3RyaW5nLlxuICAgIGlmICghc3RyMSB8fCAhc3RyMiB8fCBzdHIxW3N0cjEubGVuZ3RoIC0gMV0gIT0gc3RyMltzdHIyLmxlbmd0aCAtIDFdKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgZm9yIChpID0gMDsgaSA8IHN0cjEubGVuZ3RoICYmIGkgPCBzdHIyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChzdHIxW3N0cjEubGVuZ3RoIC0gKGkgKyAxKV0gIT0gc3RyMltzdHIyLmxlbmd0aCAtIChpICsgMSldKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RyMS5zbGljZSgtaSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN0cjEuc2xpY2UoLWkpO1xufVxuZnVuY3Rpb24gcmVwbGFjZVByZWZpeChzdHJpbmcsIG9sZFByZWZpeCwgbmV3UHJlZml4KSB7XG4gICAgaWYgKHN0cmluZy5zbGljZSgwLCBvbGRQcmVmaXgubGVuZ3RoKSAhPSBvbGRQcmVmaXgpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJzdHJpbmcgXCIuY29uY2F0KEpTT04uc3RyaW5naWZ5KHN0cmluZyksIFwiIGRvZXNuJ3Qgc3RhcnQgd2l0aCBwcmVmaXggXCIpLmNvbmNhdChKU09OLnN0cmluZ2lmeShvbGRQcmVmaXgpLCBcIjsgdGhpcyBpcyBhIGJ1Z1wiKSk7XG4gICAgfVxuICAgIHJldHVybiBuZXdQcmVmaXggKyBzdHJpbmcuc2xpY2Uob2xkUHJlZml4Lmxlbmd0aCk7XG59XG5mdW5jdGlvbiByZXBsYWNlU3VmZml4KHN0cmluZywgb2xkU3VmZml4LCBuZXdTdWZmaXgpIHtcbiAgICBpZiAoIW9sZFN1ZmZpeCkge1xuICAgICAgICByZXR1cm4gc3RyaW5nICsgbmV3U3VmZml4O1xuICAgIH1cbiAgICBpZiAoc3RyaW5nLnNsaWNlKC1vbGRTdWZmaXgubGVuZ3RoKSAhPSBvbGRTdWZmaXgpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJzdHJpbmcgXCIuY29uY2F0KEpTT04uc3RyaW5naWZ5KHN0cmluZyksIFwiIGRvZXNuJ3QgZW5kIHdpdGggc3VmZml4IFwiKS5jb25jYXQoSlNPTi5zdHJpbmdpZnkob2xkU3VmZml4KSwgXCI7IHRoaXMgaXMgYSBidWdcIikpO1xuICAgIH1cbiAgICByZXR1cm4gc3RyaW5nLnNsaWNlKDAsIC1vbGRTdWZmaXgubGVuZ3RoKSArIG5ld1N1ZmZpeDtcbn1cbmZ1bmN0aW9uIHJlbW92ZVByZWZpeChzdHJpbmcsIG9sZFByZWZpeCkge1xuICAgIHJldHVybiByZXBsYWNlUHJlZml4KHN0cmluZywgb2xkUHJlZml4LCAnJyk7XG59XG5mdW5jdGlvbiByZW1vdmVTdWZmaXgoc3RyaW5nLCBvbGRTdWZmaXgpIHtcbiAgICByZXR1cm4gcmVwbGFjZVN1ZmZpeChzdHJpbmcsIG9sZFN1ZmZpeCwgJycpO1xufVxuZnVuY3Rpb24gbWF4aW11bU92ZXJsYXAoc3RyaW5nMSwgc3RyaW5nMikge1xuICAgIHJldHVybiBzdHJpbmcyLnNsaWNlKDAsIG92ZXJsYXBDb3VudChzdHJpbmcxLCBzdHJpbmcyKSk7XG59XG4vLyBOaWNrZWQgZnJvbSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNjA0MjI4NTMvMTcwOTU4N1xuZnVuY3Rpb24gb3ZlcmxhcENvdW50KGEsIGIpIHtcbiAgICAvLyBEZWFsIHdpdGggY2FzZXMgd2hlcmUgdGhlIHN0cmluZ3MgZGlmZmVyIGluIGxlbmd0aFxuICAgIHZhciBzdGFydEEgPSAwO1xuICAgIGlmIChhLmxlbmd0aCA+IGIubGVuZ3RoKSB7XG4gICAgICAgIHN0YXJ0QSA9IGEubGVuZ3RoIC0gYi5sZW5ndGg7XG4gICAgfVxuICAgIHZhciBlbmRCID0gYi5sZW5ndGg7XG4gICAgaWYgKGEubGVuZ3RoIDwgYi5sZW5ndGgpIHtcbiAgICAgICAgZW5kQiA9IGEubGVuZ3RoO1xuICAgIH1cbiAgICAvLyBDcmVhdGUgYSBiYWNrLXJlZmVyZW5jZSBmb3IgZWFjaCBpbmRleFxuICAgIC8vICAgdGhhdCBzaG91bGQgYmUgZm9sbG93ZWQgaW4gY2FzZSBvZiBhIG1pc21hdGNoLlxuICAgIC8vICAgV2Ugb25seSBuZWVkIEIgdG8gbWFrZSB0aGVzZSByZWZlcmVuY2VzOlxuICAgIHZhciBtYXAgPSBBcnJheShlbmRCKTtcbiAgICB2YXIgayA9IDA7IC8vIEluZGV4IHRoYXQgbGFncyBiZWhpbmQgalxuICAgIG1hcFswXSA9IDA7XG4gICAgZm9yICh2YXIgaiA9IDE7IGogPCBlbmRCOyBqKyspIHtcbiAgICAgICAgaWYgKGJbal0gPT0gYltrXSkge1xuICAgICAgICAgICAgbWFwW2pdID0gbWFwW2tdOyAvLyBza2lwIG92ZXIgdGhlIHNhbWUgY2hhcmFjdGVyIChvcHRpb25hbCBvcHRpbWlzYXRpb24pXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtYXBbal0gPSBrO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChrID4gMCAmJiBiW2pdICE9IGJba10pIHtcbiAgICAgICAgICAgIGsgPSBtYXBba107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJbal0gPT0gYltrXSkge1xuICAgICAgICAgICAgaysrO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFBoYXNlIDI6IHVzZSB0aGVzZSByZWZlcmVuY2VzIHdoaWxlIGl0ZXJhdGluZyBvdmVyIEFcbiAgICBrID0gMDtcbiAgICBmb3IgKHZhciBpID0gc3RhcnRBOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgICB3aGlsZSAoayA+IDAgJiYgYVtpXSAhPSBiW2tdKSB7XG4gICAgICAgICAgICBrID0gbWFwW2tdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhW2ldID09IGJba10pIHtcbiAgICAgICAgICAgIGsrKztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaztcbn1cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBzdHJpbmcgY29uc2lzdGVudGx5IHVzZXMgV2luZG93cyBsaW5lIGVuZGluZ3MuXG4gKi9cbmZ1bmN0aW9uIGhhc09ubHlXaW5MaW5lRW5kaW5ncyhzdHJpbmcpIHtcbiAgICByZXR1cm4gc3RyaW5nLmluY2x1ZGVzKCdcXHJcXG4nKSAmJiAhc3RyaW5nLnN0YXJ0c1dpdGgoJ1xcbicpICYmICFzdHJpbmcubWF0Y2goL1teXFxyXVxcbi8pO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHN0cmluZyBjb25zaXN0ZW50bHkgdXNlcyBVbml4IGxpbmUgZW5kaW5ncy5cbiAqL1xuZnVuY3Rpb24gaGFzT25seVVuaXhMaW5lRW5kaW5ncyhzdHJpbmcpIHtcbiAgICByZXR1cm4gIXN0cmluZy5pbmNsdWRlcygnXFxyXFxuJykgJiYgc3RyaW5nLmluY2x1ZGVzKCdcXG4nKTtcbn1cbmZ1bmN0aW9uIHRyYWlsaW5nV3Moc3RyaW5nKSB7XG4gICAgLy8gWWVzLCB0aGlzIGxvb2tzIG92ZXJjb21wbGljYXRlZCBhbmQgZHVtYiAtIHdoeSBub3QgcmVwbGFjZSB0aGUgd2hvbGUgZnVuY3Rpb24gd2l0aFxuICAgIC8vICAgICByZXR1cm4gc3RyaW5nIG1hdGNoKC9cXHMqJC8pWzBdXG4gICAgLy8geW91IGFzaz8gQmVjYXVzZTpcbiAgICAvLyAxLiB0aGUgdHJhcCBkZXNjcmliZWQgYXQgaHR0cHM6Ly9tYXJrYW1lcnkuY29tL2Jsb2cvcXVhZHJhdGljLXRpbWUtcmVnZXhlcy8gd291bGQgbWVhbiBkb2luZ1xuICAgIC8vICAgIHRoaXMgd291bGQgY2F1c2UgdGhpcyBmdW5jdGlvbiB0byB0YWtlIE8oblx1MDBCMikgdGltZSBpbiB0aGUgd29yc3QgY2FzZSAoc3BlY2lmaWNhbGx5IHdoZW5cbiAgICAvLyAgICB0aGVyZSBpcyBhIG1hc3NpdmUgcnVuIG9mIE5PTi1UUkFJTElORyB3aGl0ZXNwYWNlIGluIGBzdHJpbmdgKSwgYW5kXG4gICAgLy8gMi4gdGhlIGZpeCBwcm9wb3NlZCBpbiB0aGUgc2FtZSBibG9nIHBvc3QsIG9mIHVzaW5nIGEgbmVnYXRpdmUgbG9va2JlaGluZCwgaXMgaW5jb21wYXRpYmxlXG4gICAgLy8gICAgd2l0aCBvbGQgU2FmYXJpIHZlcnNpb25zIHRoYXQgd2UnZCBsaWtlIHRvIG5vdCBicmVhayBpZiBwb3NzaWJsZSAoc2VlXG4gICAgLy8gICAgaHR0cHM6Ly9naXRodWIuY29tL2twZGVja2VyL2pzZGlmZi9wdWxsLzU1MClcbiAgICAvLyBJdCBmZWVscyBhYnN1cmQgdG8gZG8gdGhpcyB3aXRoIGFuIGV4cGxpY2l0IGxvb3AgaW5zdGVhZCBvZiBhIHJlZ2V4LCBidXQgSSByZWFsbHkgY2FuJ3Qgc2VlIGFcbiAgICAvLyBiZXR0ZXIgd2F5IHRoYXQgZG9lc24ndCByZXN1bHQgaW4gYnJva2VuIGJlaGF2aW91ci5cbiAgICB2YXIgaTtcbiAgICBmb3IgKGkgPSBzdHJpbmcubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgaWYgKCFzdHJpbmdbaV0ubWF0Y2goL1xccy8pKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3RyaW5nLnN1YnN0cmluZyhpICsgMSk7XG59XG5mdW5jdGlvbiBsZWFkaW5nV3Moc3RyaW5nKSB7XG4gICAgLy8gVGhhbmtmdWxseSB0aGUgYW5ub3lpbmcgY29uc2lkZXJhdGlvbnMgZGVzY3JpYmVkIGluIHRyYWlsaW5nV3MgZG9uJ3QgYXBwbHkgaGVyZTpcbiAgICB2YXIgbWF0Y2ggPSBzdHJpbmcubWF0Y2goL15cXHMqLyk7XG4gICAgcmV0dXJuIG1hdGNoID8gbWF0Y2hbMF0gOiAnJztcbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLndvcmRzV2l0aFNwYWNlRGlmZiA9IGV4cG9ydHMud29yZERpZmYgPSB2b2lkIDA7XG5leHBvcnRzLmRpZmZXb3JkcyA9IGRpZmZXb3JkcztcbmV4cG9ydHMuZGlmZldvcmRzV2l0aFNwYWNlID0gZGlmZldvcmRzV2l0aFNwYWNlO1xudmFyIGJhc2VfanNfMSA9IHJlcXVpcmUoXCIuL2Jhc2UuanNcIik7XG52YXIgc3RyaW5nX2pzXzEgPSByZXF1aXJlKFwiLi4vdXRpbC9zdHJpbmcuanNcIik7XG4vLyBCYXNlZCBvbiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MYXRpbl9zY3JpcHRfaW5fVW5pY29kZVxuLy9cbi8vIFJhbmdlcyBhbmQgZXhjZXB0aW9uczpcbi8vIExhdGluLTEgU3VwcGxlbWVudCwgMDA4MFx1MjAxMzAwRkZcbi8vICAtIFUrMDBENyAgXHUwMEQ3IE11bHRpcGxpY2F0aW9uIHNpZ25cbi8vICAtIFUrMDBGNyAgXHUwMEY3IERpdmlzaW9uIHNpZ25cbi8vIExhdGluIEV4dGVuZGVkLUEsIDAxMDBcdTIwMTMwMTdGXG4vLyBMYXRpbiBFeHRlbmRlZC1CLCAwMTgwXHUyMDEzMDI0RlxuLy8gSVBBIEV4dGVuc2lvbnMsIDAyNTBcdTIwMTMwMkFGXG4vLyBTcGFjaW5nIE1vZGlmaWVyIExldHRlcnMsIDAyQjBcdTIwMTMwMkZGXG4vLyAgLSBVKzAyQzcgIFx1MDJDNyAmIzcxMTsgIENhcm9uXG4vLyAgLSBVKzAyRDggIFx1MDJEOCAmIzcyODsgIEJyZXZlXG4vLyAgLSBVKzAyRDkgIFx1MDJEOSAmIzcyOTsgIERvdCBBYm92ZVxuLy8gIC0gVSswMkRBICBcdTAyREEgJiM3MzA7ICBSaW5nIEFib3ZlXG4vLyAgLSBVKzAyREIgIFx1MDJEQiAmIzczMTsgIE9nb25la1xuLy8gIC0gVSswMkRDICBcdTAyREMgJiM3MzI7ICBTbWFsbCBUaWxkZVxuLy8gIC0gVSswMkREICBcdTAyREQgJiM3MzM7ICBEb3VibGUgQWN1dGUgQWNjZW50XG4vLyBMYXRpbiBFeHRlbmRlZCBBZGRpdGlvbmFsLCAxRTAwXHUyMDEzMUVGRlxudmFyIGV4dGVuZGVkV29yZENoYXJzID0gJ2EtekEtWjAtOV9cXFxcdXtDMH0tXFxcXHV7RkZ9XFxcXHV7RDh9LVxcXFx1e0Y2fVxcXFx1e0Y4fS1cXFxcdXsyQzZ9XFxcXHV7MkM4fS1cXFxcdXsyRDd9XFxcXHV7MkRFfS1cXFxcdXsyRkZ9XFxcXHV7MUUwMH0tXFxcXHV7MUVGRn0nO1xuLy8gRWFjaCB0b2tlbiBpcyBvbmUgb2YgdGhlIGZvbGxvd2luZzpcbi8vIC0gQSBwdW5jdHVhdGlvbiBtYXJrIHBsdXMgdGhlIHN1cnJvdW5kaW5nIHdoaXRlc3BhY2Vcbi8vIC0gQSB3b3JkIHBsdXMgdGhlIHN1cnJvdW5kaW5nIHdoaXRlc3BhY2Vcbi8vIC0gUHVyZSB3aGl0ZXNwYWNlIChidXQgb25seSBpbiB0aGUgc3BlY2lhbCBjYXNlIHdoZXJlIHRoaXMgdGhlIGVudGlyZSB0ZXh0XG4vLyAgIGlzIGp1c3Qgd2hpdGVzcGFjZSlcbi8vXG4vLyBXZSBoYXZlIHRvIGluY2x1ZGUgc3Vycm91bmRpbmcgd2hpdGVzcGFjZSBpbiB0aGUgdG9rZW5zIGJlY2F1c2UgdGhlIHR3b1xuLy8gYWx0ZXJuYXRpdmUgYXBwcm9hY2hlcyBwcm9kdWNlIGhvcnJpYmx5IGJyb2tlbiByZXN1bHRzOlxuLy8gKiBJZiB3ZSBqdXN0IGRpc2NhcmQgdGhlIHdoaXRlc3BhY2UsIHdlIGNhbid0IGZ1bGx5IHJlcHJvZHVjZSB0aGUgb3JpZ2luYWxcbi8vICAgdGV4dCBmcm9tIHRoZSBzZXF1ZW5jZSBvZiB0b2tlbnMgYW5kIGFueSBhdHRlbXB0IHRvIHJlbmRlciB0aGUgZGlmZiB3aWxsXG4vLyAgIGdldCB0aGUgd2hpdGVzcGFjZSB3cm9uZy5cbi8vICogSWYgd2UgaGF2ZSBzZXBhcmF0ZSB0b2tlbnMgZm9yIHdoaXRlc3BhY2UsIHRoZW4gaW4gYSB0eXBpY2FsIHRleHQgZXZlcnlcbi8vICAgc2Vjb25kIHRva2VuIHdpbGwgYmUgYSBzaW5nbGUgc3BhY2UgY2hhcmFjdGVyLiBCdXQgdGhpcyBvZnRlbiByZXN1bHRzIGluXG4vLyAgIHRoZSBvcHRpbWFsIGRpZmYgYmV0d2VlbiB0d28gdGV4dHMgYmVpbmcgYSBwZXJ2ZXJzZSBvbmUgdGhhdCBwcmVzZXJ2ZXNcbi8vICAgdGhlIHNwYWNlcyBiZXR3ZWVuIHdvcmRzIGJ1dCBkZWxldGVzIGFuZCByZWluc2VydHMgYWN0dWFsIGNvbW1vbiB3b3Jkcy5cbi8vICAgU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9rcGRlY2tlci9qc2RpZmYvaXNzdWVzLzE2MCNpc3N1ZWNvbW1lbnQtMTg2NjA5OTY0MFxuLy8gICBmb3IgYW4gZXhhbXBsZS5cbi8vXG4vLyBLZWVwaW5nIHRoZSBzdXJyb3VuZGluZyB3aGl0ZXNwYWNlIG9mIGNvdXJzZSBoYXMgaW1wbGljYXRpb25zIGZvciAuZXF1YWxzXG4vLyBhbmQgLmpvaW4sIG5vdCBqdXN0IC50b2tlbml6ZS5cbi8vIFRoaXMgcmVnZXggZG9lcyBOT1QgZnVsbHkgaW1wbGVtZW50IHRoZSB0b2tlbml6YXRpb24gcnVsZXMgZGVzY3JpYmVkIGFib3ZlLlxuLy8gSW5zdGVhZCwgaXQgZ2l2ZXMgcnVucyBvZiB3aGl0ZXNwYWNlIHRoZWlyIG93biBcInRva2VuXCIuIFRoZSB0b2tlbml6ZSBtZXRob2Rcbi8vIHRoZW4gaGFuZGxlcyBzdGl0Y2hpbmcgd2hpdGVzcGFjZSB0b2tlbnMgb250byBhZGphY2VudCB3b3JkIG9yIHB1bmN0dWF0aW9uXG4vLyB0b2tlbnMuXG52YXIgdG9rZW5pemVJbmNsdWRpbmdXaGl0ZXNwYWNlID0gbmV3IFJlZ0V4cChcIltcIi5jb25jYXQoZXh0ZW5kZWRXb3JkQ2hhcnMsIFwiXSt8XFxcXHMrfFteXCIpLmNvbmNhdChleHRlbmRlZFdvcmRDaGFycywgXCJdXCIpLCAndWcnKTtcbnZhciBXb3JkRGlmZiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoV29yZERpZmYsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gV29yZERpZmYoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgV29yZERpZmYucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIChsZWZ0LCByaWdodCwgb3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucy5pZ25vcmVDYXNlKSB7XG4gICAgICAgICAgICBsZWZ0ID0gbGVmdC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgcmlnaHQgPSByaWdodC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsZWZ0LnRyaW0oKSA9PT0gcmlnaHQudHJpbSgpO1xuICAgIH07XG4gICAgV29yZERpZmYucHJvdG90eXBlLnRva2VuaXplID0gZnVuY3Rpb24gKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIHZhciBwYXJ0cztcbiAgICAgICAgaWYgKG9wdGlvbnMuaW50bFNlZ21lbnRlcikge1xuICAgICAgICAgICAgdmFyIHNlZ21lbnRlciA9IG9wdGlvbnMuaW50bFNlZ21lbnRlcjtcbiAgICAgICAgICAgIGlmIChzZWdtZW50ZXIucmVzb2x2ZWRPcHRpb25zKCkuZ3JhbnVsYXJpdHkgIT0gJ3dvcmQnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgc2VnbWVudGVyIHBhc3NlZCBtdXN0IGhhdmUgYSBncmFudWxhcml0eSBvZiBcIndvcmRcIicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFydHMgPSBBcnJheS5mcm9tKHNlZ21lbnRlci5zZWdtZW50KHZhbHVlKSwgZnVuY3Rpb24gKHNlZ21lbnQpIHsgcmV0dXJuIHNlZ21lbnQuc2VnbWVudDsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJ0cyA9IHZhbHVlLm1hdGNoKHRva2VuaXplSW5jbHVkaW5nV2hpdGVzcGFjZSkgfHwgW107XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRva2VucyA9IFtdO1xuICAgICAgICB2YXIgcHJldlBhcnQgPSBudWxsO1xuICAgICAgICBwYXJ0cy5mb3JFYWNoKGZ1bmN0aW9uIChwYXJ0KSB7XG4gICAgICAgICAgICBpZiAoKC9cXHMvKS50ZXN0KHBhcnQpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByZXZQYXJ0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5zLnB1c2gocGFydCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbnMucG9wKCkgKyBwYXJ0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwcmV2UGFydCAhPSBudWxsICYmICgvXFxzLykudGVzdChwcmV2UGFydCkpIHtcbiAgICAgICAgICAgICAgICBpZiAodG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXSA9PSBwcmV2UGFydCkge1xuICAgICAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbnMucG9wKCkgKyBwYXJ0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHByZXZQYXJ0ICsgcGFydCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdG9rZW5zLnB1c2gocGFydCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmV2UGFydCA9IHBhcnQ7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdG9rZW5zO1xuICAgIH07XG4gICAgV29yZERpZmYucHJvdG90eXBlLmpvaW4gPSBmdW5jdGlvbiAodG9rZW5zKSB7XG4gICAgICAgIC8vIFRva2VucyBiZWluZyBqb2luZWQgaGVyZSB3aWxsIGFsd2F5cyBoYXZlIGFwcGVhcmVkIGNvbnNlY3V0aXZlbHkgaW4gdGhlXG4gICAgICAgIC8vIHNhbWUgdGV4dCwgc28gd2UgY2FuIHNpbXBseSBzdHJpcCBvZmYgdGhlIGxlYWRpbmcgd2hpdGVzcGFjZSBmcm9tIGFsbCB0aGVcbiAgICAgICAgLy8gdG9rZW5zIGV4Y2VwdCB0aGUgZmlyc3QgKGFuZCBleGNlcHQgYW55IHdoaXRlc3BhY2Utb25seSB0b2tlbnMgLSBidXQgc3VjaFxuICAgICAgICAvLyBhIHRva2VuIHdpbGwgYWx3YXlzIGJlIHRoZSBmaXJzdCBhbmQgb25seSB0b2tlbiBhbnl3YXkpIGFuZCB0aGVuIGpvaW4gdGhlbVxuICAgICAgICAvLyBhbmQgdGhlIHdoaXRlc3BhY2UgYXJvdW5kIHdvcmRzIGFuZCBwdW5jdHVhdGlvbiB3aWxsIGVuZCB1cCBjb3JyZWN0LlxuICAgICAgICByZXR1cm4gdG9rZW5zLm1hcChmdW5jdGlvbiAodG9rZW4sIGkpIHtcbiAgICAgICAgICAgIGlmIChpID09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW4ucmVwbGFjZSgoL15cXHMrLyksICcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkuam9pbignJyk7XG4gICAgfTtcbiAgICBXb3JkRGlmZi5wcm90b3R5cGUucG9zdFByb2Nlc3MgPSBmdW5jdGlvbiAoY2hhbmdlcywgb3B0aW9ucykge1xuICAgICAgICBpZiAoIWNoYW5nZXMgfHwgb3B0aW9ucy5vbmVDaGFuZ2VQZXJUb2tlbikge1xuICAgICAgICAgICAgcmV0dXJuIGNoYW5nZXM7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxhc3RLZWVwID0gbnVsbDtcbiAgICAgICAgLy8gQ2hhbmdlIG9iamVjdHMgcmVwcmVzZW50aW5nIGFueSBpbnNlcnRpb24gb3IgZGVsZXRpb24gc2luY2UgdGhlIGxhc3RcbiAgICAgICAgLy8gXCJrZWVwXCIgY2hhbmdlIG9iamVjdC4gVGhlcmUgY2FuIGJlIGF0IG1vc3Qgb25lIG9mIGVhY2guXG4gICAgICAgIHZhciBpbnNlcnRpb24gPSBudWxsO1xuICAgICAgICB2YXIgZGVsZXRpb24gPSBudWxsO1xuICAgICAgICBjaGFuZ2VzLmZvckVhY2goZnVuY3Rpb24gKGNoYW5nZSkge1xuICAgICAgICAgICAgaWYgKGNoYW5nZS5hZGRlZCkge1xuICAgICAgICAgICAgICAgIGluc2VydGlvbiA9IGNoYW5nZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoYW5nZS5yZW1vdmVkKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRpb24gPSBjaGFuZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5zZXJ0aW9uIHx8IGRlbGV0aW9uKSB7IC8vIE1heSBiZSBmYWxzZSBhdCBzdGFydCBvZiB0ZXh0XG4gICAgICAgICAgICAgICAgICAgIGRlZHVwZVdoaXRlc3BhY2VJbkNoYW5nZU9iamVjdHMobGFzdEtlZXAsIGRlbGV0aW9uLCBpbnNlcnRpb24sIGNoYW5nZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxhc3RLZWVwID0gY2hhbmdlO1xuICAgICAgICAgICAgICAgIGluc2VydGlvbiA9IG51bGw7XG4gICAgICAgICAgICAgICAgZGVsZXRpb24gPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGluc2VydGlvbiB8fCBkZWxldGlvbikge1xuICAgICAgICAgICAgZGVkdXBlV2hpdGVzcGFjZUluQ2hhbmdlT2JqZWN0cyhsYXN0S2VlcCwgZGVsZXRpb24sIGluc2VydGlvbiwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNoYW5nZXM7XG4gICAgfTtcbiAgICByZXR1cm4gV29yZERpZmY7XG59KGJhc2VfanNfMS5kZWZhdWx0KSk7XG5leHBvcnRzLndvcmREaWZmID0gbmV3IFdvcmREaWZmKCk7XG5mdW5jdGlvbiBkaWZmV29yZHMob2xkU3RyLCBuZXdTdHIsIG9wdGlvbnMpIHtcbiAgICAvLyBUaGlzIG9wdGlvbiBoYXMgbmV2ZXIgYmVlbiBkb2N1bWVudGVkIGFuZCBuZXZlciB3aWxsIGJlIChpdCdzIGNsZWFyZXIgdG9cbiAgICAvLyBqdXN0IGNhbGwgYGRpZmZXb3Jkc1dpdGhTcGFjZWAgZGlyZWN0bHkgaWYgeW91IG5lZWQgdGhhdCBiZWhhdmlvciksIGJ1dFxuICAgIC8vIGhhcyBleGlzdGVkIGluIGpzZGlmZiBmb3IgYSBsb25nIHRpbWUsIHNvIHdlIHJldGFpbiBzdXBwb3J0IGZvciBpdCBoZXJlXG4gICAgLy8gZm9yIHRoZSBzYWtlIG9mIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuICAgIGlmICgob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmlnbm9yZVdoaXRlc3BhY2UpICE9IG51bGwgJiYgIW9wdGlvbnMuaWdub3JlV2hpdGVzcGFjZSkge1xuICAgICAgICByZXR1cm4gZGlmZldvcmRzV2l0aFNwYWNlKG9sZFN0ciwgbmV3U3RyLCBvcHRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIGV4cG9ydHMud29yZERpZmYuZGlmZihvbGRTdHIsIG5ld1N0ciwgb3B0aW9ucyk7XG59XG5mdW5jdGlvbiBkZWR1cGVXaGl0ZXNwYWNlSW5DaGFuZ2VPYmplY3RzKHN0YXJ0S2VlcCwgZGVsZXRpb24sIGluc2VydGlvbiwgZW5kS2VlcCkge1xuICAgIC8vIEJlZm9yZSByZXR1cm5pbmcsIHdlIHRpZHkgdXAgdGhlIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHdoaXRlc3BhY2Ugb2YgdGhlXG4gICAgLy8gY2hhbmdlIG9iamVjdHMgdG8gZWxpbWluYXRlIGNhc2VzIHdoZXJlIHRyYWlsaW5nIHdoaXRlc3BhY2UgaW4gb25lIG9iamVjdFxuICAgIC8vIGlzIHJlcGVhdGVkIGFzIGxlYWRpbmcgd2hpdGVzcGFjZSBpbiB0aGUgbmV4dC5cbiAgICAvLyBCZWxvdyBhcmUgZXhhbXBsZXMgb2YgdGhlIG91dGNvbWVzIHdlIHdhbnQgaGVyZSB0byBleHBsYWluIHRoZSBjb2RlLlxuICAgIC8vIEk9aW5zZXJ0LCBLPWtlZXAsIEQ9ZGVsZXRlXG4gICAgLy8gMS4gZGlmZmluZyAnZm9vIGJhciBiYXonIHZzICdmb28gYmF6J1xuICAgIC8vICAgIFByaW9yIHRvIGNsZWFudXAsIHdlIGhhdmUgSzonZm9vICcgRDonIGJhciAnIEs6JyBiYXonXG4gICAgLy8gICAgQWZ0ZXIgY2xlYW51cCwgd2Ugd2FudDogICBLOidmb28gJyBEOidiYXIgJyBLOidiYXonXG4gICAgLy9cbiAgICAvLyAyLiBEaWZmaW5nICdmb28gYmFyIGJheicgdnMgJ2ZvbyBxdXggYmF6J1xuICAgIC8vICAgIFByaW9yIHRvIGNsZWFudXAsIHdlIGhhdmUgSzonZm9vICcgRDonIGJhciAnIEk6JyBxdXggJyBLOicgYmF6J1xuICAgIC8vICAgIEFmdGVyIGNsZWFudXAsIHdlIHdhbnQgSzonZm9vICcgRDonYmFyJyBJOidxdXgnIEs6JyBiYXonXG4gICAgLy9cbiAgICAvLyAzLiBEaWZmaW5nICdmb29cXG5iYXIgYmF6JyB2cyAnZm9vIGJheidcbiAgICAvLyAgICBQcmlvciB0byBjbGVhbnVwLCB3ZSBoYXZlIEs6J2ZvbyAnIEQ6J1xcbmJhciAnIEs6JyBiYXonXG4gICAgLy8gICAgQWZ0ZXIgY2xlYW51cCwgd2Ugd2FudCBLJ2ZvbycgRDonXFxuYmFyJyBLOicgYmF6J1xuICAgIC8vXG4gICAgLy8gNC4gRGlmZmluZyAnZm9vIGJheicgdnMgJ2Zvb1xcbmJhciBiYXonXG4gICAgLy8gICAgUHJpb3IgdG8gY2xlYW51cCwgd2UgaGF2ZSBLOidmb29cXG4nIEk6J1xcbmJhciAnIEs6JyBiYXonXG4gICAgLy8gICAgQWZ0ZXIgY2xlYW51cCwgd2UgaWRlYWxseSB3YW50IEsnZm9vJyBJOidcXG5iYXInIEs6JyBiYXonXG4gICAgLy8gICAgYnV0IGRvbid0IGFjdHVhbGx5IG1hbmFnZSB0aGlzIGN1cnJlbnRseSAodGhlIHByZS1jbGVhbnVwIGNoYW5nZVxuICAgIC8vICAgIG9iamVjdHMgZG9uJ3QgY29udGFpbiBlbm91Z2ggaW5mb3JtYXRpb24gdG8gbWFrZSBpdCBwb3NzaWJsZSkuXG4gICAgLy9cbiAgICAvLyA1LiBEaWZmaW5nICdmb28gICBiYXIgYmF6JyB2cyAnZm9vICBiYXonXG4gICAgLy8gICAgUHJpb3IgdG8gY2xlYW51cCwgd2UgaGF2ZSBLOidmb28gICcgRDonICAgYmFyICcgSzonICBiYXonXG4gICAgLy8gICAgQWZ0ZXIgY2xlYW51cCwgd2Ugd2FudCBLOidmb28gICcgRDonIGJhciAnIEs6J2JheidcbiAgICAvL1xuICAgIC8vIE91ciBoYW5kbGluZyBpcyB1bmF2b2lkYWJseSBpbXBlcmZlY3QgaW4gdGhlIGNhc2Ugd2hlcmUgdGhlcmUncyBhIHNpbmdsZVxuICAgIC8vIGluZGVsIGJldHdlZW4ga2VlcHMgYW5kIHRoZSB3aGl0ZXNwYWNlIGhhcyBjaGFuZ2VkLiBGb3IgaW5zdGFuY2UsIGNvbnNpZGVyXG4gICAgLy8gZGlmZmluZyAnZm9vXFx0YmFyXFxuYmF6JyB2cyAnZm9vIGJheicuIFVubGVzcyB3ZSBjcmVhdGUgYW4gZXh0cmEgY2hhbmdlXG4gICAgLy8gb2JqZWN0IHRvIHJlcHJlc2VudCB0aGUgaW5zZXJ0aW9uIG9mIHRoZSBzcGFjZSBjaGFyYWN0ZXIgKHdoaWNoIGlzbid0IGV2ZW5cbiAgICAvLyBhIHRva2VuKSwgd2UgaGF2ZSBubyB3YXkgdG8gYXZvaWQgbG9zaW5nIGluZm9ybWF0aW9uIGFib3V0IHRoZSB0ZXh0cydcbiAgICAvLyBvcmlnaW5hbCB3aGl0ZXNwYWNlIGluIHRoZSByZXN1bHQgd2UgcmV0dXJuLiBTdGlsbCwgd2UgZG8gb3VyIGJlc3QgdG9cbiAgICAvLyBvdXRwdXQgc29tZXRoaW5nIHRoYXQgd2lsbCBsb29rIHNlbnNpYmxlIGlmIHdlIGUuZy4gcHJpbnQgaXQgd2l0aFxuICAgIC8vIGluc2VydGlvbnMgaW4gZ3JlZW4gYW5kIGRlbGV0aW9ucyBpbiByZWQuXG4gICAgLy8gQmV0d2VlbiB0d28gXCJrZWVwXCIgY2hhbmdlIG9iamVjdHMgKG9yIGJlZm9yZSB0aGUgZmlyc3Qgb3IgYWZ0ZXIgdGhlIGxhc3RcbiAgICAvLyBjaGFuZ2Ugb2JqZWN0KSwgd2UgY2FuIGhhdmUgZWl0aGVyOlxuICAgIC8vICogQSBcImRlbGV0ZVwiIGZvbGxvd2VkIGJ5IGFuIFwiaW5zZXJ0XCJcbiAgICAvLyAqIEp1c3QgYW4gXCJpbnNlcnRcIlxuICAgIC8vICogSnVzdCBhIFwiZGVsZXRlXCJcbiAgICAvLyBXZSBoYW5kbGUgdGhlIHRocmVlIGNhc2VzIHNlcGFyYXRlbHkuXG4gICAgaWYgKGRlbGV0aW9uICYmIGluc2VydGlvbikge1xuICAgICAgICB2YXIgb2xkV3NQcmVmaXggPSAoMCwgc3RyaW5nX2pzXzEubGVhZGluZ1dzKShkZWxldGlvbi52YWx1ZSk7XG4gICAgICAgIHZhciBvbGRXc1N1ZmZpeCA9ICgwLCBzdHJpbmdfanNfMS50cmFpbGluZ1dzKShkZWxldGlvbi52YWx1ZSk7XG4gICAgICAgIHZhciBuZXdXc1ByZWZpeCA9ICgwLCBzdHJpbmdfanNfMS5sZWFkaW5nV3MpKGluc2VydGlvbi52YWx1ZSk7XG4gICAgICAgIHZhciBuZXdXc1N1ZmZpeCA9ICgwLCBzdHJpbmdfanNfMS50cmFpbGluZ1dzKShpbnNlcnRpb24udmFsdWUpO1xuICAgICAgICBpZiAoc3RhcnRLZWVwKSB7XG4gICAgICAgICAgICB2YXIgY29tbW9uV3NQcmVmaXggPSAoMCwgc3RyaW5nX2pzXzEubG9uZ2VzdENvbW1vblByZWZpeCkob2xkV3NQcmVmaXgsIG5ld1dzUHJlZml4KTtcbiAgICAgICAgICAgIHN0YXJ0S2VlcC52YWx1ZSA9ICgwLCBzdHJpbmdfanNfMS5yZXBsYWNlU3VmZml4KShzdGFydEtlZXAudmFsdWUsIG5ld1dzUHJlZml4LCBjb21tb25Xc1ByZWZpeCk7XG4gICAgICAgICAgICBkZWxldGlvbi52YWx1ZSA9ICgwLCBzdHJpbmdfanNfMS5yZW1vdmVQcmVmaXgpKGRlbGV0aW9uLnZhbHVlLCBjb21tb25Xc1ByZWZpeCk7XG4gICAgICAgICAgICBpbnNlcnRpb24udmFsdWUgPSAoMCwgc3RyaW5nX2pzXzEucmVtb3ZlUHJlZml4KShpbnNlcnRpb24udmFsdWUsIGNvbW1vbldzUHJlZml4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW5kS2VlcCkge1xuICAgICAgICAgICAgdmFyIGNvbW1vbldzU3VmZml4ID0gKDAsIHN0cmluZ19qc18xLmxvbmdlc3RDb21tb25TdWZmaXgpKG9sZFdzU3VmZml4LCBuZXdXc1N1ZmZpeCk7XG4gICAgICAgICAgICBlbmRLZWVwLnZhbHVlID0gKDAsIHN0cmluZ19qc18xLnJlcGxhY2VQcmVmaXgpKGVuZEtlZXAudmFsdWUsIG5ld1dzU3VmZml4LCBjb21tb25Xc1N1ZmZpeCk7XG4gICAgICAgICAgICBkZWxldGlvbi52YWx1ZSA9ICgwLCBzdHJpbmdfanNfMS5yZW1vdmVTdWZmaXgpKGRlbGV0aW9uLnZhbHVlLCBjb21tb25Xc1N1ZmZpeCk7XG4gICAgICAgICAgICBpbnNlcnRpb24udmFsdWUgPSAoMCwgc3RyaW5nX2pzXzEucmVtb3ZlU3VmZml4KShpbnNlcnRpb24udmFsdWUsIGNvbW1vbldzU3VmZml4KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChpbnNlcnRpb24pIHtcbiAgICAgICAgLy8gVGhlIHdoaXRlc3BhY2VzIGFsbCByZWZsZWN0IHdoYXQgd2FzIGluIHRoZSBuZXcgdGV4dCByYXRoZXIgdGhhblxuICAgICAgICAvLyB0aGUgb2xkLCBzbyB3ZSBlc3NlbnRpYWxseSBoYXZlIG5vIGluZm9ybWF0aW9uIGFib3V0IHdoaXRlc3BhY2VcbiAgICAgICAgLy8gaW5zZXJ0aW9uIG9yIGRlbGV0aW9uLiBXZSBqdXN0IHdhbnQgdG8gZGVkdXBlIHRoZSB3aGl0ZXNwYWNlLlxuICAgICAgICAvLyBXZSBkbyB0aGF0IGJ5IGhhdmluZyBlYWNoIGNoYW5nZSBvYmplY3Qga2VlcCBpdHMgdHJhaWxpbmdcbiAgICAgICAgLy8gd2hpdGVzcGFjZSBhbmQgZGVsZXRpbmcgZHVwbGljYXRlIGxlYWRpbmcgd2hpdGVzcGFjZSB3aGVyZVxuICAgICAgICAvLyBwcmVzZW50LlxuICAgICAgICBpZiAoc3RhcnRLZWVwKSB7XG4gICAgICAgICAgICB2YXIgd3MgPSAoMCwgc3RyaW5nX2pzXzEubGVhZGluZ1dzKShpbnNlcnRpb24udmFsdWUpO1xuICAgICAgICAgICAgaW5zZXJ0aW9uLnZhbHVlID0gaW5zZXJ0aW9uLnZhbHVlLnN1YnN0cmluZyh3cy5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbmRLZWVwKSB7XG4gICAgICAgICAgICB2YXIgd3MgPSAoMCwgc3RyaW5nX2pzXzEubGVhZGluZ1dzKShlbmRLZWVwLnZhbHVlKTtcbiAgICAgICAgICAgIGVuZEtlZXAudmFsdWUgPSBlbmRLZWVwLnZhbHVlLnN1YnN0cmluZyh3cy5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIG90aGVyd2lzZSB3ZSd2ZSBnb3QgYSBkZWxldGlvbiBhbmQgbm8gaW5zZXJ0aW9uXG4gICAgfVxuICAgIGVsc2UgaWYgKHN0YXJ0S2VlcCAmJiBlbmRLZWVwKSB7XG4gICAgICAgIHZhciBuZXdXc0Z1bGwgPSAoMCwgc3RyaW5nX2pzXzEubGVhZGluZ1dzKShlbmRLZWVwLnZhbHVlKSwgZGVsV3NTdGFydCA9ICgwLCBzdHJpbmdfanNfMS5sZWFkaW5nV3MpKGRlbGV0aW9uLnZhbHVlKSwgZGVsV3NFbmQgPSAoMCwgc3RyaW5nX2pzXzEudHJhaWxpbmdXcykoZGVsZXRpb24udmFsdWUpO1xuICAgICAgICAvLyBBbnkgd2hpdGVzcGFjZSB0aGF0IGNvbWVzIHN0cmFpZ2h0IGFmdGVyIHN0YXJ0S2VlcCBpbiBib3RoIHRoZSBvbGQgYW5kXG4gICAgICAgIC8vIG5ldyB0ZXh0cywgYXNzaWduIHRvIHN0YXJ0S2VlcCBhbmQgcmVtb3ZlIGZyb20gdGhlIGRlbGV0aW9uLlxuICAgICAgICB2YXIgbmV3V3NTdGFydCA9ICgwLCBzdHJpbmdfanNfMS5sb25nZXN0Q29tbW9uUHJlZml4KShuZXdXc0Z1bGwsIGRlbFdzU3RhcnQpO1xuICAgICAgICBkZWxldGlvbi52YWx1ZSA9ICgwLCBzdHJpbmdfanNfMS5yZW1vdmVQcmVmaXgpKGRlbGV0aW9uLnZhbHVlLCBuZXdXc1N0YXJ0KTtcbiAgICAgICAgLy8gQW55IHdoaXRlc3BhY2UgdGhhdCBjb21lcyBzdHJhaWdodCBiZWZvcmUgZW5kS2VlcCBpbiBib3RoIHRoZSBvbGQgYW5kXG4gICAgICAgIC8vIG5ldyB0ZXh0cywgYW5kIGhhc24ndCBhbHJlYWR5IGJlZW4gYXNzaWduZWQgdG8gc3RhcnRLZWVwLCBhc3NpZ24gdG9cbiAgICAgICAgLy8gZW5kS2VlcCBhbmQgcmVtb3ZlIGZyb20gdGhlIGRlbGV0aW9uLlxuICAgICAgICB2YXIgbmV3V3NFbmQgPSAoMCwgc3RyaW5nX2pzXzEubG9uZ2VzdENvbW1vblN1ZmZpeCkoKDAsIHN0cmluZ19qc18xLnJlbW92ZVByZWZpeCkobmV3V3NGdWxsLCBuZXdXc1N0YXJ0KSwgZGVsV3NFbmQpO1xuICAgICAgICBkZWxldGlvbi52YWx1ZSA9ICgwLCBzdHJpbmdfanNfMS5yZW1vdmVTdWZmaXgpKGRlbGV0aW9uLnZhbHVlLCBuZXdXc0VuZCk7XG4gICAgICAgIGVuZEtlZXAudmFsdWUgPSAoMCwgc3RyaW5nX2pzXzEucmVwbGFjZVByZWZpeCkoZW5kS2VlcC52YWx1ZSwgbmV3V3NGdWxsLCBuZXdXc0VuZCk7XG4gICAgICAgIC8vIElmIHRoZXJlJ3MgYW55IHdoaXRlc3BhY2UgZnJvbSB0aGUgbmV3IHRleHQgdGhhdCBIQVNOJ1QgYWxyZWFkeSBiZWVuXG4gICAgICAgIC8vIGFzc2lnbmVkLCBhc3NpZ24gaXQgdG8gdGhlIHN0YXJ0OlxuICAgICAgICBzdGFydEtlZXAudmFsdWUgPSAoMCwgc3RyaW5nX2pzXzEucmVwbGFjZVN1ZmZpeCkoc3RhcnRLZWVwLnZhbHVlLCBuZXdXc0Z1bGwsIG5ld1dzRnVsbC5zbGljZSgwLCBuZXdXc0Z1bGwubGVuZ3RoIC0gbmV3V3NFbmQubGVuZ3RoKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGVuZEtlZXApIHtcbiAgICAgICAgLy8gV2UgYXJlIGF0IHRoZSBzdGFydCBvZiB0aGUgdGV4dC4gUHJlc2VydmUgYWxsIHRoZSB3aGl0ZXNwYWNlIG9uXG4gICAgICAgIC8vIGVuZEtlZXAsIGFuZCBqdXN0IHJlbW92ZSB3aGl0ZXNwYWNlIGZyb20gdGhlIGVuZCBvZiBkZWxldGlvbiB0byB0aGVcbiAgICAgICAgLy8gZXh0ZW50IHRoYXQgaXQgb3ZlcmxhcHMgd2l0aCB0aGUgc3RhcnQgb2YgZW5kS2VlcC5cbiAgICAgICAgdmFyIGVuZEtlZXBXc1ByZWZpeCA9ICgwLCBzdHJpbmdfanNfMS5sZWFkaW5nV3MpKGVuZEtlZXAudmFsdWUpO1xuICAgICAgICB2YXIgZGVsZXRpb25Xc1N1ZmZpeCA9ICgwLCBzdHJpbmdfanNfMS50cmFpbGluZ1dzKShkZWxldGlvbi52YWx1ZSk7XG4gICAgICAgIHZhciBvdmVybGFwID0gKDAsIHN0cmluZ19qc18xLm1heGltdW1PdmVybGFwKShkZWxldGlvbldzU3VmZml4LCBlbmRLZWVwV3NQcmVmaXgpO1xuICAgICAgICBkZWxldGlvbi52YWx1ZSA9ICgwLCBzdHJpbmdfanNfMS5yZW1vdmVTdWZmaXgpKGRlbGV0aW9uLnZhbHVlLCBvdmVybGFwKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoc3RhcnRLZWVwKSB7XG4gICAgICAgIC8vIFdlIGFyZSBhdCB0aGUgRU5EIG9mIHRoZSB0ZXh0LiBQcmVzZXJ2ZSBhbGwgdGhlIHdoaXRlc3BhY2Ugb25cbiAgICAgICAgLy8gc3RhcnRLZWVwLCBhbmQganVzdCByZW1vdmUgd2hpdGVzcGFjZSBmcm9tIHRoZSBzdGFydCBvZiBkZWxldGlvbiB0b1xuICAgICAgICAvLyB0aGUgZXh0ZW50IHRoYXQgaXQgb3ZlcmxhcHMgd2l0aCB0aGUgZW5kIG9mIHN0YXJ0S2VlcC5cbiAgICAgICAgdmFyIHN0YXJ0S2VlcFdzU3VmZml4ID0gKDAsIHN0cmluZ19qc18xLnRyYWlsaW5nV3MpKHN0YXJ0S2VlcC52YWx1ZSk7XG4gICAgICAgIHZhciBkZWxldGlvbldzUHJlZml4ID0gKDAsIHN0cmluZ19qc18xLmxlYWRpbmdXcykoZGVsZXRpb24udmFsdWUpO1xuICAgICAgICB2YXIgb3ZlcmxhcCA9ICgwLCBzdHJpbmdfanNfMS5tYXhpbXVtT3ZlcmxhcCkoc3RhcnRLZWVwV3NTdWZmaXgsIGRlbGV0aW9uV3NQcmVmaXgpO1xuICAgICAgICBkZWxldGlvbi52YWx1ZSA9ICgwLCBzdHJpbmdfanNfMS5yZW1vdmVQcmVmaXgpKGRlbGV0aW9uLnZhbHVlLCBvdmVybGFwKTtcbiAgICB9XG59XG52YXIgV29yZHNXaXRoU3BhY2VEaWZmID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhXb3Jkc1dpdGhTcGFjZURpZmYsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gV29yZHNXaXRoU3BhY2VEaWZmKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIFdvcmRzV2l0aFNwYWNlRGlmZi5wcm90b3R5cGUudG9rZW5pemUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgLy8gU2xpZ2h0bHkgZGlmZmVyZW50IHRvIHRoZSB0b2tlbml6ZUluY2x1ZGluZ1doaXRlc3BhY2UgcmVnZXggdXNlZCBhYm92ZSBpblxuICAgICAgICAvLyB0aGF0IHRoaXMgb25lIHRyZWF0cyBlYWNoIGluZGl2aWR1YWwgbmV3bGluZSBhcyBhIGRpc3RpbmN0IHRva2VucywgcmF0aGVyXG4gICAgICAgIC8vIHRoYW4gbWVyZ2luZyB0aGVtIGludG8gb3RoZXIgc3Vycm91bmRpbmcgd2hpdGVzcGFjZS4gVGhpcyB3YXMgcmVxdWVzdGVkXG4gICAgICAgIC8vIGluIGh0dHBzOi8vZ2l0aHViLmNvbS9rcGRlY2tlci9qc2RpZmYvaXNzdWVzLzE4MCAmXG4gICAgICAgIC8vICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9rcGRlY2tlci9qc2RpZmYvaXNzdWVzLzIxMVxuICAgICAgICB2YXIgcmVnZXggPSBuZXcgUmVnRXhwKFwiKFxcXFxyP1xcXFxuKXxbXCIuY29uY2F0KGV4dGVuZGVkV29yZENoYXJzLCBcIl0rfFteXFxcXFNcXFxcblxcXFxyXSt8W15cIikuY29uY2F0KGV4dGVuZGVkV29yZENoYXJzLCBcIl1cIiksICd1ZycpO1xuICAgICAgICByZXR1cm4gdmFsdWUubWF0Y2gocmVnZXgpIHx8IFtdO1xuICAgIH07XG4gICAgcmV0dXJuIFdvcmRzV2l0aFNwYWNlRGlmZjtcbn0oYmFzZV9qc18xLmRlZmF1bHQpKTtcbmV4cG9ydHMud29yZHNXaXRoU3BhY2VEaWZmID0gbmV3IFdvcmRzV2l0aFNwYWNlRGlmZigpO1xuZnVuY3Rpb24gZGlmZldvcmRzV2l0aFNwYWNlKG9sZFN0ciwgbmV3U3RyLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGV4cG9ydHMud29yZHNXaXRoU3BhY2VEaWZmLmRpZmYob2xkU3RyLCBuZXdTdHIsIG9wdGlvbnMpO1xufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZW5lcmF0ZU9wdGlvbnMgPSBnZW5lcmF0ZU9wdGlvbnM7XG5mdW5jdGlvbiBnZW5lcmF0ZU9wdGlvbnMob3B0aW9ucywgZGVmYXVsdHMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZGVmYXVsdHMuY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgIH1cbiAgICBlbHNlIGlmIChvcHRpb25zKSB7XG4gICAgICAgIGZvciAodmFyIG5hbWUgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob3B0aW9ucywgbmFtZSkpIHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0c1tuYW1lXSA9IG9wdGlvbnNbbmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRlZmF1bHRzO1xufVxuIiwgIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMubGluZURpZmYgPSB2b2lkIDA7XG5leHBvcnRzLmRpZmZMaW5lcyA9IGRpZmZMaW5lcztcbmV4cG9ydHMuZGlmZlRyaW1tZWRMaW5lcyA9IGRpZmZUcmltbWVkTGluZXM7XG5leHBvcnRzLnRva2VuaXplID0gdG9rZW5pemU7XG52YXIgYmFzZV9qc18xID0gcmVxdWlyZShcIi4vYmFzZS5qc1wiKTtcbnZhciBwYXJhbXNfanNfMSA9IHJlcXVpcmUoXCIuLi91dGlsL3BhcmFtcy5qc1wiKTtcbnZhciBMaW5lRGlmZiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTGluZURpZmYsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTGluZURpZmYoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50b2tlbml6ZSA9IHRva2VuaXplO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIExpbmVEaWZmLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiAobGVmdCwgcmlnaHQsIG9wdGlvbnMpIHtcbiAgICAgICAgLy8gSWYgd2UncmUgaWdub3Jpbmcgd2hpdGVzcGFjZSwgd2UgbmVlZCB0byBub3JtYWxpc2UgbGluZXMgYnkgc3RyaXBwaW5nXG4gICAgICAgIC8vIHdoaXRlc3BhY2UgYmVmb3JlIGNoZWNraW5nIGVxdWFsaXR5LiAoVGhpcyBoYXMgYW4gYW5ub3lpbmcgaW50ZXJhY3Rpb25cbiAgICAgICAgLy8gd2l0aCBuZXdsaW5lSXNUb2tlbiB0aGF0IHJlcXVpcmVzIHNwZWNpYWwgaGFuZGxpbmc6IGlmIG5ld2xpbmVzIGdldCB0aGVpclxuICAgICAgICAvLyBvd24gdG9rZW4sIHRoZW4gd2UgRE9OJ1Qgd2FudCB0byB0cmltIHRoZSAqbmV3bGluZSogdG9rZW5zIGRvd24gdG8gZW1wdHlcbiAgICAgICAgLy8gc3RyaW5ncywgc2luY2UgdGhpcyB3b3VsZCBjYXVzZSB1cyB0byB0cmVhdCB3aGl0ZXNwYWNlLW9ubHkgbGluZSBjb250ZW50XG4gICAgICAgIC8vIGFzIGVxdWFsIHRvIGEgc2VwYXJhdG9yIGJldHdlZW4gbGluZXMsIHdoaWNoIHdvdWxkIGJlIHdlaXJkIGFuZFxuICAgICAgICAvLyBpbmNvbnNpc3RlbnQgd2l0aCB0aGUgZG9jdW1lbnRlZCBiZWhhdmlvciBvZiB0aGUgb3B0aW9ucy4pXG4gICAgICAgIGlmIChvcHRpb25zLmlnbm9yZVdoaXRlc3BhY2UpIHtcbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5uZXdsaW5lSXNUb2tlbiB8fCAhbGVmdC5pbmNsdWRlcygnXFxuJykpIHtcbiAgICAgICAgICAgICAgICBsZWZ0ID0gbGVmdC50cmltKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMubmV3bGluZUlzVG9rZW4gfHwgIXJpZ2h0LmluY2x1ZGVzKCdcXG4nKSkge1xuICAgICAgICAgICAgICAgIHJpZ2h0ID0gcmlnaHQudHJpbSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9wdGlvbnMuaWdub3JlTmV3bGluZUF0RW9mICYmICFvcHRpb25zLm5ld2xpbmVJc1Rva2VuKSB7XG4gICAgICAgICAgICBpZiAobGVmdC5lbmRzV2l0aCgnXFxuJykpIHtcbiAgICAgICAgICAgICAgICBsZWZ0ID0gbGVmdC5zbGljZSgwLCAtMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmlnaHQuZW5kc1dpdGgoJ1xcbicpKSB7XG4gICAgICAgICAgICAgICAgcmlnaHQgPSByaWdodC5zbGljZSgwLCAtMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUuZXF1YWxzLmNhbGwodGhpcywgbGVmdCwgcmlnaHQsIG9wdGlvbnMpO1xuICAgIH07XG4gICAgcmV0dXJuIExpbmVEaWZmO1xufShiYXNlX2pzXzEuZGVmYXVsdCkpO1xuZXhwb3J0cy5saW5lRGlmZiA9IG5ldyBMaW5lRGlmZigpO1xuZnVuY3Rpb24gZGlmZkxpbmVzKG9sZFN0ciwgbmV3U3RyLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGV4cG9ydHMubGluZURpZmYuZGlmZihvbGRTdHIsIG5ld1N0ciwgb3B0aW9ucyk7XG59XG5mdW5jdGlvbiBkaWZmVHJpbW1lZExpbmVzKG9sZFN0ciwgbmV3U3RyLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9ICgwLCBwYXJhbXNfanNfMS5nZW5lcmF0ZU9wdGlvbnMpKG9wdGlvbnMsIHsgaWdub3JlV2hpdGVzcGFjZTogdHJ1ZSB9KTtcbiAgICByZXR1cm4gZXhwb3J0cy5saW5lRGlmZi5kaWZmKG9sZFN0ciwgbmV3U3RyLCBvcHRpb25zKTtcbn1cbi8vIEV4cG9ydGVkIHN0YW5kYWxvbmUgc28gaXQgY2FuIGJlIHVzZWQgZnJvbSBqc29uRGlmZiB0b28uXG5mdW5jdGlvbiB0b2tlbml6ZSh2YWx1ZSwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zLnN0cmlwVHJhaWxpbmdDcikge1xuICAgICAgICAvLyByZW1vdmUgb25lIFxcciBiZWZvcmUgXFxuIHRvIG1hdGNoIEdOVSBkaWZmJ3MgLS1zdHJpcC10cmFpbGluZy1jciBiZWhhdmlvclxuICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1xcclxcbi9nLCAnXFxuJyk7XG4gICAgfVxuICAgIHZhciByZXRMaW5lcyA9IFtdLCBsaW5lc0FuZE5ld2xpbmVzID0gdmFsdWUuc3BsaXQoLyhcXG58XFxyXFxuKS8pO1xuICAgIC8vIElnbm9yZSB0aGUgZmluYWwgZW1wdHkgdG9rZW4gdGhhdCBvY2N1cnMgaWYgdGhlIHN0cmluZyBlbmRzIHdpdGggYSBuZXcgbGluZVxuICAgIGlmICghbGluZXNBbmROZXdsaW5lc1tsaW5lc0FuZE5ld2xpbmVzLmxlbmd0aCAtIDFdKSB7XG4gICAgICAgIGxpbmVzQW5kTmV3bGluZXMucG9wKCk7XG4gICAgfVxuICAgIC8vIE1lcmdlIHRoZSBjb250ZW50IGFuZCBsaW5lIHNlcGFyYXRvcnMgaW50byBzaW5nbGUgdG9rZW5zXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lc0FuZE5ld2xpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBsaW5lID0gbGluZXNBbmROZXdsaW5lc1tpXTtcbiAgICAgICAgaWYgKGkgJSAyICYmICFvcHRpb25zLm5ld2xpbmVJc1Rva2VuKSB7XG4gICAgICAgICAgICByZXRMaW5lc1tyZXRMaW5lcy5sZW5ndGggLSAxXSArPSBsaW5lO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0TGluZXMucHVzaChsaW5lKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmV0TGluZXM7XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zZW50ZW5jZURpZmYgPSB2b2lkIDA7XG5leHBvcnRzLmRpZmZTZW50ZW5jZXMgPSBkaWZmU2VudGVuY2VzO1xudmFyIGJhc2VfanNfMSA9IHJlcXVpcmUoXCIuL2Jhc2UuanNcIik7XG5mdW5jdGlvbiBpc1NlbnRlbmNlRW5kUHVuY3QoY2hhcikge1xuICAgIHJldHVybiBjaGFyID09ICcuJyB8fCBjaGFyID09ICchJyB8fCBjaGFyID09ICc/Jztcbn1cbnZhciBTZW50ZW5jZURpZmYgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFNlbnRlbmNlRGlmZiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTZW50ZW5jZURpZmYoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgU2VudGVuY2VEaWZmLnByb3RvdHlwZS50b2tlbml6ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIC8vIElmIGluIGZ1dHVyZSB3ZSBkcm9wIHN1cHBvcnQgZm9yIGVudmlyb25tZW50cyB0aGF0IGRvbid0IHN1cHBvcnQgbG9va2JlaGluZHMsIHdlIGNhbiByZXBsYWNlXG4gICAgICAgIC8vIHRoaXMgZW50aXJlIGZ1bmN0aW9uIHdpdGg6XG4gICAgICAgIC8vICAgICByZXR1cm4gdmFsdWUuc3BsaXQoLyg/PD1bLiE/XSkoXFxzK3wkKS8pO1xuICAgICAgICAvLyBidXQgdW50aWwgdGhlbiwgZm9yIHNpbWlsYXIgcmVhc29ucyB0byB0aGUgdHJhaWxpbmdXcyBmdW5jdGlvbiBpbiBzdHJpbmcudHMsIHdlIGFyZSBmb3JjZWRcbiAgICAgICAgLy8gdG8gZG8gdGhpcyB2ZXJib3NlbHkgXCJieSBoYW5kXCIgaW5zdGVhZCBvZiB1c2luZyBhIHJlZ2V4LlxuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgIHZhciB0b2tlblN0YXJ0SSA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChpID09IHZhbHVlLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZS5zbGljZSh0b2tlblN0YXJ0SSkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzU2VudGVuY2VFbmRQdW5jdCh2YWx1ZVtpXSkgJiYgdmFsdWVbaSArIDFdLm1hdGNoKC9cXHMvKSkge1xuICAgICAgICAgICAgICAgIC8vIFdlJ3ZlIGhpdCBhIHNlbnRlbmNlIGJyZWFrIC0gaS5lLiBhIHB1bmN0dWF0aW9uIG1hcmsgZm9sbG93ZWQgYnkgd2hpdGVzcGFjZS5cbiAgICAgICAgICAgICAgICAvLyBXZSBub3cgd2FudCB0byBwdXNoIFRXTyB0b2tlbnMgdG8gdGhlIHJlc3VsdDpcbiAgICAgICAgICAgICAgICAvLyAxLiB0aGUgc2VudGVuY2VcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZS5zbGljZSh0b2tlblN0YXJ0SSwgaSArIDEpKTtcbiAgICAgICAgICAgICAgICAvLyAyLiB0aGUgd2hpdGVzcGFjZVxuICAgICAgICAgICAgICAgIGkgPSB0b2tlblN0YXJ0SSA9IGkgKyAxO1xuICAgICAgICAgICAgICAgIHdoaWxlICgoX2EgPSB2YWx1ZVtpICsgMV0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tYXRjaCgvXFxzLykpIHtcbiAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZS5zbGljZSh0b2tlblN0YXJ0SSwgaSArIDEpKTtcbiAgICAgICAgICAgICAgICAvLyBUaGVuIHRoZSBuZXh0IHRva2VuIChhIHNlbnRlbmNlKSBzdGFydHMgb24gdGhlIGNoYXJhY3RlciBhZnRlciB0aGUgd2hpdGVzcGFjZS5cbiAgICAgICAgICAgICAgICAvLyAoSXQncyBva2F5IGlmIHRoaXMgaXMgb2ZmIHRoZSBlbmQgb2YgdGhlIHN0cmluZyAtIHRoZW4gdGhlIG91dGVyIGxvb3Agd2lsbCB0ZXJtaW5hdGVcbiAgICAgICAgICAgICAgICAvLyBoZXJlIGFueXdheS4pXG4gICAgICAgICAgICAgICAgdG9rZW5TdGFydEkgPSBpICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgcmV0dXJuIFNlbnRlbmNlRGlmZjtcbn0oYmFzZV9qc18xLmRlZmF1bHQpKTtcbmV4cG9ydHMuc2VudGVuY2VEaWZmID0gbmV3IFNlbnRlbmNlRGlmZigpO1xuZnVuY3Rpb24gZGlmZlNlbnRlbmNlcyhvbGRTdHIsIG5ld1N0ciwgb3B0aW9ucykge1xuICAgIHJldHVybiBleHBvcnRzLnNlbnRlbmNlRGlmZi5kaWZmKG9sZFN0ciwgbmV3U3RyLCBvcHRpb25zKTtcbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNzc0RpZmYgPSB2b2lkIDA7XG5leHBvcnRzLmRpZmZDc3MgPSBkaWZmQ3NzO1xudmFyIGJhc2VfanNfMSA9IHJlcXVpcmUoXCIuL2Jhc2UuanNcIik7XG52YXIgQ3NzRGlmZiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ3NzRGlmZiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDc3NEaWZmKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIENzc0RpZmYucHJvdG90eXBlLnRva2VuaXplID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS5zcGxpdCgvKFt7fTo7LF18XFxzKykvKTtcbiAgICB9O1xuICAgIHJldHVybiBDc3NEaWZmO1xufShiYXNlX2pzXzEuZGVmYXVsdCkpO1xuZXhwb3J0cy5jc3NEaWZmID0gbmV3IENzc0RpZmYoKTtcbmZ1bmN0aW9uIGRpZmZDc3Mob2xkU3RyLCBuZXdTdHIsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gZXhwb3J0cy5jc3NEaWZmLmRpZmYob2xkU3RyLCBuZXdTdHIsIG9wdGlvbnMpO1xufVxuIiwgIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuanNvbkRpZmYgPSB2b2lkIDA7XG5leHBvcnRzLmRpZmZKc29uID0gZGlmZkpzb247XG5leHBvcnRzLmNhbm9uaWNhbGl6ZSA9IGNhbm9uaWNhbGl6ZTtcbnZhciBiYXNlX2pzXzEgPSByZXF1aXJlKFwiLi9iYXNlLmpzXCIpO1xudmFyIGxpbmVfanNfMSA9IHJlcXVpcmUoXCIuL2xpbmUuanNcIik7XG52YXIgSnNvbkRpZmYgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEpzb25EaWZmLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEpzb25EaWZmKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudG9rZW5pemUgPSBsaW5lX2pzXzEudG9rZW5pemU7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEpzb25EaWZmLnByb3RvdHlwZSwgXCJ1c2VMb25nZXN0VG9rZW5cIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIERpc2NyaW1pbmF0ZSBiZXR3ZWVuIHR3byBsaW5lcyBvZiBwcmV0dHktcHJpbnRlZCwgc2VyaWFsaXplZCBKU09OIHdoZXJlIG9uZSBvZiB0aGVtIGhhcyBhXG4gICAgICAgICAgICAvLyBkYW5nbGluZyBjb21tYSBhbmQgdGhlIG90aGVyIGRvZXNuJ3QuIFR1cm5zIG91dCBpbmNsdWRpbmcgdGhlIGRhbmdsaW5nIGNvbW1hIHlpZWxkcyB0aGUgbmljZXN0IG91dHB1dDpcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgSnNvbkRpZmYucHJvdG90eXBlLmNhc3RJbnB1dCA9IGZ1bmN0aW9uICh2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgICB2YXIgdW5kZWZpbmVkUmVwbGFjZW1lbnQgPSBvcHRpb25zLnVuZGVmaW5lZFJlcGxhY2VtZW50LCBfYSA9IG9wdGlvbnMuc3RyaW5naWZ5UmVwbGFjZXIsIHN0cmluZ2lmeVJlcGxhY2VyID0gX2EgPT09IHZvaWQgMCA/IGZ1bmN0aW9uIChrLCB2KSB7IHJldHVybiB0eXBlb2YgdiA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWRSZXBsYWNlbWVudCA6IHY7IH0gOiBfYTtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgPyB2YWx1ZSA6IEpTT04uc3RyaW5naWZ5KGNhbm9uaWNhbGl6ZSh2YWx1ZSwgbnVsbCwgbnVsbCwgc3RyaW5naWZ5UmVwbGFjZXIpLCBudWxsLCAnICAnKTtcbiAgICB9O1xuICAgIEpzb25EaWZmLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiAobGVmdCwgcmlnaHQsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUuZXF1YWxzLmNhbGwodGhpcywgbGVmdC5yZXBsYWNlKC8sKFtcXHJcXG5dKS9nLCAnJDEnKSwgcmlnaHQucmVwbGFjZSgvLChbXFxyXFxuXSkvZywgJyQxJyksIG9wdGlvbnMpO1xuICAgIH07XG4gICAgcmV0dXJuIEpzb25EaWZmO1xufShiYXNlX2pzXzEuZGVmYXVsdCkpO1xuZXhwb3J0cy5qc29uRGlmZiA9IG5ldyBKc29uRGlmZigpO1xuZnVuY3Rpb24gZGlmZkpzb24ob2xkU3RyLCBuZXdTdHIsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gZXhwb3J0cy5qc29uRGlmZi5kaWZmKG9sZFN0ciwgbmV3U3RyLCBvcHRpb25zKTtcbn1cbi8vIFRoaXMgZnVuY3Rpb24gaGFuZGxlcyB0aGUgcHJlc2VuY2Ugb2YgY2lyY3VsYXIgcmVmZXJlbmNlcyBieSBiYWlsaW5nIG91dCB3aGVuIGVuY291bnRlcmluZyBhblxuLy8gb2JqZWN0IHRoYXQgaXMgYWxyZWFkeSBvbiB0aGUgXCJzdGFja1wiIG9mIGl0ZW1zIGJlaW5nIHByb2Nlc3NlZC4gQWNjZXB0cyBhbiBvcHRpb25hbCByZXBsYWNlclxuZnVuY3Rpb24gY2Fub25pY2FsaXplKG9iaiwgc3RhY2ssIHJlcGxhY2VtZW50U3RhY2ssIHJlcGxhY2VyLCBrZXkpIHtcbiAgICBzdGFjayA9IHN0YWNrIHx8IFtdO1xuICAgIHJlcGxhY2VtZW50U3RhY2sgPSByZXBsYWNlbWVudFN0YWNrIHx8IFtdO1xuICAgIGlmIChyZXBsYWNlcikge1xuICAgICAgICBvYmogPSByZXBsYWNlcihrZXkgPT09IHVuZGVmaW5lZCA/ICcnIDoga2V5LCBvYmopO1xuICAgIH1cbiAgICB2YXIgaTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgc3RhY2subGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgaWYgKHN0YWNrW2ldID09PSBvYmopIHtcbiAgICAgICAgICAgIHJldHVybiByZXBsYWNlbWVudFN0YWNrW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBjYW5vbmljYWxpemVkT2JqO1xuICAgIGlmICgnW29iamVjdCBBcnJheV0nID09PSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSkge1xuICAgICAgICBzdGFjay5wdXNoKG9iaik7XG4gICAgICAgIGNhbm9uaWNhbGl6ZWRPYmogPSBuZXcgQXJyYXkob2JqLmxlbmd0aCk7XG4gICAgICAgIHJlcGxhY2VtZW50U3RhY2sucHVzaChjYW5vbmljYWxpemVkT2JqKTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG9iai5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgY2Fub25pY2FsaXplZE9ialtpXSA9IGNhbm9uaWNhbGl6ZShvYmpbaV0sIHN0YWNrLCByZXBsYWNlbWVudFN0YWNrLCByZXBsYWNlciwgU3RyaW5nKGkpKTtcbiAgICAgICAgfVxuICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgcmVwbGFjZW1lbnRTdGFjay5wb3AoKTtcbiAgICAgICAgcmV0dXJuIGNhbm9uaWNhbGl6ZWRPYmo7XG4gICAgfVxuICAgIGlmIChvYmogJiYgb2JqLnRvSlNPTikge1xuICAgICAgICBvYmogPSBvYmoudG9KU09OKCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiBvYmogIT09IG51bGwpIHtcbiAgICAgICAgc3RhY2sucHVzaChvYmopO1xuICAgICAgICBjYW5vbmljYWxpemVkT2JqID0ge307XG4gICAgICAgIHJlcGxhY2VtZW50U3RhY2sucHVzaChjYW5vbmljYWxpemVkT2JqKTtcbiAgICAgICAgdmFyIHNvcnRlZEtleXMgPSBbXTtcbiAgICAgICAgdmFyIGtleV8xO1xuICAgICAgICBmb3IgKGtleV8xIGluIG9iaikge1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXlfMSkpIHtcbiAgICAgICAgICAgICAgICBzb3J0ZWRLZXlzLnB1c2goa2V5XzEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNvcnRlZEtleXMuc29ydCgpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc29ydGVkS2V5cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAga2V5XzEgPSBzb3J0ZWRLZXlzW2ldO1xuICAgICAgICAgICAgY2Fub25pY2FsaXplZE9ialtrZXlfMV0gPSBjYW5vbmljYWxpemUob2JqW2tleV8xXSwgc3RhY2ssIHJlcGxhY2VtZW50U3RhY2ssIHJlcGxhY2VyLCBrZXlfMSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgIHJlcGxhY2VtZW50U3RhY2sucG9wKCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjYW5vbmljYWxpemVkT2JqID0gb2JqO1xuICAgIH1cbiAgICByZXR1cm4gY2Fub25pY2FsaXplZE9iajtcbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmFycmF5RGlmZiA9IHZvaWQgMDtcbmV4cG9ydHMuZGlmZkFycmF5cyA9IGRpZmZBcnJheXM7XG52YXIgYmFzZV9qc18xID0gcmVxdWlyZShcIi4vYmFzZS5qc1wiKTtcbnZhciBBcnJheURpZmYgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFycmF5RGlmZiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBcnJheURpZmYoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgQXJyYXlEaWZmLnByb3RvdHlwZS50b2tlbml6ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUuc2xpY2UoKTtcbiAgICB9O1xuICAgIEFycmF5RGlmZi5wcm90b3R5cGUuam9pbiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgICBBcnJheURpZmYucHJvdG90eXBlLnJlbW92ZUVtcHR5ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICAgIHJldHVybiBBcnJheURpZmY7XG59KGJhc2VfanNfMS5kZWZhdWx0KSk7XG5leHBvcnRzLmFycmF5RGlmZiA9IG5ldyBBcnJheURpZmYoKTtcbmZ1bmN0aW9uIGRpZmZBcnJheXMob2xkQXJyLCBuZXdBcnIsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gZXhwb3J0cy5hcnJheURpZmYuZGlmZihvbGRBcnIsIG5ld0Fyciwgb3B0aW9ucyk7XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hc3NpZ24gPSAodGhpcyAmJiB0aGlzLl9fYXNzaWduKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKVxuICAgICAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH07XG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy51bml4VG9XaW4gPSB1bml4VG9XaW47XG5leHBvcnRzLndpblRvVW5peCA9IHdpblRvVW5peDtcbmV4cG9ydHMuaXNVbml4ID0gaXNVbml4O1xuZXhwb3J0cy5pc1dpbiA9IGlzV2luO1xuZnVuY3Rpb24gdW5peFRvV2luKHBhdGNoKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocGF0Y2gpKSB7XG4gICAgICAgIC8vIEl0IHdvdWxkIGJlIGNsZWFuZXIgaWYgaW5zdGVhZCBvZiB0aGUgbGluZSBiZWxvdyB3ZSBjb3VsZCBqdXN0IHdyaXRlXG4gICAgICAgIC8vICAgICByZXR1cm4gcGF0Y2gubWFwKHVuaXhUb1dpbilcbiAgICAgICAgLy8gYnV0IG15c3RlcmlvdXNseSBUeXBlU2NyaXB0ICh2NS43LjMgYXQgdGhlIHRpbWUgb2Ygd3JpdGluZykgZG9lcyBub3QgbGlrZSB0aGlzIGFuZCBpdCB3aWxsXG4gICAgICAgIC8vIHJlZnVzZSB0byBjb21waWxlLCB0aGlua2luZyB0aGF0IHVuaXhUb1dpbiBjb3VsZCB0aGVuIHJldHVybiBTdHJ1Y3R1cmVkUGF0Y2hbXVtdIGFuZCB0aGVcbiAgICAgICAgLy8gcmVzdWx0IHdvdWxkIGJlIGluY29tcGF0aWJsZSB3aXRoIHRoZSBvdmVybG9hZCBzaWduYXR1cmVzLlxuICAgICAgICAvLyBTZWUgYnVnIHJlcG9ydCBhdCBodHRwczovL2dpdGh1Yi5jb20vbWljcm9zb2Z0L1R5cGVTY3JpcHQvaXNzdWVzLzYxMzk4LlxuICAgICAgICByZXR1cm4gcGF0Y2gubWFwKGZ1bmN0aW9uIChwKSB7IHJldHVybiB1bml4VG9XaW4ocCk7IH0pO1xuICAgIH1cbiAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIHBhdGNoKSwgeyBodW5rczogcGF0Y2guaHVua3MubWFwKGZ1bmN0aW9uIChodW5rKSB7IHJldHVybiAoX19hc3NpZ24oX19hc3NpZ24oe30sIGh1bmspLCB7IGxpbmVzOiBodW5rLmxpbmVzLm1hcChmdW5jdGlvbiAobGluZSwgaSkge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKGxpbmUuc3RhcnRzV2l0aCgnXFxcXCcpIHx8IGxpbmUuZW5kc1dpdGgoJ1xccicpIHx8ICgoX2EgPSBodW5rLmxpbmVzW2kgKyAxXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnN0YXJ0c1dpdGgoJ1xcXFwnKSkpXG4gICAgICAgICAgICAgICAgICAgID8gbGluZVxuICAgICAgICAgICAgICAgICAgICA6IGxpbmUgKyAnXFxyJztcbiAgICAgICAgICAgIH0pIH0pKTsgfSkgfSk7XG59XG5mdW5jdGlvbiB3aW5Ub1VuaXgocGF0Y2gpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShwYXRjaCkpIHtcbiAgICAgICAgLy8gKFNlZSBjb21tZW50IGFib3ZlIGVxdWl2YWxlbnQgbGluZSBpbiB1bml4VG9XaW4pXG4gICAgICAgIHJldHVybiBwYXRjaC5tYXAoZnVuY3Rpb24gKHApIHsgcmV0dXJuIHdpblRvVW5peChwKTsgfSk7XG4gICAgfVxuICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgcGF0Y2gpLCB7IGh1bmtzOiBwYXRjaC5odW5rcy5tYXAoZnVuY3Rpb24gKGh1bmspIHsgcmV0dXJuIChfX2Fzc2lnbihfX2Fzc2lnbih7fSwgaHVuayksIHsgbGluZXM6IGh1bmsubGluZXMubWFwKGZ1bmN0aW9uIChsaW5lKSB7IHJldHVybiBsaW5lLmVuZHNXaXRoKCdcXHInKSA/IGxpbmUuc3Vic3RyaW5nKDAsIGxpbmUubGVuZ3RoIC0gMSkgOiBsaW5lOyB9KSB9KSk7IH0pIH0pO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHBhdGNoIGNvbnNpc3RlbnRseSB1c2VzIFVuaXggbGluZSBlbmRpbmdzIChvciBvbmx5IGludm9sdmVzIG9uZSBsaW5lIGFuZCBoYXNcbiAqIG5vIGxpbmUgZW5kaW5ncykuXG4gKi9cbmZ1bmN0aW9uIGlzVW5peChwYXRjaCkge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShwYXRjaCkpIHtcbiAgICAgICAgcGF0Y2ggPSBbcGF0Y2hdO1xuICAgIH1cbiAgICByZXR1cm4gIXBhdGNoLnNvbWUoZnVuY3Rpb24gKGluZGV4KSB7IHJldHVybiBpbmRleC5odW5rcy5zb21lKGZ1bmN0aW9uIChodW5rKSB7IHJldHVybiBodW5rLmxpbmVzLnNvbWUoZnVuY3Rpb24gKGxpbmUpIHsgcmV0dXJuICFsaW5lLnN0YXJ0c1dpdGgoJ1xcXFwnKSAmJiBsaW5lLmVuZHNXaXRoKCdcXHInKTsgfSk7IH0pOyB9KTtcbn1cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBwYXRjaCB1c2VzIFdpbmRvd3MgbGluZSBlbmRpbmdzIGFuZCBvbmx5IFdpbmRvd3MgbGluZSBlbmRpbmdzLlxuICovXG5mdW5jdGlvbiBpc1dpbihwYXRjaCkge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShwYXRjaCkpIHtcbiAgICAgICAgcGF0Y2ggPSBbcGF0Y2hdO1xuICAgIH1cbiAgICByZXR1cm4gcGF0Y2guc29tZShmdW5jdGlvbiAoaW5kZXgpIHsgcmV0dXJuIGluZGV4Lmh1bmtzLnNvbWUoZnVuY3Rpb24gKGh1bmspIHsgcmV0dXJuIGh1bmsubGluZXMuc29tZShmdW5jdGlvbiAobGluZSkgeyByZXR1cm4gbGluZS5lbmRzV2l0aCgnXFxyJyk7IH0pOyB9KTsgfSlcbiAgICAgICAgJiYgcGF0Y2guZXZlcnkoZnVuY3Rpb24gKGluZGV4KSB7IHJldHVybiBpbmRleC5odW5rcy5ldmVyeShmdW5jdGlvbiAoaHVuaykgeyByZXR1cm4gaHVuay5saW5lcy5ldmVyeShmdW5jdGlvbiAobGluZSwgaSkgeyB2YXIgX2E7IHJldHVybiBsaW5lLnN0YXJ0c1dpdGgoJ1xcXFwnKSB8fCBsaW5lLmVuZHNXaXRoKCdcXHInKSB8fCAoKF9hID0gaHVuay5saW5lc1tpICsgMV0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zdGFydHNXaXRoKCdcXFxcJykpOyB9KTsgfSk7IH0pO1xufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5wYXJzZVBhdGNoID0gcGFyc2VQYXRjaDtcbi8qKlxuICogUGFyc2VzIGEgcGF0Y2ggaW50byBzdHJ1Y3R1cmVkIGRhdGEsIGluIHRoZSBzYW1lIHN0cnVjdHVyZSByZXR1cm5lZCBieSBgc3RydWN0dXJlZFBhdGNoYC5cbiAqXG4gKiBAcmV0dXJuIGEgSlNPTiBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgdGhlIGEgcGF0Y2gsIHN1aXRhYmxlIGZvciB1c2Ugd2l0aCB0aGUgYGFwcGx5UGF0Y2hgIG1ldGhvZC5cbiAqL1xuZnVuY3Rpb24gcGFyc2VQYXRjaCh1bmlEaWZmKSB7XG4gICAgdmFyIGRpZmZzdHIgPSB1bmlEaWZmLnNwbGl0KC9cXG4vKSwgbGlzdCA9IFtdO1xuICAgIHZhciBpID0gMDtcbiAgICBmdW5jdGlvbiBwYXJzZUluZGV4KCkge1xuICAgICAgICB2YXIgaW5kZXggPSB7fTtcbiAgICAgICAgbGlzdC5wdXNoKGluZGV4KTtcbiAgICAgICAgLy8gUGFyc2UgZGlmZiBtZXRhZGF0YVxuICAgICAgICB3aGlsZSAoaSA8IGRpZmZzdHIubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgbGluZSA9IGRpZmZzdHJbaV07XG4gICAgICAgICAgICAvLyBGaWxlIGhlYWRlciBmb3VuZCwgZW5kIHBhcnNpbmcgZGlmZiBtZXRhZGF0YVxuICAgICAgICAgICAgaWYgKCgvXigtLS18XFwrXFwrXFwrfEBAKVxccy8pLnRlc3QobGluZSkpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIERpZmYgaW5kZXhcbiAgICAgICAgICAgIHZhciBoZWFkZXIgPSAoL14oPzpJbmRleDp8ZGlmZig/OiAtciBcXHcrKSspXFxzKyguKz8pXFxzKiQvKS5leGVjKGxpbmUpO1xuICAgICAgICAgICAgaWYgKGhlYWRlcikge1xuICAgICAgICAgICAgICAgIGluZGV4LmluZGV4ID0gaGVhZGVyWzFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIC8vIFBhcnNlIGZpbGUgaGVhZGVycyBpZiB0aGV5IGFyZSBkZWZpbmVkLiBVbmlmaWVkIGRpZmYgcmVxdWlyZXMgdGhlbSwgYnV0XG4gICAgICAgIC8vIHRoZXJlJ3Mgbm8gdGVjaG5pY2FsIGlzc3VlcyB0byBoYXZlIGFuIGlzb2xhdGVkIGh1bmsgd2l0aG91dCBmaWxlIGhlYWRlclxuICAgICAgICBwYXJzZUZpbGVIZWFkZXIoaW5kZXgpO1xuICAgICAgICBwYXJzZUZpbGVIZWFkZXIoaW5kZXgpO1xuICAgICAgICAvLyBQYXJzZSBodW5rc1xuICAgICAgICBpbmRleC5odW5rcyA9IFtdO1xuICAgICAgICB3aGlsZSAoaSA8IGRpZmZzdHIubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgbGluZSA9IGRpZmZzdHJbaV07XG4gICAgICAgICAgICBpZiAoKC9eKEluZGV4Olxcc3xkaWZmXFxzfC0tLVxcc3xcXCtcXCtcXCtcXHN8PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSkvKS50ZXN0KGxpbmUpKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgoL15AQC8pLnRlc3QobGluZSkpIHtcbiAgICAgICAgICAgICAgICBpbmRleC5odW5rcy5wdXNoKHBhcnNlSHVuaygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGxpbmUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gbGluZSAnICsgKGkgKyAxKSArICcgJyArIEpTT04uc3RyaW5naWZ5KGxpbmUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBQYXJzZXMgdGhlIC0tLSBhbmQgKysrIGhlYWRlcnMsIGlmIG5vbmUgYXJlIGZvdW5kLCBubyBsaW5lc1xuICAgIC8vIGFyZSBjb25zdW1lZC5cbiAgICBmdW5jdGlvbiBwYXJzZUZpbGVIZWFkZXIoaW5kZXgpIHtcbiAgICAgICAgdmFyIGZpbGVIZWFkZXIgPSAoL14oLS0tfFxcK1xcK1xcKylcXHMrKC4qKVxccj8kLykuZXhlYyhkaWZmc3RyW2ldKTtcbiAgICAgICAgaWYgKGZpbGVIZWFkZXIpIHtcbiAgICAgICAgICAgIHZhciBkYXRhID0gZmlsZUhlYWRlclsyXS5zcGxpdCgnXFx0JywgMiksIGhlYWRlciA9IChkYXRhWzFdIHx8ICcnKS50cmltKCk7XG4gICAgICAgICAgICB2YXIgZmlsZU5hbWUgPSBkYXRhWzBdLnJlcGxhY2UoL1xcXFxcXFxcL2csICdcXFxcJyk7XG4gICAgICAgICAgICBpZiAoKC9eXCIuKlwiJC8pLnRlc3QoZmlsZU5hbWUpKSB7XG4gICAgICAgICAgICAgICAgZmlsZU5hbWUgPSBmaWxlTmFtZS5zdWJzdHIoMSwgZmlsZU5hbWUubGVuZ3RoIC0gMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZmlsZUhlYWRlclsxXSA9PT0gJy0tLScpIHtcbiAgICAgICAgICAgICAgICBpbmRleC5vbGRGaWxlTmFtZSA9IGZpbGVOYW1lO1xuICAgICAgICAgICAgICAgIGluZGV4Lm9sZEhlYWRlciA9IGhlYWRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGluZGV4Lm5ld0ZpbGVOYW1lID0gZmlsZU5hbWU7XG4gICAgICAgICAgICAgICAgaW5kZXgubmV3SGVhZGVyID0gaGVhZGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFBhcnNlcyBhIGh1bmtcbiAgICAvLyBUaGlzIGFzc3VtZXMgdGhhdCB3ZSBhcmUgYXQgdGhlIHN0YXJ0IG9mIGEgaHVuay5cbiAgICBmdW5jdGlvbiBwYXJzZUh1bmsoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdmFyIGNodW5rSGVhZGVySW5kZXggPSBpLCBjaHVua0hlYWRlckxpbmUgPSBkaWZmc3RyW2krK10sIGNodW5rSGVhZGVyID0gY2h1bmtIZWFkZXJMaW5lLnNwbGl0KC9AQCAtKFxcZCspKD86LChcXGQrKSk/IFxcKyhcXGQrKSg/OiwoXFxkKykpPyBAQC8pO1xuICAgICAgICB2YXIgaHVuayA9IHtcbiAgICAgICAgICAgIG9sZFN0YXJ0OiArY2h1bmtIZWFkZXJbMV0sXG4gICAgICAgICAgICBvbGRMaW5lczogdHlwZW9mIGNodW5rSGVhZGVyWzJdID09PSAndW5kZWZpbmVkJyA/IDEgOiArY2h1bmtIZWFkZXJbMl0sXG4gICAgICAgICAgICBuZXdTdGFydDogK2NodW5rSGVhZGVyWzNdLFxuICAgICAgICAgICAgbmV3TGluZXM6IHR5cGVvZiBjaHVua0hlYWRlcls0XSA9PT0gJ3VuZGVmaW5lZCcgPyAxIDogK2NodW5rSGVhZGVyWzRdLFxuICAgICAgICAgICAgbGluZXM6IFtdXG4gICAgICAgIH07XG4gICAgICAgIC8vIFVuaWZpZWQgRGlmZiBGb3JtYXQgcXVpcms6IElmIHRoZSBjaHVuayBzaXplIGlzIDAsXG4gICAgICAgIC8vIHRoZSBmaXJzdCBudW1iZXIgaXMgb25lIGxvd2VyIHRoYW4gb25lIHdvdWxkIGV4cGVjdC5cbiAgICAgICAgLy8gaHR0cHM6Ly93d3cuYXJ0aW1hLmNvbS93ZWJsb2dzL3ZpZXdwb3N0LmpzcD90aHJlYWQ9MTY0MjkzXG4gICAgICAgIGlmIChodW5rLm9sZExpbmVzID09PSAwKSB7XG4gICAgICAgICAgICBodW5rLm9sZFN0YXJ0ICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGh1bmsubmV3TGluZXMgPT09IDApIHtcbiAgICAgICAgICAgIGh1bmsubmV3U3RhcnQgKz0gMTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYWRkQ291bnQgPSAwLCByZW1vdmVDb3VudCA9IDA7XG4gICAgICAgIGZvciAoOyBpIDwgZGlmZnN0ci5sZW5ndGggJiYgKHJlbW92ZUNvdW50IDwgaHVuay5vbGRMaW5lcyB8fCBhZGRDb3VudCA8IGh1bmsubmV3TGluZXMgfHwgKChfYSA9IGRpZmZzdHJbaV0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zdGFydHNXaXRoKCdcXFxcJykpKTsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgb3BlcmF0aW9uID0gKGRpZmZzdHJbaV0ubGVuZ3RoID09IDAgJiYgaSAhPSAoZGlmZnN0ci5sZW5ndGggLSAxKSkgPyAnICcgOiBkaWZmc3RyW2ldWzBdO1xuICAgICAgICAgICAgaWYgKG9wZXJhdGlvbiA9PT0gJysnIHx8IG9wZXJhdGlvbiA9PT0gJy0nIHx8IG9wZXJhdGlvbiA9PT0gJyAnIHx8IG9wZXJhdGlvbiA9PT0gJ1xcXFwnKSB7XG4gICAgICAgICAgICAgICAgaHVuay5saW5lcy5wdXNoKGRpZmZzdHJbaV0pO1xuICAgICAgICAgICAgICAgIGlmIChvcGVyYXRpb24gPT09ICcrJykge1xuICAgICAgICAgICAgICAgICAgICBhZGRDb3VudCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChvcGVyYXRpb24gPT09ICctJykge1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVDb3VudCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChvcGVyYXRpb24gPT09ICcgJykge1xuICAgICAgICAgICAgICAgICAgICBhZGRDb3VudCsrO1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVDb3VudCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkh1bmsgYXQgbGluZSBcIi5jb25jYXQoY2h1bmtIZWFkZXJJbmRleCArIDEsIFwiIGNvbnRhaW5lZCBpbnZhbGlkIGxpbmUgXCIpLmNvbmNhdChkaWZmc3RyW2ldKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSGFuZGxlIHRoZSBlbXB0eSBibG9jayBjb3VudCBjYXNlXG4gICAgICAgIGlmICghYWRkQ291bnQgJiYgaHVuay5uZXdMaW5lcyA9PT0gMSkge1xuICAgICAgICAgICAgaHVuay5uZXdMaW5lcyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFyZW1vdmVDb3VudCAmJiBodW5rLm9sZExpbmVzID09PSAxKSB7XG4gICAgICAgICAgICBodW5rLm9sZExpbmVzID0gMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBQZXJmb3JtIHNhbml0eSBjaGVja2luZ1xuICAgICAgICBpZiAoYWRkQ291bnQgIT09IGh1bmsubmV3TGluZXMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQWRkZWQgbGluZSBjb3VudCBkaWQgbm90IG1hdGNoIGZvciBodW5rIGF0IGxpbmUgJyArIChjaHVua0hlYWRlckluZGV4ICsgMSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZW1vdmVDb3VudCAhPT0gaHVuay5vbGRMaW5lcykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZW1vdmVkIGxpbmUgY291bnQgZGlkIG5vdCBtYXRjaCBmb3IgaHVuayBhdCBsaW5lICcgKyAoY2h1bmtIZWFkZXJJbmRleCArIDEpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaHVuaztcbiAgICB9XG4gICAgd2hpbGUgKGkgPCBkaWZmc3RyLmxlbmd0aCkge1xuICAgICAgICBwYXJzZUluZGV4KCk7XG4gICAgfVxuICAgIHJldHVybiBsaXN0O1xufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmYXVsdF8xO1xuLy8gSXRlcmF0b3IgdGhhdCB0cmF2ZXJzZXMgaW4gdGhlIHJhbmdlIG9mIFttaW4sIG1heF0sIHN0ZXBwaW5nXG4vLyBieSBkaXN0YW5jZSBmcm9tIGEgZ2l2ZW4gc3RhcnQgcG9zaXRpb24uIEkuZS4gZm9yIFswLCA0XSwgd2l0aFxuLy8gc3RhcnQgb2YgMiwgdGhpcyB3aWxsIGl0ZXJhdGUgMiwgMywgMSwgNCwgMC5cbmZ1bmN0aW9uIGRlZmF1bHRfMShzdGFydCwgbWluTGluZSwgbWF4TGluZSkge1xuICAgIHZhciB3YW50Rm9yd2FyZCA9IHRydWUsIGJhY2t3YXJkRXhoYXVzdGVkID0gZmFsc2UsIGZvcndhcmRFeGhhdXN0ZWQgPSBmYWxzZSwgbG9jYWxPZmZzZXQgPSAxO1xuICAgIHJldHVybiBmdW5jdGlvbiBpdGVyYXRvcigpIHtcbiAgICAgICAgaWYgKHdhbnRGb3J3YXJkICYmICFmb3J3YXJkRXhoYXVzdGVkKSB7XG4gICAgICAgICAgICBpZiAoYmFja3dhcmRFeGhhdXN0ZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbE9mZnNldCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgd2FudEZvcndhcmQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHRyeWluZyB0byBmaXQgYmV5b25kIHRleHQgbGVuZ3RoLCBhbmQgaWYgbm90LCBjaGVjayBpdCBmaXRzXG4gICAgICAgICAgICAvLyBhZnRlciBvZmZzZXQgbG9jYXRpb24gKG9yIGRlc2lyZWQgbG9jYXRpb24gb24gZmlyc3QgaXRlcmF0aW9uKVxuICAgICAgICAgICAgaWYgKHN0YXJ0ICsgbG9jYWxPZmZzZXQgPD0gbWF4TGluZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdGFydCArIGxvY2FsT2Zmc2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yd2FyZEV4aGF1c3RlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFiYWNrd2FyZEV4aGF1c3RlZCkge1xuICAgICAgICAgICAgaWYgKCFmb3J3YXJkRXhoYXVzdGVkKSB7XG4gICAgICAgICAgICAgICAgd2FudEZvcndhcmQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdHJ5aW5nIHRvIGZpdCBiZWZvcmUgdGV4dCBiZWdpbm5pbmcsIGFuZCBpZiBub3QsIGNoZWNrIGl0IGZpdHNcbiAgICAgICAgICAgIC8vIGJlZm9yZSBvZmZzZXQgbG9jYXRpb25cbiAgICAgICAgICAgIGlmIChtaW5MaW5lIDw9IHN0YXJ0IC0gbG9jYWxPZmZzZXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhcnQgLSBsb2NhbE9mZnNldCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYmFja3dhcmRFeGhhdXN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIGl0ZXJhdG9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2UgdHJpZWQgdG8gZml0IGh1bmsgYmVmb3JlIHRleHQgYmVnaW5uaW5nIGFuZCBiZXlvbmQgdGV4dCBsZW5ndGgsIHRoZW5cbiAgICAgICAgLy8gaHVuayBjYW4ndCBmaXQgb24gdGhlIHRleHQuIFJldHVybiB1bmRlZmluZWRcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9O1xufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5hcHBseVBhdGNoID0gYXBwbHlQYXRjaDtcbmV4cG9ydHMuYXBwbHlQYXRjaGVzID0gYXBwbHlQYXRjaGVzO1xudmFyIHN0cmluZ19qc18xID0gcmVxdWlyZShcIi4uL3V0aWwvc3RyaW5nLmpzXCIpO1xudmFyIGxpbmVfZW5kaW5nc19qc18xID0gcmVxdWlyZShcIi4vbGluZS1lbmRpbmdzLmpzXCIpO1xudmFyIHBhcnNlX2pzXzEgPSByZXF1aXJlKFwiLi9wYXJzZS5qc1wiKTtcbnZhciBkaXN0YW5jZV9pdGVyYXRvcl9qc18xID0gcmVxdWlyZShcIi4uL3V0aWwvZGlzdGFuY2UtaXRlcmF0b3IuanNcIik7XG4vKipcbiAqIGF0dGVtcHRzIHRvIGFwcGx5IGEgdW5pZmllZCBkaWZmIHBhdGNoLlxuICpcbiAqIEh1bmtzIGFyZSBhcHBsaWVkIGZpcnN0IHRvIGxhc3QuXG4gKiBgYXBwbHlQYXRjaGAgZmlyc3QgdHJpZXMgdG8gYXBwbHkgdGhlIGZpcnN0IGh1bmsgYXQgdGhlIGxpbmUgbnVtYmVyIHNwZWNpZmllZCBpbiB0aGUgaHVuayBoZWFkZXIsIGFuZCB3aXRoIGFsbCBjb250ZXh0IGxpbmVzIG1hdGNoaW5nIGV4YWN0bHkuXG4gKiBJZiB0aGF0IGZhaWxzLCBpdCB0cmllcyBzY2FubmluZyBiYWNrd2FyZHMgYW5kIGZvcndhcmRzLCBvbmUgbGluZSBhdCBhIHRpbWUsIHRvIGZpbmQgYSBwbGFjZSB0byBhcHBseSB0aGUgaHVuayB3aGVyZSB0aGUgY29udGV4dCBsaW5lcyBtYXRjaCBleGFjdGx5LlxuICogSWYgdGhhdCBzdGlsbCBmYWlscywgYW5kIGBmdXp6RmFjdG9yYCBpcyBncmVhdGVyIHRoYW4gemVybywgaXQgaW5jcmVtZW50cyB0aGUgbWF4aW11bSBudW1iZXIgb2YgbWlzbWF0Y2hlcyAobWlzc2luZywgZXh0cmEsIG9yIGNoYW5nZWQgY29udGV4dCBsaW5lcykgdGhhdCB0aGVyZSBjYW4gYmUgYmV0d2VlbiB0aGUgaHVuayBjb250ZXh0IGFuZCBhIHJlZ2lvbiB3aGVyZSB3ZSBhcmUgdHJ5aW5nIHRvIGFwcGx5IHRoZSBwYXRjaCBzdWNoIHRoYXQgdGhlIGh1bmsgd2lsbCBzdGlsbCBiZSBjb25zaWRlcmVkIHRvIG1hdGNoLlxuICogUmVnYXJkbGVzcyBvZiBgZnV6ekZhY3RvcmAsIGxpbmVzIHRvIGJlIGRlbGV0ZWQgaW4gdGhlIGh1bmsgKm11c3QqIGJlIHByZXNlbnQgZm9yIGEgaHVuayB0byBtYXRjaCwgYW5kIHRoZSBjb250ZXh0IGxpbmVzICppbW1lZGlhdGVseSogYmVmb3JlIGFuZCBhZnRlciBhbiBpbnNlcnRpb24gbXVzdCBtYXRjaCBleGFjdGx5LlxuICpcbiAqIE9uY2UgYSBodW5rIGlzIHN1Y2Nlc3NmdWxseSBmaXR0ZWQsIHRoZSBwcm9jZXNzIGJlZ2lucyBhZ2FpbiB3aXRoIHRoZSBuZXh0IGh1bmsuXG4gKiBSZWdhcmRsZXNzIG9mIGBmdXp6RmFjdG9yYCwgbGF0ZXIgaHVua3MgbXVzdCBiZSBhcHBsaWVkIGxhdGVyIGluIHRoZSBmaWxlIHRoYW4gZWFybGllciBodW5rcy5cbiAqXG4gKiBJZiBhIGh1bmsgY2Fubm90IGJlIHN1Y2Nlc3NmdWxseSBmaXR0ZWQgKmFueXdoZXJlKiB3aXRoIGZld2VyIHRoYW4gYGZ1enpGYWN0b3JgIG1pc21hdGNoZXMsIGBhcHBseVBhdGNoYCBmYWlscyBhbmQgcmV0dXJucyBgZmFsc2VgLlxuICpcbiAqIElmIGEgaHVuayBpcyBzdWNjZXNzZnVsbHkgZml0dGVkIGJ1dCBub3QgYXQgdGhlIGxpbmUgbnVtYmVyIHNwZWNpZmllZCBieSB0aGUgaHVuayBoZWFkZXIsIGFsbCBzdWJzZXF1ZW50IGh1bmtzIGhhdmUgdGhlaXIgdGFyZ2V0IGxpbmUgbnVtYmVyIGFkanVzdGVkIGFjY29yZGluZ2x5LlxuICogKGUuZy4gaWYgdGhlIGZpcnN0IGh1bmsgaXMgYXBwbGllZCAxMCBsaW5lcyBiZWxvdyB3aGVyZSB0aGUgaHVuayBoZWFkZXIgc2FpZCBpdCBzaG91bGQgZml0LCBgYXBwbHlQYXRjaGAgd2lsbCAqc3RhcnQqIGxvb2tpbmcgZm9yIHNvbWV3aGVyZSB0byBhcHBseSB0aGUgc2Vjb25kIGh1bmsgMTAgbGluZXMgYmVsb3cgd2hlcmUgaXRzIGh1bmsgaGVhZGVyIHNheXMgaXQgZ29lcy4pXG4gKlxuICogSWYgdGhlIHBhdGNoIHdhcyBhcHBsaWVkIHN1Y2Nlc3NmdWxseSwgcmV0dXJucyBhIHN0cmluZyBjb250YWluaW5nIHRoZSBwYXRjaGVkIHRleHQuXG4gKiBJZiB0aGUgcGF0Y2ggY291bGQgbm90IGJlIGFwcGxpZWQgKGJlY2F1c2Ugc29tZSBodW5rcyBpbiB0aGUgcGF0Y2ggY291bGRuJ3QgYmUgZml0dGVkIHRvIHRoZSB0ZXh0IGluIGBzb3VyY2VgKSwgYGFwcGx5UGF0Y2hgIHJldHVybnMgZmFsc2UuXG4gKlxuICogQHBhcmFtIHBhdGNoIGEgc3RyaW5nIGRpZmYgb3IgdGhlIG91dHB1dCBmcm9tIHRoZSBgcGFyc2VQYXRjaGAgb3IgYHN0cnVjdHVyZWRQYXRjaGAgbWV0aG9kcy5cbiAqL1xuZnVuY3Rpb24gYXBwbHlQYXRjaChzb3VyY2UsIHBhdGNoLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICB2YXIgcGF0Y2hlcztcbiAgICBpZiAodHlwZW9mIHBhdGNoID09PSAnc3RyaW5nJykge1xuICAgICAgICBwYXRjaGVzID0gKDAsIHBhcnNlX2pzXzEucGFyc2VQYXRjaCkocGF0Y2gpO1xuICAgIH1cbiAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHBhdGNoKSkge1xuICAgICAgICBwYXRjaGVzID0gcGF0Y2g7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBwYXRjaGVzID0gW3BhdGNoXTtcbiAgICB9XG4gICAgaWYgKHBhdGNoZXMubGVuZ3RoID4gMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FwcGx5UGF0Y2ggb25seSB3b3JrcyB3aXRoIGEgc2luZ2xlIGlucHV0LicpO1xuICAgIH1cbiAgICByZXR1cm4gYXBwbHlTdHJ1Y3R1cmVkUGF0Y2goc291cmNlLCBwYXRjaGVzWzBdLCBvcHRpb25zKTtcbn1cbmZ1bmN0aW9uIGFwcGx5U3RydWN0dXJlZFBhdGNoKHNvdXJjZSwgcGF0Y2gsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgIGlmIChvcHRpb25zLmF1dG9Db252ZXJ0TGluZUVuZGluZ3MgfHwgb3B0aW9ucy5hdXRvQ29udmVydExpbmVFbmRpbmdzID09IG51bGwpIHtcbiAgICAgICAgaWYgKCgwLCBzdHJpbmdfanNfMS5oYXNPbmx5V2luTGluZUVuZGluZ3MpKHNvdXJjZSkgJiYgKDAsIGxpbmVfZW5kaW5nc19qc18xLmlzVW5peCkocGF0Y2gpKSB7XG4gICAgICAgICAgICBwYXRjaCA9ICgwLCBsaW5lX2VuZGluZ3NfanNfMS51bml4VG9XaW4pKHBhdGNoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoMCwgc3RyaW5nX2pzXzEuaGFzT25seVVuaXhMaW5lRW5kaW5ncykoc291cmNlKSAmJiAoMCwgbGluZV9lbmRpbmdzX2pzXzEuaXNXaW4pKHBhdGNoKSkge1xuICAgICAgICAgICAgcGF0Y2ggPSAoMCwgbGluZV9lbmRpbmdzX2pzXzEud2luVG9Vbml4KShwYXRjaCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQXBwbHkgdGhlIGRpZmYgdG8gdGhlIGlucHV0XG4gICAgdmFyIGxpbmVzID0gc291cmNlLnNwbGl0KCdcXG4nKSwgaHVua3MgPSBwYXRjaC5odW5rcywgY29tcGFyZUxpbmUgPSBvcHRpb25zLmNvbXBhcmVMaW5lIHx8IChmdW5jdGlvbiAobGluZU51bWJlciwgbGluZSwgb3BlcmF0aW9uLCBwYXRjaENvbnRlbnQpIHsgcmV0dXJuIGxpbmUgPT09IHBhdGNoQ29udGVudDsgfSksIGZ1enpGYWN0b3IgPSBvcHRpb25zLmZ1enpGYWN0b3IgfHwgMDtcbiAgICB2YXIgbWluTGluZSA9IDA7XG4gICAgaWYgKGZ1enpGYWN0b3IgPCAwIHx8ICFOdW1iZXIuaXNJbnRlZ2VyKGZ1enpGYWN0b3IpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZnV6ekZhY3RvciBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIGludGVnZXInKTtcbiAgICB9XG4gICAgLy8gU3BlY2lhbCBjYXNlIGZvciBlbXB0eSBwYXRjaC5cbiAgICBpZiAoIWh1bmtzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gc291cmNlO1xuICAgIH1cbiAgICAvLyBCZWZvcmUgYW55dGhpbmcgZWxzZSwgaGFuZGxlIEVPRk5MIGluc2VydGlvbi9yZW1vdmFsLiBJZiB0aGUgcGF0Y2ggdGVsbHMgdXMgdG8gbWFrZSBhIGNoYW5nZVxuICAgIC8vIHRvIHRoZSBFT0ZOTCB0aGF0IGlzIHJlZHVuZGFudC9pbXBvc3NpYmxlIC0gaS5lLiB0byByZW1vdmUgYSBuZXdsaW5lIHRoYXQncyBub3QgdGhlcmUsIG9yIGFkZCBhXG4gICAgLy8gbmV3bGluZSB0aGF0IGFscmVhZHkgZXhpc3RzIC0gdGhlbiB3ZSBlaXRoZXIgcmV0dXJuIGZhbHNlIGFuZCBmYWlsIHRvIGFwcGx5IHRoZSBwYXRjaCAoaWZcbiAgICAvLyBmdXp6RmFjdG9yIGlzIDApIG9yIHNpbXBseSBpZ25vcmUgdGhlIHByb2JsZW0gYW5kIGRvIG5vdGhpbmcgKGlmIGZ1enpGYWN0b3IgaXMgPjApLlxuICAgIC8vIElmIHdlIGRvIG5lZWQgdG8gcmVtb3ZlL2FkZCBhIG5ld2xpbmUgYXQgRU9GLCB0aGlzIHdpbGwgYWx3YXlzIGJlIGluIHRoZSBmaW5hbCBodW5rOlxuICAgIHZhciBwcmV2TGluZSA9ICcnLCByZW1vdmVFT0ZOTCA9IGZhbHNlLCBhZGRFT0ZOTCA9IGZhbHNlO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaHVua3NbaHVua3MubGVuZ3RoIC0gMV0ubGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGxpbmUgPSBodW5rc1todW5rcy5sZW5ndGggLSAxXS5saW5lc1tpXTtcbiAgICAgICAgaWYgKGxpbmVbMF0gPT0gJ1xcXFwnKSB7XG4gICAgICAgICAgICBpZiAocHJldkxpbmVbMF0gPT0gJysnKSB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlRU9GTkwgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocHJldkxpbmVbMF0gPT0gJy0nKSB7XG4gICAgICAgICAgICAgICAgYWRkRU9GTkwgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHByZXZMaW5lID0gbGluZTtcbiAgICB9XG4gICAgaWYgKHJlbW92ZUVPRk5MKSB7XG4gICAgICAgIGlmIChhZGRFT0ZOTCkge1xuICAgICAgICAgICAgLy8gVGhpcyBtZWFucyB0aGUgZmluYWwgbGluZSBnZXRzIGNoYW5nZWQgYnV0IGRvZXNuJ3QgaGF2ZSBhIHRyYWlsaW5nIG5ld2xpbmUgaW4gZWl0aGVyIHRoZVxuICAgICAgICAgICAgLy8gb3JpZ2luYWwgb3IgcGF0Y2hlZCB2ZXJzaW9uLiBJbiB0aGF0IGNhc2UsIHdlIGRvIG5vdGhpbmcgaWYgZnV6ekZhY3RvciA+IDAsIGFuZCBpZlxuICAgICAgICAgICAgLy8gZnV6ekZhY3RvciBpcyAwLCB3ZSBzaW1wbHkgdmFsaWRhdGUgdGhhdCB0aGUgc291cmNlIGZpbGUgaGFzIG5vIHRyYWlsaW5nIG5ld2xpbmUuXG4gICAgICAgICAgICBpZiAoIWZ1enpGYWN0b3IgJiYgbGluZXNbbGluZXMubGVuZ3RoIC0gMV0gPT0gJycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobGluZXNbbGluZXMubGVuZ3RoIC0gMV0gPT0gJycpIHtcbiAgICAgICAgICAgIGxpbmVzLnBvcCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFmdXp6RmFjdG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoYWRkRU9GTkwpIHtcbiAgICAgICAgaWYgKGxpbmVzW2xpbmVzLmxlbmd0aCAtIDFdICE9ICcnKSB7XG4gICAgICAgICAgICBsaW5lcy5wdXNoKCcnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghZnV6ekZhY3Rvcikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGUgaHVuayBjYW4gYmUgbWFkZSB0byBmaXQgYXQgdGhlIHByb3ZpZGVkIGxvY2F0aW9uIHdpdGggYXQgbW9zdCBgbWF4RXJyb3JzYFxuICAgICAqIGluc2VydGlvbnMsIHN1YnN0aXR1dGlvbnMsIG9yIGRlbGV0aW9ucywgd2hpbGUgZW5zdXJpbmcgYWxzbyB0aGF0OlxuICAgICAqIC0gbGluZXMgZGVsZXRlZCBpbiB0aGUgaHVuayBtYXRjaCBleGFjdGx5LCBhbmRcbiAgICAgKiAtIHdoZXJldmVyIGFuIGluc2VydGlvbiBvcGVyYXRpb24gb3IgYmxvY2sgb2YgaW5zZXJ0aW9uIG9wZXJhdGlvbnMgYXBwZWFycyBpbiB0aGUgaHVuaywgdGhlXG4gICAgICogICBpbW1lZGlhdGVseSBwcmVjZWRpbmcgYW5kIGZvbGxvd2luZyBsaW5lcyBvZiBjb250ZXh0IG1hdGNoIGV4YWN0bHlcbiAgICAgKlxuICAgICAqIGB0b1Bvc2Agc2hvdWxkIGJlIHNldCBzdWNoIHRoYXQgbGluZXNbdG9Qb3NdIGlzIG1lYW50IHRvIG1hdGNoIGh1bmtMaW5lc1swXS5cbiAgICAgKlxuICAgICAqIElmIHRoZSBodW5rIGNhbiBiZSBhcHBsaWVkLCByZXR1cm5zIGFuIG9iamVjdCB3aXRoIHByb3BlcnRpZXMgYG9sZExpbmVMYXN0SWAgYW5kXG4gICAgICogYHJlcGxhY2VtZW50TGluZXNgLiBPdGhlcndpc2UsIHJldHVybnMgbnVsbC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhcHBseUh1bmsoaHVua0xpbmVzLCB0b1BvcywgbWF4RXJyb3JzLCBodW5rTGluZXNJLCBsYXN0Q29udGV4dExpbmVNYXRjaGVkLCBwYXRjaGVkTGluZXMsIHBhdGNoZWRMaW5lc0xlbmd0aCkge1xuICAgICAgICBpZiAoaHVua0xpbmVzSSA9PT0gdm9pZCAwKSB7IGh1bmtMaW5lc0kgPSAwOyB9XG4gICAgICAgIGlmIChsYXN0Q29udGV4dExpbmVNYXRjaGVkID09PSB2b2lkIDApIHsgbGFzdENvbnRleHRMaW5lTWF0Y2hlZCA9IHRydWU7IH1cbiAgICAgICAgaWYgKHBhdGNoZWRMaW5lcyA9PT0gdm9pZCAwKSB7IHBhdGNoZWRMaW5lcyA9IFtdOyB9XG4gICAgICAgIGlmIChwYXRjaGVkTGluZXNMZW5ndGggPT09IHZvaWQgMCkgeyBwYXRjaGVkTGluZXNMZW5ndGggPSAwOyB9XG4gICAgICAgIHZhciBuQ29uc2VjdXRpdmVPbGRDb250ZXh0TGluZXMgPSAwO1xuICAgICAgICB2YXIgbmV4dENvbnRleHRMaW5lTXVzdE1hdGNoID0gZmFsc2U7XG4gICAgICAgIGZvciAoOyBodW5rTGluZXNJIDwgaHVua0xpbmVzLmxlbmd0aDsgaHVua0xpbmVzSSsrKSB7XG4gICAgICAgICAgICB2YXIgaHVua0xpbmUgPSBodW5rTGluZXNbaHVua0xpbmVzSV0sIG9wZXJhdGlvbiA9IChodW5rTGluZS5sZW5ndGggPiAwID8gaHVua0xpbmVbMF0gOiAnICcpLCBjb250ZW50ID0gKGh1bmtMaW5lLmxlbmd0aCA+IDAgPyBodW5rTGluZS5zdWJzdHIoMSkgOiBodW5rTGluZSk7XG4gICAgICAgICAgICBpZiAob3BlcmF0aW9uID09PSAnLScpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29tcGFyZUxpbmUodG9Qb3MgKyAxLCBsaW5lc1t0b1Bvc10sIG9wZXJhdGlvbiwgY29udGVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9Qb3MrKztcbiAgICAgICAgICAgICAgICAgICAgbkNvbnNlY3V0aXZlT2xkQ29udGV4dExpbmVzID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbWF4RXJyb3JzIHx8IGxpbmVzW3RvUG9zXSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwYXRjaGVkTGluZXNbcGF0Y2hlZExpbmVzTGVuZ3RoXSA9IGxpbmVzW3RvUG9zXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFwcGx5SHVuayhodW5rTGluZXMsIHRvUG9zICsgMSwgbWF4RXJyb3JzIC0gMSwgaHVua0xpbmVzSSwgZmFsc2UsIHBhdGNoZWRMaW5lcywgcGF0Y2hlZExpbmVzTGVuZ3RoICsgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wZXJhdGlvbiA9PT0gJysnKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFsYXN0Q29udGV4dExpbmVNYXRjaGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYXRjaGVkTGluZXNbcGF0Y2hlZExpbmVzTGVuZ3RoXSA9IGNvbnRlbnQ7XG4gICAgICAgICAgICAgICAgcGF0Y2hlZExpbmVzTGVuZ3RoKys7XG4gICAgICAgICAgICAgICAgbkNvbnNlY3V0aXZlT2xkQ29udGV4dExpbmVzID0gMDtcbiAgICAgICAgICAgICAgICBuZXh0Q29udGV4dExpbmVNdXN0TWF0Y2ggPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wZXJhdGlvbiA9PT0gJyAnKSB7XG4gICAgICAgICAgICAgICAgbkNvbnNlY3V0aXZlT2xkQ29udGV4dExpbmVzKys7XG4gICAgICAgICAgICAgICAgcGF0Y2hlZExpbmVzW3BhdGNoZWRMaW5lc0xlbmd0aF0gPSBsaW5lc1t0b1Bvc107XG4gICAgICAgICAgICAgICAgaWYgKGNvbXBhcmVMaW5lKHRvUG9zICsgMSwgbGluZXNbdG9Qb3NdLCBvcGVyYXRpb24sIGNvbnRlbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhdGNoZWRMaW5lc0xlbmd0aCsrO1xuICAgICAgICAgICAgICAgICAgICBsYXN0Q29udGV4dExpbmVNYXRjaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgbmV4dENvbnRleHRMaW5lTXVzdE1hdGNoID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHRvUG9zKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dENvbnRleHRMaW5lTXVzdE1hdGNoIHx8ICFtYXhFcnJvcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIENvbnNpZGVyIDMgcG9zc2liaWxpdGllcyBpbiBzZXF1ZW5jZTpcbiAgICAgICAgICAgICAgICAgICAgLy8gMS4gbGluZXMgY29udGFpbnMgYSAqc3Vic3RpdHV0aW9uKiBub3QgaW5jbHVkZWQgaW4gdGhlIHBhdGNoIGNvbnRleHQsIG9yXG4gICAgICAgICAgICAgICAgICAgIC8vIDIuIGxpbmVzIGNvbnRhaW5zIGFuICppbnNlcnRpb24qIG5vdCBpbmNsdWRlZCBpbiB0aGUgcGF0Y2ggY29udGV4dCwgb3JcbiAgICAgICAgICAgICAgICAgICAgLy8gMy4gbGluZXMgY29udGFpbnMgYSAqZGVsZXRpb24qIG5vdCBpbmNsdWRlZCBpbiB0aGUgcGF0Y2ggY29udGV4dFxuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgZmlyc3QgdHdvIG9wdGlvbnMgYXJlIG9mIGNvdXJzZSBvbmx5IHBvc3NpYmxlIGlmIHRoZSBsaW5lIGZyb20gbGluZXMgaXMgbm9uLW51bGwgLVxuICAgICAgICAgICAgICAgICAgICAvLyBpLmUuIG9ubHkgb3B0aW9uIDMgaXMgcG9zc2libGUgaWYgd2UndmUgb3ZlcnJ1biB0aGUgZW5kIG9mIHRoZSBvbGQgZmlsZS5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChsaW5lc1t0b1Bvc10gJiYgKGFwcGx5SHVuayhodW5rTGluZXMsIHRvUG9zICsgMSwgbWF4RXJyb3JzIC0gMSwgaHVua0xpbmVzSSArIDEsIGZhbHNlLCBwYXRjaGVkTGluZXMsIHBhdGNoZWRMaW5lc0xlbmd0aCArIDEpIHx8IGFwcGx5SHVuayhodW5rTGluZXMsIHRvUG9zICsgMSwgbWF4RXJyb3JzIC0gMSwgaHVua0xpbmVzSSwgZmFsc2UsIHBhdGNoZWRMaW5lcywgcGF0Y2hlZExpbmVzTGVuZ3RoICsgMSkpIHx8IGFwcGx5SHVuayhodW5rTGluZXMsIHRvUG9zLCBtYXhFcnJvcnMgLSAxLCBodW5rTGluZXNJICsgMSwgZmFsc2UsIHBhdGNoZWRMaW5lcywgcGF0Y2hlZExpbmVzTGVuZ3RoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEJlZm9yZSByZXR1cm5pbmcsIHRyaW0gYW55IHVubW9kaWZpZWQgY29udGV4dCBsaW5lcyBvZmYgdGhlIGVuZCBvZiBwYXRjaGVkTGluZXMgYW5kIHJlZHVjZVxuICAgICAgICAvLyB0b1BvcyAoYW5kIHRodXMgb2xkTGluZUxhc3RJKSBhY2NvcmRpbmdseS4gVGhpcyBhbGxvd3MgbGF0ZXIgaHVua3MgdG8gYmUgYXBwbGllZCB0byBhIHJlZ2lvblxuICAgICAgICAvLyB0aGF0IHN0YXJ0cyBpbiB0aGlzIGh1bmsncyB0cmFpbGluZyBjb250ZXh0LlxuICAgICAgICBwYXRjaGVkTGluZXNMZW5ndGggLT0gbkNvbnNlY3V0aXZlT2xkQ29udGV4dExpbmVzO1xuICAgICAgICB0b1BvcyAtPSBuQ29uc2VjdXRpdmVPbGRDb250ZXh0TGluZXM7XG4gICAgICAgIHBhdGNoZWRMaW5lcy5sZW5ndGggPSBwYXRjaGVkTGluZXNMZW5ndGg7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwYXRjaGVkTGluZXM6IHBhdGNoZWRMaW5lcyxcbiAgICAgICAgICAgIG9sZExpbmVMYXN0STogdG9Qb3MgLSAxXG4gICAgICAgIH07XG4gICAgfVxuICAgIHZhciByZXN1bHRMaW5lcyA9IFtdO1xuICAgIC8vIFNlYXJjaCBiZXN0IGZpdCBvZmZzZXRzIGZvciBlYWNoIGh1bmsgYmFzZWQgb24gdGhlIHByZXZpb3VzIG9uZXNcbiAgICB2YXIgcHJldkh1bmtPZmZzZXQgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaHVua3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGh1bmsgPSBodW5rc1tpXTtcbiAgICAgICAgdmFyIGh1bmtSZXN1bHQgPSB2b2lkIDA7XG4gICAgICAgIHZhciBtYXhMaW5lID0gbGluZXMubGVuZ3RoIC0gaHVuay5vbGRMaW5lcyArIGZ1enpGYWN0b3I7XG4gICAgICAgIHZhciB0b1BvcyA9IHZvaWQgMDtcbiAgICAgICAgZm9yICh2YXIgbWF4RXJyb3JzID0gMDsgbWF4RXJyb3JzIDw9IGZ1enpGYWN0b3I7IG1heEVycm9ycysrKSB7XG4gICAgICAgICAgICB0b1BvcyA9IGh1bmsub2xkU3RhcnQgKyBwcmV2SHVua09mZnNldCAtIDE7XG4gICAgICAgICAgICB2YXIgaXRlcmF0b3IgPSAoMCwgZGlzdGFuY2VfaXRlcmF0b3JfanNfMS5kZWZhdWx0KSh0b1BvcywgbWluTGluZSwgbWF4TGluZSk7XG4gICAgICAgICAgICBmb3IgKDsgdG9Qb3MgIT09IHVuZGVmaW5lZDsgdG9Qb3MgPSBpdGVyYXRvcigpKSB7XG4gICAgICAgICAgICAgICAgaHVua1Jlc3VsdCA9IGFwcGx5SHVuayhodW5rLmxpbmVzLCB0b1BvcywgbWF4RXJyb3JzKTtcbiAgICAgICAgICAgICAgICBpZiAoaHVua1Jlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaHVua1Jlc3VsdCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghaHVua1Jlc3VsdCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvcHkgZXZlcnl0aGluZyBmcm9tIHRoZSBlbmQgb2Ygd2hlcmUgd2UgYXBwbGllZCB0aGUgbGFzdCBodW5rIHRvIHRoZSBzdGFydCBvZiB0aGlzIGh1bmtcbiAgICAgICAgZm9yICh2YXIgaV8xID0gbWluTGluZTsgaV8xIDwgdG9Qb3M7IGlfMSsrKSB7XG4gICAgICAgICAgICByZXN1bHRMaW5lcy5wdXNoKGxpbmVzW2lfMV0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFkZCB0aGUgbGluZXMgcHJvZHVjZWQgYnkgYXBwbHlpbmcgdGhlIGh1bms6XG4gICAgICAgIGZvciAodmFyIGlfMiA9IDA7IGlfMiA8IGh1bmtSZXN1bHQucGF0Y2hlZExpbmVzLmxlbmd0aDsgaV8yKyspIHtcbiAgICAgICAgICAgIHZhciBsaW5lID0gaHVua1Jlc3VsdC5wYXRjaGVkTGluZXNbaV8yXTtcbiAgICAgICAgICAgIHJlc3VsdExpbmVzLnB1c2gobGluZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2V0IGxvd2VyIHRleHQgbGltaXQgdG8gZW5kIG9mIHRoZSBjdXJyZW50IGh1bmssIHNvIG5leHQgb25lcyBkb24ndCB0cnlcbiAgICAgICAgLy8gdG8gZml0IG92ZXIgYWxyZWFkeSBwYXRjaGVkIHRleHRcbiAgICAgICAgbWluTGluZSA9IGh1bmtSZXN1bHQub2xkTGluZUxhc3RJICsgMTtcbiAgICAgICAgLy8gTm90ZSB0aGUgb2Zmc2V0IGJldHdlZW4gd2hlcmUgdGhlIHBhdGNoIHNhaWQgdGhlIGh1bmsgc2hvdWxkJ3ZlIGFwcGxpZWQgYW5kIHdoZXJlIHdlXG4gICAgICAgIC8vIGFwcGxpZWQgaXQsIHNvIHdlIGNhbiBhZGp1c3QgZnV0dXJlIGh1bmtzIGFjY29yZGluZ2x5OlxuICAgICAgICBwcmV2SHVua09mZnNldCA9IHRvUG9zICsgMSAtIGh1bmsub2xkU3RhcnQ7XG4gICAgfVxuICAgIC8vIENvcHkgb3ZlciB0aGUgcmVzdCBvZiB0aGUgbGluZXMgZnJvbSB0aGUgb2xkIHRleHRcbiAgICBmb3IgKHZhciBpID0gbWluTGluZTsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlc3VsdExpbmVzLnB1c2gobGluZXNbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0TGluZXMuam9pbignXFxuJyk7XG59XG4vKipcbiAqIGFwcGxpZXMgb25lIG9yIG1vcmUgcGF0Y2hlcy5cbiAqXG4gKiBgcGF0Y2hgIG1heSBiZSBlaXRoZXIgYW4gYXJyYXkgb2Ygc3RydWN0dXJlZCBwYXRjaCBvYmplY3RzLCBvciBhIHN0cmluZyByZXByZXNlbnRpbmcgYSBwYXRjaCBpbiB1bmlmaWVkIGRpZmYgZm9ybWF0ICh3aGljaCBtYXkgcGF0Y2ggb25lIG9yIG1vcmUgZmlsZXMpLlxuICpcbiAqIFRoaXMgbWV0aG9kIHdpbGwgaXRlcmF0ZSBvdmVyIHRoZSBjb250ZW50cyBvZiB0aGUgcGF0Y2ggYW5kIGFwcGx5IHRvIGRhdGEgcHJvdmlkZWQgdGhyb3VnaCBjYWxsYmFja3MuIFRoZSBnZW5lcmFsIGZsb3cgZm9yIGVhY2ggcGF0Y2ggaW5kZXggaXM6XG4gKlxuICogLSBgb3B0aW9ucy5sb2FkRmlsZShpbmRleCwgY2FsbGJhY2spYCBpcyBjYWxsZWQuIFRoZSBjYWxsZXIgc2hvdWxkIHRoZW4gbG9hZCB0aGUgY29udGVudHMgb2YgdGhlIGZpbGUgYW5kIHRoZW4gcGFzcyB0aGF0IHRvIHRoZSBgY2FsbGJhY2soZXJyLCBkYXRhKWAgY2FsbGJhY2suIFBhc3NpbmcgYW4gYGVycmAgd2lsbCB0ZXJtaW5hdGUgZnVydGhlciBwYXRjaCBleGVjdXRpb24uXG4gKiAtIGBvcHRpb25zLnBhdGNoZWQoaW5kZXgsIGNvbnRlbnQsIGNhbGxiYWNrKWAgaXMgY2FsbGVkIG9uY2UgdGhlIHBhdGNoIGhhcyBiZWVuIGFwcGxpZWQuIGBjb250ZW50YCB3aWxsIGJlIHRoZSByZXR1cm4gdmFsdWUgZnJvbSBgYXBwbHlQYXRjaGAuIFdoZW4gaXQncyByZWFkeSwgdGhlIGNhbGxlciBzaG91bGQgY2FsbCBgY2FsbGJhY2soZXJyKWAgY2FsbGJhY2suIFBhc3NpbmcgYW4gYGVycmAgd2lsbCB0ZXJtaW5hdGUgZnVydGhlciBwYXRjaCBleGVjdXRpb24uXG4gKlxuICogT25jZSBhbGwgcGF0Y2hlcyBoYXZlIGJlZW4gYXBwbGllZCBvciBhbiBlcnJvciBvY2N1cnMsIHRoZSBgb3B0aW9ucy5jb21wbGV0ZShlcnIpYCBjYWxsYmFjayBpcyBtYWRlLlxuICovXG5mdW5jdGlvbiBhcHBseVBhdGNoZXModW5pRGlmZiwgb3B0aW9ucykge1xuICAgIHZhciBzcERpZmYgPSB0eXBlb2YgdW5pRGlmZiA9PT0gJ3N0cmluZycgPyAoMCwgcGFyc2VfanNfMS5wYXJzZVBhdGNoKSh1bmlEaWZmKSA6IHVuaURpZmY7XG4gICAgdmFyIGN1cnJlbnRJbmRleCA9IDA7XG4gICAgZnVuY3Rpb24gcHJvY2Vzc0luZGV4KCkge1xuICAgICAgICB2YXIgaW5kZXggPSBzcERpZmZbY3VycmVudEluZGV4KytdO1xuICAgICAgICBpZiAoIWluZGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIG9wdGlvbnMubG9hZEZpbGUoaW5kZXgsIGZ1bmN0aW9uIChlcnIsIGRhdGEpIHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5jb21wbGV0ZShlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHVwZGF0ZWRDb250ZW50ID0gYXBwbHlQYXRjaChkYXRhLCBpbmRleCwgb3B0aW9ucyk7XG4gICAgICAgICAgICBvcHRpb25zLnBhdGNoZWQoaW5kZXgsIHVwZGF0ZWRDb250ZW50LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5jb21wbGV0ZShlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwcm9jZXNzSW5kZXgoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcHJvY2Vzc0luZGV4KCk7XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hc3NpZ24gPSAodGhpcyAmJiB0aGlzLl9fYXNzaWduKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKVxuICAgICAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH07XG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5yZXZlcnNlUGF0Y2ggPSByZXZlcnNlUGF0Y2g7XG5mdW5jdGlvbiByZXZlcnNlUGF0Y2goc3RydWN0dXJlZFBhdGNoKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc3RydWN0dXJlZFBhdGNoKSkge1xuICAgICAgICAvLyAoU2VlIGNvbW1lbnQgaW4gdW5peFRvV2luIGZvciB3aHkgd2UgbmVlZCB0aGUgcG9pbnRsZXNzLWxvb2tpbmcgYW5vbnltb3VzIGZ1bmN0aW9uIGhlcmUpXG4gICAgICAgIHJldHVybiBzdHJ1Y3R1cmVkUGF0Y2gubWFwKGZ1bmN0aW9uIChwYXRjaCkgeyByZXR1cm4gcmV2ZXJzZVBhdGNoKHBhdGNoKTsgfSkucmV2ZXJzZSgpO1xuICAgIH1cbiAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIHN0cnVjdHVyZWRQYXRjaCksIHsgb2xkRmlsZU5hbWU6IHN0cnVjdHVyZWRQYXRjaC5uZXdGaWxlTmFtZSwgb2xkSGVhZGVyOiBzdHJ1Y3R1cmVkUGF0Y2gubmV3SGVhZGVyLCBuZXdGaWxlTmFtZTogc3RydWN0dXJlZFBhdGNoLm9sZEZpbGVOYW1lLCBuZXdIZWFkZXI6IHN0cnVjdHVyZWRQYXRjaC5vbGRIZWFkZXIsIGh1bmtzOiBzdHJ1Y3R1cmVkUGF0Y2guaHVua3MubWFwKGZ1bmN0aW9uIChodW5rKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG9sZExpbmVzOiBodW5rLm5ld0xpbmVzLFxuICAgICAgICAgICAgICAgIG9sZFN0YXJ0OiBodW5rLm5ld1N0YXJ0LFxuICAgICAgICAgICAgICAgIG5ld0xpbmVzOiBodW5rLm9sZExpbmVzLFxuICAgICAgICAgICAgICAgIG5ld1N0YXJ0OiBodW5rLm9sZFN0YXJ0LFxuICAgICAgICAgICAgICAgIGxpbmVzOiBodW5rLmxpbmVzLm1hcChmdW5jdGlvbiAobCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobC5zdGFydHNXaXRoKCctJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIitcIi5jb25jYXQobC5zbGljZSgxKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGwuc3RhcnRzV2l0aCgnKycpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCItXCIuY29uY2F0KGwuc2xpY2UoMSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KSB9KTtcbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2Fzc2lnbiA9ICh0aGlzICYmIHRoaXMuX19hc3NpZ24pIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odCkge1xuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpXG4gICAgICAgICAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnN0cnVjdHVyZWRQYXRjaCA9IHN0cnVjdHVyZWRQYXRjaDtcbmV4cG9ydHMuZm9ybWF0UGF0Y2ggPSBmb3JtYXRQYXRjaDtcbmV4cG9ydHMuY3JlYXRlVHdvRmlsZXNQYXRjaCA9IGNyZWF0ZVR3b0ZpbGVzUGF0Y2g7XG5leHBvcnRzLmNyZWF0ZVBhdGNoID0gY3JlYXRlUGF0Y2g7XG52YXIgbGluZV9qc18xID0gcmVxdWlyZShcIi4uL2RpZmYvbGluZS5qc1wiKTtcbmZ1bmN0aW9uIHN0cnVjdHVyZWRQYXRjaChvbGRGaWxlTmFtZSwgbmV3RmlsZU5hbWUsIG9sZFN0ciwgbmV3U3RyLCBvbGRIZWFkZXIsIG5ld0hlYWRlciwgb3B0aW9ucykge1xuICAgIHZhciBvcHRpb25zT2JqO1xuICAgIGlmICghb3B0aW9ucykge1xuICAgICAgICBvcHRpb25zT2JqID0ge307XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIG9wdGlvbnNPYmogPSB7IGNhbGxiYWNrOiBvcHRpb25zIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBvcHRpb25zT2JqID0gb3B0aW9ucztcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zT2JqLmNvbnRleHQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIG9wdGlvbnNPYmouY29udGV4dCA9IDQ7XG4gICAgfVxuICAgIC8vIFdlIGNvcHkgdGhpcyBpbnRvIGl0cyBvd24gdmFyaWFibGUgdG8gcGxhY2F0ZSBUeXBlU2NyaXB0LCB3aGljaCB0aGlua3NcbiAgICAvLyBvcHRpb25zT2JqLmNvbnRleHQgbWlnaHQgYmUgdW5kZWZpbmVkIGluIHRoZSBjYWxsYmFja3MgYmVsb3cuXG4gICAgdmFyIGNvbnRleHQgPSBvcHRpb25zT2JqLmNvbnRleHQ7XG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciAocnVudGltZSBjaGVjayBmb3Igc29tZXRoaW5nIHRoYXQgaXMgY29ycmVjdGx5IGEgc3RhdGljIHR5cGUgZXJyb3IpXG4gICAgaWYgKG9wdGlvbnNPYmoubmV3bGluZUlzVG9rZW4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCduZXdsaW5lSXNUb2tlbiBtYXkgbm90IGJlIHVzZWQgd2l0aCBwYXRjaC1nZW5lcmF0aW9uIGZ1bmN0aW9ucywgb25seSB3aXRoIGRpZmZpbmcgZnVuY3Rpb25zJyk7XG4gICAgfVxuICAgIGlmICghb3B0aW9uc09iai5jYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gZGlmZkxpbmVzUmVzdWx0VG9QYXRjaCgoMCwgbGluZV9qc18xLmRpZmZMaW5lcykob2xkU3RyLCBuZXdTdHIsIG9wdGlvbnNPYmopKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhciBjYWxsYmFja18xID0gb3B0aW9uc09iai5jYWxsYmFjaztcbiAgICAgICAgKDAsIGxpbmVfanNfMS5kaWZmTGluZXMpKG9sZFN0ciwgbmV3U3RyLCBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgb3B0aW9uc09iaiksIHsgY2FsbGJhY2s6IGZ1bmN0aW9uIChkaWZmKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhdGNoID0gZGlmZkxpbmVzUmVzdWx0VG9QYXRjaChkaWZmKTtcbiAgICAgICAgICAgICAgICAvLyBUeXBlU2NyaXB0IGlzIHVuaGFwcHkgd2l0aG91dCB0aGUgY2FzdCBiZWNhdXNlIGl0IGRvZXMgbm90IHVuZGVyc3RhbmQgdGhhdCBgcGF0Y2hgIG1heVxuICAgICAgICAgICAgICAgIC8vIGJlIHVuZGVmaW5lZCBoZXJlIG9ubHkgaWYgYGNhbGxiYWNrYCBpcyBTdHJ1Y3R1cmVkUGF0Y2hDYWxsYmFja0Fib3J0YWJsZTpcbiAgICAgICAgICAgICAgICBjYWxsYmFja18xKHBhdGNoKTtcbiAgICAgICAgICAgIH0gfSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkaWZmTGluZXNSZXN1bHRUb1BhdGNoKGRpZmYpIHtcbiAgICAgICAgLy8gU1RFUCAxOiBCdWlsZCB1cCB0aGUgcGF0Y2ggd2l0aCBubyBcIlxcIE5vIG5ld2xpbmUgYXQgZW5kIG9mIGZpbGVcIiBsaW5lcyBhbmQgd2l0aCB0aGUgYXJyYXlzXG4gICAgICAgIC8vICAgICAgICAgb2YgbGluZXMgY29udGFpbmluZyB0cmFpbGluZyBuZXdsaW5lIGNoYXJhY3RlcnMuIFdlJ2xsIHRpZHkgdXAgbGF0ZXIuLi5cbiAgICAgICAgaWYgKCFkaWZmKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZGlmZi5wdXNoKHsgdmFsdWU6ICcnLCBsaW5lczogW10gfSk7IC8vIEFwcGVuZCBhbiBlbXB0eSB2YWx1ZSB0byBtYWtlIGNsZWFudXAgZWFzaWVyXG4gICAgICAgIGZ1bmN0aW9uIGNvbnRleHRMaW5lcyhsaW5lcykge1xuICAgICAgICAgICAgcmV0dXJuIGxpbmVzLm1hcChmdW5jdGlvbiAoZW50cnkpIHsgcmV0dXJuICcgJyArIGVudHJ5OyB9KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaHVua3MgPSBbXTtcbiAgICAgICAgdmFyIG9sZFJhbmdlU3RhcnQgPSAwLCBuZXdSYW5nZVN0YXJ0ID0gMCwgY3VyUmFuZ2UgPSBbXSwgb2xkTGluZSA9IDEsIG5ld0xpbmUgPSAxO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpZmYubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjdXJyZW50ID0gZGlmZltpXSwgbGluZXMgPSBjdXJyZW50LmxpbmVzIHx8IHNwbGl0TGluZXMoY3VycmVudC52YWx1ZSk7XG4gICAgICAgICAgICBjdXJyZW50LmxpbmVzID0gbGluZXM7XG4gICAgICAgICAgICBpZiAoY3VycmVudC5hZGRlZCB8fCBjdXJyZW50LnJlbW92ZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSBoYXZlIHByZXZpb3VzIGNvbnRleHQsIHN0YXJ0IHdpdGggdGhhdFxuICAgICAgICAgICAgICAgIGlmICghb2xkUmFuZ2VTdGFydCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcHJldiA9IGRpZmZbaSAtIDFdO1xuICAgICAgICAgICAgICAgICAgICBvbGRSYW5nZVN0YXJ0ID0gb2xkTGluZTtcbiAgICAgICAgICAgICAgICAgICAgbmV3UmFuZ2VTdGFydCA9IG5ld0xpbmU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcmV2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJSYW5nZSA9IGNvbnRleHQgPiAwID8gY29udGV4dExpbmVzKHByZXYubGluZXMuc2xpY2UoLWNvbnRleHQpKSA6IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgb2xkUmFuZ2VTdGFydCAtPSBjdXJSYW5nZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdSYW5nZVN0YXJ0IC09IGN1clJhbmdlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBPdXRwdXQgb3VyIGNoYW5nZXNcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIGxpbmVzXzEgPSBsaW5lczsgX2kgPCBsaW5lc18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGluZSA9IGxpbmVzXzFbX2ldO1xuICAgICAgICAgICAgICAgICAgICBjdXJSYW5nZS5wdXNoKChjdXJyZW50LmFkZGVkID8gJysnIDogJy0nKSArIGxpbmUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBUcmFjayB0aGUgdXBkYXRlZCBmaWxlIHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnQuYWRkZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3TGluZSArPSBsaW5lcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvbGRMaW5lICs9IGxpbmVzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBJZGVudGljYWwgY29udGV4dCBsaW5lcy4gVHJhY2sgbGluZSBjaGFuZ2VzXG4gICAgICAgICAgICAgICAgaWYgKG9sZFJhbmdlU3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2xvc2Ugb3V0IGFueSBjaGFuZ2VzIHRoYXQgaGF2ZSBiZWVuIG91dHB1dCAob3Igam9pbiBvdmVybGFwcGluZylcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxpbmVzLmxlbmd0aCA8PSBjb250ZXh0ICogMiAmJiBpIDwgZGlmZi5sZW5ndGggLSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBPdmVybGFwcGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2EgPSAwLCBfYiA9IGNvbnRleHRMaW5lcyhsaW5lcyk7IF9hIDwgX2IubGVuZ3RoOyBfYSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxpbmUgPSBfYltfYV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VyUmFuZ2UucHVzaChsaW5lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVuZCB0aGUgcmFuZ2UgYW5kIG91dHB1dFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRleHRTaXplID0gTWF0aC5taW4obGluZXMubGVuZ3RoLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9jID0gMCwgX2QgPSBjb250ZXh0TGluZXMobGluZXMuc2xpY2UoMCwgY29udGV4dFNpemUpKTsgX2MgPCBfZC5sZW5ndGg7IF9jKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGluZSA9IF9kW19jXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJSYW5nZS5wdXNoKGxpbmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGh1bmsgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2xkU3RhcnQ6IG9sZFJhbmdlU3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2xkTGluZXM6IChvbGRMaW5lIC0gb2xkUmFuZ2VTdGFydCArIGNvbnRleHRTaXplKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdTdGFydDogbmV3UmFuZ2VTdGFydCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdMaW5lczogKG5ld0xpbmUgLSBuZXdSYW5nZVN0YXJ0ICsgY29udGV4dFNpemUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVzOiBjdXJSYW5nZVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGh1bmtzLnB1c2goaHVuayk7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbGRSYW5nZVN0YXJ0ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1JhbmdlU3RhcnQgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VyUmFuZ2UgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvbGRMaW5lICs9IGxpbmVzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBuZXdMaW5lICs9IGxpbmVzLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBTdGVwIDI6IGVsaW1pbmF0ZSB0aGUgdHJhaWxpbmcgYFxcbmAgZnJvbSBlYWNoIGxpbmUgb2YgZWFjaCBodW5rLCBhbmQsIHdoZXJlIG5lZWRlZCwgYWRkXG4gICAgICAgIC8vICAgICAgICAgXCJcXCBObyBuZXdsaW5lIGF0IGVuZCBvZiBmaWxlXCIuXG4gICAgICAgIGZvciAodmFyIF9lID0gMCwgaHVua3NfMSA9IGh1bmtzOyBfZSA8IGh1bmtzXzEubGVuZ3RoOyBfZSsrKSB7XG4gICAgICAgICAgICB2YXIgaHVuayA9IGh1bmtzXzFbX2VdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBodW5rLmxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGh1bmsubGluZXNbaV0uZW5kc1dpdGgoJ1xcbicpKSB7XG4gICAgICAgICAgICAgICAgICAgIGh1bmsubGluZXNbaV0gPSBodW5rLmxpbmVzW2ldLnNsaWNlKDAsIC0xKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGh1bmsubGluZXMuc3BsaWNlKGkgKyAxLCAwLCAnXFxcXCBObyBuZXdsaW5lIGF0IGVuZCBvZiBmaWxlJyk7XG4gICAgICAgICAgICAgICAgICAgIGkrKzsgLy8gU2tpcCB0aGUgbGluZSB3ZSBqdXN0IGFkZGVkLCB0aGVuIGNvbnRpbnVlIGl0ZXJhdGluZ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgb2xkRmlsZU5hbWU6IG9sZEZpbGVOYW1lLCBuZXdGaWxlTmFtZTogbmV3RmlsZU5hbWUsXG4gICAgICAgICAgICBvbGRIZWFkZXI6IG9sZEhlYWRlciwgbmV3SGVhZGVyOiBuZXdIZWFkZXIsXG4gICAgICAgICAgICBodW5rczogaHVua3NcbiAgICAgICAgfTtcbiAgICB9XG59XG4vKipcbiAqIGNyZWF0ZXMgYSB1bmlmaWVkIGRpZmYgcGF0Y2guXG4gKiBAcGFyYW0gcGF0Y2ggZWl0aGVyIGEgc2luZ2xlIHN0cnVjdHVyZWQgcGF0Y2ggb2JqZWN0IChhcyByZXR1cm5lZCBieSBgc3RydWN0dXJlZFBhdGNoYCkgb3IgYW4gYXJyYXkgb2YgdGhlbSAoYXMgcmV0dXJuZWQgYnkgYHBhcnNlUGF0Y2hgKVxuICovXG5mdW5jdGlvbiBmb3JtYXRQYXRjaChwYXRjaCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHBhdGNoKSkge1xuICAgICAgICByZXR1cm4gcGF0Y2gubWFwKGZvcm1hdFBhdGNoKS5qb2luKCdcXG4nKTtcbiAgICB9XG4gICAgdmFyIHJldCA9IFtdO1xuICAgIGlmIChwYXRjaC5vbGRGaWxlTmFtZSA9PSBwYXRjaC5uZXdGaWxlTmFtZSkge1xuICAgICAgICByZXQucHVzaCgnSW5kZXg6ICcgKyBwYXRjaC5vbGRGaWxlTmFtZSk7XG4gICAgfVxuICAgIHJldC5wdXNoKCc9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Jyk7XG4gICAgcmV0LnB1c2goJy0tLSAnICsgcGF0Y2gub2xkRmlsZU5hbWUgKyAodHlwZW9mIHBhdGNoLm9sZEhlYWRlciA9PT0gJ3VuZGVmaW5lZCcgPyAnJyA6ICdcXHQnICsgcGF0Y2gub2xkSGVhZGVyKSk7XG4gICAgcmV0LnB1c2goJysrKyAnICsgcGF0Y2gubmV3RmlsZU5hbWUgKyAodHlwZW9mIHBhdGNoLm5ld0hlYWRlciA9PT0gJ3VuZGVmaW5lZCcgPyAnJyA6ICdcXHQnICsgcGF0Y2gubmV3SGVhZGVyKSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRjaC5odW5rcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgaHVuayA9IHBhdGNoLmh1bmtzW2ldO1xuICAgICAgICAvLyBVbmlmaWVkIERpZmYgRm9ybWF0IHF1aXJrOiBJZiB0aGUgY2h1bmsgc2l6ZSBpcyAwLFxuICAgICAgICAvLyB0aGUgZmlyc3QgbnVtYmVyIGlzIG9uZSBsb3dlciB0aGFuIG9uZSB3b3VsZCBleHBlY3QuXG4gICAgICAgIC8vIGh0dHBzOi8vd3d3LmFydGltYS5jb20vd2VibG9ncy92aWV3cG9zdC5qc3A/dGhyZWFkPTE2NDI5M1xuICAgICAgICBpZiAoaHVuay5vbGRMaW5lcyA9PT0gMCkge1xuICAgICAgICAgICAgaHVuay5vbGRTdGFydCAtPSAxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChodW5rLm5ld0xpbmVzID09PSAwKSB7XG4gICAgICAgICAgICBodW5rLm5ld1N0YXJ0IC09IDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0LnB1c2goJ0BAIC0nICsgaHVuay5vbGRTdGFydCArICcsJyArIGh1bmsub2xkTGluZXNcbiAgICAgICAgICAgICsgJyArJyArIGh1bmsubmV3U3RhcnQgKyAnLCcgKyBodW5rLm5ld0xpbmVzXG4gICAgICAgICAgICArICcgQEAnKTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IGh1bmsubGluZXM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgbGluZSA9IF9hW19pXTtcbiAgICAgICAgICAgIHJldC5wdXNoKGxpbmUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXQuam9pbignXFxuJykgKyAnXFxuJztcbn1cbmZ1bmN0aW9uIGNyZWF0ZVR3b0ZpbGVzUGF0Y2gob2xkRmlsZU5hbWUsIG5ld0ZpbGVOYW1lLCBvbGRTdHIsIG5ld1N0ciwgb2xkSGVhZGVyLCBuZXdIZWFkZXIsIG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgb3B0aW9ucyA9IHsgY2FsbGJhY2s6IG9wdGlvbnMgfTtcbiAgICB9XG4gICAgaWYgKCEob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmNhbGxiYWNrKSkge1xuICAgICAgICB2YXIgcGF0Y2hPYmogPSBzdHJ1Y3R1cmVkUGF0Y2gob2xkRmlsZU5hbWUsIG5ld0ZpbGVOYW1lLCBvbGRTdHIsIG5ld1N0ciwgb2xkSGVhZGVyLCBuZXdIZWFkZXIsIG9wdGlvbnMpO1xuICAgICAgICBpZiAoIXBhdGNoT2JqKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvcm1hdFBhdGNoKHBhdGNoT2JqKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhciBjYWxsYmFja18yID0gb3B0aW9ucy5jYWxsYmFjaztcbiAgICAgICAgc3RydWN0dXJlZFBhdGNoKG9sZEZpbGVOYW1lLCBuZXdGaWxlTmFtZSwgb2xkU3RyLCBuZXdTdHIsIG9sZEhlYWRlciwgbmV3SGVhZGVyLCBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgb3B0aW9ucyksIHsgY2FsbGJhY2s6IGZ1bmN0aW9uIChwYXRjaE9iaikge1xuICAgICAgICAgICAgICAgIGlmICghcGF0Y2hPYmopIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tfMih1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tfMihmb3JtYXRQYXRjaChwYXRjaE9iaikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gfSkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZVBhdGNoKGZpbGVOYW1lLCBvbGRTdHIsIG5ld1N0ciwgb2xkSGVhZGVyLCBuZXdIZWFkZXIsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gY3JlYXRlVHdvRmlsZXNQYXRjaChmaWxlTmFtZSwgZmlsZU5hbWUsIG9sZFN0ciwgbmV3U3RyLCBvbGRIZWFkZXIsIG5ld0hlYWRlciwgb3B0aW9ucyk7XG59XG4vKipcbiAqIFNwbGl0IGB0ZXh0YCBpbnRvIGFuIGFycmF5IG9mIGxpbmVzLCBpbmNsdWRpbmcgdGhlIHRyYWlsaW5nIG5ld2xpbmUgY2hhcmFjdGVyICh3aGVyZSBwcmVzZW50KVxuICovXG5mdW5jdGlvbiBzcGxpdExpbmVzKHRleHQpIHtcbiAgICB2YXIgaGFzVHJhaWxpbmdObCA9IHRleHQuZW5kc1dpdGgoJ1xcbicpO1xuICAgIHZhciByZXN1bHQgPSB0ZXh0LnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24gKGxpbmUpIHsgcmV0dXJuIGxpbmUgKyAnXFxuJzsgfSk7XG4gICAgaWYgKGhhc1RyYWlsaW5nTmwpIHtcbiAgICAgICAgcmVzdWx0LnBvcCgpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmVzdWx0LnB1c2gocmVzdWx0LnBvcCgpLnNsaWNlKDAsIC0xKSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNvbnZlcnRDaGFuZ2VzVG9ETVAgPSBjb252ZXJ0Q2hhbmdlc1RvRE1QO1xuLyoqXG4gKiBjb252ZXJ0cyBhIGxpc3Qgb2YgY2hhbmdlIG9iamVjdHMgdG8gdGhlIGZvcm1hdCByZXR1cm5lZCBieSBHb29nbGUncyBbZGlmZi1tYXRjaC1wYXRjaF0oaHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS9kaWZmLW1hdGNoLXBhdGNoKSBsaWJyYXJ5XG4gKi9cbmZ1bmN0aW9uIGNvbnZlcnRDaGFuZ2VzVG9ETVAoY2hhbmdlcykge1xuICAgIHZhciByZXQgPSBbXTtcbiAgICB2YXIgY2hhbmdlLCBvcGVyYXRpb247XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNoYW5nZSA9IGNoYW5nZXNbaV07XG4gICAgICAgIGlmIChjaGFuZ2UuYWRkZWQpIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbiA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2hhbmdlLnJlbW92ZWQpIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbiA9IC0xO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb3BlcmF0aW9uID0gMDtcbiAgICAgICAgfVxuICAgICAgICByZXQucHVzaChbb3BlcmF0aW9uLCBjaGFuZ2UudmFsdWVdKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY29udmVydENoYW5nZXNUb1hNTCA9IGNvbnZlcnRDaGFuZ2VzVG9YTUw7XG4vKipcbiAqIGNvbnZlcnRzIGEgbGlzdCBvZiBjaGFuZ2Ugb2JqZWN0cyB0byBhIHNlcmlhbGl6ZWQgWE1MIGZvcm1hdFxuICovXG5mdW5jdGlvbiBjb252ZXJ0Q2hhbmdlc1RvWE1MKGNoYW5nZXMpIHtcbiAgICB2YXIgcmV0ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGFuZ2UgPSBjaGFuZ2VzW2ldO1xuICAgICAgICBpZiAoY2hhbmdlLmFkZGVkKSB7XG4gICAgICAgICAgICByZXQucHVzaCgnPGlucz4nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjaGFuZ2UucmVtb3ZlZCkge1xuICAgICAgICAgICAgcmV0LnB1c2goJzxkZWw+Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0LnB1c2goZXNjYXBlSFRNTChjaGFuZ2UudmFsdWUpKTtcbiAgICAgICAgaWYgKGNoYW5nZS5hZGRlZCkge1xuICAgICAgICAgICAgcmV0LnB1c2goJzwvaW5zPicpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNoYW5nZS5yZW1vdmVkKSB7XG4gICAgICAgICAgICByZXQucHVzaCgnPC9kZWw+Jyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJldC5qb2luKCcnKTtcbn1cbmZ1bmN0aW9uIGVzY2FwZUhUTUwocykge1xuICAgIHZhciBuID0gcztcbiAgICBuID0gbi5yZXBsYWNlKC8mL2csICcmYW1wOycpO1xuICAgIG4gPSBuLnJlcGxhY2UoLzwvZywgJyZsdDsnKTtcbiAgICBuID0gbi5yZXBsYWNlKC8+L2csICcmZ3Q7Jyk7XG4gICAgbiA9IG4ucmVwbGFjZSgvXCIvZywgJyZxdW90OycpO1xuICAgIHJldHVybiBuO1xufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuLyogU2VlIExJQ0VOU0UgZmlsZSBmb3IgdGVybXMgb2YgdXNlICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNhbm9uaWNhbGl6ZSA9IGV4cG9ydHMuY29udmVydENoYW5nZXNUb1hNTCA9IGV4cG9ydHMuY29udmVydENoYW5nZXNUb0RNUCA9IGV4cG9ydHMucmV2ZXJzZVBhdGNoID0gZXhwb3J0cy5wYXJzZVBhdGNoID0gZXhwb3J0cy5hcHBseVBhdGNoZXMgPSBleHBvcnRzLmFwcGx5UGF0Y2ggPSBleHBvcnRzLmZvcm1hdFBhdGNoID0gZXhwb3J0cy5jcmVhdGVQYXRjaCA9IGV4cG9ydHMuY3JlYXRlVHdvRmlsZXNQYXRjaCA9IGV4cG9ydHMuc3RydWN0dXJlZFBhdGNoID0gZXhwb3J0cy5hcnJheURpZmYgPSBleHBvcnRzLmRpZmZBcnJheXMgPSBleHBvcnRzLmpzb25EaWZmID0gZXhwb3J0cy5kaWZmSnNvbiA9IGV4cG9ydHMuY3NzRGlmZiA9IGV4cG9ydHMuZGlmZkNzcyA9IGV4cG9ydHMuc2VudGVuY2VEaWZmID0gZXhwb3J0cy5kaWZmU2VudGVuY2VzID0gZXhwb3J0cy5kaWZmVHJpbW1lZExpbmVzID0gZXhwb3J0cy5saW5lRGlmZiA9IGV4cG9ydHMuZGlmZkxpbmVzID0gZXhwb3J0cy53b3Jkc1dpdGhTcGFjZURpZmYgPSBleHBvcnRzLmRpZmZXb3Jkc1dpdGhTcGFjZSA9IGV4cG9ydHMud29yZERpZmYgPSBleHBvcnRzLmRpZmZXb3JkcyA9IGV4cG9ydHMuY2hhcmFjdGVyRGlmZiA9IGV4cG9ydHMuZGlmZkNoYXJzID0gZXhwb3J0cy5EaWZmID0gdm9pZCAwO1xuLypcbiAqIFRleHQgZGlmZiBpbXBsZW1lbnRhdGlvbi5cbiAqXG4gKiBUaGlzIGxpYnJhcnkgc3VwcG9ydHMgdGhlIGZvbGxvd2luZyBBUElzOlxuICogRGlmZi5kaWZmQ2hhcnM6IENoYXJhY3RlciBieSBjaGFyYWN0ZXIgZGlmZlxuICogRGlmZi5kaWZmV29yZHM6IFdvcmQgKGFzIGRlZmluZWQgYnkgXFxiIHJlZ2V4KSBkaWZmIHdoaWNoIGlnbm9yZXMgd2hpdGVzcGFjZVxuICogRGlmZi5kaWZmTGluZXM6IExpbmUgYmFzZWQgZGlmZlxuICpcbiAqIERpZmYuZGlmZkNzczogRGlmZiB0YXJnZXRlZCBhdCBDU1MgY29udGVudFxuICpcbiAqIFRoZXNlIG1ldGhvZHMgYXJlIGJhc2VkIG9uIHRoZSBpbXBsZW1lbnRhdGlvbiBwcm9wb3NlZCBpblxuICogXCJBbiBPKE5EKSBEaWZmZXJlbmNlIEFsZ29yaXRobSBhbmQgaXRzIFZhcmlhdGlvbnNcIiAoTXllcnMsIDE5ODYpLlxuICogaHR0cDovL2NpdGVzZWVyeC5pc3QucHN1LmVkdS92aWV3ZG9jL3N1bW1hcnk/ZG9pPTEwLjEuMS40LjY5MjdcbiAqL1xudmFyIGJhc2VfanNfMSA9IHJlcXVpcmUoXCIuL2RpZmYvYmFzZS5qc1wiKTtcbmV4cG9ydHMuRGlmZiA9IGJhc2VfanNfMS5kZWZhdWx0O1xudmFyIGNoYXJhY3Rlcl9qc18xID0gcmVxdWlyZShcIi4vZGlmZi9jaGFyYWN0ZXIuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkaWZmQ2hhcnNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNoYXJhY3Rlcl9qc18xLmRpZmZDaGFyczsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNoYXJhY3RlckRpZmZcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNoYXJhY3Rlcl9qc18xLmNoYXJhY3RlckRpZmY7IH0gfSk7XG52YXIgd29yZF9qc18xID0gcmVxdWlyZShcIi4vZGlmZi93b3JkLmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZGlmZldvcmRzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB3b3JkX2pzXzEuZGlmZldvcmRzOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZGlmZldvcmRzV2l0aFNwYWNlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB3b3JkX2pzXzEuZGlmZldvcmRzV2l0aFNwYWNlOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwid29yZERpZmZcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHdvcmRfanNfMS53b3JkRGlmZjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIndvcmRzV2l0aFNwYWNlRGlmZlwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gd29yZF9qc18xLndvcmRzV2l0aFNwYWNlRGlmZjsgfSB9KTtcbnZhciBsaW5lX2pzXzEgPSByZXF1aXJlKFwiLi9kaWZmL2xpbmUuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkaWZmTGluZXNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGxpbmVfanNfMS5kaWZmTGluZXM7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkaWZmVHJpbW1lZExpbmVzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBsaW5lX2pzXzEuZGlmZlRyaW1tZWRMaW5lczsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImxpbmVEaWZmXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBsaW5lX2pzXzEubGluZURpZmY7IH0gfSk7XG52YXIgc2VudGVuY2VfanNfMSA9IHJlcXVpcmUoXCIuL2RpZmYvc2VudGVuY2UuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkaWZmU2VudGVuY2VzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzZW50ZW5jZV9qc18xLmRpZmZTZW50ZW5jZXM7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzZW50ZW5jZURpZmZcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNlbnRlbmNlX2pzXzEuc2VudGVuY2VEaWZmOyB9IH0pO1xudmFyIGNzc19qc18xID0gcmVxdWlyZShcIi4vZGlmZi9jc3MuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkaWZmQ3NzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjc3NfanNfMS5kaWZmQ3NzOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY3NzRGlmZlwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY3NzX2pzXzEuY3NzRGlmZjsgfSB9KTtcbnZhciBqc29uX2pzXzEgPSByZXF1aXJlKFwiLi9kaWZmL2pzb24uanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkaWZmSnNvblwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4ganNvbl9qc18xLmRpZmZKc29uOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY2Fub25pY2FsaXplXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBqc29uX2pzXzEuY2Fub25pY2FsaXplOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwianNvbkRpZmZcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGpzb25fanNfMS5qc29uRGlmZjsgfSB9KTtcbnZhciBhcnJheV9qc18xID0gcmVxdWlyZShcIi4vZGlmZi9hcnJheS5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImRpZmZBcnJheXNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFycmF5X2pzXzEuZGlmZkFycmF5czsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImFycmF5RGlmZlwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYXJyYXlfanNfMS5hcnJheURpZmY7IH0gfSk7XG52YXIgYXBwbHlfanNfMSA9IHJlcXVpcmUoXCIuL3BhdGNoL2FwcGx5LmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiYXBwbHlQYXRjaFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYXBwbHlfanNfMS5hcHBseVBhdGNoOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiYXBwbHlQYXRjaGVzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBhcHBseV9qc18xLmFwcGx5UGF0Y2hlczsgfSB9KTtcbnZhciBwYXJzZV9qc18xID0gcmVxdWlyZShcIi4vcGF0Y2gvcGFyc2UuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJwYXJzZVBhdGNoXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwYXJzZV9qc18xLnBhcnNlUGF0Y2g7IH0gfSk7XG52YXIgcmV2ZXJzZV9qc18xID0gcmVxdWlyZShcIi4vcGF0Y2gvcmV2ZXJzZS5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInJldmVyc2VQYXRjaFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcmV2ZXJzZV9qc18xLnJldmVyc2VQYXRjaDsgfSB9KTtcbnZhciBjcmVhdGVfanNfMSA9IHJlcXVpcmUoXCIuL3BhdGNoL2NyZWF0ZS5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInN0cnVjdHVyZWRQYXRjaFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY3JlYXRlX2pzXzEuc3RydWN0dXJlZFBhdGNoOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY3JlYXRlVHdvRmlsZXNQYXRjaFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY3JlYXRlX2pzXzEuY3JlYXRlVHdvRmlsZXNQYXRjaDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNyZWF0ZVBhdGNoXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjcmVhdGVfanNfMS5jcmVhdGVQYXRjaDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImZvcm1hdFBhdGNoXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjcmVhdGVfanNfMS5mb3JtYXRQYXRjaDsgfSB9KTtcbnZhciBkbXBfanNfMSA9IHJlcXVpcmUoXCIuL2NvbnZlcnQvZG1wLmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY29udmVydENoYW5nZXNUb0RNUFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZG1wX2pzXzEuY29udmVydENoYW5nZXNUb0RNUDsgfSB9KTtcbnZhciB4bWxfanNfMSA9IHJlcXVpcmUoXCIuL2NvbnZlcnQveG1sLmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY29udmVydENoYW5nZXNUb1hNTFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4geG1sX2pzXzEuY29udmVydENoYW5nZXNUb1hNTDsgfSB9KTtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuY29uc3QgYXJyYXlQcm90byA9IHJlcXVpcmUoXCJAc2lub25qcy9jb21tb25zXCIpLnByb3RvdHlwZXMuYXJyYXk7XG5jb25zdCBDb2xvcml6ZXIgPSByZXF1aXJlKFwiLi9jb2xvcml6ZXJcIik7XG5jb25zdCBjb2xvcm9yaXplciA9IG5ldyBDb2xvcml6ZXIoKTtcbmNvbnN0IG1hdGNoID0gcmVxdWlyZShcIkBzaW5vbmpzL3NhbXNhbVwiKS5jcmVhdGVNYXRjaGVyO1xuY29uc3QgdGltZXNJbldvcmRzID0gcmVxdWlyZShcIi4vdXRpbC9jb3JlL3RpbWVzLWluLXdvcmRzXCIpO1xuY29uc3QgaW5zcGVjdCA9IHJlcXVpcmUoXCJ1dGlsXCIpLmluc3BlY3Q7XG5jb25zdCBqc0RpZmYgPSByZXF1aXJlKFwiZGlmZlwiKTtcblxuY29uc3Qgam9pbiA9IGFycmF5UHJvdG8uam9pbjtcbmNvbnN0IG1hcCA9IGFycmF5UHJvdG8ubWFwO1xuY29uc3QgcHVzaCA9IGFycmF5UHJvdG8ucHVzaDtcbmNvbnN0IHNsaWNlID0gYXJyYXlQcm90by5zbGljZTtcblxuLyoqXG4gKlxuICogQHBhcmFtIG1hdGNoZXJcbiAqIEBwYXJhbSBjYWxsZWRBcmdcbiAqIEBwYXJhbSBjYWxsZWRBcmdNZXNzYWdlXG4gKlxuICogQHJldHVybnMge3N0cmluZ30gdGhlIGNvbG9yZWQgdGV4dFxuICovXG5mdW5jdGlvbiBjb2xvclNpbm9uTWF0Y2hUZXh0KG1hdGNoZXIsIGNhbGxlZEFyZywgY2FsbGVkQXJnTWVzc2FnZSkge1xuICAgIGxldCBjYWxsZWRBcmd1bWVudE1lc3NhZ2UgPSBjYWxsZWRBcmdNZXNzYWdlO1xuICAgIGxldCBtYXRjaGVyTWVzc2FnZSA9IG1hdGNoZXIubWVzc2FnZTtcbiAgICBpZiAoIW1hdGNoZXIudGVzdChjYWxsZWRBcmcpKSB7XG4gICAgICAgIG1hdGNoZXJNZXNzYWdlID0gY29sb3Jvcml6ZXIucmVkKG1hdGNoZXIubWVzc2FnZSk7XG4gICAgICAgIGlmIChjYWxsZWRBcmd1bWVudE1lc3NhZ2UpIHtcbiAgICAgICAgICAgIGNhbGxlZEFyZ3VtZW50TWVzc2FnZSA9IGNvbG9yb3JpemVyLmdyZWVuKGNhbGxlZEFyZ3VtZW50TWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGAke2NhbGxlZEFyZ3VtZW50TWVzc2FnZX0gJHttYXRjaGVyTWVzc2FnZX1gO1xufVxuXG4vKipcbiAqIEBwYXJhbSBkaWZmXG4gKlxuICogQHJldHVybnMge3N0cmluZ30gdGhlIGNvbG9yZWQgZGlmZlxuICovXG5mdW5jdGlvbiBjb2xvckRpZmZUZXh0KGRpZmYpIHtcbiAgICBjb25zdCBvYmplY3RzID0gbWFwKGRpZmYsIGZ1bmN0aW9uIChwYXJ0KSB7XG4gICAgICAgIGxldCB0ZXh0ID0gcGFydC52YWx1ZTtcbiAgICAgICAgaWYgKHBhcnQuYWRkZWQpIHtcbiAgICAgICAgICAgIHRleHQgPSBjb2xvcm9yaXplci5ncmVlbih0ZXh0KTtcbiAgICAgICAgfSBlbHNlIGlmIChwYXJ0LnJlbW92ZWQpIHtcbiAgICAgICAgICAgIHRleHQgPSBjb2xvcm9yaXplci5yZWQodGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRpZmYubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICB0ZXh0ICs9IFwiIFwiOyAvLyBmb3JtYXQgc2ltcGxlIGRpZmZzXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfSk7XG4gICAgcmV0dXJuIGpvaW4ob2JqZWN0cywgXCJcIik7XG59XG5cbi8qKlxuICpcbiAqIEBwYXJhbSB2YWx1ZVxuICogQHJldHVybnMge3N0cmluZ30gYSBxdW90ZWQgc3RyaW5nXG4gKi9cbmZ1bmN0aW9uIHF1b3RlU3RyaW5nVmFsdWUodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgYzogZnVuY3Rpb24gKHNweUluc3RhbmNlKSB7XG4gICAgICAgIHJldHVybiB0aW1lc0luV29yZHMoc3B5SW5zdGFuY2UuY2FsbENvdW50KTtcbiAgICB9LFxuXG4gICAgbjogZnVuY3Rpb24gKHNweUluc3RhbmNlKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAc2lub25qcy9uby1wcm90b3R5cGUtbWV0aG9kcy9uby1wcm90b3R5cGUtbWV0aG9kc1xuICAgICAgICByZXR1cm4gc3B5SW5zdGFuY2UudG9TdHJpbmcoKTtcbiAgICB9LFxuXG4gICAgRDogZnVuY3Rpb24gKHNweUluc3RhbmNlLCBhcmdzKSB7XG4gICAgICAgIGxldCBtZXNzYWdlID0gXCJcIjtcblxuICAgICAgICBmb3IgKGxldCBpID0gMCwgbCA9IHNweUluc3RhbmNlLmNhbGxDb3VudDsgaSA8IGw7ICsraSkge1xuICAgICAgICAgICAgLy8gZGVzY3JpYmUgbXVsdGlwbGUgY2FsbHNcbiAgICAgICAgICAgIGlmIChsID4gMSkge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgKz0gYFxcbkNhbGwgJHtpICsgMX06YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNhbGxlZEFyZ3MgPSBzcHlJbnN0YW5jZS5nZXRDYWxsKGkpLmFyZ3M7XG4gICAgICAgICAgICBjb25zdCBleHBlY3RlZEFyZ3MgPSBzbGljZShhcmdzKTtcblxuICAgICAgICAgICAgZm9yIChcbiAgICAgICAgICAgICAgICBsZXQgaiA9IDA7XG4gICAgICAgICAgICAgICAgaiA8IGNhbGxlZEFyZ3MubGVuZ3RoIHx8IGogPCBleHBlY3RlZEFyZ3MubGVuZ3RoO1xuICAgICAgICAgICAgICAgICsralxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNhbGxlZEFyZyA9IGNhbGxlZEFyZ3Nbal07XG4gICAgICAgICAgICAgICAgbGV0IGV4cGVjdGVkQXJnID0gZXhwZWN0ZWRBcmdzW2pdO1xuICAgICAgICAgICAgICAgIGlmIChjYWxsZWRBcmcpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGVkQXJnID0gcXVvdGVTdHJpbmdWYWx1ZShjYWxsZWRBcmcpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChleHBlY3RlZEFyZykge1xuICAgICAgICAgICAgICAgICAgICBleHBlY3RlZEFyZyA9IHF1b3RlU3RyaW5nVmFsdWUoZXhwZWN0ZWRBcmcpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgKz0gXCJcXG5cIjtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGNhbGxlZEFyZ01lc3NhZ2UgPVxuICAgICAgICAgICAgICAgICAgICBqIDwgY2FsbGVkQXJncy5sZW5ndGggPyBpbnNwZWN0KGNhbGxlZEFyZykgOiBcIlwiO1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaC5pc01hdGNoZXIoZXhwZWN0ZWRBcmcpKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgKz0gY29sb3JTaW5vbk1hdGNoVGV4dChcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkQXJnLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGVkQXJnLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGVkQXJnTWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBleHBlY3RlZEFyZ01lc3NhZ2UgPVxuICAgICAgICAgICAgICAgICAgICAgICAgaiA8IGV4cGVjdGVkQXJncy5sZW5ndGggPyBpbnNwZWN0KGV4cGVjdGVkQXJnKSA6IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRpZmYgPSBqc0RpZmYuZGlmZkpzb24oXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsZWRBcmdNZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWRBcmdNZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlICs9IGNvbG9yRGlmZlRleHQoZGlmZik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcblxuICAgIEM6IGZ1bmN0aW9uIChzcHlJbnN0YW5jZSkge1xuICAgICAgICBjb25zdCBjYWxscyA9IFtdO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gc3B5SW5zdGFuY2UuY2FsbENvdW50OyBpIDwgbDsgKytpKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHNpbm9uanMvbm8tcHJvdG90eXBlLW1ldGhvZHMvbm8tcHJvdG90eXBlLW1ldGhvZHNcbiAgICAgICAgICAgIGxldCBzdHJpbmdpZmllZENhbGwgPSBgICAgICR7c3B5SW5zdGFuY2UuZ2V0Q2FsbChpKS50b1N0cmluZygpfWA7XG4gICAgICAgICAgICBpZiAoL1xcbi8udGVzdChjYWxsc1tpIC0gMV0pKSB7XG4gICAgICAgICAgICAgICAgc3RyaW5naWZpZWRDYWxsID0gYFxcbiR7c3RyaW5naWZpZWRDYWxsfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwdXNoKGNhbGxzLCBzdHJpbmdpZmllZENhbGwpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNhbGxzLmxlbmd0aCA+IDAgPyBgXFxuJHtqb2luKGNhbGxzLCBcIlxcblwiKX1gIDogXCJcIjtcbiAgICB9LFxuXG4gICAgdDogZnVuY3Rpb24gKHNweUluc3RhbmNlKSB7XG4gICAgICAgIGNvbnN0IG9iamVjdHMgPSBbXTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMCwgbCA9IHNweUluc3RhbmNlLmNhbGxDb3VudDsgaSA8IGw7ICsraSkge1xuICAgICAgICAgICAgcHVzaChvYmplY3RzLCBpbnNwZWN0KHNweUluc3RhbmNlLnRoaXNWYWx1ZXNbaV0pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBqb2luKG9iamVjdHMsIFwiLCBcIik7XG4gICAgfSxcblxuICAgIFwiKlwiOiBmdW5jdGlvbiAoc3B5SW5zdGFuY2UsIGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIGpvaW4oXG4gICAgICAgICAgICBtYXAoYXJncywgZnVuY3Rpb24gKGFyZykge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbnNwZWN0KGFyZyk7XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIFwiLCBcIixcbiAgICAgICAgKTtcbiAgICB9LFxufTtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuY29uc3QgYXJyYXlQcm90byA9IHJlcXVpcmUoXCJAc2lub25qcy9jb21tb25zXCIpLnByb3RvdHlwZXMuYXJyYXk7XG5jb25zdCBleHRlbmQgPSByZXF1aXJlKFwiLi91dGlsL2NvcmUvZXh0ZW5kXCIpO1xuY29uc3QgZnVuY3Rpb25Ub1N0cmluZyA9IHJlcXVpcmUoXCIuL3V0aWwvY29yZS9mdW5jdGlvbi10by1zdHJpbmdcIik7XG5jb25zdCBwcm94eUNhbGwgPSByZXF1aXJlKFwiLi9wcm94eS1jYWxsXCIpO1xuY29uc3QgcHJveHlDYWxsVXRpbCA9IHJlcXVpcmUoXCIuL3Byb3h5LWNhbGwtdXRpbFwiKTtcbmNvbnN0IHByb3h5SW52b2tlID0gcmVxdWlyZShcIi4vcHJveHktaW52b2tlXCIpO1xuY29uc3QgaW5zcGVjdCA9IHJlcXVpcmUoXCJ1dGlsXCIpLmluc3BlY3Q7XG5cbmNvbnN0IHB1c2ggPSBhcnJheVByb3RvLnB1c2g7XG5jb25zdCBmb3JFYWNoID0gYXJyYXlQcm90by5mb3JFYWNoO1xuY29uc3Qgc2xpY2UgPSBhcnJheVByb3RvLnNsaWNlO1xuXG5jb25zdCBlbXB0eUZha2VzID0gT2JqZWN0LmZyZWV6ZShbXSk7XG5cbi8vIFB1YmxpYyBBUElcbmNvbnN0IHByb3h5QXBpID0ge1xuICAgIHRvU3RyaW5nOiBmdW5jdGlvblRvU3RyaW5nLFxuXG4gICAgbmFtZWQ6IGZ1bmN0aW9uIG5hbWVkKG5hbWUpIHtcbiAgICAgICAgdGhpcy5kaXNwbGF5TmFtZSA9IG5hbWU7XG4gICAgICAgIGNvbnN0IG5hbWVEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0aGlzLCBcIm5hbWVcIik7XG4gICAgICAgIGlmIChuYW1lRGVzY3JpcHRvciAmJiBuYW1lRGVzY3JpcHRvci5jb25maWd1cmFibGUpIHtcbiAgICAgICAgICAgIC8vIElFIDExIGZ1bmN0aW9ucyBkb24ndCBoYXZlIGEgbmFtZS5cbiAgICAgICAgICAgIC8vIFNhZmFyaSA5IGhhcyBuYW1lcyB0aGF0IGFyZSBub3QgY29uZmlndXJhYmxlLlxuICAgICAgICAgICAgbmFtZURlc2NyaXB0b3IudmFsdWUgPSBuYW1lO1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCBuYW1lRGVzY3JpcHRvcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGludm9rZTogcHJveHlJbnZva2UsXG5cbiAgICAvKlxuICAgICAqIEhvb2sgZm9yIGRlcml2ZWQgaW1wbGVtZW50YXRpb24gdG8gcmV0dXJuIGZha2UgaW5zdGFuY2VzIG1hdGNoaW5nIHRoZVxuICAgICAqIGdpdmVuIGFyZ3VtZW50cy5cbiAgICAgKi9cbiAgICBtYXRjaGluZ0Zha2VzOiBmdW5jdGlvbiAoLyphcmdzLCBzdHJpY3QqLykge1xuICAgICAgICByZXR1cm4gZW1wdHlGYWtlcztcbiAgICB9LFxuXG4gICAgZ2V0Q2FsbDogZnVuY3Rpb24gZ2V0Q2FsbChpbmRleCkge1xuICAgICAgICBsZXQgaSA9IGluZGV4O1xuICAgICAgICBpZiAoaSA8IDApIHtcbiAgICAgICAgICAgIC8vIE5lZ2F0aXZlIGluZGljZXMgbWVhbnMgY291bnRpbmcgYmFja3dhcmRzIGZyb20gdGhlIGxhc3QgY2FsbFxuICAgICAgICAgICAgaSArPSB0aGlzLmNhbGxDb3VudDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaSA8IDAgfHwgaSA+PSB0aGlzLmNhbGxDb3VudCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcHJveHlDYWxsKFxuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgIHRoaXMudGhpc1ZhbHVlc1tpXSxcbiAgICAgICAgICAgIHRoaXMuYXJnc1tpXSxcbiAgICAgICAgICAgIHRoaXMucmV0dXJuVmFsdWVzW2ldLFxuICAgICAgICAgICAgdGhpcy5leGNlcHRpb25zW2ldLFxuICAgICAgICAgICAgdGhpcy5jYWxsSWRzW2ldLFxuICAgICAgICAgICAgdGhpcy5lcnJvcnNXaXRoQ2FsbFN0YWNrW2ldLFxuICAgICAgICApO1xuICAgIH0sXG5cbiAgICBnZXRDYWxsczogZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zdCBjYWxscyA9IFtdO1xuICAgICAgICBsZXQgaTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5jYWxsQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgcHVzaChjYWxscywgdGhpcy5nZXRDYWxsKGkpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjYWxscztcbiAgICB9LFxuXG4gICAgY2FsbGVkQmVmb3JlOiBmdW5jdGlvbiBjYWxsZWRCZWZvcmUocHJveHkpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNhbGxlZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFwcm94eS5jYWxsZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbElkc1swXSA8IHByb3h5LmNhbGxJZHNbcHJveHkuY2FsbElkcy5sZW5ndGggLSAxXTtcbiAgICB9LFxuXG4gICAgY2FsbGVkQWZ0ZXI6IGZ1bmN0aW9uIGNhbGxlZEFmdGVyKHByb3h5KSB7XG4gICAgICAgIGlmICghdGhpcy5jYWxsZWQgfHwgIXByb3h5LmNhbGxlZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbElkc1t0aGlzLmNhbGxDb3VudCAtIDFdID4gcHJveHkuY2FsbElkc1swXTtcbiAgICB9LFxuXG4gICAgY2FsbGVkSW1tZWRpYXRlbHlCZWZvcmU6IGZ1bmN0aW9uIGNhbGxlZEltbWVkaWF0ZWx5QmVmb3JlKHByb3h5KSB7XG4gICAgICAgIGlmICghdGhpcy5jYWxsZWQgfHwgIXByb3h5LmNhbGxlZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHRoaXMuY2FsbElkc1t0aGlzLmNhbGxDb3VudCAtIDFdID09PVxuICAgICAgICAgICAgcHJveHkuY2FsbElkc1twcm94eS5jYWxsQ291bnQgLSAxXSAtIDFcbiAgICAgICAgKTtcbiAgICB9LFxuXG4gICAgY2FsbGVkSW1tZWRpYXRlbHlBZnRlcjogZnVuY3Rpb24gY2FsbGVkSW1tZWRpYXRlbHlBZnRlcihwcm94eSkge1xuICAgICAgICBpZiAoIXRoaXMuY2FsbGVkIHx8ICFwcm94eS5jYWxsZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB0aGlzLmNhbGxJZHNbdGhpcy5jYWxsQ291bnQgLSAxXSA9PT1cbiAgICAgICAgICAgIHByb3h5LmNhbGxJZHNbcHJveHkuY2FsbENvdW50IC0gMV0gKyAxXG4gICAgICAgICk7XG4gICAgfSxcblxuICAgIGZvcm1hdHRlcnM6IHJlcXVpcmUoXCIuL3NweS1mb3JtYXR0ZXJzXCIpLFxuICAgIHByaW50ZjogZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgICBjb25zdCBzcHlJbnN0YW5jZSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSBzbGljZShhcmd1bWVudHMsIDEpO1xuICAgICAgICBsZXQgZm9ybWF0dGVyO1xuXG4gICAgICAgIHJldHVybiAoZm9ybWF0IHx8IFwiXCIpLnJlcGxhY2UoLyUoLikvZywgZnVuY3Rpb24gKG1hdGNoLCBzcGVjaWZpZXIpIHtcbiAgICAgICAgICAgIGZvcm1hdHRlciA9IHByb3h5QXBpLmZvcm1hdHRlcnNbc3BlY2lmaWVyXTtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBmb3JtYXR0ZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBTdHJpbmcoZm9ybWF0dGVyKHNweUluc3RhbmNlLCBhcmdzKSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFpc05hTihwYXJzZUludChzcGVjaWZpZXIsIDEwKSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5zcGVjdChhcmdzW3NwZWNpZmllciAtIDFdKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGAlJHtzcGVjaWZpZXJ9YDtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIHJlc2V0SGlzdG9yeTogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5pbnZva2luZykge1xuICAgICAgICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgIFwiQ2Fubm90IHJlc2V0IFNpbm9uIGZ1bmN0aW9uIHdoaWxlIGludm9raW5nIGl0LiBcIiArXG4gICAgICAgICAgICAgICAgICAgIFwiTW92ZSB0aGUgY2FsbCB0byAucmVzZXRIaXN0b3J5IG91dHNpZGUgb2YgdGhlIGNhbGxiYWNrLlwiLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGVyci5uYW1lID0gXCJJbnZhbGlkUmVzZXRFeGNlcHRpb25cIjtcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY2FsbGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMubm90Q2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5jYWxsZWRPbmNlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY2FsbGVkVHdpY2UgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jYWxsZWRUaHJpY2UgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jYWxsQ291bnQgPSAwO1xuICAgICAgICB0aGlzLmZpcnN0Q2FsbCA9IG51bGw7XG4gICAgICAgIHRoaXMuc2Vjb25kQ2FsbCA9IG51bGw7XG4gICAgICAgIHRoaXMudGhpcmRDYWxsID0gbnVsbDtcbiAgICAgICAgdGhpcy5sYXN0Q2FsbCA9IG51bGw7XG4gICAgICAgIHRoaXMuYXJncyA9IFtdO1xuICAgICAgICB0aGlzLmZpcnN0QXJnID0gbnVsbDtcbiAgICAgICAgdGhpcy5sYXN0QXJnID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZXR1cm5WYWx1ZXMgPSBbXTtcbiAgICAgICAgdGhpcy50aGlzVmFsdWVzID0gW107XG4gICAgICAgIHRoaXMuZXhjZXB0aW9ucyA9IFtdO1xuICAgICAgICB0aGlzLmNhbGxJZHMgPSBbXTtcbiAgICAgICAgdGhpcy5lcnJvcnNXaXRoQ2FsbFN0YWNrID0gW107XG5cbiAgICAgICAgaWYgKHRoaXMuZmFrZXMpIHtcbiAgICAgICAgICAgIGZvckVhY2godGhpcy5mYWtlcywgZnVuY3Rpb24gKGZha2UpIHtcbiAgICAgICAgICAgICAgICBmYWtlLnJlc2V0SGlzdG9yeSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxufTtcblxuY29uc3QgZGVsZWdhdGVUb0NhbGxzID0gcHJveHlDYWxsVXRpbC5kZWxlZ2F0ZVRvQ2FsbHM7XG5kZWxlZ2F0ZVRvQ2FsbHMocHJveHlBcGksIFwiY2FsbGVkT25cIiwgdHJ1ZSk7XG5kZWxlZ2F0ZVRvQ2FsbHMocHJveHlBcGksIFwiYWx3YXlzQ2FsbGVkT25cIiwgZmFsc2UsIFwiY2FsbGVkT25cIik7XG5kZWxlZ2F0ZVRvQ2FsbHMocHJveHlBcGksIFwiY2FsbGVkV2l0aFwiLCB0cnVlKTtcbmRlbGVnYXRlVG9DYWxscyhcbiAgICBwcm94eUFwaSxcbiAgICBcImNhbGxlZE9uY2VXaXRoXCIsXG4gICAgdHJ1ZSxcbiAgICBcImNhbGxlZFdpdGhcIixcbiAgICBmYWxzZSxcbiAgICB1bmRlZmluZWQsXG4gICAgMSxcbik7XG5kZWxlZ2F0ZVRvQ2FsbHMocHJveHlBcGksIFwiY2FsbGVkV2l0aE1hdGNoXCIsIHRydWUpO1xuZGVsZWdhdGVUb0NhbGxzKHByb3h5QXBpLCBcImFsd2F5c0NhbGxlZFdpdGhcIiwgZmFsc2UsIFwiY2FsbGVkV2l0aFwiKTtcbmRlbGVnYXRlVG9DYWxscyhwcm94eUFwaSwgXCJhbHdheXNDYWxsZWRXaXRoTWF0Y2hcIiwgZmFsc2UsIFwiY2FsbGVkV2l0aE1hdGNoXCIpO1xuZGVsZWdhdGVUb0NhbGxzKHByb3h5QXBpLCBcImNhbGxlZFdpdGhFeGFjdGx5XCIsIHRydWUpO1xuZGVsZWdhdGVUb0NhbGxzKFxuICAgIHByb3h5QXBpLFxuICAgIFwiY2FsbGVkT25jZVdpdGhFeGFjdGx5XCIsXG4gICAgdHJ1ZSxcbiAgICBcImNhbGxlZFdpdGhFeGFjdGx5XCIsXG4gICAgZmFsc2UsXG4gICAgdW5kZWZpbmVkLFxuICAgIDEsXG4pO1xuZGVsZWdhdGVUb0NhbGxzKFxuICAgIHByb3h5QXBpLFxuICAgIFwiY2FsbGVkT25jZVdpdGhNYXRjaFwiLFxuICAgIHRydWUsXG4gICAgXCJjYWxsZWRXaXRoTWF0Y2hcIixcbiAgICBmYWxzZSxcbiAgICB1bmRlZmluZWQsXG4gICAgMSxcbik7XG5kZWxlZ2F0ZVRvQ2FsbHMoXG4gICAgcHJveHlBcGksXG4gICAgXCJhbHdheXNDYWxsZWRXaXRoRXhhY3RseVwiLFxuICAgIGZhbHNlLFxuICAgIFwiY2FsbGVkV2l0aEV4YWN0bHlcIixcbik7XG5kZWxlZ2F0ZVRvQ2FsbHMoXG4gICAgcHJveHlBcGksXG4gICAgXCJuZXZlckNhbGxlZFdpdGhcIixcbiAgICBmYWxzZSxcbiAgICBcIm5vdENhbGxlZFdpdGhcIixcbiAgICBmYWxzZSxcbiAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG4pO1xuZGVsZWdhdGVUb0NhbGxzKFxuICAgIHByb3h5QXBpLFxuICAgIFwibmV2ZXJDYWxsZWRXaXRoTWF0Y2hcIixcbiAgICBmYWxzZSxcbiAgICBcIm5vdENhbGxlZFdpdGhNYXRjaFwiLFxuICAgIGZhbHNlLFxuICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcbik7XG5kZWxlZ2F0ZVRvQ2FsbHMocHJveHlBcGksIFwidGhyZXdcIiwgdHJ1ZSk7XG5kZWxlZ2F0ZVRvQ2FsbHMocHJveHlBcGksIFwiYWx3YXlzVGhyZXdcIiwgZmFsc2UsIFwidGhyZXdcIik7XG5kZWxlZ2F0ZVRvQ2FsbHMocHJveHlBcGksIFwicmV0dXJuZWRcIiwgdHJ1ZSk7XG5kZWxlZ2F0ZVRvQ2FsbHMocHJveHlBcGksIFwiYWx3YXlzUmV0dXJuZWRcIiwgZmFsc2UsIFwicmV0dXJuZWRcIik7XG5kZWxlZ2F0ZVRvQ2FsbHMocHJveHlBcGksIFwiY2FsbGVkV2l0aE5ld1wiLCB0cnVlKTtcbmRlbGVnYXRlVG9DYWxscyhwcm94eUFwaSwgXCJhbHdheXNDYWxsZWRXaXRoTmV3XCIsIGZhbHNlLCBcImNhbGxlZFdpdGhOZXdcIik7XG5cbmZ1bmN0aW9uIGNyZWF0ZVByb3h5KGZ1bmMsIG9yaWdpbmFsRnVuYykge1xuICAgIGNvbnN0IHByb3h5ID0gd3JhcEZ1bmN0aW9uKGZ1bmMsIG9yaWdpbmFsRnVuYyk7XG5cbiAgICAvLyBJbmhlcml0IGZ1bmN0aW9uIHByb3BlcnRpZXM6XG4gICAgZXh0ZW5kKHByb3h5LCBmdW5jKTtcblxuICAgIHByb3h5LnByb3RvdHlwZSA9IGZ1bmMucHJvdG90eXBlO1xuXG4gICAgZXh0ZW5kLm5vbkVudW0ocHJveHksIHByb3h5QXBpKTtcblxuICAgIHJldHVybiBwcm94eTtcbn1cblxuZnVuY3Rpb24gd3JhcEZ1bmN0aW9uKGZ1bmMsIG9yaWdpbmFsRnVuYykge1xuICAgIGNvbnN0IGFyaXR5ID0gb3JpZ2luYWxGdW5jLmxlbmd0aDtcbiAgICBsZXQgcDtcbiAgICAvLyBEbyBub3QgY2hhbmdlIHRoaXMgdG8gdXNlIGFuIGV2YWwuIFByb2plY3RzIHRoYXQgZGVwZW5kIG9uIHNpbm9uIGJsb2NrIHRoZSB1c2Ugb2YgZXZhbC5cbiAgICAvLyByZWY6IGh0dHBzOi8vZ2l0aHViLmNvbS9zaW5vbmpzL3Npbm9uL2lzc3Vlcy83MTBcbiAgICBzd2l0Y2ggKGFyaXR5KSB7XG4gICAgICAgIC8qZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMsIG1heC1sZW4qL1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBwID0gZnVuY3Rpb24gcHJveHkoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHAuaW52b2tlKGZ1bmMsIHRoaXMsIHNsaWNlKGFyZ3VtZW50cykpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBwID0gZnVuY3Rpb24gcHJveHkoYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwLmludm9rZShmdW5jLCB0aGlzLCBzbGljZShhcmd1bWVudHMpKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgcCA9IGZ1bmN0aW9uIHByb3h5KGEsIGIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcC5pbnZva2UoZnVuYywgdGhpcywgc2xpY2UoYXJndW1lbnRzKSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHAgPSBmdW5jdGlvbiBwcm94eShhLCBiLCBjKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHAuaW52b2tlKGZ1bmMsIHRoaXMsIHNsaWNlKGFyZ3VtZW50cykpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICBwID0gZnVuY3Rpb24gcHJveHkoYSwgYiwgYywgZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwLmludm9rZShmdW5jLCB0aGlzLCBzbGljZShhcmd1bWVudHMpKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgcCA9IGZ1bmN0aW9uIHByb3h5KGEsIGIsIGMsIGQsIGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcC5pbnZva2UoZnVuYywgdGhpcywgc2xpY2UoYXJndW1lbnRzKSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgIHAgPSBmdW5jdGlvbiBwcm94eShhLCBiLCBjLCBkLCBlLCBmKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHAuaW52b2tlKGZ1bmMsIHRoaXMsIHNsaWNlKGFyZ3VtZW50cykpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICBwID0gZnVuY3Rpb24gcHJveHkoYSwgYiwgYywgZCwgZSwgZiwgZykge1xuICAgICAgICAgICAgICAgIHJldHVybiBwLmludm9rZShmdW5jLCB0aGlzLCBzbGljZShhcmd1bWVudHMpKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgcCA9IGZ1bmN0aW9uIHByb3h5KGEsIGIsIGMsIGQsIGUsIGYsIGcsIGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcC5pbnZva2UoZnVuYywgdGhpcywgc2xpY2UoYXJndW1lbnRzKSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgIHAgPSBmdW5jdGlvbiBwcm94eShhLCBiLCBjLCBkLCBlLCBmLCBnLCBoLCBpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHAuaW52b2tlKGZ1bmMsIHRoaXMsIHNsaWNlKGFyZ3VtZW50cykpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgcCA9IGZ1bmN0aW9uIHByb3h5KGEsIGIsIGMsIGQsIGUsIGYsIGcsIGgsIGksIGopIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcC5pbnZva2UoZnVuYywgdGhpcywgc2xpY2UoYXJndW1lbnRzKSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICBwID0gZnVuY3Rpb24gcHJveHkoYSwgYiwgYywgZCwgZSwgZiwgZywgaCwgaSwgaiwgaykge1xuICAgICAgICAgICAgICAgIHJldHVybiBwLmludm9rZShmdW5jLCB0aGlzLCBzbGljZShhcmd1bWVudHMpKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgIHAgPSBmdW5jdGlvbiBwcm94eShhLCBiLCBjLCBkLCBlLCBmLCBnLCBoLCBpLCBqLCBrLCBsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHAuaW52b2tlKGZ1bmMsIHRoaXMsIHNsaWNlKGFyZ3VtZW50cykpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcCA9IGZ1bmN0aW9uIHByb3h5KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwLmludm9rZShmdW5jLCB0aGlzLCBzbGljZShhcmd1bWVudHMpKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgLyplc2xpbnQtZW5hYmxlKi9cbiAgICB9XG4gICAgY29uc3QgbmFtZURlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKFxuICAgICAgICBvcmlnaW5hbEZ1bmMsXG4gICAgICAgIFwibmFtZVwiLFxuICAgICk7XG4gICAgaWYgKG5hbWVEZXNjcmlwdG9yICYmIG5hbWVEZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSkge1xuICAgICAgICAvLyBJRSAxMSBmdW5jdGlvbnMgZG9uJ3QgaGF2ZSBhIG5hbWUuXG4gICAgICAgIC8vIFNhZmFyaSA5IGhhcyBuYW1lcyB0aGF0IGFyZSBub3QgY29uZmlndXJhYmxlLlxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocCwgXCJuYW1lXCIsIG5hbWVEZXNjcmlwdG9yKTtcbiAgICB9XG4gICAgZXh0ZW5kLm5vbkVudW0ocCwge1xuICAgICAgICBpc1Npbm9uUHJveHk6IHRydWUsXG5cbiAgICAgICAgY2FsbGVkOiBmYWxzZSxcbiAgICAgICAgbm90Q2FsbGVkOiB0cnVlLFxuICAgICAgICBjYWxsZWRPbmNlOiBmYWxzZSxcbiAgICAgICAgY2FsbGVkVHdpY2U6IGZhbHNlLFxuICAgICAgICBjYWxsZWRUaHJpY2U6IGZhbHNlLFxuICAgICAgICBjYWxsQ291bnQ6IDAsXG4gICAgICAgIGZpcnN0Q2FsbDogbnVsbCxcbiAgICAgICAgZmlyc3RBcmc6IG51bGwsXG4gICAgICAgIHNlY29uZENhbGw6IG51bGwsXG4gICAgICAgIHRoaXJkQ2FsbDogbnVsbCxcbiAgICAgICAgbGFzdENhbGw6IG51bGwsXG4gICAgICAgIGxhc3RBcmc6IG51bGwsXG4gICAgICAgIGFyZ3M6IFtdLFxuICAgICAgICByZXR1cm5WYWx1ZXM6IFtdLFxuICAgICAgICB0aGlzVmFsdWVzOiBbXSxcbiAgICAgICAgZXhjZXB0aW9uczogW10sXG4gICAgICAgIGNhbGxJZHM6IFtdLFxuICAgICAgICBlcnJvcnNXaXRoQ2FsbFN0YWNrOiBbXSxcbiAgICB9KTtcbiAgICByZXR1cm4gcDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVQcm94eTtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBAcGFyYW0geyp9IG9iamVjdFxuICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gd2hldGhlciBhIHByb3AgZXhpc3RzIGluIHRoZSBwcm90b3R5cGUgY2hhaW5cbiAqL1xuZnVuY3Rpb24gaXNOb25FeGlzdGVudFByb3BlcnR5KG9iamVjdCwgcHJvcGVydHkpIHtcbiAgICByZXR1cm4gQm9vbGVhbihcbiAgICAgICAgb2JqZWN0ICYmIHR5cGVvZiBwcm9wZXJ0eSAhPT0gXCJ1bmRlZmluZWRcIiAmJiAhKHByb3BlcnR5IGluIG9iamVjdCksXG4gICAgKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc05vbkV4aXN0ZW50UHJvcGVydHk7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogVmVyaWZ5IGlmIGFuIG9iamVjdCBpcyBhIEVDTUFTY3JpcHQgTW9kdWxlXG4gKlxuICogQXMgdGhlIGV4cG9ydHMgZnJvbSBhIG1vZHVsZSBpcyBpbW11dGFibGUgd2UgY2Fubm90IGFsdGVyIHRoZSBleHBvcnRzXG4gKiB1c2luZyBzcGllcyBvciBzdHVicy4gTGV0IHRoZSBjb25zdW1lciBrbm93IHRoaXMgdG8gYXZvaWQgYnVnIHJlcG9ydHNcbiAqIG9uIHdlaXJkIGVycm9yIG1lc3NhZ2VzLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBleGFtaW5lXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSB3aGVuIHRoZSBvYmplY3QgaXMgYSBtb2R1bGVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgcmV0dXJuIChcbiAgICAgICAgb2JqZWN0ICYmXG4gICAgICAgIHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICAgICAgb2JqZWN0W1N5bWJvbC50b1N0cmluZ1RhZ10gPT09IFwiTW9kdWxlXCIgJiZcbiAgICAgICAgT2JqZWN0LmlzU2VhbGVkKG9iamVjdClcbiAgICApO1xufTtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuY29uc3QgZnVuY3Rpb25OYW1lID0gcmVxdWlyZShcIkBzaW5vbmpzL2NvbW1vbnNcIikuZnVuY3Rpb25OYW1lO1xuXG5jb25zdCBnZXRQcm9wZXJ0eURlc2NyaXB0b3IgPSByZXF1aXJlKFwiLi9nZXQtcHJvcGVydHktZGVzY3JpcHRvclwiKTtcbmNvbnN0IHdhbGsgPSByZXF1aXJlKFwiLi93YWxrXCIpO1xuXG4vKipcbiAqIEEgdXRpbGl0eSB0aGF0IGFsbG93cyB0cmF2ZXJzaW5nIGFuIG9iamVjdCwgYXBwbHlpbmcgbXV0YXRpbmcgZnVuY3Rpb25zIG9uIHRoZSBwcm9wZXJ0aWVzXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gbXV0YXRvciBjYWxsZWQgb24gZWFjaCBwcm9wZXJ0eVxuICogQHBhcmFtIHtvYmplY3R9IG9iamVjdCB0aGUgb2JqZWN0IHdlIGFyZSB3YWxraW5nIG92ZXJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZpbHRlciBhIHByZWRpY2F0ZSAoYm9vbGVhbiBmdW5jdGlvbikgdGhhdCB3aWxsIGRlY2lkZSB3aGV0aGVyIG9yIG5vdCB0byBhcHBseSB0aGUgbXV0YXRvciB0byB0aGUgY3VycmVudCBwcm9wZXJ0eVxuICogQHJldHVybnMge3ZvaWR9IG5vdGhpbmdcbiAqL1xuZnVuY3Rpb24gd2Fsa09iamVjdChtdXRhdG9yLCBvYmplY3QsIGZpbHRlcikge1xuICAgIGxldCBjYWxsZWQgPSBmYWxzZTtcbiAgICBjb25zdCBuYW1lID0gZnVuY3Rpb25OYW1lKG11dGF0b3IpO1xuXG4gICAgaWYgKCFvYmplY3QpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYFRyeWluZyB0byAke25hbWV9IG9iamVjdCBidXQgcmVjZWl2ZWQgJHtTdHJpbmcob2JqZWN0KX1gLFxuICAgICAgICApO1xuICAgIH1cblxuICAgIHdhbGsob2JqZWN0LCBmdW5jdGlvbiAocHJvcCwgcHJvcE93bmVyKSB7XG4gICAgICAgIC8vIHdlIGRvbid0IHdhbnQgdG8gc3R1YiB0aGluZ3MgbGlrZSB0b1N0cmluZygpLCB2YWx1ZU9mKCksIGV0Yy4gc28gd2Ugb25seSBzdHViIGlmIHRoZSBvYmplY3RcbiAgICAgICAgLy8gaXMgbm90IE9iamVjdC5wcm90b3R5cGVcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgcHJvcE93bmVyICE9PSBPYmplY3QucHJvdG90eXBlICYmXG4gICAgICAgICAgICBwcm9wICE9PSBcImNvbnN0cnVjdG9yXCIgJiZcbiAgICAgICAgICAgIHR5cGVvZiBnZXRQcm9wZXJ0eURlc2NyaXB0b3IocHJvcE93bmVyLCBwcm9wKS52YWx1ZSA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgICkge1xuICAgICAgICAgICAgaWYgKGZpbHRlcikge1xuICAgICAgICAgICAgICAgIGlmIChmaWx0ZXIob2JqZWN0LCBwcm9wKSkge1xuICAgICAgICAgICAgICAgICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBtdXRhdG9yKG9iamVjdCwgcHJvcCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIG11dGF0b3Iob2JqZWN0LCBwcm9wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKCFjYWxsZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYEZvdW5kIG5vIG1ldGhvZHMgb24gb2JqZWN0IHRvIHdoaWNoIHdlIGNvdWxkIGFwcGx5IG11dGF0aW9uc2AsXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9iamVjdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB3YWxrT2JqZWN0O1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5jb25zdCBzaW5vblR5cGVTeW1ib2xQcm9wZXJ0eSA9IFN5bWJvbChcIlNpbm9uVHlwZVwiKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSB0eXBlIG9mIGEgU2lub24gb2JqZWN0IHRvIG1ha2UgaXQgcG9zc2libGUgdG8gaWRlbnRpZnkgaXQgbGF0ZXIgYXQgcnVudGltZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R8RnVuY3Rpb259IG9iamVjdCAgb2JqZWN0L2Z1bmN0aW9uIHRvIHNldCB0aGUgdHlwZSBvblxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIHRoZSBuYW1lZCB0eXBlIG9mIHRoZSBvYmplY3QvZnVuY3Rpb25cbiAgICAgKi9cbiAgICBzZXQob2JqZWN0LCB0eXBlKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsIHNpbm9uVHlwZVN5bWJvbFByb3BlcnR5LCB7XG4gICAgICAgICAgICB2YWx1ZTogdHlwZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBnZXQob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiBvYmplY3QgJiYgb2JqZWN0W3Npbm9uVHlwZVN5bWJvbFByb3BlcnR5XTtcbiAgICB9LFxufTtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWVtcHR5LWZ1bmN0aW9uXG5jb25zdCBub29wID0gKCkgPT4ge307XG5jb25zdCBnZXRQcm9wZXJ0eURlc2NyaXB0b3IgPSByZXF1aXJlKFwiLi9nZXQtcHJvcGVydHktZGVzY3JpcHRvclwiKTtcbmNvbnN0IGV4dGVuZCA9IHJlcXVpcmUoXCIuL2V4dGVuZFwiKTtcbmNvbnN0IHNpbm9uVHlwZSA9IHJlcXVpcmUoXCIuL3Npbm9uLXR5cGVcIik7XG5jb25zdCBoYXNPd25Qcm9wZXJ0eSA9XG4gICAgcmVxdWlyZShcIkBzaW5vbmpzL2NvbW1vbnNcIikucHJvdG90eXBlcy5vYmplY3QuaGFzT3duUHJvcGVydHk7XG5jb25zdCB2YWx1ZVRvU3RyaW5nID0gcmVxdWlyZShcIkBzaW5vbmpzL2NvbW1vbnNcIikudmFsdWVUb1N0cmluZztcbmNvbnN0IHB1c2ggPSByZXF1aXJlKFwiQHNpbm9uanMvY29tbW9uc1wiKS5wcm90b3R5cGVzLmFycmF5LnB1c2g7XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIChcbiAgICAgICAgdHlwZW9mIG9iaiA9PT0gXCJmdW5jdGlvblwiIHx8XG4gICAgICAgIEJvb2xlYW4ob2JqICYmIG9iai5jb25zdHJ1Y3RvciAmJiBvYmouY2FsbCAmJiBvYmouYXBwbHkpXG4gICAgKTtcbn1cblxuZnVuY3Rpb24gbWlycm9yUHJvcGVydGllcyh0YXJnZXQsIHNvdXJjZSkge1xuICAgIGZvciAoY29uc3QgcHJvcCBpbiBzb3VyY2UpIHtcbiAgICAgICAgaWYgKCFoYXNPd25Qcm9wZXJ0eSh0YXJnZXQsIHByb3ApKSB7XG4gICAgICAgICAgICB0YXJnZXRbcHJvcF0gPSBzb3VyY2VbcHJvcF07XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIGdldEFjY2Vzc29yKG9iamVjdCwgcHJvcGVydHksIG1ldGhvZCkge1xuICAgIGNvbnN0IGFjY2Vzc29ycyA9IFtcImdldFwiLCBcInNldFwiXTtcbiAgICBjb25zdCBkZXNjcmlwdG9yID0gZ2V0UHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhY2Nlc3NvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgZGVzY3JpcHRvclthY2Nlc3NvcnNbaV1dICYmXG4gICAgICAgICAgICBkZXNjcmlwdG9yW2FjY2Vzc29yc1tpXV0ubmFtZSA9PT0gbWV0aG9kLm5hbWVcbiAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gYWNjZXNzb3JzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuXG4vLyBDaGVhcCB3YXkgdG8gZGV0ZWN0IGlmIHdlIGhhdmUgRVM1IHN1cHBvcnQuXG5jb25zdCBoYXNFUzVTdXBwb3J0ID0gXCJrZXlzXCIgaW4gT2JqZWN0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHdyYXBNZXRob2Qob2JqZWN0LCBwcm9wZXJ0eSwgbWV0aG9kKSB7XG4gICAgaWYgKCFvYmplY3QpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlNob3VsZCB3cmFwIHByb3BlcnR5IG9mIG9iamVjdFwiKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG1ldGhvZCAhPT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBtZXRob2QgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgIFwiTWV0aG9kIHdyYXBwZXIgc2hvdWxkIGJlIGEgZnVuY3Rpb24gb3IgYSBwcm9wZXJ0eSBkZXNjcmlwdG9yXCIsXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2hlY2tXcmFwcGVkTWV0aG9kKHdyYXBwZWRNZXRob2QpIHtcbiAgICAgICAgbGV0IGVycm9yO1xuXG4gICAgICAgIGlmICghaXNGdW5jdGlvbih3cmFwcGVkTWV0aG9kKSkge1xuICAgICAgICAgICAgZXJyb3IgPSBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgICAgIGBBdHRlbXB0ZWQgdG8gd3JhcCAke3R5cGVvZiB3cmFwcGVkTWV0aG9kfSBwcm9wZXJ0eSAke3ZhbHVlVG9TdHJpbmcoXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnR5LFxuICAgICAgICAgICAgICAgICl9IGFzIGZ1bmN0aW9uYCxcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSBpZiAod3JhcHBlZE1ldGhvZC5yZXN0b3JlICYmIHdyYXBwZWRNZXRob2QucmVzdG9yZS5zaW5vbikge1xuICAgICAgICAgICAgZXJyb3IgPSBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgICAgIGBBdHRlbXB0ZWQgdG8gd3JhcCAke3ZhbHVlVG9TdHJpbmcoXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnR5LFxuICAgICAgICAgICAgICAgICl9IHdoaWNoIGlzIGFscmVhZHkgd3JhcHBlZGAsXG4gICAgICAgICAgICApO1xuICAgICAgICB9IGVsc2UgaWYgKHdyYXBwZWRNZXRob2QuY2FsbGVkQmVmb3JlKSB7XG4gICAgICAgICAgICBjb25zdCB2ZXJiID0gd3JhcHBlZE1ldGhvZC5yZXR1cm5zID8gXCJzdHViYmVkXCIgOiBcInNwaWVkIG9uXCI7XG4gICAgICAgICAgICBlcnJvciA9IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICAgICAgYEF0dGVtcHRlZCB0byB3cmFwICR7dmFsdWVUb1N0cmluZyhcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydHksXG4gICAgICAgICAgICAgICAgKX0gd2hpY2ggaXMgYWxyZWFkeSAke3ZlcmJ9YCxcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmICh3cmFwcGVkTWV0aG9kICYmIHdyYXBwZWRNZXRob2Quc3RhY2tUcmFjZUVycm9yKSB7XG4gICAgICAgICAgICAgICAgZXJyb3Iuc3RhY2sgKz0gYFxcbi0tLS0tLS0tLS0tLS0tXFxuJHt3cmFwcGVkTWV0aG9kLnN0YWNrVHJhY2VFcnJvci5zdGFja31gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgZXJyb3IsIHdyYXBwZWRNZXRob2QsIGksIHdyYXBwZWRNZXRob2REZXNjLCB0YXJnZXQsIGFjY2Vzc29yO1xuXG4gICAgY29uc3Qgd3JhcHBlZE1ldGhvZHMgPSBbXTtcblxuICAgIGZ1bmN0aW9uIHNpbXBsZVByb3BlcnR5QXNzaWdubWVudCgpIHtcbiAgICAgICAgd3JhcHBlZE1ldGhvZCA9IG9iamVjdFtwcm9wZXJ0eV07XG4gICAgICAgIGNoZWNrV3JhcHBlZE1ldGhvZCh3cmFwcGVkTWV0aG9kKTtcbiAgICAgICAgb2JqZWN0W3Byb3BlcnR5XSA9IG1ldGhvZDtcbiAgICAgICAgbWV0aG9kLmRpc3BsYXlOYW1lID0gcHJvcGVydHk7XG4gICAgfVxuXG4gICAgLy8gRmlyZWZveCBoYXMgYSBwcm9ibGVtIHdoZW4gdXNpbmcgaGFzT3duLmNhbGwgb24gb2JqZWN0cyBmcm9tIG90aGVyIGZyYW1lcy5cbiAgICBjb25zdCBvd25lZCA9IG9iamVjdC5oYXNPd25Qcm9wZXJ0eVxuICAgICAgICA/IG9iamVjdC5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eSkgLy8gZXNsaW50LWRpc2FibGUtbGluZSBAc2lub25qcy9uby1wcm90b3R5cGUtbWV0aG9kcy9uby1wcm90b3R5cGUtbWV0aG9kc1xuICAgICAgICA6IGhhc093blByb3BlcnR5KG9iamVjdCwgcHJvcGVydHkpO1xuXG4gICAgaWYgKGhhc0VTNVN1cHBvcnQpIHtcbiAgICAgICAgY29uc3QgbWV0aG9kRGVzYyA9XG4gICAgICAgICAgICB0eXBlb2YgbWV0aG9kID09PSBcImZ1bmN0aW9uXCIgPyB7IHZhbHVlOiBtZXRob2QgfSA6IG1ldGhvZDtcbiAgICAgICAgd3JhcHBlZE1ldGhvZERlc2MgPSBnZXRQcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7XG5cbiAgICAgICAgaWYgKCF3cmFwcGVkTWV0aG9kRGVzYykge1xuICAgICAgICAgICAgZXJyb3IgPSBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgICAgIGBBdHRlbXB0ZWQgdG8gd3JhcCAke3R5cGVvZiB3cmFwcGVkTWV0aG9kfSBwcm9wZXJ0eSAke3Byb3BlcnR5fSBhcyBmdW5jdGlvbmAsXG4gICAgICAgICAgICApO1xuICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgd3JhcHBlZE1ldGhvZERlc2MucmVzdG9yZSAmJlxuICAgICAgICAgICAgd3JhcHBlZE1ldGhvZERlc2MucmVzdG9yZS5zaW5vblxuICAgICAgICApIHtcbiAgICAgICAgICAgIGVycm9yID0gbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgICAgICBgQXR0ZW1wdGVkIHRvIHdyYXAgJHtwcm9wZXJ0eX0gd2hpY2ggaXMgYWxyZWFkeSB3cmFwcGVkYCxcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAod3JhcHBlZE1ldGhvZERlc2MgJiYgd3JhcHBlZE1ldGhvZERlc2Muc3RhY2tUcmFjZUVycm9yKSB7XG4gICAgICAgICAgICAgICAgZXJyb3Iuc3RhY2sgKz0gYFxcbi0tLS0tLS0tLS0tLS0tXFxuJHt3cmFwcGVkTWV0aG9kRGVzYy5zdGFja1RyYWNlRXJyb3Iuc3RhY2t9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdHlwZXMgPSBPYmplY3Qua2V5cyhtZXRob2REZXNjKTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHR5cGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB3cmFwcGVkTWV0aG9kID0gd3JhcHBlZE1ldGhvZERlc2NbdHlwZXNbaV1dO1xuICAgICAgICAgICAgY2hlY2tXcmFwcGVkTWV0aG9kKHdyYXBwZWRNZXRob2QpO1xuICAgICAgICAgICAgcHVzaCh3cmFwcGVkTWV0aG9kcywgd3JhcHBlZE1ldGhvZCk7XG4gICAgICAgIH1cblxuICAgICAgICBtaXJyb3JQcm9wZXJ0aWVzKG1ldGhvZERlc2MsIHdyYXBwZWRNZXRob2REZXNjKTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHR5cGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBtaXJyb3JQcm9wZXJ0aWVzKG1ldGhvZERlc2NbdHlwZXNbaV1dLCB3cmFwcGVkTWV0aG9kRGVzY1t0eXBlc1tpXV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8geW91IGFyZSBub3QgYWxsb3dlZCB0byBmbGlwIHRoZSBjb25maWd1cmFibGUgcHJvcCBvbiBhblxuICAgICAgICAvLyBleGlzdGluZyBkZXNjcmlwdG9yIHRvIGFueXRoaW5nIGJ1dCBmYWxzZSAoIzI1MTQpXG4gICAgICAgIGlmICghb3duZWQpIHtcbiAgICAgICAgICAgIG1ldGhvZERlc2MuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsIHByb3BlcnR5LCBtZXRob2REZXNjKTtcblxuICAgICAgICAvLyBjYXRjaCBmYWlsaW5nIGFzc2lnbm1lbnRcbiAgICAgICAgLy8gdGhpcyBpcyB0aGUgY29udmVyc2Ugb2YgdGhlIGNoZWNrIGluIGAucmVzdG9yZWAgYmVsb3dcbiAgICAgICAgaWYgKHR5cGVvZiBtZXRob2QgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmplY3RbcHJvcGVydHldICE9PSBtZXRob2QpIHtcbiAgICAgICAgICAgIC8vIGNvcnJlY3QgYW55IHdyb25nZG9pbmdzIGNhdXNlZCBieSB0aGUgZGVmaW5lUHJvcGVydHkgY2FsbCBhYm92ZSxcbiAgICAgICAgICAgIC8vIHN1Y2ggYXMgYWRkaW5nIG5ldyBpdGVtcyAoaWYgb2JqZWN0IHdhcyBhIFN0b3JhZ2Ugb2JqZWN0KVxuICAgICAgICAgICAgZGVsZXRlIG9iamVjdFtwcm9wZXJ0eV07XG4gICAgICAgICAgICBzaW1wbGVQcm9wZXJ0eUFzc2lnbm1lbnQoKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHNpbXBsZVByb3BlcnR5QXNzaWdubWVudCgpO1xuICAgIH1cblxuICAgIGV4dGVuZE9iamVjdFdpdGhXcmFwcGVkTWV0aG9kcygpO1xuXG4gICAgZnVuY3Rpb24gZXh0ZW5kT2JqZWN0V2l0aFdyYXBwZWRNZXRob2RzKCkge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgd3JhcHBlZE1ldGhvZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFjY2Vzc29yID0gZ2V0QWNjZXNzb3Iob2JqZWN0LCBwcm9wZXJ0eSwgd3JhcHBlZE1ldGhvZHNbaV0pO1xuICAgICAgICAgICAgdGFyZ2V0ID0gYWNjZXNzb3IgPyBtZXRob2RbYWNjZXNzb3JdIDogbWV0aG9kO1xuICAgICAgICAgICAgZXh0ZW5kLm5vbkVudW0odGFyZ2V0LCB7XG4gICAgICAgICAgICAgICAgZGlzcGxheU5hbWU6IHByb3BlcnR5LFxuICAgICAgICAgICAgICAgIHdyYXBwZWRNZXRob2Q6IHdyYXBwZWRNZXRob2RzW2ldLFxuXG4gICAgICAgICAgICAgICAgLy8gU2V0IHVwIGFuIEVycm9yIG9iamVjdCBmb3IgYSBzdGFjayB0cmFjZSB3aGljaCBjYW4gYmUgdXNlZCBsYXRlciB0byBmaW5kIHdoYXQgbGluZSBvZlxuICAgICAgICAgICAgICAgIC8vIGNvZGUgdGhlIG9yaWdpbmFsIG1ldGhvZCB3YXMgY3JlYXRlZCBvbi5cbiAgICAgICAgICAgICAgICBzdGFja1RyYWNlRXJyb3I6IG5ldyBFcnJvcihcIlN0YWNrIFRyYWNlIGZvciBvcmlnaW5hbFwiKSxcblxuICAgICAgICAgICAgICAgIHJlc3RvcmU6IHJlc3RvcmUsXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdGFyZ2V0LnJlc3RvcmUuc2lub24gPSB0cnVlO1xuICAgICAgICAgICAgaWYgKCFoYXNFUzVTdXBwb3J0KSB7XG4gICAgICAgICAgICAgICAgbWlycm9yUHJvcGVydGllcyh0YXJnZXQsIHdyYXBwZWRNZXRob2QpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVzdG9yZSgpIHtcbiAgICAgICAgYWNjZXNzb3IgPSBnZXRBY2Nlc3NvcihvYmplY3QsIHByb3BlcnR5LCB0aGlzLndyYXBwZWRNZXRob2QpO1xuICAgICAgICBsZXQgZGVzY3JpcHRvcjtcbiAgICAgICAgLy8gRm9yIHByb3RvdHlwZSBwcm9wZXJ0aWVzIHRyeSB0byByZXNldCBieSBkZWxldGUgZmlyc3QuXG4gICAgICAgIC8vIElmIHRoaXMgZmFpbHMgKGV4OiBsb2NhbFN0b3JhZ2Ugb24gbW9iaWxlIHNhZmFyaSkgdGhlbiBmb3JjZSBhIHJlc2V0XG4gICAgICAgIC8vIHZpYSBkaXJlY3QgYXNzaWdubWVudC5cbiAgICAgICAgaWYgKGFjY2Vzc29yKSB7XG4gICAgICAgICAgICBpZiAoIW93bmVkKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSW4gc29tZSBjYXNlcyBgZGVsZXRlYCBtYXkgdGhyb3cgYW4gZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG9iamVjdFtwcm9wZXJ0eV1bYWNjZXNzb3JdO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZW1wdHlcbiAgICAgICAgICAgICAgICAvLyBGb3IgbmF0aXZlIGNvZGUgZnVuY3Rpb25zIGBkZWxldGVgIGZhaWxzIHdpdGhvdXQgdGhyb3dpbmcgYW4gZXJyb3JcbiAgICAgICAgICAgICAgICAvLyBvbiBDaHJvbWUgPCA0MywgUGhhbnRvbUpTLCBldGMuXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGhhc0VTNVN1cHBvcnQpIHtcbiAgICAgICAgICAgICAgICBkZXNjcmlwdG9yID0gZ2V0UHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpO1xuICAgICAgICAgICAgICAgIGRlc2NyaXB0b3JbYWNjZXNzb3JdID0gd3JhcHBlZE1ldGhvZERlc2NbYWNjZXNzb3JdO1xuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsIHByb3BlcnR5LCBkZXNjcmlwdG9yKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGhhc0VTNVN1cHBvcnQpIHtcbiAgICAgICAgICAgICAgICBkZXNjcmlwdG9yID0gZ2V0UHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpO1xuICAgICAgICAgICAgICAgIGlmIChkZXNjcmlwdG9yICYmIGRlc2NyaXB0b3IudmFsdWUgPT09IHRhcmdldCkge1xuICAgICAgICAgICAgICAgICAgICBvYmplY3RbcHJvcGVydHldW2FjY2Vzc29yXSA9IHRoaXMud3JhcHBlZE1ldGhvZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFVzZSBzdHJpY3QgZXF1YWxpdHkgY29tcGFyaXNvbiB0byBjaGVjayBmYWlsdXJlcyB0aGVuIGZvcmNlIGEgcmVzZXRcbiAgICAgICAgICAgICAgICAvLyB2aWEgZGlyZWN0IGFzc2lnbm1lbnQuXG4gICAgICAgICAgICAgICAgaWYgKG9iamVjdFtwcm9wZXJ0eV1bYWNjZXNzb3JdID09PSB0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0W3Byb3BlcnR5XVthY2Nlc3Nvcl0gPSB0aGlzLndyYXBwZWRNZXRob2Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFvd25lZCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBvYmplY3RbcHJvcGVydHldO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZW1wdHlcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaGFzRVM1U3VwcG9ydCkge1xuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsIHByb3BlcnR5LCB3cmFwcGVkTWV0aG9kRGVzYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChoYXNFUzVTdXBwb3J0KSB7XG4gICAgICAgICAgICAgICAgZGVzY3JpcHRvciA9IGdldFByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTtcbiAgICAgICAgICAgICAgICBpZiAoZGVzY3JpcHRvciAmJiBkZXNjcmlwdG9yLnZhbHVlID09PSB0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0W3Byb3BlcnR5XSA9IHRoaXMud3JhcHBlZE1ldGhvZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChvYmplY3RbcHJvcGVydHldID09PSB0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0W3Byb3BlcnR5XSA9IHRoaXMud3JhcHBlZE1ldGhvZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNpbm9uVHlwZS5nZXQob2JqZWN0KSA9PT0gXCJzdHViLWluc3RhbmNlXCIpIHtcbiAgICAgICAgICAgIC8vIHRoaXMgaXMgc2ltcGx5IHRvIGF2b2lkIGVycm9ycyBhZnRlciByZXN0b3JpbmcgaWYgc29tZXRoaW5nIHNob3VsZFxuICAgICAgICAgICAgLy8gdHJhdmVyc2UgdGhlIG9iamVjdCBpbiBhIGNsZWFudXAgcGhhc2UsIHJlZiAjMjQ3N1xuICAgICAgICAgICAgb2JqZWN0W3Byb3BlcnR5XSA9IG5vb3A7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbWV0aG9kO1xufTtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuY29uc3QgYXJyYXlQcm90byA9IHJlcXVpcmUoXCJAc2lub25qcy9jb21tb25zXCIpLnByb3RvdHlwZXMuYXJyYXk7XG5jb25zdCBjcmVhdGVQcm94eSA9IHJlcXVpcmUoXCIuL3Byb3h5XCIpO1xuY29uc3QgZXh0ZW5kID0gcmVxdWlyZShcIi4vdXRpbC9jb3JlL2V4dGVuZFwiKTtcbmNvbnN0IGZ1bmN0aW9uTmFtZSA9IHJlcXVpcmUoXCJAc2lub25qcy9jb21tb25zXCIpLmZ1bmN0aW9uTmFtZTtcbmNvbnN0IGdldFByb3BlcnR5RGVzY3JpcHRvciA9IHJlcXVpcmUoXCIuL3V0aWwvY29yZS9nZXQtcHJvcGVydHktZGVzY3JpcHRvclwiKTtcbmNvbnN0IGRlZXBFcXVhbCA9IHJlcXVpcmUoXCJAc2lub25qcy9zYW1zYW1cIikuZGVlcEVxdWFsO1xuY29uc3QgaXNFc01vZHVsZSA9IHJlcXVpcmUoXCIuL3V0aWwvY29yZS9pcy1lcy1tb2R1bGVcIik7XG5jb25zdCBwcm94eUNhbGxVdGlsID0gcmVxdWlyZShcIi4vcHJveHktY2FsbC11dGlsXCIpO1xuY29uc3Qgd2Fsa09iamVjdCA9IHJlcXVpcmUoXCIuL3V0aWwvY29yZS93YWxrLW9iamVjdFwiKTtcbmNvbnN0IHdyYXBNZXRob2QgPSByZXF1aXJlKFwiLi91dGlsL2NvcmUvd3JhcC1tZXRob2RcIik7XG5jb25zdCB2YWx1ZVRvU3RyaW5nID0gcmVxdWlyZShcIkBzaW5vbmpzL2NvbW1vbnNcIikudmFsdWVUb1N0cmluZztcblxuLyogY2FjaGUgcmVmZXJlbmNlcyB0byBsaWJyYXJ5IG1ldGhvZHMgc28gdGhhdCB0aGV5IGFsc28gY2FuIGJlIHN0dWJiZWQgd2l0aG91dCBwcm9ibGVtcyAqL1xuY29uc3QgZm9yRWFjaCA9IGFycmF5UHJvdG8uZm9yRWFjaDtcbmNvbnN0IHBvcCA9IGFycmF5UHJvdG8ucG9wO1xuY29uc3QgcHVzaCA9IGFycmF5UHJvdG8ucHVzaDtcbmNvbnN0IHNsaWNlID0gYXJyYXlQcm90by5zbGljZTtcbmNvbnN0IGZpbHRlciA9IEFycmF5LnByb3RvdHlwZS5maWx0ZXI7XG5cbmxldCB1dWlkID0gMDtcblxuZnVuY3Rpb24gbWF0Y2hlcyhmYWtlLCBhcmdzLCBzdHJpY3QpIHtcbiAgICBjb25zdCBtYXJncyA9IGZha2UubWF0Y2hpbmdBcmd1bWVudHM7XG4gICAgaWYgKFxuICAgICAgICBtYXJncy5sZW5ndGggPD0gYXJncy5sZW5ndGggJiZcbiAgICAgICAgZGVlcEVxdWFsKHNsaWNlKGFyZ3MsIDAsIG1hcmdzLmxlbmd0aCksIG1hcmdzKVxuICAgICkge1xuICAgICAgICByZXR1cm4gIXN0cmljdCB8fCBtYXJncy5sZW5ndGggPT09IGFyZ3MubGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbi8vIFB1YmxpYyBBUElcbmNvbnN0IHNweUFwaSA9IHtcbiAgICB3aXRoQXJnczogZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zdCBhcmdzID0gc2xpY2UoYXJndW1lbnRzKTtcbiAgICAgICAgY29uc3QgbWF0Y2hpbmcgPSBwb3AodGhpcy5tYXRjaGluZ0Zha2VzKGFyZ3MsIHRydWUpKTtcbiAgICAgICAgaWYgKG1hdGNoaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gbWF0Y2hpbmc7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBvcmlnaW5hbCA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGZha2UgPSB0aGlzLmluc3RhbnRpYXRlRmFrZSgpO1xuICAgICAgICBmYWtlLm1hdGNoaW5nQXJndW1lbnRzID0gYXJncztcbiAgICAgICAgZmFrZS5wYXJlbnQgPSB0aGlzO1xuICAgICAgICBwdXNoKHRoaXMuZmFrZXMsIGZha2UpO1xuXG4gICAgICAgIGZha2Uud2l0aEFyZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gb3JpZ2luYWwud2l0aEFyZ3MuYXBwbHkob3JpZ2luYWwsIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgZm9yRWFjaChvcmlnaW5hbC5hcmdzLCBmdW5jdGlvbiAoYXJnLCBpKSB7XG4gICAgICAgICAgICBpZiAoIW1hdGNoZXMoZmFrZSwgYXJnKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcHJveHlDYWxsVXRpbC5pbmNyZW1lbnRDYWxsQ291bnQoZmFrZSk7XG4gICAgICAgICAgICBwdXNoKGZha2UudGhpc1ZhbHVlcywgb3JpZ2luYWwudGhpc1ZhbHVlc1tpXSk7XG4gICAgICAgICAgICBwdXNoKGZha2UuYXJncywgYXJnKTtcbiAgICAgICAgICAgIHB1c2goZmFrZS5yZXR1cm5WYWx1ZXMsIG9yaWdpbmFsLnJldHVyblZhbHVlc1tpXSk7XG4gICAgICAgICAgICBwdXNoKGZha2UuZXhjZXB0aW9ucywgb3JpZ2luYWwuZXhjZXB0aW9uc1tpXSk7XG4gICAgICAgICAgICBwdXNoKGZha2UuY2FsbElkcywgb3JpZ2luYWwuY2FsbElkc1tpXSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHByb3h5Q2FsbFV0aWwuY3JlYXRlQ2FsbFByb3BlcnRpZXMoZmFrZSk7XG5cbiAgICAgICAgcmV0dXJuIGZha2U7XG4gICAgfSxcblxuICAgIC8vIE92ZXJyaWRlIHByb3h5IGRlZmF1bHQgaW1wbGVtZW50YXRpb25cbiAgICBtYXRjaGluZ0Zha2VzOiBmdW5jdGlvbiAoYXJncywgc3RyaWN0KSB7XG4gICAgICAgIHJldHVybiBmaWx0ZXIuY2FsbCh0aGlzLmZha2VzLCBmdW5jdGlvbiAoZmFrZSkge1xuICAgICAgICAgICAgcmV0dXJuIG1hdGNoZXMoZmFrZSwgYXJncywgc3RyaWN0KTtcbiAgICAgICAgfSk7XG4gICAgfSxcbn07XG5cbi8qIGVzbGludC1kaXNhYmxlIEBzaW5vbmpzL25vLXByb3RvdHlwZS1tZXRob2RzL25vLXByb3RvdHlwZS1tZXRob2RzICovXG5jb25zdCBkZWxlZ2F0ZVRvQ2FsbHMgPSBwcm94eUNhbGxVdGlsLmRlbGVnYXRlVG9DYWxscztcbmRlbGVnYXRlVG9DYWxscyhzcHlBcGksIFwiY2FsbEFyZ1wiLCBmYWxzZSwgXCJjYWxsQXJnV2l0aFwiLCB0cnVlLCBmdW5jdGlvbiAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgJHt0aGlzLnRvU3RyaW5nKCl9IGNhbm5vdCBjYWxsIGFyZyBzaW5jZSBpdCB3YXMgbm90IHlldCBpbnZva2VkLmAsXG4gICAgKTtcbn0pO1xuc3B5QXBpLmNhbGxBcmdXaXRoID0gc3B5QXBpLmNhbGxBcmc7XG5kZWxlZ2F0ZVRvQ2FsbHMoc3B5QXBpLCBcImNhbGxBcmdPblwiLCBmYWxzZSwgXCJjYWxsQXJnT25XaXRoXCIsIHRydWUsIGZ1bmN0aW9uICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGAke3RoaXMudG9TdHJpbmcoKX0gY2Fubm90IGNhbGwgYXJnIHNpbmNlIGl0IHdhcyBub3QgeWV0IGludm9rZWQuYCxcbiAgICApO1xufSk7XG5zcHlBcGkuY2FsbEFyZ09uV2l0aCA9IHNweUFwaS5jYWxsQXJnT247XG5kZWxlZ2F0ZVRvQ2FsbHMoc3B5QXBpLCBcInRocm93QXJnXCIsIGZhbHNlLCBcInRocm93QXJnXCIsIGZhbHNlLCBmdW5jdGlvbiAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgJHt0aGlzLnRvU3RyaW5nKCl9IGNhbm5vdCB0aHJvdyBhcmcgc2luY2UgaXQgd2FzIG5vdCB5ZXQgaW52b2tlZC5gLFxuICAgICk7XG59KTtcbmRlbGVnYXRlVG9DYWxscyhzcHlBcGksIFwieWllbGRcIiwgZmFsc2UsIFwieWllbGRcIiwgdHJ1ZSwgZnVuY3Rpb24gKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYCR7dGhpcy50b1N0cmluZygpfSBjYW5ub3QgeWllbGQgc2luY2UgaXQgd2FzIG5vdCB5ZXQgaW52b2tlZC5gLFxuICAgICk7XG59KTtcbi8vIFwiaW52b2tlQ2FsbGJhY2tcIiBpcyBhbiBhbGlhcyBmb3IgXCJ5aWVsZFwiIHNpbmNlIFwieWllbGRcIiBpcyBpbnZhbGlkIGluIHN0cmljdCBtb2RlLlxuc3B5QXBpLmludm9rZUNhbGxiYWNrID0gc3B5QXBpLnlpZWxkO1xuZGVsZWdhdGVUb0NhbGxzKHNweUFwaSwgXCJ5aWVsZE9uXCIsIGZhbHNlLCBcInlpZWxkT25cIiwgdHJ1ZSwgZnVuY3Rpb24gKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYCR7dGhpcy50b1N0cmluZygpfSBjYW5ub3QgeWllbGQgc2luY2UgaXQgd2FzIG5vdCB5ZXQgaW52b2tlZC5gLFxuICAgICk7XG59KTtcbmRlbGVnYXRlVG9DYWxscyhzcHlBcGksIFwieWllbGRUb1wiLCBmYWxzZSwgXCJ5aWVsZFRvXCIsIHRydWUsIGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYCR7dGhpcy50b1N0cmluZygpfSBjYW5ub3QgeWllbGQgdG8gJyR7dmFsdWVUb1N0cmluZyhcbiAgICAgICAgICAgIHByb3BlcnR5LFxuICAgICAgICApfScgc2luY2UgaXQgd2FzIG5vdCB5ZXQgaW52b2tlZC5gLFxuICAgICk7XG59KTtcbmRlbGVnYXRlVG9DYWxscyhcbiAgICBzcHlBcGksXG4gICAgXCJ5aWVsZFRvT25cIixcbiAgICBmYWxzZSxcbiAgICBcInlpZWxkVG9PblwiLFxuICAgIHRydWUsXG4gICAgZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGAke3RoaXMudG9TdHJpbmcoKX0gY2Fubm90IHlpZWxkIHRvICcke3ZhbHVlVG9TdHJpbmcoXG4gICAgICAgICAgICAgICAgcHJvcGVydHksXG4gICAgICAgICAgICApfScgc2luY2UgaXQgd2FzIG5vdCB5ZXQgaW52b2tlZC5gLFxuICAgICAgICApO1xuICAgIH0sXG4pO1xuXG5mdW5jdGlvbiBjcmVhdGVTcHkoZnVuYykge1xuICAgIGxldCBuYW1lO1xuICAgIGxldCBmdW5rID0gZnVuYztcblxuICAgIGlmICh0eXBlb2YgZnVuayAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGZ1bmsgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbmFtZSA9IGZ1bmN0aW9uTmFtZShmdW5rKTtcbiAgICB9XG5cbiAgICBjb25zdCBwcm94eSA9IGNyZWF0ZVByb3h5KGZ1bmssIGZ1bmspO1xuXG4gICAgLy8gSW5oZXJpdCBzcHkgQVBJOlxuICAgIGV4dGVuZC5ub25FbnVtKHByb3h5LCBzcHlBcGkpO1xuICAgIGV4dGVuZC5ub25FbnVtKHByb3h5LCB7XG4gICAgICAgIGRpc3BsYXlOYW1lOiBuYW1lIHx8IFwic3B5XCIsXG4gICAgICAgIGZha2VzOiBbXSxcbiAgICAgICAgaW5zdGFudGlhdGVGYWtlOiBjcmVhdGVTcHksXG4gICAgICAgIGlkOiBgc3B5IyR7dXVpZCsrfWAsXG4gICAgfSk7XG4gICAgcmV0dXJuIHByb3h5O1xufVxuXG5mdW5jdGlvbiBzcHkob2JqZWN0LCBwcm9wZXJ0eSwgdHlwZXMpIHtcbiAgICBpZiAoaXNFc01vZHVsZShvYmplY3QpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFUyBNb2R1bGVzIGNhbm5vdCBiZSBzcGllZFwiKTtcbiAgICB9XG5cbiAgICBpZiAoIXByb3BlcnR5ICYmIHR5cGVvZiBvYmplY3QgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gY3JlYXRlU3B5KG9iamVjdCk7XG4gICAgfVxuXG4gICAgaWYgKCFwcm9wZXJ0eSAmJiB0eXBlb2Ygb2JqZWN0ID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHJldHVybiB3YWxrT2JqZWN0KHNweSwgb2JqZWN0KTtcbiAgICB9XG5cbiAgICBpZiAoIW9iamVjdCAmJiAhcHJvcGVydHkpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVNweShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmICghdHlwZXMpIHtcbiAgICAgICAgcmV0dXJuIHdyYXBNZXRob2Qob2JqZWN0LCBwcm9wZXJ0eSwgY3JlYXRlU3B5KG9iamVjdFtwcm9wZXJ0eV0pKTtcbiAgICB9XG5cbiAgICBjb25zdCBkZXNjcmlwdG9yID0ge307XG4gICAgY29uc3QgbWV0aG9kRGVzYyA9IGdldFByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTtcblxuICAgIGZvckVhY2godHlwZXMsIGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIGRlc2NyaXB0b3JbdHlwZV0gPSBjcmVhdGVTcHkobWV0aG9kRGVzY1t0eXBlXSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gd3JhcE1ldGhvZChvYmplY3QsIHByb3BlcnR5LCBkZXNjcmlwdG9yKTtcbn1cblxuZXh0ZW5kKHNweSwgc3B5QXBpKTtcbm1vZHVsZS5leHBvcnRzID0gc3B5O1xuIiwgIlwidXNlIHN0cmljdFwiO1xuY29uc3QgdmFsdWVUb1N0cmluZyA9IHJlcXVpcmUoXCJAc2lub25qcy9jb21tb25zXCIpLnZhbHVlVG9TdHJpbmc7XG5cbmZ1bmN0aW9uIHRocm93T25GYWxzeU9iamVjdChvYmplY3QsIHByb3BlcnR5KSB7XG4gICAgaWYgKHByb3BlcnR5ICYmICFvYmplY3QpIHtcbiAgICAgICAgY29uc3QgdHlwZSA9IG9iamVjdCA9PT0gbnVsbCA/IFwibnVsbFwiIDogXCJ1bmRlZmluZWRcIjtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYFRyeWluZyB0byBzdHViIHByb3BlcnR5ICcke3ZhbHVlVG9TdHJpbmcocHJvcGVydHkpfScgb2YgJHt0eXBlfWAsXG4gICAgICAgICk7XG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRocm93T25GYWxzeU9iamVjdDtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuY29uc3QgYXJyYXlQcm90byA9IHJlcXVpcmUoXCJAc2lub25qcy9jb21tb25zXCIpLnByb3RvdHlwZXMuYXJyYXk7XG5jb25zdCBiZWhhdmlvciA9IHJlcXVpcmUoXCIuL2JlaGF2aW9yXCIpO1xuY29uc3QgYmVoYXZpb3JzID0gcmVxdWlyZShcIi4vZGVmYXVsdC1iZWhhdmlvcnNcIik7XG5jb25zdCBjcmVhdGVQcm94eSA9IHJlcXVpcmUoXCIuL3Byb3h5XCIpO1xuY29uc3QgZnVuY3Rpb25OYW1lID0gcmVxdWlyZShcIkBzaW5vbmpzL2NvbW1vbnNcIikuZnVuY3Rpb25OYW1lO1xuY29uc3QgaGFzT3duUHJvcGVydHkgPVxuICAgIHJlcXVpcmUoXCJAc2lub25qcy9jb21tb25zXCIpLnByb3RvdHlwZXMub2JqZWN0Lmhhc093blByb3BlcnR5O1xuY29uc3QgaXNOb25FeGlzdGVudFByb3BlcnR5ID0gcmVxdWlyZShcIi4vdXRpbC9jb3JlL2lzLW5vbi1leGlzdGVudC1wcm9wZXJ0eVwiKTtcbmNvbnN0IHNweSA9IHJlcXVpcmUoXCIuL3NweVwiKTtcbmNvbnN0IGV4dGVuZCA9IHJlcXVpcmUoXCIuL3V0aWwvY29yZS9leHRlbmRcIik7XG5jb25zdCBnZXRQcm9wZXJ0eURlc2NyaXB0b3IgPSByZXF1aXJlKFwiLi91dGlsL2NvcmUvZ2V0LXByb3BlcnR5LWRlc2NyaXB0b3JcIik7XG5jb25zdCBpc0VzTW9kdWxlID0gcmVxdWlyZShcIi4vdXRpbC9jb3JlL2lzLWVzLW1vZHVsZVwiKTtcbmNvbnN0IHNpbm9uVHlwZSA9IHJlcXVpcmUoXCIuL3V0aWwvY29yZS9zaW5vbi10eXBlXCIpO1xuY29uc3Qgd3JhcE1ldGhvZCA9IHJlcXVpcmUoXCIuL3V0aWwvY29yZS93cmFwLW1ldGhvZFwiKTtcbmNvbnN0IHRocm93T25GYWxzeU9iamVjdCA9IHJlcXVpcmUoXCIuL3Rocm93LW9uLWZhbHN5LW9iamVjdFwiKTtcbmNvbnN0IHZhbHVlVG9TdHJpbmcgPSByZXF1aXJlKFwiQHNpbm9uanMvY29tbW9uc1wiKS52YWx1ZVRvU3RyaW5nO1xuY29uc3Qgd2Fsa09iamVjdCA9IHJlcXVpcmUoXCIuL3V0aWwvY29yZS93YWxrLW9iamVjdFwiKTtcblxuY29uc3QgZm9yRWFjaCA9IGFycmF5UHJvdG8uZm9yRWFjaDtcbmNvbnN0IHBvcCA9IGFycmF5UHJvdG8ucG9wO1xuY29uc3Qgc2xpY2UgPSBhcnJheVByb3RvLnNsaWNlO1xuY29uc3Qgc29ydCA9IGFycmF5UHJvdG8uc29ydDtcblxubGV0IHV1aWQgPSAwO1xuXG5mdW5jdGlvbiBjcmVhdGVTdHViKG9yaWdpbmFsRnVuYykge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItY29uc3RcbiAgICBsZXQgcHJveHk7XG5cbiAgICBmdW5jdGlvbiBmdW5jdGlvblN0dWIoKSB7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSBzbGljZShhcmd1bWVudHMpO1xuICAgICAgICBjb25zdCBtYXRjaGluZ3MgPSBwcm94eS5tYXRjaGluZ0Zha2VzKGFyZ3MpO1xuXG4gICAgICAgIGNvbnN0IGZuU3R1YiA9XG4gICAgICAgICAgICBwb3AoXG4gICAgICAgICAgICAgICAgc29ydChtYXRjaGluZ3MsIGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgICAgICAgICBhLm1hdGNoaW5nQXJndW1lbnRzLmxlbmd0aCAtIGIubWF0Y2hpbmdBcmd1bWVudHMubGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICApIHx8IHByb3h5O1xuICAgICAgICByZXR1cm4gZ2V0Q3VycmVudEJlaGF2aW9yKGZuU3R1YikuaW52b2tlKHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgcHJveHkgPSBjcmVhdGVQcm94eShmdW5jdGlvblN0dWIsIG9yaWdpbmFsRnVuYyB8fCBmdW5jdGlvblN0dWIpO1xuICAgIC8vIEluaGVyaXQgc3B5IEFQSTpcbiAgICBleHRlbmQubm9uRW51bShwcm94eSwgc3B5KTtcbiAgICAvLyBJbmhlcml0IHN0dWIgQVBJOlxuICAgIGV4dGVuZC5ub25FbnVtKHByb3h5LCBzdHViKTtcblxuICAgIGNvbnN0IG5hbWUgPSBvcmlnaW5hbEZ1bmMgPyBmdW5jdGlvbk5hbWUob3JpZ2luYWxGdW5jKSA6IG51bGw7XG4gICAgZXh0ZW5kLm5vbkVudW0ocHJveHksIHtcbiAgICAgICAgZmFrZXM6IFtdLFxuICAgICAgICBpbnN0YW50aWF0ZUZha2U6IGNyZWF0ZVN0dWIsXG4gICAgICAgIGRpc3BsYXlOYW1lOiBuYW1lIHx8IFwic3R1YlwiLFxuICAgICAgICBkZWZhdWx0QmVoYXZpb3I6IG51bGwsXG4gICAgICAgIGJlaGF2aW9yczogW10sXG4gICAgICAgIGlkOiBgc3R1YiMke3V1aWQrK31gLFxuICAgIH0pO1xuXG4gICAgc2lub25UeXBlLnNldChwcm94eSwgXCJzdHViXCIpO1xuXG4gICAgcmV0dXJuIHByb3h5O1xufVxuXG5mdW5jdGlvbiBzdHViKG9iamVjdCwgcHJvcGVydHkpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgIFwic3R1YihvYmosICdtZXRoJywgZm4pIGhhcyBiZWVuIHJlbW92ZWQsIHNlZSBkb2N1bWVudGF0aW9uXCIsXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKGlzRXNNb2R1bGUob2JqZWN0KSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRVMgTW9kdWxlcyBjYW5ub3QgYmUgc3R1YmJlZFwiKTtcbiAgICB9XG5cbiAgICB0aHJvd09uRmFsc3lPYmplY3QuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcblxuICAgIGlmIChpc05vbkV4aXN0ZW50UHJvcGVydHkob2JqZWN0LCBwcm9wZXJ0eSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgIGBDYW5ub3Qgc3R1YiBub24tZXhpc3RlbnQgcHJvcGVydHkgJHt2YWx1ZVRvU3RyaW5nKHByb3BlcnR5KX1gLFxuICAgICAgICApO1xuICAgIH1cblxuICAgIGNvbnN0IGFjdHVhbERlc2NyaXB0b3IgPSBnZXRQcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7XG5cbiAgICBhc3NlcnRWYWxpZFByb3BlcnR5RGVzY3JpcHRvcihhY3R1YWxEZXNjcmlwdG9yLCBwcm9wZXJ0eSk7XG5cbiAgICBjb25zdCBpc09iamVjdE9yRnVuY3Rpb24gPVxuICAgICAgICB0eXBlb2Ygb2JqZWN0ID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBvYmplY3QgPT09IFwiZnVuY3Rpb25cIjtcbiAgICBjb25zdCBpc1N0dWJiaW5nRW50aXJlT2JqZWN0ID1cbiAgICAgICAgdHlwZW9mIHByb3BlcnR5ID09PSBcInVuZGVmaW5lZFwiICYmIGlzT2JqZWN0T3JGdW5jdGlvbjtcbiAgICBjb25zdCBpc0NyZWF0aW5nTmV3U3R1YiA9ICFvYmplY3QgJiYgdHlwZW9mIHByb3BlcnR5ID09PSBcInVuZGVmaW5lZFwiO1xuICAgIGNvbnN0IGlzU3R1YmJpbmdOb25GdW5jUHJvcGVydHkgPVxuICAgICAgICBpc09iamVjdE9yRnVuY3Rpb24gJiZcbiAgICAgICAgdHlwZW9mIHByb3BlcnR5ICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgICAgICh0eXBlb2YgYWN0dWFsRGVzY3JpcHRvciA9PT0gXCJ1bmRlZmluZWRcIiB8fFxuICAgICAgICAgICAgdHlwZW9mIGFjdHVhbERlc2NyaXB0b3IudmFsdWUgIT09IFwiZnVuY3Rpb25cIik7XG5cbiAgICBpZiAoaXNTdHViYmluZ0VudGlyZU9iamVjdCkge1xuICAgICAgICByZXR1cm4gd2Fsa09iamVjdChzdHViLCBvYmplY3QpO1xuICAgIH1cblxuICAgIGlmIChpc0NyZWF0aW5nTmV3U3R1Yikge1xuICAgICAgICByZXR1cm4gY3JlYXRlU3R1YigpO1xuICAgIH1cblxuICAgIGNvbnN0IGZ1bmMgPVxuICAgICAgICB0eXBlb2YgYWN0dWFsRGVzY3JpcHRvci52YWx1ZSA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgICAgICA/IGFjdHVhbERlc2NyaXB0b3IudmFsdWVcbiAgICAgICAgICAgIDogbnVsbDtcbiAgICBjb25zdCBzID0gY3JlYXRlU3R1YihmdW5jKTtcblxuICAgIGV4dGVuZC5ub25FbnVtKHMsIHtcbiAgICAgICAgcm9vdE9iajogb2JqZWN0LFxuICAgICAgICBwcm9wTmFtZTogcHJvcGVydHksXG4gICAgICAgIHNoYWRvd3NQcm9wT25Qcm90b3R5cGU6ICFhY3R1YWxEZXNjcmlwdG9yLmlzT3duLFxuICAgICAgICByZXN0b3JlOiBmdW5jdGlvbiByZXN0b3JlKCkge1xuICAgICAgICAgICAgaWYgKGFjdHVhbERlc2NyaXB0b3IgIT09IHVuZGVmaW5lZCAmJiBhY3R1YWxEZXNjcmlwdG9yLmlzT3duKSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iamVjdCwgcHJvcGVydHksIGFjdHVhbERlc2NyaXB0b3IpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGVsZXRlIG9iamVjdFtwcm9wZXJ0eV07XG4gICAgICAgIH0sXG4gICAgfSk7XG5cbiAgICByZXR1cm4gaXNTdHViYmluZ05vbkZ1bmNQcm9wZXJ0eSA/IHMgOiB3cmFwTWV0aG9kKG9iamVjdCwgcHJvcGVydHksIHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRWYWxpZFByb3BlcnR5RGVzY3JpcHRvcihkZXNjcmlwdG9yLCBwcm9wZXJ0eSkge1xuICAgIGlmICghZGVzY3JpcHRvciB8fCAhcHJvcGVydHkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZGVzY3JpcHRvci5pc093biAmJiAhZGVzY3JpcHRvci5jb25maWd1cmFibGUgJiYgIWRlc2NyaXB0b3Iud3JpdGFibGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgIGBUaGUgZGVzY3JpcHRvciBmb3IgcHJvcGVydHkgXFxgJHtwcm9wZXJ0eX1cXGAgaXMgbm9uLWNvbmZpZ3VyYWJsZSBhbmQgbm9uLXdyaXRhYmxlLiBgICtcbiAgICAgICAgICAgICAgICBgU2lub24gY2Fubm90IHN0dWIgcHJvcGVydGllcyB0aGF0IGFyZSBpbW11dGFibGUuIGAgK1xuICAgICAgICAgICAgICAgIGBTZWUgaHR0cHM6Ly9zaW5vbmpzLm9yZy9mYXEjcHJvcGVydHktZGVzY3JpcHRvci1lcnJvcnMgZm9yIGhlbHAgZml4aW5nIHRoaXMgaXNzdWUuYCxcbiAgICAgICAgKTtcbiAgICB9XG4gICAgaWYgKChkZXNjcmlwdG9yLmdldCB8fCBkZXNjcmlwdG9yLnNldCkgJiYgIWRlc2NyaXB0b3IuY29uZmlndXJhYmxlKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICBgRGVzY3JpcHRvciBmb3IgYWNjZXNzb3IgcHJvcGVydHkgJHtwcm9wZXJ0eX0gaXMgbm9uLWNvbmZpZ3VyYWJsZWAsXG4gICAgICAgICk7XG4gICAgfVxuICAgIGlmIChpc0RhdGFEZXNjcmlwdG9yKGRlc2NyaXB0b3IpICYmICFkZXNjcmlwdG9yLndyaXRhYmxlKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICBgRGVzY3JpcHRvciBmb3IgZGF0YSBwcm9wZXJ0eSAke3Byb3BlcnR5fSBpcyBub24td3JpdGFibGVgLFxuICAgICAgICApO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gaXNEYXRhRGVzY3JpcHRvcihkZXNjcmlwdG9yKSB7XG4gICAgcmV0dXJuIChcbiAgICAgICAgIWRlc2NyaXB0b3IudmFsdWUgJiZcbiAgICAgICAgIWRlc2NyaXB0b3Iud3JpdGFibGUgJiZcbiAgICAgICAgIWRlc2NyaXB0b3Iuc2V0ICYmXG4gICAgICAgICFkZXNjcmlwdG9yLmdldFxuICAgICk7XG59XG5cbi8qZXNsaW50LWRpc2FibGUgbm8tdXNlLWJlZm9yZS1kZWZpbmUqL1xuZnVuY3Rpb24gZ2V0UGFyZW50QmVoYXZpb3VyKHN0dWJJbnN0YW5jZSkge1xuICAgIHJldHVybiBzdHViSW5zdGFuY2UucGFyZW50ICYmIGdldEN1cnJlbnRCZWhhdmlvcihzdHViSW5zdGFuY2UucGFyZW50KTtcbn1cblxuZnVuY3Rpb24gZ2V0RGVmYXVsdEJlaGF2aW9yKHN0dWJJbnN0YW5jZSkge1xuICAgIHJldHVybiAoXG4gICAgICAgIHN0dWJJbnN0YW5jZS5kZWZhdWx0QmVoYXZpb3IgfHxcbiAgICAgICAgZ2V0UGFyZW50QmVoYXZpb3VyKHN0dWJJbnN0YW5jZSkgfHxcbiAgICAgICAgYmVoYXZpb3IuY3JlYXRlKHN0dWJJbnN0YW5jZSlcbiAgICApO1xufVxuXG5mdW5jdGlvbiBnZXRDdXJyZW50QmVoYXZpb3Ioc3R1Ykluc3RhbmNlKSB7XG4gICAgY29uc3QgY3VycmVudEJlaGF2aW9yID0gc3R1Ykluc3RhbmNlLmJlaGF2aW9yc1tzdHViSW5zdGFuY2UuY2FsbENvdW50IC0gMV07XG4gICAgcmV0dXJuIGN1cnJlbnRCZWhhdmlvciAmJiBjdXJyZW50QmVoYXZpb3IuaXNQcmVzZW50KClcbiAgICAgICAgPyBjdXJyZW50QmVoYXZpb3JcbiAgICAgICAgOiBnZXREZWZhdWx0QmVoYXZpb3Ioc3R1Ykluc3RhbmNlKTtcbn1cbi8qZXNsaW50LWVuYWJsZSBuby11c2UtYmVmb3JlLWRlZmluZSovXG5cbmNvbnN0IHByb3RvID0ge1xuICAgIHJlc2V0QmVoYXZpb3I6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5kZWZhdWx0QmVoYXZpb3IgPSBudWxsO1xuICAgICAgICB0aGlzLmJlaGF2aW9ycyA9IFtdO1xuXG4gICAgICAgIGRlbGV0ZSB0aGlzLnJldHVyblZhbHVlO1xuICAgICAgICBkZWxldGUgdGhpcy5yZXR1cm5BcmdBdDtcbiAgICAgICAgZGVsZXRlIHRoaXMudGhyb3dBcmdBdDtcbiAgICAgICAgZGVsZXRlIHRoaXMucmVzb2x2ZUFyZ0F0O1xuICAgICAgICBkZWxldGUgdGhpcy5mYWtlRm47XG4gICAgICAgIHRoaXMucmV0dXJuVGhpcyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnJlc29sdmVUaGlzID0gZmFsc2U7XG5cbiAgICAgICAgZm9yRWFjaCh0aGlzLmZha2VzLCBmdW5jdGlvbiAoZmFrZSkge1xuICAgICAgICAgICAgZmFrZS5yZXNldEJlaGF2aW9yKCk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICByZXNldDogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnJlc2V0SGlzdG9yeSgpO1xuICAgICAgICB0aGlzLnJlc2V0QmVoYXZpb3IoKTtcbiAgICB9LFxuXG4gICAgb25DYWxsOiBmdW5jdGlvbiBvbkNhbGwoaW5kZXgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmJlaGF2aW9yc1tpbmRleF0pIHtcbiAgICAgICAgICAgIHRoaXMuYmVoYXZpb3JzW2luZGV4XSA9IGJlaGF2aW9yLmNyZWF0ZSh0aGlzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmJlaGF2aW9yc1tpbmRleF07XG4gICAgfSxcblxuICAgIG9uRmlyc3RDYWxsOiBmdW5jdGlvbiBvbkZpcnN0Q2FsbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub25DYWxsKDApO1xuICAgIH0sXG5cbiAgICBvblNlY29uZENhbGw6IGZ1bmN0aW9uIG9uU2Vjb25kQ2FsbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub25DYWxsKDEpO1xuICAgIH0sXG5cbiAgICBvblRoaXJkQ2FsbDogZnVuY3Rpb24gb25UaGlyZENhbGwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9uQ2FsbCgyKTtcbiAgICB9LFxuXG4gICAgd2l0aEFyZ3M6IGZ1bmN0aW9uIHdpdGhBcmdzKCkge1xuICAgICAgICBjb25zdCBmYWtlID0gc3B5LndpdGhBcmdzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIGlmICh0aGlzLmRlZmF1bHRCZWhhdmlvciAmJiB0aGlzLmRlZmF1bHRCZWhhdmlvci5wcm9taXNlTGlicmFyeSkge1xuICAgICAgICAgICAgZmFrZS5kZWZhdWx0QmVoYXZpb3IgPVxuICAgICAgICAgICAgICAgIGZha2UuZGVmYXVsdEJlaGF2aW9yIHx8IGJlaGF2aW9yLmNyZWF0ZShmYWtlKTtcbiAgICAgICAgICAgIGZha2UuZGVmYXVsdEJlaGF2aW9yLnByb21pc2VMaWJyYXJ5ID1cbiAgICAgICAgICAgICAgICB0aGlzLmRlZmF1bHRCZWhhdmlvci5wcm9taXNlTGlicmFyeTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFrZTtcbiAgICB9LFxufTtcblxuZm9yRWFjaChPYmplY3Qua2V5cyhiZWhhdmlvciksIGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgICBpZiAoXG4gICAgICAgIGhhc093blByb3BlcnR5KGJlaGF2aW9yLCBtZXRob2QpICYmXG4gICAgICAgICFoYXNPd25Qcm9wZXJ0eShwcm90bywgbWV0aG9kKSAmJlxuICAgICAgICBtZXRob2QgIT09IFwiY3JlYXRlXCIgJiZcbiAgICAgICAgbWV0aG9kICE9PSBcImludm9rZVwiXG4gICAgKSB7XG4gICAgICAgIHByb3RvW21ldGhvZF0gPSBiZWhhdmlvci5jcmVhdGVCZWhhdmlvcihtZXRob2QpO1xuICAgIH1cbn0pO1xuXG5mb3JFYWNoKE9iamVjdC5rZXlzKGJlaGF2aW9ycyksIGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkoYmVoYXZpb3JzLCBtZXRob2QpICYmICFoYXNPd25Qcm9wZXJ0eShwcm90bywgbWV0aG9kKSkge1xuICAgICAgICBiZWhhdmlvci5hZGRCZWhhdmlvcihzdHViLCBtZXRob2QsIGJlaGF2aW9yc1ttZXRob2RdKTtcbiAgICB9XG59KTtcblxuZXh0ZW5kKHN0dWIsIHByb3RvKTtcbm1vZHVsZS5leHBvcnRzID0gc3R1YjtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuY29uc3QgYXJyYXlQcm90byA9IHJlcXVpcmUoXCJAc2lub25qcy9jb21tb25zXCIpLnByb3RvdHlwZXMuYXJyYXk7XG5jb25zdCBwcm94eUludm9rZSA9IHJlcXVpcmUoXCIuL3Byb3h5LWludm9rZVwiKTtcbmNvbnN0IHByb3h5Q2FsbFRvU3RyaW5nID0gcmVxdWlyZShcIi4vcHJveHktY2FsbFwiKS50b1N0cmluZztcbmNvbnN0IHRpbWVzSW5Xb3JkcyA9IHJlcXVpcmUoXCIuL3V0aWwvY29yZS90aW1lcy1pbi13b3Jkc1wiKTtcbmNvbnN0IGV4dGVuZCA9IHJlcXVpcmUoXCIuL3V0aWwvY29yZS9leHRlbmRcIik7XG5jb25zdCBtYXRjaCA9IHJlcXVpcmUoXCJAc2lub25qcy9zYW1zYW1cIikuY3JlYXRlTWF0Y2hlcjtcbmNvbnN0IHN0dWIgPSByZXF1aXJlKFwiLi9zdHViXCIpO1xuY29uc3QgYXNzZXJ0ID0gcmVxdWlyZShcIi4vYXNzZXJ0XCIpO1xuY29uc3QgZGVlcEVxdWFsID0gcmVxdWlyZShcIkBzaW5vbmpzL3NhbXNhbVwiKS5kZWVwRXF1YWw7XG5jb25zdCBpbnNwZWN0ID0gcmVxdWlyZShcInV0aWxcIikuaW5zcGVjdDtcbmNvbnN0IHZhbHVlVG9TdHJpbmcgPSByZXF1aXJlKFwiQHNpbm9uanMvY29tbW9uc1wiKS52YWx1ZVRvU3RyaW5nO1xuXG5jb25zdCBldmVyeSA9IGFycmF5UHJvdG8uZXZlcnk7XG5jb25zdCBmb3JFYWNoID0gYXJyYXlQcm90by5mb3JFYWNoO1xuY29uc3QgcHVzaCA9IGFycmF5UHJvdG8ucHVzaDtcbmNvbnN0IHNsaWNlID0gYXJyYXlQcm90by5zbGljZTtcblxuZnVuY3Rpb24gY2FsbENvdW50SW5Xb3JkcyhjYWxsQ291bnQpIHtcbiAgICBpZiAoY2FsbENvdW50ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBcIm5ldmVyIGNhbGxlZFwiO1xuICAgIH1cblxuICAgIHJldHVybiBgY2FsbGVkICR7dGltZXNJbldvcmRzKGNhbGxDb3VudCl9YDtcbn1cblxuZnVuY3Rpb24gZXhwZWN0ZWRDYWxsQ291bnRJbldvcmRzKGV4cGVjdGF0aW9uKSB7XG4gICAgY29uc3QgbWluID0gZXhwZWN0YXRpb24ubWluQ2FsbHM7XG4gICAgY29uc3QgbWF4ID0gZXhwZWN0YXRpb24ubWF4Q2FsbHM7XG5cbiAgICBpZiAodHlwZW9mIG1pbiA9PT0gXCJudW1iZXJcIiAmJiB0eXBlb2YgbWF4ID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIGxldCBzdHIgPSB0aW1lc0luV29yZHMobWluKTtcblxuICAgICAgICBpZiAobWluICE9PSBtYXgpIHtcbiAgICAgICAgICAgIHN0ciA9IGBhdCBsZWFzdCAke3N0cn0gYW5kIGF0IG1vc3QgJHt0aW1lc0luV29yZHMobWF4KX1gO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG1pbiA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICByZXR1cm4gYGF0IGxlYXN0ICR7dGltZXNJbldvcmRzKG1pbil9YDtcbiAgICB9XG5cbiAgICByZXR1cm4gYGF0IG1vc3QgJHt0aW1lc0luV29yZHMobWF4KX1gO1xufVxuXG5mdW5jdGlvbiByZWNlaXZlZE1pbkNhbGxzKGV4cGVjdGF0aW9uKSB7XG4gICAgY29uc3QgaGFzTWluTGltaXQgPSB0eXBlb2YgZXhwZWN0YXRpb24ubWluQ2FsbHMgPT09IFwibnVtYmVyXCI7XG4gICAgcmV0dXJuICFoYXNNaW5MaW1pdCB8fCBleHBlY3RhdGlvbi5jYWxsQ291bnQgPj0gZXhwZWN0YXRpb24ubWluQ2FsbHM7XG59XG5cbmZ1bmN0aW9uIHJlY2VpdmVkTWF4Q2FsbHMoZXhwZWN0YXRpb24pIHtcbiAgICBpZiAodHlwZW9mIGV4cGVjdGF0aW9uLm1heENhbGxzICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZXhwZWN0YXRpb24uY2FsbENvdW50ID09PSBleHBlY3RhdGlvbi5tYXhDYWxscztcbn1cblxuZnVuY3Rpb24gdmVyaWZ5TWF0Y2hlcihwb3NzaWJsZU1hdGNoZXIsIGFyZykge1xuICAgIGNvbnN0IGlzTWF0Y2hlciA9IG1hdGNoLmlzTWF0Y2hlcihwb3NzaWJsZU1hdGNoZXIpO1xuXG4gICAgcmV0dXJuIChpc01hdGNoZXIgJiYgcG9zc2libGVNYXRjaGVyLnRlc3QoYXJnKSkgfHwgdHJ1ZTtcbn1cblxuY29uc3QgbW9ja0V4cGVjdGF0aW9uID0ge1xuICAgIG1pbkNhbGxzOiAxLFxuICAgIG1heENhbGxzOiAxLFxuXG4gICAgY3JlYXRlOiBmdW5jdGlvbiBjcmVhdGUobWV0aG9kTmFtZSkge1xuICAgICAgICBjb25zdCBleHBlY3RhdGlvbiA9IGV4dGVuZC5ub25FbnVtKHN0dWIoKSwgbW9ja0V4cGVjdGF0aW9uKTtcbiAgICAgICAgZGVsZXRlIGV4cGVjdGF0aW9uLmNyZWF0ZTtcbiAgICAgICAgZXhwZWN0YXRpb24ubWV0aG9kID0gbWV0aG9kTmFtZTtcblxuICAgICAgICByZXR1cm4gZXhwZWN0YXRpb247XG4gICAgfSxcblxuICAgIGludm9rZTogZnVuY3Rpb24gaW52b2tlKGZ1bmMsIHRoaXNWYWx1ZSwgYXJncykge1xuICAgICAgICB0aGlzLnZlcmlmeUNhbGxBbGxvd2VkKHRoaXNWYWx1ZSwgYXJncyk7XG5cbiAgICAgICAgcmV0dXJuIHByb3h5SW52b2tlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSxcblxuICAgIGF0TGVhc3Q6IGZ1bmN0aW9uIGF0TGVhc3QobnVtKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbnVtICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGAnJHt2YWx1ZVRvU3RyaW5nKG51bSl9JyBpcyBub3QgbnVtYmVyYCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMubGltaXRzU2V0KSB7XG4gICAgICAgICAgICB0aGlzLm1heENhbGxzID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMubGltaXRzU2V0ID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubWluQ2FsbHMgPSBudW07XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGF0TW9zdDogZnVuY3Rpb24gYXRNb3N0KG51bSkge1xuICAgICAgICBpZiAodHlwZW9mIG51bSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgJyR7dmFsdWVUb1N0cmluZyhudW0pfScgaXMgbm90IG51bWJlcmApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLmxpbWl0c1NldCkge1xuICAgICAgICAgICAgdGhpcy5taW5DYWxscyA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmxpbWl0c1NldCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm1heENhbGxzID0gbnVtO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBuZXZlcjogZnVuY3Rpb24gbmV2ZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmV4YWN0bHkoMCk7XG4gICAgfSxcblxuICAgIG9uY2U6IGZ1bmN0aW9uIG9uY2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmV4YWN0bHkoMSk7XG4gICAgfSxcblxuICAgIHR3aWNlOiBmdW5jdGlvbiB0d2ljZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhhY3RseSgyKTtcbiAgICB9LFxuXG4gICAgdGhyaWNlOiBmdW5jdGlvbiB0aHJpY2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmV4YWN0bHkoMyk7XG4gICAgfSxcblxuICAgIGV4YWN0bHk6IGZ1bmN0aW9uIGV4YWN0bHkobnVtKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbnVtICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGAnJHt2YWx1ZVRvU3RyaW5nKG51bSl9JyBpcyBub3QgYSBudW1iZXJgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuYXRMZWFzdChudW0pO1xuICAgICAgICByZXR1cm4gdGhpcy5hdE1vc3QobnVtKTtcbiAgICB9LFxuXG4gICAgbWV0OiBmdW5jdGlvbiBtZXQoKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5mYWlsZWQgJiYgcmVjZWl2ZWRNaW5DYWxscyh0aGlzKTtcbiAgICB9LFxuXG4gICAgdmVyaWZ5Q2FsbEFsbG93ZWQ6IGZ1bmN0aW9uIHZlcmlmeUNhbGxBbGxvd2VkKHRoaXNWYWx1ZSwgYXJncykge1xuICAgICAgICBjb25zdCBleHBlY3RlZEFyZ3VtZW50cyA9IHRoaXMuZXhwZWN0ZWRBcmd1bWVudHM7XG5cbiAgICAgICAgaWYgKHJlY2VpdmVkTWF4Q2FsbHModGhpcykpIHtcbiAgICAgICAgICAgIHRoaXMuZmFpbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIG1vY2tFeHBlY3RhdGlvbi5mYWlsKFxuICAgICAgICAgICAgICAgIGAke3RoaXMubWV0aG9kfSBhbHJlYWR5IGNhbGxlZCAke3RpbWVzSW5Xb3Jkcyh0aGlzLm1heENhbGxzKX1gLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChcImV4cGVjdGVkVGhpc1wiIGluIHRoaXMgJiYgdGhpcy5leHBlY3RlZFRoaXMgIT09IHRoaXNWYWx1ZSkge1xuICAgICAgICAgICAgbW9ja0V4cGVjdGF0aW9uLmZhaWwoXG4gICAgICAgICAgICAgICAgYCR7dGhpcy5tZXRob2R9IGNhbGxlZCB3aXRoICR7dmFsdWVUb1N0cmluZyhcbiAgICAgICAgICAgICAgICAgICAgdGhpc1ZhbHVlLFxuICAgICAgICAgICAgICAgICl9IGFzIHRoaXNWYWx1ZSwgZXhwZWN0ZWQgJHt2YWx1ZVRvU3RyaW5nKHRoaXMuZXhwZWN0ZWRUaGlzKX1gLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghKFwiZXhwZWN0ZWRBcmd1bWVudHNcIiBpbiB0aGlzKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFhcmdzKSB7XG4gICAgICAgICAgICBtb2NrRXhwZWN0YXRpb24uZmFpbChcbiAgICAgICAgICAgICAgICBgJHt0aGlzLm1ldGhvZH0gcmVjZWl2ZWQgbm8gYXJndW1lbnRzLCBleHBlY3RlZCAke2luc3BlY3QoXG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkQXJndW1lbnRzLFxuICAgICAgICAgICAgICAgICl9YCxcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYXJncy5sZW5ndGggPCBleHBlY3RlZEFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIG1vY2tFeHBlY3RhdGlvbi5mYWlsKFxuICAgICAgICAgICAgICAgIGAke3RoaXMubWV0aG9kfSByZWNlaXZlZCB0b28gZmV3IGFyZ3VtZW50cyAoJHtpbnNwZWN0KFxuICAgICAgICAgICAgICAgICAgICBhcmdzLFxuICAgICAgICAgICAgICAgICl9KSwgZXhwZWN0ZWQgJHtpbnNwZWN0KGV4cGVjdGVkQXJndW1lbnRzKX1gLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIHRoaXMuZXhwZWN0c0V4YWN0QXJnQ291bnQgJiZcbiAgICAgICAgICAgIGFyZ3MubGVuZ3RoICE9PSBleHBlY3RlZEFyZ3VtZW50cy5sZW5ndGhcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBtb2NrRXhwZWN0YXRpb24uZmFpbChcbiAgICAgICAgICAgICAgICBgJHt0aGlzLm1ldGhvZH0gcmVjZWl2ZWQgdG9vIG1hbnkgYXJndW1lbnRzICgke2luc3BlY3QoXG4gICAgICAgICAgICAgICAgICAgIGFyZ3MsXG4gICAgICAgICAgICAgICAgKX0pLCBleHBlY3RlZCAke2luc3BlY3QoZXhwZWN0ZWRBcmd1bWVudHMpfWAsXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yRWFjaChcbiAgICAgICAgICAgIGV4cGVjdGVkQXJndW1lbnRzLFxuICAgICAgICAgICAgZnVuY3Rpb24gKGV4cGVjdGVkQXJndW1lbnQsIGkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXZlcmlmeU1hdGNoZXIoZXhwZWN0ZWRBcmd1bWVudCwgYXJnc1tpXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbW9ja0V4cGVjdGF0aW9uLmZhaWwoXG4gICAgICAgICAgICAgICAgICAgICAgICBgJHt0aGlzLm1ldGhvZH0gcmVjZWl2ZWQgd3JvbmcgYXJndW1lbnRzICR7aW5zcGVjdChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzLFxuICAgICAgICAgICAgICAgICAgICAgICAgKX0sIGRpZG4ndCBtYXRjaCAke1N0cmluZyhleHBlY3RlZEFyZ3VtZW50cyl9YCxcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIWRlZXBFcXVhbChhcmdzW2ldLCBleHBlY3RlZEFyZ3VtZW50KSkge1xuICAgICAgICAgICAgICAgICAgICBtb2NrRXhwZWN0YXRpb24uZmFpbChcbiAgICAgICAgICAgICAgICAgICAgICAgIGAke3RoaXMubWV0aG9kfSByZWNlaXZlZCB3cm9uZyBhcmd1bWVudHMgJHtpbnNwZWN0KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MsXG4gICAgICAgICAgICAgICAgICAgICAgICApfSwgZXhwZWN0ZWQgJHtpbnNwZWN0KGV4cGVjdGVkQXJndW1lbnRzKX1gLFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICApO1xuICAgIH0sXG5cbiAgICBhbGxvd3NDYWxsOiBmdW5jdGlvbiBhbGxvd3NDYWxsKHRoaXNWYWx1ZSwgYXJncykge1xuICAgICAgICBjb25zdCBleHBlY3RlZEFyZ3VtZW50cyA9IHRoaXMuZXhwZWN0ZWRBcmd1bWVudHM7XG5cbiAgICAgICAgaWYgKHRoaXMubWV0KCkgJiYgcmVjZWl2ZWRNYXhDYWxscyh0aGlzKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKFwiZXhwZWN0ZWRUaGlzXCIgaW4gdGhpcyAmJiB0aGlzLmV4cGVjdGVkVGhpcyAhPT0gdGhpc1ZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIShcImV4cGVjdGVkQXJndW1lbnRzXCIgaW4gdGhpcykpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVyc2NvcmUtZGFuZ2xlXG4gICAgICAgIGNvbnN0IF9hcmdzID0gYXJncyB8fCBbXTtcblxuICAgICAgICBpZiAoX2FyZ3MubGVuZ3RoIDwgZXhwZWN0ZWRBcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoXG4gICAgICAgICAgICB0aGlzLmV4cGVjdHNFeGFjdEFyZ0NvdW50ICYmXG4gICAgICAgICAgICBfYXJncy5sZW5ndGggIT09IGV4cGVjdGVkQXJndW1lbnRzLmxlbmd0aFxuICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBldmVyeShleHBlY3RlZEFyZ3VtZW50cywgZnVuY3Rpb24gKGV4cGVjdGVkQXJndW1lbnQsIGkpIHtcbiAgICAgICAgICAgIGlmICghdmVyaWZ5TWF0Y2hlcihleHBlY3RlZEFyZ3VtZW50LCBfYXJnc1tpXSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghZGVlcEVxdWFsKF9hcmdzW2ldLCBleHBlY3RlZEFyZ3VtZW50KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICB3aXRoQXJnczogZnVuY3Rpb24gd2l0aEFyZ3MoKSB7XG4gICAgICAgIHRoaXMuZXhwZWN0ZWRBcmd1bWVudHMgPSBzbGljZShhcmd1bWVudHMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgd2l0aEV4YWN0QXJnczogZnVuY3Rpb24gd2l0aEV4YWN0QXJncygpIHtcbiAgICAgICAgdGhpcy53aXRoQXJncy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB0aGlzLmV4cGVjdHNFeGFjdEFyZ0NvdW50ID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIG9uOiBmdW5jdGlvbiBvbih0aGlzVmFsdWUpIHtcbiAgICAgICAgdGhpcy5leHBlY3RlZFRoaXMgPSB0aGlzVmFsdWU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICB0b1N0cmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zdCBhcmdzID0gc2xpY2UodGhpcy5leHBlY3RlZEFyZ3VtZW50cyB8fCBbXSk7XG5cbiAgICAgICAgaWYgKCF0aGlzLmV4cGVjdHNFeGFjdEFyZ0NvdW50KSB7XG4gICAgICAgICAgICBwdXNoKGFyZ3MsIFwiWy4uLl1cIik7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjYWxsU3RyID0gcHJveHlDYWxsVG9TdHJpbmcuY2FsbCh7XG4gICAgICAgICAgICBwcm94eTogdGhpcy5tZXRob2QgfHwgXCJhbm9ueW1vdXMgbW9jayBleHBlY3RhdGlvblwiLFxuICAgICAgICAgICAgYXJnczogYXJncyxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGAke2NhbGxTdHIucmVwbGFjZShcbiAgICAgICAgICAgIFwiLCBbLi4uXCIsXG4gICAgICAgICAgICBcIlssIC4uLlwiLFxuICAgICAgICApfSAke2V4cGVjdGVkQ2FsbENvdW50SW5Xb3Jkcyh0aGlzKX1gO1xuXG4gICAgICAgIGlmICh0aGlzLm1ldCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gYEV4cGVjdGF0aW9uIG1ldDogJHttZXNzYWdlfWA7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYEV4cGVjdGVkICR7bWVzc2FnZX0gKCR7Y2FsbENvdW50SW5Xb3Jkcyh0aGlzLmNhbGxDb3VudCl9KWA7XG4gICAgfSxcblxuICAgIHZlcmlmeTogZnVuY3Rpb24gdmVyaWZ5KCkge1xuICAgICAgICBpZiAoIXRoaXMubWV0KCkpIHtcbiAgICAgICAgICAgIG1vY2tFeHBlY3RhdGlvbi5mYWlsKFN0cmluZyh0aGlzKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtb2NrRXhwZWN0YXRpb24ucGFzcyhTdHJpbmcodGhpcykpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcblxuICAgIHBhc3M6IGZ1bmN0aW9uIHBhc3MobWVzc2FnZSkge1xuICAgICAgICBhc3NlcnQucGFzcyhtZXNzYWdlKTtcbiAgICB9LFxuXG4gICAgZmFpbDogZnVuY3Rpb24gZmFpbChtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IGV4Y2VwdGlvbiA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICAgICAgZXhjZXB0aW9uLm5hbWUgPSBcIkV4cGVjdGF0aW9uRXJyb3JcIjtcblxuICAgICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgfSxcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gbW9ja0V4cGVjdGF0aW9uO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5jb25zdCBhcnJheVByb3RvID0gcmVxdWlyZShcIkBzaW5vbmpzL2NvbW1vbnNcIikucHJvdG90eXBlcy5hcnJheTtcbmNvbnN0IG1vY2tFeHBlY3RhdGlvbiA9IHJlcXVpcmUoXCIuL21vY2stZXhwZWN0YXRpb25cIik7XG5jb25zdCBwcm94eUNhbGxUb1N0cmluZyA9IHJlcXVpcmUoXCIuL3Byb3h5LWNhbGxcIikudG9TdHJpbmc7XG5jb25zdCBleHRlbmQgPSByZXF1aXJlKFwiLi91dGlsL2NvcmUvZXh0ZW5kXCIpO1xuY29uc3QgZGVlcEVxdWFsID0gcmVxdWlyZShcIkBzaW5vbmpzL3NhbXNhbVwiKS5kZWVwRXF1YWw7XG5jb25zdCB3cmFwTWV0aG9kID0gcmVxdWlyZShcIi4vdXRpbC9jb3JlL3dyYXAtbWV0aG9kXCIpO1xuXG5jb25zdCBjb25jYXQgPSBhcnJheVByb3RvLmNvbmNhdDtcbmNvbnN0IGZpbHRlciA9IGFycmF5UHJvdG8uZmlsdGVyO1xuY29uc3QgZm9yRWFjaCA9IGFycmF5UHJvdG8uZm9yRWFjaDtcbmNvbnN0IGV2ZXJ5ID0gYXJyYXlQcm90by5ldmVyeTtcbmNvbnN0IGpvaW4gPSBhcnJheVByb3RvLmpvaW47XG5jb25zdCBwdXNoID0gYXJyYXlQcm90by5wdXNoO1xuY29uc3Qgc2xpY2UgPSBhcnJheVByb3RvLnNsaWNlO1xuY29uc3QgdW5zaGlmdCA9IGFycmF5UHJvdG8udW5zaGlmdDtcblxuZnVuY3Rpb24gbW9jayhvYmplY3QpIHtcbiAgICBpZiAoIW9iamVjdCB8fCB0eXBlb2Ygb2JqZWN0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiBtb2NrRXhwZWN0YXRpb24uY3JlYXRlKG9iamVjdCA/IG9iamVjdCA6IFwiQW5vbnltb3VzIG1vY2tcIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1vY2suY3JlYXRlKG9iamVjdCk7XG59XG5cbmZ1bmN0aW9uIGVhY2goY29sbGVjdGlvbiwgY2FsbGJhY2spIHtcbiAgICBjb25zdCBjb2wgPSBjb2xsZWN0aW9uIHx8IFtdO1xuXG4gICAgZm9yRWFjaChjb2wsIGNhbGxiYWNrKTtcbn1cblxuZnVuY3Rpb24gYXJyYXlFcXVhbHMoYXJyMSwgYXJyMiwgY29tcGFyZUxlbmd0aCkge1xuICAgIGlmIChjb21wYXJlTGVuZ3RoICYmIGFycjEubGVuZ3RoICE9PSBhcnIyLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIGV2ZXJ5KGFycjEsIGZ1bmN0aW9uIChlbGVtZW50LCBpKSB7XG4gICAgICAgIHJldHVybiBkZWVwRXF1YWwoYXJyMltpXSwgZWxlbWVudCk7XG4gICAgfSk7XG59XG5cbmV4dGVuZChtb2NrLCB7XG4gICAgY3JlYXRlOiBmdW5jdGlvbiBjcmVhdGUob2JqZWN0KSB7XG4gICAgICAgIGlmICghb2JqZWN0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwib2JqZWN0IGlzIG51bGxcIik7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBtb2NrT2JqZWN0ID0gZXh0ZW5kLm5vbkVudW0oe30sIG1vY2ssIHsgb2JqZWN0OiBvYmplY3QgfSk7XG4gICAgICAgIGRlbGV0ZSBtb2NrT2JqZWN0LmNyZWF0ZTtcblxuICAgICAgICByZXR1cm4gbW9ja09iamVjdDtcbiAgICB9LFxuXG4gICAgZXhwZWN0czogZnVuY3Rpb24gZXhwZWN0cyhtZXRob2QpIHtcbiAgICAgICAgaWYgKCFtZXRob2QpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJtZXRob2QgaXMgZmFsc3lcIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuZXhwZWN0YXRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLmV4cGVjdGF0aW9ucyA9IHt9O1xuICAgICAgICAgICAgdGhpcy5wcm94aWVzID0gW107XG4gICAgICAgICAgICB0aGlzLmZhaWx1cmVzID0gW107XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuZXhwZWN0YXRpb25zW21ldGhvZF0pIHtcbiAgICAgICAgICAgIHRoaXMuZXhwZWN0YXRpb25zW21ldGhvZF0gPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IG1vY2tPYmplY3QgPSB0aGlzO1xuXG4gICAgICAgICAgICB3cmFwTWV0aG9kKHRoaXMub2JqZWN0LCBtZXRob2QsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbW9ja09iamVjdC5pbnZva2VNZXRob2QobWV0aG9kLCB0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHB1c2godGhpcy5wcm94aWVzLCBtZXRob2QpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZXhwZWN0YXRpb24gPSBtb2NrRXhwZWN0YXRpb24uY3JlYXRlKG1ldGhvZCk7XG4gICAgICAgIGV4cGVjdGF0aW9uLndyYXBwZWRNZXRob2QgPSB0aGlzLm9iamVjdFttZXRob2RdLndyYXBwZWRNZXRob2Q7XG4gICAgICAgIHB1c2godGhpcy5leHBlY3RhdGlvbnNbbWV0aG9kXSwgZXhwZWN0YXRpb24pO1xuXG4gICAgICAgIHJldHVybiBleHBlY3RhdGlvbjtcbiAgICB9LFxuXG4gICAgcmVzdG9yZTogZnVuY3Rpb24gcmVzdG9yZSgpIHtcbiAgICAgICAgY29uc3Qgb2JqZWN0ID0gdGhpcy5vYmplY3Q7XG5cbiAgICAgICAgZWFjaCh0aGlzLnByb3hpZXMsIGZ1bmN0aW9uIChwcm94eSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3RbcHJveHldLnJlc3RvcmUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIG9iamVjdFtwcm94eV0ucmVzdG9yZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgdmVyaWZ5OiBmdW5jdGlvbiB2ZXJpZnkoKSB7XG4gICAgICAgIGNvbnN0IGV4cGVjdGF0aW9ucyA9IHRoaXMuZXhwZWN0YXRpb25zIHx8IHt9O1xuICAgICAgICBjb25zdCBtZXNzYWdlcyA9IHRoaXMuZmFpbHVyZXMgPyBzbGljZSh0aGlzLmZhaWx1cmVzKSA6IFtdO1xuICAgICAgICBjb25zdCBtZXQgPSBbXTtcblxuICAgICAgICBlYWNoKHRoaXMucHJveGllcywgZnVuY3Rpb24gKHByb3h5KSB7XG4gICAgICAgICAgICBlYWNoKGV4cGVjdGF0aW9uc1twcm94eV0sIGZ1bmN0aW9uIChleHBlY3RhdGlvbikge1xuICAgICAgICAgICAgICAgIGlmICghZXhwZWN0YXRpb24ubWV0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcHVzaChtZXNzYWdlcywgU3RyaW5nKGV4cGVjdGF0aW9uKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcHVzaChtZXQsIFN0cmluZyhleHBlY3RhdGlvbikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLnJlc3RvcmUoKTtcblxuICAgICAgICBpZiAobWVzc2FnZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgbW9ja0V4cGVjdGF0aW9uLmZhaWwoam9pbihjb25jYXQobWVzc2FnZXMsIG1ldCksIFwiXFxuXCIpKTtcbiAgICAgICAgfSBlbHNlIGlmIChtZXQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgbW9ja0V4cGVjdGF0aW9uLnBhc3Moam9pbihjb25jYXQobWVzc2FnZXMsIG1ldCksIFwiXFxuXCIpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG5cbiAgICBpbnZva2VNZXRob2Q6IGZ1bmN0aW9uIGludm9rZU1ldGhvZChtZXRob2QsIHRoaXNWYWx1ZSwgYXJncykge1xuICAgICAgICAvKiBpZiB3ZSBjYW5ub3QgZmluZCBhbnkgbWF0Y2hpbmcgZmlsZXMgd2Ugd2lsbCBleHBsaWNpdGx5IGNhbGwgbW9ja0V4cGVjdGlvbiNmYWlsIHdpdGggZXJyb3IgbWVzc2FnZXMgKi9cbiAgICAgICAgLyogZXNsaW50IGNvbnNpc3RlbnQtcmV0dXJuOiBcIm9mZlwiICovXG4gICAgICAgIGNvbnN0IGV4cGVjdGF0aW9ucyA9XG4gICAgICAgICAgICB0aGlzLmV4cGVjdGF0aW9ucyAmJiB0aGlzLmV4cGVjdGF0aW9uc1ttZXRob2RdXG4gICAgICAgICAgICAgICAgPyB0aGlzLmV4cGVjdGF0aW9uc1ttZXRob2RdXG4gICAgICAgICAgICAgICAgOiBbXTtcbiAgICAgICAgY29uc3QgY3VycmVudEFyZ3MgPSBhcmdzIHx8IFtdO1xuICAgICAgICBsZXQgYXZhaWxhYmxlO1xuXG4gICAgICAgIGNvbnN0IGV4cGVjdGF0aW9uc1dpdGhNYXRjaGluZ0FyZ3MgPSBmaWx0ZXIoXG4gICAgICAgICAgICBleHBlY3RhdGlvbnMsXG4gICAgICAgICAgICBmdW5jdGlvbiAoZXhwZWN0YXRpb24pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBleHBlY3RlZEFyZ3MgPSBleHBlY3RhdGlvbi5leHBlY3RlZEFyZ3VtZW50cyB8fCBbXTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBhcnJheUVxdWFscyhcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWRBcmdzLFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50QXJncyxcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0YXRpb24uZXhwZWN0c0V4YWN0QXJnQ291bnQsXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICk7XG5cbiAgICAgICAgY29uc3QgZXhwZWN0YXRpb25zVG9BcHBseSA9IGZpbHRlcihcbiAgICAgICAgICAgIGV4cGVjdGF0aW9uc1dpdGhNYXRjaGluZ0FyZ3MsXG4gICAgICAgICAgICBmdW5jdGlvbiAoZXhwZWN0YXRpb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgICAgICAhZXhwZWN0YXRpb24ubWV0KCkgJiZcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0YXRpb24uYWxsb3dzQ2FsbCh0aGlzVmFsdWUsIGFyZ3MpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICk7XG5cbiAgICAgICAgaWYgKGV4cGVjdGF0aW9uc1RvQXBwbHkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGV4cGVjdGF0aW9uc1RvQXBwbHlbMF0uYXBwbHkodGhpc1ZhbHVlLCBhcmdzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG1lc3NhZ2VzID0gW107XG4gICAgICAgIGxldCBleGhhdXN0ZWQgPSAwO1xuXG4gICAgICAgIGZvckVhY2goZXhwZWN0YXRpb25zV2l0aE1hdGNoaW5nQXJncywgZnVuY3Rpb24gKGV4cGVjdGF0aW9uKSB7XG4gICAgICAgICAgICBpZiAoZXhwZWN0YXRpb24uYWxsb3dzQ2FsbCh0aGlzVmFsdWUsIGFyZ3MpKSB7XG4gICAgICAgICAgICAgICAgYXZhaWxhYmxlID0gYXZhaWxhYmxlIHx8IGV4cGVjdGF0aW9uO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBleGhhdXN0ZWQgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGF2YWlsYWJsZSAmJiBleGhhdXN0ZWQgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBhdmFpbGFibGUuYXBwbHkodGhpc1ZhbHVlLCBhcmdzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvckVhY2goZXhwZWN0YXRpb25zLCBmdW5jdGlvbiAoZXhwZWN0YXRpb24pIHtcbiAgICAgICAgICAgIHB1c2gobWVzc2FnZXMsIGAgICAgJHtTdHJpbmcoZXhwZWN0YXRpb24pfWApO1xuICAgICAgICB9KTtcblxuICAgICAgICB1bnNoaWZ0KFxuICAgICAgICAgICAgbWVzc2FnZXMsXG4gICAgICAgICAgICBgVW5leHBlY3RlZCBjYWxsOiAke3Byb3h5Q2FsbFRvU3RyaW5nLmNhbGwoe1xuICAgICAgICAgICAgICAgIHByb3h5OiBtZXRob2QsXG4gICAgICAgICAgICAgICAgYXJnczogYXJncyxcbiAgICAgICAgICAgIH0pfWAsXG4gICAgICAgICk7XG5cbiAgICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKCk7XG4gICAgICAgIGlmICghZXJyLnN0YWNrKSB7XG4gICAgICAgICAgICAvLyBQaGFudG9tSlMgZG9lcyBub3Qgc2VyaWFsaXplIHRoZSBzdGFjayB0cmFjZSB1bnRpbCB0aGUgZXJyb3IgaGFzIGJlZW4gdGhyb3duXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAvKiBlbXB0eSAqL1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHB1c2goXG4gICAgICAgICAgICB0aGlzLmZhaWx1cmVzLFxuICAgICAgICAgICAgYFVuZXhwZWN0ZWQgY2FsbDogJHtwcm94eUNhbGxUb1N0cmluZy5jYWxsKHtcbiAgICAgICAgICAgICAgICBwcm94eTogbWV0aG9kLFxuICAgICAgICAgICAgICAgIGFyZ3M6IGFyZ3MsXG4gICAgICAgICAgICAgICAgc3RhY2s6IGVyci5zdGFjayxcbiAgICAgICAgICAgIH0pfWAsXG4gICAgICAgICk7XG5cbiAgICAgICAgbW9ja0V4cGVjdGF0aW9uLmZhaWwoam9pbihtZXNzYWdlcywgXCJcXG5cIikpO1xuICAgIH0sXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBtb2NrO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5jb25zdCBzdHViID0gcmVxdWlyZShcIi4vc3R1YlwiKTtcbmNvbnN0IHNpbm9uVHlwZSA9IHJlcXVpcmUoXCIuL3V0aWwvY29yZS9zaW5vbi10eXBlXCIpO1xuY29uc3QgZm9yRWFjaCA9IHJlcXVpcmUoXCJAc2lub25qcy9jb21tb25zXCIpLnByb3RvdHlwZXMuYXJyYXkuZm9yRWFjaDtcblxuZnVuY3Rpb24gaXNTdHViKHZhbHVlKSB7XG4gICAgcmV0dXJuIHNpbm9uVHlwZS5nZXQodmFsdWUpID09PSBcInN0dWJcIjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjcmVhdGVTdHViSW5zdGFuY2UoY29uc3RydWN0b3IsIG92ZXJyaWRlcykge1xuICAgIGlmICh0eXBlb2YgY29uc3RydWN0b3IgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiVGhlIGNvbnN0cnVjdG9yIHNob3VsZCBiZSBhIGZ1bmN0aW9uLlwiKTtcbiAgICB9XG5cbiAgICBjb25zdCBzdHViSW5zdGFuY2UgPSBPYmplY3QuY3JlYXRlKGNvbnN0cnVjdG9yLnByb3RvdHlwZSk7XG4gICAgc2lub25UeXBlLnNldChzdHViSW5zdGFuY2UsIFwic3R1Yi1pbnN0YW5jZVwiKTtcblxuICAgIGNvbnN0IHN0dWJiZWRPYmplY3QgPSBzdHViKHN0dWJJbnN0YW5jZSk7XG5cbiAgICBmb3JFYWNoKE9iamVjdC5rZXlzKG92ZXJyaWRlcyB8fCB7fSksIGZ1bmN0aW9uIChwcm9wZXJ0eU5hbWUpIHtcbiAgICAgICAgaWYgKHByb3BlcnR5TmFtZSBpbiBzdHViYmVkT2JqZWN0KSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IG92ZXJyaWRlc1twcm9wZXJ0eU5hbWVdO1xuICAgICAgICAgICAgaWYgKGlzU3R1Yih2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBzdHViYmVkT2JqZWN0W3Byb3BlcnR5TmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3R1YmJlZE9iamVjdFtwcm9wZXJ0eU5hbWVdLnJldHVybnModmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgIGBDYW5ub3Qgc3R1YiAke3Byb3BlcnR5TmFtZX0uIFByb3BlcnR5IGRvZXMgbm90IGV4aXN0IWAsXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHN0dWJiZWRPYmplY3Q7XG59O1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5jb25zdCBhcnJheVByb3RvID0gcmVxdWlyZShcIkBzaW5vbmpzL2NvbW1vbnNcIikucHJvdG90eXBlcy5hcnJheTtcbmNvbnN0IGNyZWF0ZVByb3h5ID0gcmVxdWlyZShcIi4vcHJveHlcIik7XG5jb25zdCBuZXh0VGljayA9IHJlcXVpcmUoXCIuL3V0aWwvY29yZS9uZXh0LXRpY2tcIik7XG5cbmNvbnN0IHNsaWNlID0gYXJyYXlQcm90by5zbGljZTtcblxubW9kdWxlLmV4cG9ydHMgPSBmYWtlO1xuXG4vKipcbiAqIFJldHVybnMgYSBgZmFrZWAgdGhhdCByZWNvcmRzIGFsbCBjYWxscywgYXJndW1lbnRzIGFuZCByZXR1cm4gdmFsdWVzLlxuICpcbiAqIFdoZW4gYW4gYGZgIGFyZ3VtZW50IGlzIHN1cHBsaWVkLCB0aGlzIGltcGxlbWVudGF0aW9uIHdpbGwgYmUgdXNlZC5cbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gY3JlYXRlIGFuIGVtcHR5IGZha2VcbiAqIHZhciBmMSA9IHNpbm9uLmZha2UoKTtcbiAqXG4gKiBmMSgpO1xuICpcbiAqIGYxLmNhbGxlZE9uY2UoKVxuICogLy8gdHJ1ZVxuICpcbiAqIEBleGFtcGxlXG4gKiBmdW5jdGlvbiBncmVldChncmVldGluZykge1xuICogICBjb25zb2xlLmxvZyhgSGVsbG8gJHtncmVldGluZ31gKTtcbiAqIH1cbiAqXG4gKiAvLyBjcmVhdGUgYSBmYWtlIHdpdGggaW1wbGVtZW50YXRpb25cbiAqIHZhciBmMiA9IHNpbm9uLmZha2UoZ3JlZXQpO1xuICpcbiAqIC8vIEhlbGxvIHdvcmxkXG4gKiBmMihcIndvcmxkXCIpO1xuICpcbiAqIGYyLmNhbGxlZFdpdGgoXCJ3b3JsZFwiKTtcbiAqIC8vIHRydWVcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufHVuZGVmaW5lZH0gZlxuICogQHJldHVybnMge0Z1bmN0aW9ufVxuICogQG5hbWVzcGFjZVxuICovXG5mdW5jdGlvbiBmYWtlKGYpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgdHlwZW9mIGYgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgZiBhcmd1bWVudCB0byBiZSBhIEZ1bmN0aW9uXCIpO1xuICAgIH1cblxuICAgIHJldHVybiB3cmFwRnVuYyhmKTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgYGZha2VgIHRoYXQgcmV0dXJucyB0aGUgcHJvdmlkZWQgYHZhbHVlYCwgYXMgd2VsbCBhcyByZWNvcmRpbmcgYWxsXG4gKiBjYWxscywgYXJndW1lbnRzIGFuZCByZXR1cm4gdmFsdWVzLlxuICpcbiAqIEBleGFtcGxlXG4gKiB2YXIgZjEgPSBzaW5vbi5mYWtlLnJldHVybnMoNDIpO1xuICpcbiAqIGYxKCk7XG4gKiAvLyA0MlxuICpcbiAqIEBtZW1iZXJvZiBmYWtlXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259XG4gKi9cbmZha2UucmV0dXJucyA9IGZ1bmN0aW9uIHJldHVybnModmFsdWUpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUganNkb2MvcmVxdWlyZS1qc2RvY1xuICAgIGZ1bmN0aW9uIGYoKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gd3JhcEZ1bmMoZik7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBgZmFrZWAgdGhhdCB0aHJvd3MgYW4gRXJyb3IuXG4gKiBJZiB0aGUgYHZhbHVlYCBhcmd1bWVudCBkb2VzIG5vdCBoYXZlIEVycm9yIGluIGl0cyBwcm90b3R5cGUgY2hhaW4sIGl0IHdpbGxcbiAqIGJlIHVzZWQgZm9yIGNyZWF0aW5nIGEgbmV3IGVycm9yLlxuICpcbiAqIEBleGFtcGxlXG4gKiB2YXIgZjEgPSBzaW5vbi5mYWtlLnRocm93cyhcImhlbGxvXCIpO1xuICpcbiAqIGYxKCk7XG4gKiAvLyBVbmNhdWdodCBFcnJvcjogaGVsbG9cbiAqXG4gKiBAZXhhbXBsZVxuICogdmFyIGYyID0gc2lub24uZmFrZS50aHJvd3MobmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXJndW1lbnRcIikpO1xuICpcbiAqIGYyKCk7XG4gKiAvLyBVbmNhdWdodCBUeXBlRXJyb3I6IEludmFsaWQgYXJndW1lbnRcbiAqXG4gKiBAbWVtYmVyb2YgZmFrZVxuICogQHBhcmFtIHsqfEVycm9yfSB2YWx1ZVxuICogQHJldHVybnMge0Z1bmN0aW9ufVxuICovXG5mYWtlLnRocm93cyA9IGZ1bmN0aW9uIHRocm93cyh2YWx1ZSkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBqc2RvYy9yZXF1aXJlLWpzZG9jXG4gICAgZnVuY3Rpb24gZigpIHtcbiAgICAgICAgdGhyb3cgZ2V0RXJyb3IodmFsdWUpO1xuICAgIH1cblxuICAgIHJldHVybiB3cmFwRnVuYyhmKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIGBmYWtlYCB0aGF0IHJldHVybnMgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIHBhc3NlZCBgdmFsdWVgXG4gKiBhcmd1bWVudC5cbiAqXG4gKiBAZXhhbXBsZVxuICogdmFyIGYxID0gc2lub24uZmFrZS5yZXNvbHZlcyhcImFwcGxlIHBpZVwiKTtcbiAqXG4gKiBhd2FpdCBmMSgpO1xuICogLy8gXCJhcHBsZSBwaWVcIlxuICpcbiAqIEBtZW1iZXJvZiBmYWtlXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259XG4gKi9cbmZha2UucmVzb2x2ZXMgPSBmdW5jdGlvbiByZXNvbHZlcyh2YWx1ZSkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBqc2RvYy9yZXF1aXJlLWpzZG9jXG4gICAgZnVuY3Rpb24gZigpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2YWx1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHdyYXBGdW5jKGYpO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgYGZha2VgIHRoYXQgcmV0dXJucyBhIHByb21pc2UgdGhhdCByZWplY3RzIHRvIHRoZSBwYXNzZWQgYHZhbHVlYFxuICogYXJndW1lbnQuIFdoZW4gYHZhbHVlYCBkb2VzIG5vdCBoYXZlIEVycm9yIGluIGl0cyBwcm90b3R5cGUgY2hhaW4sIGl0IHdpbGwgYmVcbiAqIHdyYXBwZWQgaW4gYW4gRXJyb3IuXG4gKlxuICogQGV4YW1wbGVcbiAqIHZhciBmMSA9IHNpbm9uLmZha2UucmVqZWN0cyhcIjooXCIpO1xuICpcbiAqIHRyeSB7XG4gKiAgIGF3YWl0IGYxKCk7XG4gKiB9IGNhdGNoIChlcnJvcikge1xuICogICBjb25zb2xlLmxvZyhlcnJvcik7XG4gKiAgIC8vIFwiOihcIlxuICogfVxuICpcbiAqIEBtZW1iZXJvZiBmYWtlXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259XG4gKi9cbmZha2UucmVqZWN0cyA9IGZ1bmN0aW9uIHJlamVjdHModmFsdWUpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUganNkb2MvcmVxdWlyZS1qc2RvY1xuICAgIGZ1bmN0aW9uIGYoKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChnZXRFcnJvcih2YWx1ZSkpO1xuICAgIH1cblxuICAgIHJldHVybiB3cmFwRnVuYyhmKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIGBmYWtlYCB0aGF0IGNhbGxzIHRoZSBjYWxsYmFjayB3aXRoIHRoZSBkZWZpbmVkIGFyZ3VtZW50cy5cbiAqXG4gKiBAZXhhbXBsZVxuICogZnVuY3Rpb24gY2FsbGJhY2soKSB7XG4gKiAgIGNvbnNvbGUubG9nKGFyZ3VtZW50cy5qb2luKFwiKlwiKSk7XG4gKiB9XG4gKlxuICogY29uc3QgZjEgPSBzaW5vbi5mYWtlLnlpZWxkcyhcImFwcGxlXCIsIFwicGllXCIpO1xuICpcbiAqIGYxKGNhbGxiYWNrKTtcbiAqIC8vIFwiYXBwbGUqcGllXCJcbiAqXG4gKiBAbWVtYmVyb2YgZmFrZVxuICogQHJldHVybnMge0Z1bmN0aW9ufVxuICovXG5mYWtlLnlpZWxkcyA9IGZ1bmN0aW9uIHlpZWxkcygpIHtcbiAgICBjb25zdCB2YWx1ZXMgPSBzbGljZShhcmd1bWVudHMpO1xuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGpzZG9jL3JlcXVpcmUtanNkb2NcbiAgICBmdW5jdGlvbiBmKCkge1xuICAgICAgICBjb25zdCBjYWxsYmFjayA9IGFyZ3VtZW50c1thcmd1bWVudHMubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIGxhc3QgYXJndW1lbnQgdG8gYmUgYSBmdW5jdGlvblwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNhbGxiYWNrLmFwcGx5KG51bGwsIHZhbHVlcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHdyYXBGdW5jKGYpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgYGZha2VgIHRoYXQgY2FsbHMgdGhlIGNhbGxiYWNrICoqYXN5bmNocm9ub3VzbHkqKiB3aXRoIHRoZVxuICogZGVmaW5lZCBhcmd1bWVudHMuXG4gKlxuICogQGV4YW1wbGVcbiAqIGZ1bmN0aW9uIGNhbGxiYWNrKCkge1xuICogICBjb25zb2xlLmxvZyhhcmd1bWVudHMuam9pbihcIipcIikpO1xuICogfVxuICpcbiAqIGNvbnN0IGYxID0gc2lub24uZmFrZS55aWVsZHMoXCJhcHBsZVwiLCBcInBpZVwiKTtcbiAqXG4gKiBmMShjYWxsYmFjayk7XG4gKlxuICogc2V0VGltZW91dCgoKSA9PiB7XG4gKiAgIC8vIFwiYXBwbGUqcGllXCJcbiAqIH0pO1xuICpcbiAqIEBtZW1iZXJvZiBmYWtlXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259XG4gKi9cbmZha2UueWllbGRzQXN5bmMgPSBmdW5jdGlvbiB5aWVsZHNBc3luYygpIHtcbiAgICBjb25zdCB2YWx1ZXMgPSBzbGljZShhcmd1bWVudHMpO1xuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGpzZG9jL3JlcXVpcmUtanNkb2NcbiAgICBmdW5jdGlvbiBmKCkge1xuICAgICAgICBjb25zdCBjYWxsYmFjayA9IGFyZ3VtZW50c1thcmd1bWVudHMubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIGxhc3QgYXJndW1lbnQgdG8gYmUgYSBmdW5jdGlvblwiKTtcbiAgICAgICAgfVxuICAgICAgICBuZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjYWxsYmFjay5hcHBseShudWxsLCB2YWx1ZXMpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gd3JhcEZ1bmMoZik7XG59O1xuXG5sZXQgdXVpZCA9IDA7XG4vKipcbiAqIENyZWF0ZXMgYSBwcm94eSAoc2lub24gY29uY2VwdCkgZnJvbSB0aGUgcGFzc2VkIGZ1bmN0aW9uLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0gIHtGdW5jdGlvbn0gZlxuICogQHJldHVybnMge0Z1bmN0aW9ufVxuICovXG5mdW5jdGlvbiB3cmFwRnVuYyhmKSB7XG4gICAgY29uc3QgZmFrZUluc3RhbmNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBsZXQgZmlyc3RBcmcsIGxhc3RBcmc7XG5cbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBmaXJzdEFyZyA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgICAgIGxhc3RBcmcgPSBhcmd1bWVudHNbYXJndW1lbnRzLmxlbmd0aCAtIDFdO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY2FsbGJhY2sgPVxuICAgICAgICAgICAgbGFzdEFyZyAmJiB0eXBlb2YgbGFzdEFyZyA9PT0gXCJmdW5jdGlvblwiID8gbGFzdEFyZyA6IHVuZGVmaW5lZDtcblxuICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby11c2UtYmVmb3JlLWRlZmluZSAqL1xuICAgICAgICBwcm94eS5maXJzdEFyZyA9IGZpcnN0QXJnO1xuICAgICAgICBwcm94eS5sYXN0QXJnID0gbGFzdEFyZztcbiAgICAgICAgcHJveHkuY2FsbGJhY2sgPSBjYWxsYmFjaztcblxuICAgICAgICByZXR1cm4gZiAmJiBmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgICBjb25zdCBwcm94eSA9IGNyZWF0ZVByb3h5KGZha2VJbnN0YW5jZSwgZiB8fCBmYWtlSW5zdGFuY2UpO1xuXG4gICAgcHJveHkuZGlzcGxheU5hbWUgPSBcImZha2VcIjtcbiAgICBwcm94eS5pZCA9IGBmYWtlIyR7dXVpZCsrfWA7XG5cbiAgICByZXR1cm4gcHJveHk7XG59XG5cbi8qKlxuICogUmV0dXJucyBhbiBFcnJvciBpbnN0YW5jZSBmcm9tIHRoZSBwYXNzZWQgdmFsdWUsIGlmIHRoZSB2YWx1ZSBpcyBub3RcbiAqIGFscmVhZHkgYW4gRXJyb3IgaW5zdGFuY2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSAgeyp9IHZhbHVlIFtkZXNjcmlwdGlvbl1cbiAqIEByZXR1cm5zIHtFcnJvcn0gICAgICAgW2Rlc2NyaXB0aW9uXVxuICovXG5mdW5jdGlvbiBnZXRFcnJvcih2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIEVycm9yID8gdmFsdWUgOiBuZXcgRXJyb3IodmFsdWUpO1xufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5jb25zdCBhcnJheVByb3RvID0gcmVxdWlyZShcIkBzaW5vbmpzL2NvbW1vbnNcIikucHJvdG90eXBlcy5hcnJheTtcbmNvbnN0IGxvZ2dlciA9IHJlcXVpcmUoXCJAc2lub25qcy9jb21tb25zXCIpLmRlcHJlY2F0ZWQ7XG5jb25zdCBjb2xsZWN0T3duTWV0aG9kcyA9IHJlcXVpcmUoXCIuL2NvbGxlY3Qtb3duLW1ldGhvZHNcIik7XG5jb25zdCBnZXRQcm9wZXJ0eURlc2NyaXB0b3IgPSByZXF1aXJlKFwiLi91dGlsL2NvcmUvZ2V0LXByb3BlcnR5LWRlc2NyaXB0b3JcIik7XG5jb25zdCBpc1Byb3BlcnR5Q29uZmlndXJhYmxlID0gcmVxdWlyZShcIi4vdXRpbC9jb3JlL2lzLXByb3BlcnR5LWNvbmZpZ3VyYWJsZVwiKTtcbmNvbnN0IG1hdGNoID0gcmVxdWlyZShcIkBzaW5vbmpzL3NhbXNhbVwiKS5jcmVhdGVNYXRjaGVyO1xuY29uc3Qgc2lub25Bc3NlcnQgPSByZXF1aXJlKFwiLi9hc3NlcnRcIik7XG5jb25zdCBzaW5vbkNsb2NrID0gcmVxdWlyZShcIi4vdXRpbC9mYWtlLXRpbWVyc1wiKTtcbmNvbnN0IHNpbm9uTW9jayA9IHJlcXVpcmUoXCIuL21vY2tcIik7XG5jb25zdCBzaW5vblNweSA9IHJlcXVpcmUoXCIuL3NweVwiKTtcbmNvbnN0IHNpbm9uU3R1YiA9IHJlcXVpcmUoXCIuL3N0dWJcIik7XG5jb25zdCBzaW5vbkNyZWF0ZVN0dWJJbnN0YW5jZSA9IHJlcXVpcmUoXCIuL2NyZWF0ZS1zdHViLWluc3RhbmNlXCIpO1xuY29uc3Qgc2lub25GYWtlID0gcmVxdWlyZShcIi4vZmFrZVwiKTtcbmNvbnN0IHZhbHVlVG9TdHJpbmcgPSByZXF1aXJlKFwiQHNpbm9uanMvY29tbW9uc1wiKS52YWx1ZVRvU3RyaW5nO1xuXG5jb25zdCBERUZBVUxUX0xFQUtfVEhSRVNIT0xEID0gMTAwMDA7XG5cbmNvbnN0IGZpbHRlciA9IGFycmF5UHJvdG8uZmlsdGVyO1xuY29uc3QgZm9yRWFjaCA9IGFycmF5UHJvdG8uZm9yRWFjaDtcbmNvbnN0IHB1c2ggPSBhcnJheVByb3RvLnB1c2g7XG5jb25zdCByZXZlcnNlID0gYXJyYXlQcm90by5yZXZlcnNlO1xuXG5mdW5jdGlvbiBhcHBseU9uRWFjaChmYWtlcywgbWV0aG9kKSB7XG4gICAgY29uc3QgbWF0Y2hpbmdGYWtlcyA9IGZpbHRlcihmYWtlcywgZnVuY3Rpb24gKGZha2UpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBmYWtlW21ldGhvZF0gPT09IFwiZnVuY3Rpb25cIjtcbiAgICB9KTtcblxuICAgIGZvckVhY2gobWF0Y2hpbmdGYWtlcywgZnVuY3Rpb24gKGZha2UpIHtcbiAgICAgICAgZmFrZVttZXRob2RdKCk7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIHRocm93T25BY2Nlc3NvcnMoZGVzY3JpcHRvcikge1xuICAgIGlmICh0eXBlb2YgZGVzY3JpcHRvci5nZXQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVc2Ugc2FuZGJveC5yZXBsYWNlR2V0dGVyIGZvciByZXBsYWNpbmcgZ2V0dGVyc1wiKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGRlc2NyaXB0b3Iuc2V0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVXNlIHNhbmRib3gucmVwbGFjZVNldHRlciBmb3IgcmVwbGFjaW5nIHNldHRlcnNcIik7XG4gICAgfVxufVxuXG5mdW5jdGlvbiB2ZXJpZnlTYW1lVHlwZShvYmplY3QsIHByb3BlcnR5LCByZXBsYWNlbWVudCkge1xuICAgIGlmICh0eXBlb2Ygb2JqZWN0W3Byb3BlcnR5XSAhPT0gdHlwZW9mIHJlcGxhY2VtZW50KSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICBgQ2Fubm90IHJlcGxhY2UgJHt0eXBlb2Ygb2JqZWN0W1xuICAgICAgICAgICAgICAgIHByb3BlcnR5XG4gICAgICAgICAgICBdfSB3aXRoICR7dHlwZW9mIHJlcGxhY2VtZW50fWAsXG4gICAgICAgICk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBjaGVja0ZvclZhbGlkQXJndW1lbnRzKGRlc2NyaXB0b3IsIHByb3BlcnR5LCByZXBsYWNlbWVudCkge1xuICAgIGlmICh0eXBlb2YgZGVzY3JpcHRvciA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgYENhbm5vdCByZXBsYWNlIG5vbi1leGlzdGVudCBwcm9wZXJ0eSAke3ZhbHVlVG9TdHJpbmcoXG4gICAgICAgICAgICAgICAgcHJvcGVydHksXG4gICAgICAgICAgICApfS4gUGVyaGFwcyB5b3UgbWVhbnQgc2FuZGJveC5kZWZpbmUoKT9gLFxuICAgICAgICApO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgcmVwbGFjZW1lbnQgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIHJlcGxhY2VtZW50IGFyZ3VtZW50IHRvIGJlIGRlZmluZWRcIik7XG4gICAgfVxufVxuXG4vKipcbiAqIEEgc2lub24gc2FuZGJveFxuICpcbiAqIEBwYXJhbSBvcHRzXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdHMuYXNzZXJ0T3B0aW9uc10gc2VlIHRoZSBDcmVhdGVBc3NlcnRPcHRpb25zIGluIC4vYXNzZXJ0XG4gKiBAY2xhc3NcbiAqL1xuZnVuY3Rpb24gU2FuZGJveChvcHRzID0ge30pIHtcbiAgICBjb25zdCBzYW5kYm94ID0gdGhpcztcbiAgICBjb25zdCBhc3NlcnRPcHRpb25zID0gb3B0cy5hc3NlcnRPcHRpb25zIHx8IHt9O1xuICAgIGxldCBmYWtlUmVzdG9yZXJzID0gW107XG5cbiAgICBsZXQgY29sbGVjdGlvbiA9IFtdO1xuICAgIGxldCBsb2dnZWRMZWFrV2FybmluZyA9IGZhbHNlO1xuICAgIHNhbmRib3gubGVha1RocmVzaG9sZCA9IERFRkFVTFRfTEVBS19USFJFU0hPTEQ7XG5cbiAgICBmdW5jdGlvbiBhZGRUb0NvbGxlY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIHB1c2goY29sbGVjdGlvbiwgb2JqZWN0KSA+IHNhbmRib3gubGVha1RocmVzaG9sZCAmJlxuICAgICAgICAgICAgIWxvZ2dlZExlYWtXYXJuaW5nXG4gICAgICAgICkge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgICAgIGxvZ2dlci5wcmludFdhcm5pbmcoXG4gICAgICAgICAgICAgICAgXCJQb3RlbnRpYWwgbWVtb3J5IGxlYWsgZGV0ZWN0ZWQ7IGJlIHN1cmUgdG8gY2FsbCByZXN0b3JlKCkgdG8gY2xlYW4gdXAgeW91ciBzYW5kYm94LiBUbyBzdXBwcmVzcyB0aGlzIHdhcm5pbmcsIG1vZGlmeSB0aGUgbGVha1RocmVzaG9sZCBwcm9wZXJ0eSBvZiB5b3VyIHNhbmRib3guXCIsXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgbG9nZ2VkTGVha1dhcm5pbmcgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2FuZGJveC5hc3NlcnQgPSBzaW5vbkFzc2VydC5jcmVhdGVBc3NlcnRPYmplY3QoYXNzZXJ0T3B0aW9ucyk7XG5cbiAgICAvLyB0aGlzIGlzIGZvciB0ZXN0aW5nIG9ubHlcbiAgICBzYW5kYm94LmdldEZha2VzID0gZnVuY3Rpb24gZ2V0RmFrZXMoKSB7XG4gICAgICAgIHJldHVybiBjb2xsZWN0aW9uO1xuICAgIH07XG5cbiAgICBzYW5kYm94LmNyZWF0ZVN0dWJJbnN0YW5jZSA9IGZ1bmN0aW9uIGNyZWF0ZVN0dWJJbnN0YW5jZSgpIHtcbiAgICAgICAgY29uc3Qgc3R1YmJlZCA9IHNpbm9uQ3JlYXRlU3R1Ykluc3RhbmNlLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgY29uc3Qgb3duTWV0aG9kcyA9IGNvbGxlY3RPd25NZXRob2RzKHN0dWJiZWQpO1xuXG4gICAgICAgIGZvckVhY2gob3duTWV0aG9kcywgZnVuY3Rpb24gKG1ldGhvZCkge1xuICAgICAgICAgICAgYWRkVG9Db2xsZWN0aW9uKG1ldGhvZCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBzdHViYmVkO1xuICAgIH07XG5cbiAgICBzYW5kYm94LmluamVjdCA9IGZ1bmN0aW9uIGluamVjdChvYmopIHtcbiAgICAgICAgb2JqLnNweSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBzYW5kYm94LnNweS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIG9iai5zdHViID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHNhbmRib3guc3R1Yi5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIG9iai5tb2NrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHNhbmRib3gubW9jay5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIG9iai5jcmVhdGVTdHViSW5zdGFuY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gc2FuZGJveC5jcmVhdGVTdHViSW5zdGFuY2UuYXBwbHkoc2FuZGJveCwgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcblxuICAgICAgICBvYmouZmFrZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBzYW5kYm94LmZha2UuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcblxuICAgICAgICBvYmouZGVmaW5lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHNhbmRib3guZGVmaW5lLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgb2JqLnJlcGxhY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gc2FuZGJveC5yZXBsYWNlLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgb2JqLnJlcGxhY2VTZXR0ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gc2FuZGJveC5yZXBsYWNlU2V0dGVyLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgb2JqLnJlcGxhY2VHZXR0ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gc2FuZGJveC5yZXBsYWNlR2V0dGVyLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHNhbmRib3guY2xvY2spIHtcbiAgICAgICAgICAgIG9iai5jbG9jayA9IHNhbmRib3guY2xvY2s7XG4gICAgICAgIH1cblxuICAgICAgICBvYmoubWF0Y2ggPSBtYXRjaDtcblxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH07XG5cbiAgICBzYW5kYm94Lm1vY2sgPSBmdW5jdGlvbiBtb2NrKCkge1xuICAgICAgICBjb25zdCBtID0gc2lub25Nb2NrLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgYWRkVG9Db2xsZWN0aW9uKG0pO1xuXG4gICAgICAgIHJldHVybiBtO1xuICAgIH07XG5cbiAgICBzYW5kYm94LnJlc2V0ID0gZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgICAgIGFwcGx5T25FYWNoKGNvbGxlY3Rpb24sIFwicmVzZXRcIik7XG4gICAgICAgIGFwcGx5T25FYWNoKGNvbGxlY3Rpb24sIFwicmVzZXRIaXN0b3J5XCIpO1xuICAgIH07XG5cbiAgICBzYW5kYm94LnJlc2V0QmVoYXZpb3IgPSBmdW5jdGlvbiByZXNldEJlaGF2aW9yKCkge1xuICAgICAgICBhcHBseU9uRWFjaChjb2xsZWN0aW9uLCBcInJlc2V0QmVoYXZpb3JcIik7XG4gICAgfTtcblxuICAgIHNhbmRib3gucmVzZXRIaXN0b3J5ID0gZnVuY3Rpb24gcmVzZXRIaXN0b3J5KCkge1xuICAgICAgICBmdW5jdGlvbiBwcml2YXRlUmVzZXRIaXN0b3J5KGYpIHtcbiAgICAgICAgICAgIGNvbnN0IG1ldGhvZCA9IGYucmVzZXRIaXN0b3J5IHx8IGYucmVzZXQ7XG4gICAgICAgICAgICBpZiAobWV0aG9kKSB7XG4gICAgICAgICAgICAgICAgbWV0aG9kLmNhbGwoZik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3JFYWNoKGNvbGxlY3Rpb24sIHByaXZhdGVSZXNldEhpc3RvcnkpO1xuICAgIH07XG5cbiAgICBzYW5kYm94LnJlc3RvcmUgPSBmdW5jdGlvbiByZXN0b3JlKCkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgIFwic2FuZGJveC5yZXN0b3JlKCkgZG9lcyBub3QgdGFrZSBhbnkgcGFyYW1ldGVycy4gUGVyaGFwcyB5b3UgbWVhbnQgc3R1Yi5yZXN0b3JlKClcIixcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICByZXZlcnNlKGNvbGxlY3Rpb24pO1xuICAgICAgICBhcHBseU9uRWFjaChjb2xsZWN0aW9uLCBcInJlc3RvcmVcIik7XG4gICAgICAgIGNvbGxlY3Rpb24gPSBbXTtcblxuICAgICAgICBmb3JFYWNoKGZha2VSZXN0b3JlcnMsIGZ1bmN0aW9uIChyZXN0b3Jlcikge1xuICAgICAgICAgICAgcmVzdG9yZXIoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGZha2VSZXN0b3JlcnMgPSBbXTtcblxuICAgICAgICBzYW5kYm94LnJlc3RvcmVDb250ZXh0KCk7XG4gICAgfTtcblxuICAgIHNhbmRib3gucmVzdG9yZUNvbnRleHQgPSBmdW5jdGlvbiByZXN0b3JlQ29udGV4dCgpIHtcbiAgICAgICAgaWYgKCFzYW5kYm94LmluamVjdGVkS2V5cykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yRWFjaChzYW5kYm94LmluamVjdGVkS2V5cywgZnVuY3Rpb24gKGluamVjdGVkS2V5KSB7XG4gICAgICAgICAgICBkZWxldGUgc2FuZGJveC5pbmplY3RJbnRvW2luamVjdGVkS2V5XTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgc2FuZGJveC5pbmplY3RlZEtleXMubGVuZ3RoID0gMDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHJlc3RvcmVyIGZ1bmN0aW9uIGZvciB0aGUgcHJvcGVydHlcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fEZ1bmN0aW9ufSBvYmplY3RcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHlcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGZvcmNlQXNzaWdubWVudFxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gcmVzdG9yZXIgZnVuY3Rpb25cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRGYWtlUmVzdG9yZXIob2JqZWN0LCBwcm9wZXJ0eSwgZm9yY2VBc3NpZ25tZW50ID0gZmFsc2UpIHtcbiAgICAgICAgY29uc3QgZGVzY3JpcHRvciA9IGdldFByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBmb3JjZUFzc2lnbm1lbnQgJiYgb2JqZWN0W3Byb3BlcnR5XTtcblxuICAgICAgICBmdW5jdGlvbiByZXN0b3JlcigpIHtcbiAgICAgICAgICAgIGlmIChmb3JjZUFzc2lnbm1lbnQpIHtcbiAgICAgICAgICAgICAgICBvYmplY3RbcHJvcGVydHldID0gdmFsdWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGRlc2NyaXB0b3I/LmlzT3duKSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iamVjdCwgcHJvcGVydHksIGRlc2NyaXB0b3IpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgb2JqZWN0W3Byb3BlcnR5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3RvcmVyLm9iamVjdCA9IG9iamVjdDtcbiAgICAgICAgcmVzdG9yZXIucHJvcGVydHkgPSBwcm9wZXJ0eTtcbiAgICAgICAgcmV0dXJuIHJlc3RvcmVyO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHZlcmlmeU5vdFJlcGxhY2VkKG9iamVjdCwgcHJvcGVydHkpIHtcbiAgICAgICAgZm9yRWFjaChmYWtlUmVzdG9yZXJzLCBmdW5jdGlvbiAoZmFrZVJlc3RvcmVyKSB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgZmFrZVJlc3RvcmVyLm9iamVjdCA9PT0gb2JqZWN0ICYmXG4gICAgICAgICAgICAgICAgZmFrZVJlc3RvcmVyLnByb3BlcnR5ID09PSBwcm9wZXJ0eVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgYEF0dGVtcHRlZCB0byByZXBsYWNlICR7cHJvcGVydHl9IHdoaWNoIGlzIGFscmVhZHkgcmVwbGFjZWRgLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlcGxhY2UgYW4gZXhpc3RpbmcgcHJvcGVydHlcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fEZ1bmN0aW9ufSBvYmplY3RcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHlcbiAgICAgKiBAcGFyYW0geyp9IHJlcGxhY2VtZW50IGEgZmFrZSwgc3R1Yiwgc3B5IG9yIGFueSBvdGhlciB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIHNhbmRib3gucmVwbGFjZSA9IGZ1bmN0aW9uIHJlcGxhY2Uob2JqZWN0LCBwcm9wZXJ0eSwgcmVwbGFjZW1lbnQpIHtcbiAgICAgICAgY29uc3QgZGVzY3JpcHRvciA9IGdldFByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTtcbiAgICAgICAgY2hlY2tGb3JWYWxpZEFyZ3VtZW50cyhkZXNjcmlwdG9yLCBwcm9wZXJ0eSwgcmVwbGFjZW1lbnQpO1xuICAgICAgICB0aHJvd09uQWNjZXNzb3JzKGRlc2NyaXB0b3IpO1xuICAgICAgICB2ZXJpZnlTYW1lVHlwZShvYmplY3QsIHByb3BlcnR5LCByZXBsYWNlbWVudCk7XG5cbiAgICAgICAgdmVyaWZ5Tm90UmVwbGFjZWQob2JqZWN0LCBwcm9wZXJ0eSk7XG5cbiAgICAgICAgLy8gc3RvcmUgYSBmdW5jdGlvbiBmb3IgcmVzdG9yaW5nIHRoZSByZXBsYWNlZCBwcm9wZXJ0eVxuICAgICAgICBwdXNoKGZha2VSZXN0b3JlcnMsIGdldEZha2VSZXN0b3JlcihvYmplY3QsIHByb3BlcnR5KSk7XG5cbiAgICAgICAgb2JqZWN0W3Byb3BlcnR5XSA9IHJlcGxhY2VtZW50O1xuXG4gICAgICAgIHJldHVybiByZXBsYWNlbWVudDtcbiAgICB9O1xuXG4gICAgc2FuZGJveC5yZXBsYWNlLnVzaW5nQWNjZXNzb3IgPSBmdW5jdGlvbiByZXBsYWNlVXNpbmdBY2Nlc3NvcihcbiAgICAgICAgb2JqZWN0LFxuICAgICAgICBwcm9wZXJ0eSxcbiAgICAgICAgcmVwbGFjZW1lbnQsXG4gICAgKSB7XG4gICAgICAgIGNvbnN0IGRlc2NyaXB0b3IgPSBnZXRQcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7XG4gICAgICAgIGNoZWNrRm9yVmFsaWRBcmd1bWVudHMoZGVzY3JpcHRvciwgcHJvcGVydHksIHJlcGxhY2VtZW50KTtcbiAgICAgICAgdmVyaWZ5U2FtZVR5cGUob2JqZWN0LCBwcm9wZXJ0eSwgcmVwbGFjZW1lbnQpO1xuXG4gICAgICAgIHZlcmlmeU5vdFJlcGxhY2VkKG9iamVjdCwgcHJvcGVydHkpO1xuXG4gICAgICAgIC8vIHN0b3JlIGEgZnVuY3Rpb24gZm9yIHJlc3RvcmluZyB0aGUgcmVwbGFjZWQgcHJvcGVydHlcbiAgICAgICAgcHVzaChmYWtlUmVzdG9yZXJzLCBnZXRGYWtlUmVzdG9yZXIob2JqZWN0LCBwcm9wZXJ0eSwgdHJ1ZSkpO1xuXG4gICAgICAgIG9iamVjdFtwcm9wZXJ0eV0gPSByZXBsYWNlbWVudDtcblxuICAgICAgICByZXR1cm4gcmVwbGFjZW1lbnQ7XG4gICAgfTtcblxuICAgIHNhbmRib3guZGVmaW5lID0gZnVuY3Rpb24gZGVmaW5lKG9iamVjdCwgcHJvcGVydHksIHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGRlc2NyaXB0b3IgPSBnZXRQcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7XG5cbiAgICAgICAgaWYgKGRlc2NyaXB0b3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICAgICAgYENhbm5vdCBkZWZpbmUgdGhlIGFscmVhZHkgZXhpc3RpbmcgcHJvcGVydHkgJHt2YWx1ZVRvU3RyaW5nKFxuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eSxcbiAgICAgICAgICAgICAgICApfS4gUGVyaGFwcyB5b3UgbWVhbnQgc2FuZGJveC5yZXBsYWNlKCk/YCxcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgdmFsdWUgYXJndW1lbnQgdG8gYmUgZGVmaW5lZFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZlcmlmeU5vdFJlcGxhY2VkKG9iamVjdCwgcHJvcGVydHkpO1xuXG4gICAgICAgIC8vIHN0b3JlIGEgZnVuY3Rpb24gZm9yIHJlc3RvcmluZyB0aGUgZGVmaW5lZCBwcm9wZXJ0eVxuICAgICAgICBwdXNoKGZha2VSZXN0b3JlcnMsIGdldEZha2VSZXN0b3JlcihvYmplY3QsIHByb3BlcnR5KSk7XG5cbiAgICAgICAgb2JqZWN0W3Byb3BlcnR5XSA9IHZhbHVlO1xuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuXG4gICAgc2FuZGJveC5yZXBsYWNlR2V0dGVyID0gZnVuY3Rpb24gcmVwbGFjZUdldHRlcihcbiAgICAgICAgb2JqZWN0LFxuICAgICAgICBwcm9wZXJ0eSxcbiAgICAgICAgcmVwbGFjZW1lbnQsXG4gICAgKSB7XG4gICAgICAgIGNvbnN0IGRlc2NyaXB0b3IgPSBnZXRQcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBkZXNjcmlwdG9yID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgICAgIGBDYW5ub3QgcmVwbGFjZSBub24tZXhpc3RlbnQgcHJvcGVydHkgJHt2YWx1ZVRvU3RyaW5nKFxuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eSxcbiAgICAgICAgICAgICAgICApfWAsXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiByZXBsYWNlbWVudCAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgICAgIFwiRXhwZWN0ZWQgcmVwbGFjZW1lbnQgYXJndW1lbnQgdG8gYmUgYSBmdW5jdGlvblwiLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgZGVzY3JpcHRvci5nZXQgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYG9iamVjdC5wcm9wZXJ0eWAgaXMgbm90IGEgZ2V0dGVyXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmVyaWZ5Tm90UmVwbGFjZWQob2JqZWN0LCBwcm9wZXJ0eSk7XG5cbiAgICAgICAgLy8gc3RvcmUgYSBmdW5jdGlvbiBmb3IgcmVzdG9yaW5nIHRoZSByZXBsYWNlZCBwcm9wZXJ0eVxuICAgICAgICBwdXNoKGZha2VSZXN0b3JlcnMsIGdldEZha2VSZXN0b3JlcihvYmplY3QsIHByb3BlcnR5KSk7XG5cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iamVjdCwgcHJvcGVydHksIHtcbiAgICAgICAgICAgIGdldDogcmVwbGFjZW1lbnQsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IGlzUHJvcGVydHlDb25maWd1cmFibGUob2JqZWN0LCBwcm9wZXJ0eSksXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiByZXBsYWNlbWVudDtcbiAgICB9O1xuXG4gICAgc2FuZGJveC5yZXBsYWNlU2V0dGVyID0gZnVuY3Rpb24gcmVwbGFjZVNldHRlcihcbiAgICAgICAgb2JqZWN0LFxuICAgICAgICBwcm9wZXJ0eSxcbiAgICAgICAgcmVwbGFjZW1lbnQsXG4gICAgKSB7XG4gICAgICAgIGNvbnN0IGRlc2NyaXB0b3IgPSBnZXRQcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBkZXNjcmlwdG9yID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgICAgIGBDYW5ub3QgcmVwbGFjZSBub24tZXhpc3RlbnQgcHJvcGVydHkgJHt2YWx1ZVRvU3RyaW5nKFxuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eSxcbiAgICAgICAgICAgICAgICApfWAsXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiByZXBsYWNlbWVudCAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgICAgIFwiRXhwZWN0ZWQgcmVwbGFjZW1lbnQgYXJndW1lbnQgdG8gYmUgYSBmdW5jdGlvblwiLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgZGVzY3JpcHRvci5zZXQgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYG9iamVjdC5wcm9wZXJ0eWAgaXMgbm90IGEgc2V0dGVyXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmVyaWZ5Tm90UmVwbGFjZWQob2JqZWN0LCBwcm9wZXJ0eSk7XG5cbiAgICAgICAgLy8gc3RvcmUgYSBmdW5jdGlvbiBmb3IgcmVzdG9yaW5nIHRoZSByZXBsYWNlZCBwcm9wZXJ0eVxuICAgICAgICBwdXNoKGZha2VSZXN0b3JlcnMsIGdldEZha2VSZXN0b3JlcihvYmplY3QsIHByb3BlcnR5KSk7XG5cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGFjY2Vzc29yLXBhaXJzXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsIHByb3BlcnR5LCB7XG4gICAgICAgICAgICBzZXQ6IHJlcGxhY2VtZW50LFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiBpc1Byb3BlcnR5Q29uZmlndXJhYmxlKG9iamVjdCwgcHJvcGVydHkpLFxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gcmVwbGFjZW1lbnQ7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGNvbW1vblBvc3RJbml0U2V0dXAoYXJncywgc3B5KSB7XG4gICAgICAgIGNvbnN0IFtvYmplY3QsIHByb3BlcnR5LCB0eXBlc10gPSBhcmdzO1xuXG4gICAgICAgIGNvbnN0IGlzU3B5aW5nT25FbnRpcmVPYmplY3QgPVxuICAgICAgICAgICAgdHlwZW9mIHByb3BlcnR5ID09PSBcInVuZGVmaW5lZFwiICYmXG4gICAgICAgICAgICAodHlwZW9mIG9iamVjdCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2Ygb2JqZWN0ID09PSBcImZ1bmN0aW9uXCIpO1xuXG4gICAgICAgIGlmIChpc1NweWluZ09uRW50aXJlT2JqZWN0KSB7XG4gICAgICAgICAgICBjb25zdCBvd25NZXRob2RzID0gY29sbGVjdE93bk1ldGhvZHMoc3B5KTtcblxuICAgICAgICAgICAgZm9yRWFjaChvd25NZXRob2RzLCBmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgICAgICAgICAgICAgYWRkVG9Db2xsZWN0aW9uKG1ldGhvZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHR5cGVzKSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBhY2Nlc3NvclR5cGUgb2YgdHlwZXMpIHtcbiAgICAgICAgICAgICAgICBhZGRUb0NvbGxlY3Rpb24oc3B5W2FjY2Vzc29yVHlwZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYWRkVG9Db2xsZWN0aW9uKHNweSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3B5O1xuICAgIH1cblxuICAgIHNhbmRib3guc3B5ID0gZnVuY3Rpb24gc3B5KCkge1xuICAgICAgICBjb25zdCBjcmVhdGVkU3B5ID0gc2lub25TcHkuYXBwbHkoc2lub25TcHksIGFyZ3VtZW50cyk7XG4gICAgICAgIHJldHVybiBjb21tb25Qb3N0SW5pdFNldHVwKGFyZ3VtZW50cywgY3JlYXRlZFNweSk7XG4gICAgfTtcblxuICAgIHNhbmRib3guc3R1YiA9IGZ1bmN0aW9uIHN0dWIoKSB7XG4gICAgICAgIGNvbnN0IGNyZWF0ZWRTdHViID0gc2lub25TdHViLmFwcGx5KHNpbm9uU3R1YiwgYXJndW1lbnRzKTtcbiAgICAgICAgcmV0dXJuIGNvbW1vblBvc3RJbml0U2V0dXAoYXJndW1lbnRzLCBjcmVhdGVkU3R1Yik7XG4gICAgfTtcblxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuICAgIHNhbmRib3guZmFrZSA9IGZ1bmN0aW9uIGZha2UoZikge1xuICAgICAgICBjb25zdCBzID0gc2lub25GYWtlLmFwcGx5KHNpbm9uRmFrZSwgYXJndW1lbnRzKTtcblxuICAgICAgICBhZGRUb0NvbGxlY3Rpb24ocyk7XG5cbiAgICAgICAgcmV0dXJuIHM7XG4gICAgfTtcblxuICAgIGZvckVhY2goT2JqZWN0LmtleXMoc2lub25GYWtlKSwgZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBjb25zdCBmYWtlQmVoYXZpb3IgPSBzaW5vbkZha2Vba2V5XTtcbiAgICAgICAgaWYgKHR5cGVvZiBmYWtlQmVoYXZpb3IgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgc2FuZGJveC5mYWtlW2tleV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcyA9IGZha2VCZWhhdmlvci5hcHBseShmYWtlQmVoYXZpb3IsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgICAgICAgICBhZGRUb0NvbGxlY3Rpb24ocyk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gcztcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHNhbmRib3gudXNlRmFrZVRpbWVycyA9IGZ1bmN0aW9uIHVzZUZha2VUaW1lcnMoYXJncykge1xuICAgICAgICBjb25zdCBjbG9jayA9IHNpbm9uQ2xvY2sudXNlRmFrZVRpbWVycy5jYWxsKG51bGwsIGFyZ3MpO1xuXG4gICAgICAgIHNhbmRib3guY2xvY2sgPSBjbG9jaztcbiAgICAgICAgYWRkVG9Db2xsZWN0aW9uKGNsb2NrKTtcblxuICAgICAgICByZXR1cm4gY2xvY2s7XG4gICAgfTtcblxuICAgIHNhbmRib3gudmVyaWZ5ID0gZnVuY3Rpb24gdmVyaWZ5KCkge1xuICAgICAgICBhcHBseU9uRWFjaChjb2xsZWN0aW9uLCBcInZlcmlmeVwiKTtcbiAgICB9O1xuXG4gICAgc2FuZGJveC52ZXJpZnlBbmRSZXN0b3JlID0gZnVuY3Rpb24gdmVyaWZ5QW5kUmVzdG9yZSgpIHtcbiAgICAgICAgbGV0IGV4Y2VwdGlvbjtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgc2FuZGJveC52ZXJpZnkoKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgZXhjZXB0aW9uID0gZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNhbmRib3gucmVzdG9yZSgpO1xuXG4gICAgICAgIGlmIChleGNlcHRpb24pIHtcbiAgICAgICAgICAgIHRocm93IGV4Y2VwdGlvbjtcbiAgICAgICAgfVxuICAgIH07XG59XG5cblNhbmRib3gucHJvdG90eXBlLm1hdGNoID0gbWF0Y2g7XG5cbm1vZHVsZS5leHBvcnRzID0gU2FuZGJveDtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuY29uc3QgYXJyYXlQcm90byA9IHJlcXVpcmUoXCJAc2lub25qcy9jb21tb25zXCIpLnByb3RvdHlwZXMuYXJyYXk7XG5jb25zdCBTYW5kYm94ID0gcmVxdWlyZShcIi4vc2FuZGJveFwiKTtcblxuY29uc3QgZm9yRWFjaCA9IGFycmF5UHJvdG8uZm9yRWFjaDtcbmNvbnN0IHB1c2ggPSBhcnJheVByb3RvLnB1c2g7XG5cbmZ1bmN0aW9uIHByZXBhcmVTYW5kYm94RnJvbUNvbmZpZyhjb25maWcpIHtcbiAgICBjb25zdCBzYW5kYm94ID0gbmV3IFNhbmRib3goeyBhc3NlcnRPcHRpb25zOiBjb25maWcuYXNzZXJ0T3B0aW9ucyB9KTtcblxuICAgIGlmIChjb25maWcudXNlRmFrZVRpbWVycykge1xuICAgICAgICBpZiAodHlwZW9mIGNvbmZpZy51c2VGYWtlVGltZXJzID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICBzYW5kYm94LnVzZUZha2VUaW1lcnMoY29uZmlnLnVzZUZha2VUaW1lcnMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2FuZGJveC51c2VGYWtlVGltZXJzKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc2FuZGJveDtcbn1cblxuZnVuY3Rpb24gZXhwb3NlVmFsdWUoc2FuZGJveCwgY29uZmlnLCBrZXksIHZhbHVlKSB7XG4gICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGNvbmZpZy5pbmplY3RJbnRvICYmICEoa2V5IGluIGNvbmZpZy5pbmplY3RJbnRvKSkge1xuICAgICAgICBjb25maWcuaW5qZWN0SW50b1trZXldID0gdmFsdWU7XG4gICAgICAgIHB1c2goc2FuZGJveC5pbmplY3RlZEtleXMsIGtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcHVzaChzYW5kYm94LmFyZ3MsIHZhbHVlKTtcbiAgICB9XG59XG5cbi8qKlxuICogT3B0aW9ucyB0byBjdXN0b21pemUgYSBzYW5kYm94XG4gKlxuICogVGhlIHNhbmRib3gncyBtZXRob2RzIGNhbiBiZSBpbmplY3RlZCBpbnRvIGFub3RoZXIgb2JqZWN0IGZvclxuICogY29udmVuaWVuY2UuIFRoZSBgaW5qZWN0SW50b2AgY29uZmlndXJhdGlvbiBvcHRpb24gY2FuIG5hbWUgYW5cbiAqIG9iamVjdCB0byBhZGQgcHJvcGVydGllcyB0by5cbiAqXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBTYW5kYm94Q29uZmlnXG4gKiBAcHJvcGVydHkge3N0cmluZ1tdfSBwcm9wZXJ0aWVzIFRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBBUEkgdG8gZXhwb3NlIG9uIHRoZSBzYW5kYm94LiBFeGFtcGxlczogWydzcHknLCAnZmFrZScsICdyZXN0b3JlJ11cbiAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBpbmplY3RJbnRvIGFuIG9iamVjdCBpbiB3aGljaCB0byBpbmplY3QgcHJvcGVydGllcyBmcm9tIHRoZSBzYW5kYm94IChhIGZhY2FkZSkuIFRoaXMgaXMgbW9zdGx5IGFuIGludGVncmF0aW9uIGZlYXR1cmUgKHNpbm9uLXRlc3QgYmVpbmcgb25lKS5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gdXNlRmFrZVRpbWVycyAgd2hldGhlciB0aW1lcnMgYXJlIGZha2VkIGJ5IGRlZmF1bHRcbiAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBbYXNzZXJ0T3B0aW9uc10gc2VlIENyZWF0ZUFzc2VydE9wdGlvbnMgaW4gLi9hc3NlcnRcbiAqXG4gKiBUaGlzIHR5cGUgZGVmIGlzIHJlYWxseSBzdWZmZXJpbmcgZnJvbSBKU0RvYyBub3QgaGF2aW5nIHN0YW5kYXJkaXplZFxuICogaG93IHRvIHJlZmVyZW5jZSB0eXBlcyBkZWZpbmVkIGluIG90aGVyIG1vZHVsZXMgOihcbiAqL1xuXG4vKipcbiAqIEEgY29uZmlndXJlZCBzaW5vbiBzYW5kYm94IChwcml2YXRlIHR5cGUpXG4gKlxuICogQHR5cGVkZWYge29iamVjdH0gQ29uZmlndXJlZFNpbm9uU2FuZGJveFR5cGVcbiAqIEBwcml2YXRlXG4gKiBAYXVnbWVudHMgU2FuZGJveFxuICogQHByb3BlcnR5IHtzdHJpbmdbXX0gaW5qZWN0ZWRLZXlzIHRoZSBrZXlzIHRoYXQgaGF2ZSBiZWVuIGluamVjdGVkIChmcm9tIGNvbmZpZy5pbmplY3RJbnRvKVxuICogQHByb3BlcnR5IHsqW119IGFyZ3MgdGhlIGFyZ3VtZW50cyBmb3IgdGhlIHNhbmRib3hcbiAqL1xuXG4vKipcbiAqIENyZWF0ZSBhIHNhbmRib3hcbiAqXG4gKiBBcyBvZiBTaW5vbiA1IHRoZSBgc2lub25gIGluc3RhbmNlIGl0c2VsZiBpcyBhIFNhbmRib3gsIHNvIHlvdVxuICogaGFyZGx5IGV2ZXIgbmVlZCB0byBjcmVhdGUgYWRkaXRpb25hbCBpbnN0YW5jZXMgZm9yIHRoZSBzYWtlIG9mIHRlc3RpbmdcbiAqXG4gKiBAcGFyYW0gY29uZmlnIHtTYW5kYm94Q29uZmlnfVxuICogQHJldHVybnMge1NhbmRib3h9XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVNhbmRib3goY29uZmlnKSB7XG4gICAgaWYgKCFjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTYW5kYm94KCk7XG4gICAgfVxuXG4gICAgY29uc3QgY29uZmlndXJlZFNhbmRib3ggPSBwcmVwYXJlU2FuZGJveEZyb21Db25maWcoY29uZmlnKTtcbiAgICBjb25maWd1cmVkU2FuZGJveC5hcmdzID0gY29uZmlndXJlZFNhbmRib3guYXJncyB8fCBbXTtcbiAgICBjb25maWd1cmVkU2FuZGJveC5pbmplY3RlZEtleXMgPSBbXTtcbiAgICBjb25maWd1cmVkU2FuZGJveC5pbmplY3RJbnRvID0gY29uZmlnLmluamVjdEludG87XG4gICAgY29uc3QgZXhwb3NlZCA9IGNvbmZpZ3VyZWRTYW5kYm94LmluamVjdCh7fSk7XG5cbiAgICBpZiAoY29uZmlnLnByb3BlcnRpZXMpIHtcbiAgICAgICAgZm9yRWFjaChjb25maWcucHJvcGVydGllcywgZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID1cbiAgICAgICAgICAgICAgICBleHBvc2VkW3Byb3BdIHx8IChwcm9wID09PSBcInNhbmRib3hcIiAmJiBjb25maWd1cmVkU2FuZGJveCk7XG4gICAgICAgICAgICBleHBvc2VWYWx1ZShjb25maWd1cmVkU2FuZGJveCwgY29uZmlnLCBwcm9wLCB2YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGV4cG9zZVZhbHVlKGNvbmZpZ3VyZWRTYW5kYm94LCBjb25maWcsIFwic2FuZGJveFwiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY29uZmlndXJlZFNhbmRib3g7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlU2FuZGJveDtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gaXNSZXN0b3JhYmxlKG9iaikge1xuICAgIHJldHVybiAoXG4gICAgICAgIHR5cGVvZiBvYmogPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgICB0eXBlb2Ygb2JqLnJlc3RvcmUgPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgICBvYmoucmVzdG9yZS5zaW5vblxuICAgICk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNSZXN0b3JhYmxlO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5jb25zdCBmYWtlID0gcmVxdWlyZShcIi4vZmFrZVwiKTtcbmNvbnN0IGlzUmVzdG9yYWJsZSA9IHJlcXVpcmUoXCIuL3V0aWwvY29yZS9pcy1yZXN0b3JhYmxlXCIpO1xuXG5jb25zdCBTVEFUVVNfUEVORElORyA9IFwicGVuZGluZ1wiO1xuY29uc3QgU1RBVFVTX1JFU09MVkVEID0gXCJyZXNvbHZlZFwiO1xuY29uc3QgU1RBVFVTX1JFSkVDVEVEID0gXCJyZWplY3RlZFwiO1xuXG4vKipcbiAqIFJldHVybnMgYSBmYWtlIGZvciBhIGdpdmVuIGZ1bmN0aW9uIG9yIHVuZGVmaW5lZC4gSWYgbm8gZnVuY3Rpb24gaXMgZ2l2ZW4sIGFcbiAqIG5ldyBmYWtlIGlzIHJldHVybmVkLiBJZiB0aGUgZ2l2ZW4gZnVuY3Rpb24gaXMgYWxyZWFkeSBhIGZha2UsIGl0IGlzXG4gKiByZXR1cm5lZCBhcyBpcy4gT3RoZXJ3aXNlIHRoZSBnaXZlbiBmdW5jdGlvbiBpcyB3cmFwcGVkIGluIGEgbmV3IGZha2UuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2V4ZWN1dG9yXSBUaGUgb3B0aW9uYWwgZXhlY3V0b3IgZnVuY3Rpb24uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259XG4gKi9cbmZ1bmN0aW9uIGdldEZha2VFeGVjdXRvcihleGVjdXRvcikge1xuICAgIGlmIChpc1Jlc3RvcmFibGUoZXhlY3V0b3IpKSB7XG4gICAgICAgIHJldHVybiBleGVjdXRvcjtcbiAgICB9XG4gICAgaWYgKGV4ZWN1dG9yKSB7XG4gICAgICAgIHJldHVybiBmYWtlKGV4ZWN1dG9yKTtcbiAgICB9XG4gICAgcmV0dXJuIGZha2UoKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgbmV3IHByb21pc2UgdGhhdCBleHBvc2VzIGl0J3MgaW50ZXJuYWwgYHN0YXR1c2AsIGByZXNvbHZlZFZhbHVlYFxuICogYW5kIGByZWplY3RlZFZhbHVlYCBhbmQgY2FuIGJlIHJlc29sdmVkIG9yIHJlamVjdGVkIGZyb20gdGhlIG91dHNpZGUgYnlcbiAqIGNhbGxpbmcgYHJlc29sdmUodmFsdWUpYCBvciBgcmVqZWN0KHJlYXNvbilgLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtleGVjdXRvcl0gVGhlIG9wdGlvbmFsIGV4ZWN1dG9yIGZ1bmN0aW9uLlxuICogQHJldHVybnMge1Byb21pc2V9XG4gKi9cbmZ1bmN0aW9uIHByb21pc2UoZXhlY3V0b3IpIHtcbiAgICBjb25zdCBmYWtlRXhlY3V0b3IgPSBnZXRGYWtlRXhlY3V0b3IoZXhlY3V0b3IpO1xuICAgIGNvbnN0IHNpbm9uUHJvbWlzZSA9IG5ldyBQcm9taXNlKGZha2VFeGVjdXRvcik7XG5cbiAgICBzaW5vblByb21pc2Uuc3RhdHVzID0gU1RBVFVTX1BFTkRJTkc7XG4gICAgc2lub25Qcm9taXNlXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgc2lub25Qcm9taXNlLnN0YXR1cyA9IFNUQVRVU19SRVNPTFZFRDtcbiAgICAgICAgICAgIHNpbm9uUHJvbWlzZS5yZXNvbHZlZFZhbHVlID0gdmFsdWU7XG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaChmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgICAgICBzaW5vblByb21pc2Uuc3RhdHVzID0gU1RBVFVTX1JFSkVDVEVEO1xuICAgICAgICAgICAgc2lub25Qcm9taXNlLnJlamVjdGVkVmFsdWUgPSByZWFzb247XG4gICAgICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogUmVzb2x2ZXMgb3IgcmVqZWN0cyB0aGUgcHJvbWlzZSB3aXRoIHRoZSBnaXZlbiBzdGF0dXMgYW5kIHZhbHVlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0YXR1c1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpbmFsaXplKHN0YXR1cywgdmFsdWUsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmIChzaW5vblByb21pc2Uuc3RhdHVzICE9PSBTVEFUVVNfUEVORElORykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQcm9taXNlIGFscmVhZHkgJHtzaW5vblByb21pc2Uuc3RhdHVzfWApO1xuICAgICAgICB9XG5cbiAgICAgICAgc2lub25Qcm9taXNlLnN0YXR1cyA9IHN0YXR1cztcbiAgICAgICAgY2FsbGJhY2sodmFsdWUpO1xuICAgIH1cblxuICAgIHNpbm9uUHJvbWlzZS5yZXNvbHZlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGZpbmFsaXplKFNUQVRVU19SRVNPTFZFRCwgdmFsdWUsIGZha2VFeGVjdXRvci5maXJzdENhbGwuYXJnc1swXSk7XG4gICAgICAgIC8vIFJldHVybiB0aGUgcHJvbWlzZSBzbyB0aGF0IGNhbGxlcnMgY2FuIGF3YWl0IGl0OlxuICAgICAgICByZXR1cm4gc2lub25Qcm9taXNlO1xuICAgIH07XG4gICAgc2lub25Qcm9taXNlLnJlamVjdCA9IGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgZmluYWxpemUoU1RBVFVTX1JFSkVDVEVELCByZWFzb24sIGZha2VFeGVjdXRvci5maXJzdENhbGwuYXJnc1sxXSk7XG4gICAgICAgIC8vIFJldHVybiBhIG5ldyBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiB0aGUgc2lub24gcHJvbWlzZSB3YXNcbiAgICAgICAgLy8gcmVqZWN0ZWQsIHNvIHRoYXQgY2FsbGVycyBjYW4gYXdhaXQgaXQ6XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgICAgc2lub25Qcm9taXNlLmNhdGNoKCgpID0+IHJlc29sdmUoKSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICByZXR1cm4gc2lub25Qcm9taXNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHByb21pc2U7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmNvbnN0IHdhbGtPYmplY3QgPSByZXF1aXJlKFwiLi91dGlsL2NvcmUvd2Fsay1vYmplY3RcIik7XG5cbmZ1bmN0aW9uIGZpbHRlcihvYmplY3QsIHByb3BlcnR5KSB7XG4gICAgcmV0dXJuIG9iamVjdFtwcm9wZXJ0eV0ucmVzdG9yZSAmJiBvYmplY3RbcHJvcGVydHldLnJlc3RvcmUuc2lub247XG59XG5cbmZ1bmN0aW9uIHJlc3RvcmUob2JqZWN0LCBwcm9wZXJ0eSkge1xuICAgIG9iamVjdFtwcm9wZXJ0eV0ucmVzdG9yZSgpO1xufVxuXG5mdW5jdGlvbiByZXN0b3JlT2JqZWN0KG9iamVjdCkge1xuICAgIHJldHVybiB3YWxrT2JqZWN0KHJlc3RvcmUsIG9iamVjdCwgZmlsdGVyKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSByZXN0b3JlT2JqZWN0O1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5jb25zdCBiZWhhdmlvciA9IHJlcXVpcmUoXCIuL3Npbm9uL2JlaGF2aW9yXCIpO1xuY29uc3QgY3JlYXRlU2FuZGJveCA9IHJlcXVpcmUoXCIuL3Npbm9uL2NyZWF0ZS1zYW5kYm94XCIpO1xuY29uc3QgZXh0ZW5kID0gcmVxdWlyZShcIi4vc2lub24vdXRpbC9jb3JlL2V4dGVuZFwiKTtcbmNvbnN0IGZha2VUaW1lcnMgPSByZXF1aXJlKFwiLi9zaW5vbi91dGlsL2Zha2UtdGltZXJzXCIpO1xuY29uc3QgU2FuZGJveCA9IHJlcXVpcmUoXCIuL3Npbm9uL3NhbmRib3hcIik7XG5jb25zdCBzdHViID0gcmVxdWlyZShcIi4vc2lub24vc3R1YlwiKTtcbmNvbnN0IHByb21pc2UgPSByZXF1aXJlKFwiLi9zaW5vbi9wcm9taXNlXCIpO1xuXG4vKipcbiAqIEByZXR1cm5zIHtvYmplY3R9IGEgY29uZmlndXJlZCBzYW5kYm94XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY3JlYXRlQXBpKCkge1xuICAgIGNvbnN0IGFwaU1ldGhvZHMgPSB7XG4gICAgICAgIGNyZWF0ZVNhbmRib3g6IGNyZWF0ZVNhbmRib3gsXG4gICAgICAgIG1hdGNoOiByZXF1aXJlKFwiQHNpbm9uanMvc2Ftc2FtXCIpLmNyZWF0ZU1hdGNoZXIsXG4gICAgICAgIHJlc3RvcmVPYmplY3Q6IHJlcXVpcmUoXCIuL3Npbm9uL3Jlc3RvcmUtb2JqZWN0XCIpLFxuXG4gICAgICAgIGV4cGVjdGF0aW9uOiByZXF1aXJlKFwiLi9zaW5vbi9tb2NrLWV4cGVjdGF0aW9uXCIpLFxuXG4gICAgICAgIC8vIGZha2UgdGltZXJzXG4gICAgICAgIHRpbWVyczogZmFrZVRpbWVycy50aW1lcnMsXG5cbiAgICAgICAgYWRkQmVoYXZpb3I6IGZ1bmN0aW9uIChuYW1lLCBmbikge1xuICAgICAgICAgICAgYmVoYXZpb3IuYWRkQmVoYXZpb3Ioc3R1YiwgbmFtZSwgZm4pO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIGZha2UgcHJvbWlzZVxuICAgICAgICBwcm9taXNlOiBwcm9taXNlLFxuICAgIH07XG5cbiAgICBjb25zdCBzYW5kYm94ID0gbmV3IFNhbmRib3goKTtcbiAgICByZXR1cm4gZXh0ZW5kKHNhbmRib3gsIGFwaU1ldGhvZHMpO1xufTtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuY29uc3QgY3JlYXRlQXBpID0gcmVxdWlyZShcIi4vY3JlYXRlLXNpbm9uLWFwaVwiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVBcGkoKTtcbiJdLAogICJtYXBwaW5ncyI6ICI7Ozs7Ozs7O0FBQUE7QUFBQSxnREFBQUEsVUFBQUMsU0FBQTtBQUFBO0FBTUEsUUFBSTtBQUdKLFFBQUksT0FBTyxXQUFXLGFBQWE7QUFFL0IscUJBQWU7QUFBQSxJQUNuQixXQUFXLE9BQU8sV0FBVyxhQUFhO0FBRXRDLHFCQUFlO0FBQUEsSUFDbkIsT0FBTztBQUVILHFCQUFlO0FBQUEsSUFDbkI7QUFFQSxJQUFBQSxRQUFPLFVBQVU7QUFBQTtBQUFBOzs7QUNwQmpCO0FBQUEsb0VBQUFDLFVBQUFDLFNBQUE7QUFBQTtBQVVBLFFBQUk7QUFDSixRQUFJO0FBQ0EsWUFBTSxTQUFTLENBQUM7QUFFaEIsYUFBTztBQUNQLHNCQUFnQjtBQUFBLElBQ3BCLFNBQVMsR0FBRztBQUlSLHNCQUFnQjtBQUFBLElBQ3BCO0FBRUEsSUFBQUEsUUFBTyxVQUFVO0FBQUE7QUFBQTs7O0FDdkJqQjtBQUFBLDJFQUFBQyxVQUFBQyxTQUFBO0FBQUE7QUFFQSxRQUFJLE9BQU8sU0FBUztBQUNwQixRQUFJLGdCQUFnQjtBQUVwQixRQUFJLHVCQUF1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bkIsUUFBTSxVQUFVO0FBQ2hCLFFBQU0sT0FBTztBQUNiLFFBQU0sVUFBVTtBQUtoQixJQUFBQSxRQUFPLFVBQVUsU0FBU0MsYUFBWTtBQUNsQyxZQUFNLGFBQWE7QUFBQSxRQUNmO0FBQUEsUUFDQSxPQUFPLGlCQUEyQjtBQUFBLFFBQ2xDLGVBQWU7QUFBQSxRQUVmLGFBQWE7QUFBQTtBQUFBLFFBR2IsUUFBUSxXQUFXO0FBQUEsUUFFbkIsYUFBYSxTQUFVLE1BQU0sSUFBSTtBQUM3QixtQkFBUyxZQUFZLE1BQU0sTUFBTSxFQUFFO0FBQUEsUUFDdkM7QUFBQTtBQUFBLFFBR0E7QUFBQSxNQUNKO0FBRUEsWUFBTSxVQUFVLElBQUksUUFBUTtBQUM1QixhQUFPLE9BQU8sU0FBUyxVQUFVO0FBQUEsSUFDckM7QUFBQTtBQUFBOzs7QUNoQ0EsSUFBTSxZQUFZO0FBRWxCLE9BQU8sVUFBVSxVQUFVOyIsCiAgIm5hbWVzIjogWyJleHBvcnRzIiwgIm1vZHVsZSIsICJleHBvcnRzIiwgIm1vZHVsZSIsICJleHBvcnRzIiwgIm1vZHVsZSIsICJleHBvcnRzIiwgIm1vZHVsZSIsICJleHBvcnRzIiwgIm1vZHVsZSIsICJleHBvcnRzIiwgIm1vZHVsZSIsICJleHBvcnRzIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgImdsb2JhbCIsICJleHBvcnRzIiwgIm1vZHVsZSIsICJleHBvcnRzIiwgIm1vZHVsZSIsICJleHBvcnRzIiwgIm1vZHVsZSIsICJleHBvcnRzIiwgIm1vZHVsZSIsICJleHBvcnRzIiwgIm1vZHVsZSIsICJwcm9jZXNzIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgImlzTmFOIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgImlzTmFOIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgInJlcXVpcmVfdHlwZV9kZXRlY3QiLCAiZXhwb3J0cyIsICJtb2R1bGUiLCAiZ2xvYmFsIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgImlzTmFOIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgInJlcXVpcmVfaXNfaXRlcmFibGUiLCAiZXhwb3J0cyIsICJtb2R1bGUiLCAiZXhwb3J0cyIsICJtb2R1bGUiLCAiZXhwb3J0cyIsICJtb2R1bGUiLCAiZXhwb3J0cyIsICJtb2R1bGUiLCAiZXhwb3J0cyIsICJtb2R1bGUiLCAiZXhwb3J0cyIsICJtb2R1bGUiLCAiZXhwb3J0cyIsICJtb2R1bGUiLCAiZXhwb3J0cyIsICJtb2R1bGUiLCAicmVxdWlyZV9zaGFtcyIsICJleHBvcnRzIiwgIm1vZHVsZSIsICJleHBvcnRzIiwgIm1vZHVsZSIsICJleHBvcnRzIiwgIm1vZHVsZSIsICJleHBvcnRzIiwgIm1vZHVsZSIsICJleHBvcnRzIiwgIm1vZHVsZSIsICJleHBvcnRzIiwgIm1vZHVsZSIsICJleHBvcnRzIiwgIm1vZHVsZSIsICJleHBvcnRzIiwgIm1vZHVsZSIsICJleHBvcnRzIiwgIm1vZHVsZSIsICJleHBvcnRzIiwgIm1vZHVsZSIsICJleHBvcnRzIiwgIm1vZHVsZSIsICJjb25jYXR0eSIsICJzbGljeSIsICJFbXB0eSIsICJleHBvcnRzIiwgIm1vZHVsZSIsICJleHBvcnRzIiwgIm1vZHVsZSIsICJleHBvcnRzIiwgIm1vZHVsZSIsICJ1bmRlZmluZWQiLCAiZG9FdmFsIiwgInN0cmluZ1RvUGF0aCIsICJnZXRCYXNlSW50cmluc2ljIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgImhhc1Byb3BlcnR5RGVzY3JpcHRvcnMiLCAiZXhwb3J0cyIsICJtb2R1bGUiLCAiZGVmaW5lIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgImFwcGx5QmluZCIsICJleHBvcnRzIiwgIm1vZHVsZSIsICJyZXF1aXJlX2lzX2FyZ3VtZW50cyIsICJleHBvcnRzIiwgIm1vZHVsZSIsICJleHBvcnRzIiwgIm1vZHVsZSIsICJleHBvcnRzIiwgIm1vZHVsZSIsICJleHBvcnRzIiwgIm1vZHVsZSIsICJmb3JFYWNoQXJyYXkiLCAiZm9yRWFjaFN0cmluZyIsICJmb3JFYWNoT2JqZWN0IiwgImZvckVhY2giLCAiZXhwb3J0cyIsICJtb2R1bGUiLCAiZXhwb3J0cyIsICJtb2R1bGUiLCAiZXhwb3J0cyIsICJtb2R1bGUiLCAiZXhwb3J0cyIsICJtb2R1bGUiLCAiZXhwb3J0cyIsICJleHBvcnRzIiwgIm1vZHVsZSIsICJleHBvcnRzIiwgIm1vZHVsZSIsICJleHBvcnRzIiwgImdldE93blByb3BlcnR5RGVzY3JpcHRvcnMiLCAieCIsICJzZWxmIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgInRpbWVycyIsICJzZXRUaW1lb3V0IiwgImNsZWFyVGltZW91dCIsICJzZXRJbnRlcnZhbCIsICJjbGVhckludGVydmFsIiwgImV4cG9ydHMiLCAiZXhwb3J0cyIsICJleHBvcnRzIiwgIm1vZHVsZSIsICJleHBvcnRzIiwgIm1vZHVsZSIsICJzZWxmIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgImV4cG9ydHMiLCAiRGlmZiIsICJ2YWx1ZSIsICJleHBvcnRzIiwgImQiLCAiYiIsICJDaGFyYWN0ZXJEaWZmIiwgInJlcXVpcmVfc3RyaW5nIiwgImV4cG9ydHMiLCAiZXhwb3J0cyIsICJkIiwgImIiLCAiV29yZERpZmYiLCAiV29yZHNXaXRoU3BhY2VEaWZmIiwgImV4cG9ydHMiLCAiZXhwb3J0cyIsICJkIiwgImIiLCAiTGluZURpZmYiLCAiZXhwb3J0cyIsICJkIiwgImIiLCAiU2VudGVuY2VEaWZmIiwgImV4cG9ydHMiLCAiZCIsICJiIiwgIkNzc0RpZmYiLCAiZXhwb3J0cyIsICJkIiwgImIiLCAiSnNvbkRpZmYiLCAicmVxdWlyZV9hcnJheSIsICJleHBvcnRzIiwgImQiLCAiYiIsICJBcnJheURpZmYiLCAiZXhwb3J0cyIsICJleHBvcnRzIiwgImV4cG9ydHMiLCAiZXhwb3J0cyIsICJsaW5lIiwgInRvUG9zIiwgIm1heEVycm9ycyIsICJlcnIiLCAiZXhwb3J0cyIsICJleHBvcnRzIiwgImxpbmVzIiwgInBhdGNoT2JqIiwgImV4cG9ydHMiLCAiZXhwb3J0cyIsICJleHBvcnRzIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgIndyYXBwZWRNZXRob2QiLCAiZXJyb3IiLCAiZXhwb3J0cyIsICJtb2R1bGUiLCAiZXhwb3J0cyIsICJtb2R1bGUiLCAiZXhwb3J0cyIsICJtb2R1bGUiLCAiZXhwb3J0cyIsICJtb2R1bGUiLCAiZXhwb3J0cyIsICJtb2R1bGUiLCAiZXhwb3J0cyIsICJtb2R1bGUiLCAiZXhwb3J0cyIsICJtb2R1bGUiLCAiZXhwb3J0cyIsICJtb2R1bGUiLCAiZGVmaW5lIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgImNyZWF0ZUFwaSJdCn0K
